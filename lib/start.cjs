'use strict';

var process$1 = require('process');
var cluster = require('cluster');
var tty = require('node:tty');
var path = require('path');
var require$$2 = require('os');
var require$$4$1 = require('url');
var fs = require('fs');
var require$$3$2 = require('crypto');
var require$$0$b = require('net');
var require$$0$3 = require('node:events');
var require$$0$2 = require('node:util');
var require$$0$4 = require('node:http');
var require$$1$1 = require('node:diagnostics_channel');
var require$$1 = require('node:https');
var require$$2$1 = require('node:http2');
var require$$3$3 = require('node:dns');
var require$$0$5 = require('node:os');
var require$$0$7 = require('node:stream');
var require$$1$2 = require('events');
var require$$2$2 = require('util');
var assert = require('assert');
var require$$2$3 = require('worker_threads');
var require$$0$6 = require('module');
var path$1 = require('node:path');
var require$$7 = require('buffer');
var require$$0$8 = require('node:async_hooks');
var require$$0$9 = require('node:assert');
var require$$1$3 = require('node:url');
var require$$0$a = require('node:crypto');
var fs$1 = require('node:fs');
var require$$5 = require('node:fs/promises');
var require$$2$4 = require('node:string_decoder');
var fs$2 = require('fs/promises');
var require$$0$c = require('child_process');
var realZlib = require('zlib');

var _documentCurrentScript = typeof document !== 'undefined' ? document.currentScript : null;
function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var fs__namespace = /*#__PURE__*/_interopNamespaceDefault(fs$2);
var realZlib__namespace = /*#__PURE__*/_interopNamespaceDefault(realZlib);

// eslint-disable-next-line no-warning-comments
// TODO: Use a better method when it's added to Node.js (https://github.com/nodejs/node/pull/40240)
// Lots of optionals here to support Deno.
const hasColors = tty?.WriteStream?.prototype?.hasColors?.() ?? false;

const format$2 = (open, close) => {
	if (!hasColors) {
		return input => input;
	}

	const openCode = `\u001B[${open}m`;
	const closeCode = `\u001B[${close}m`;

	return input => {
		const string = input + ''; // eslint-disable-line no-implicit-coercion -- This is faster.
		let index = string.indexOf(closeCode);

		if (index === -1) {
			// Note: Intentionally not using string interpolation for performance reasons.
			return openCode + string + closeCode;
		}

		// Handle nested colors.

		// We could have done this, but it's too slow (as of Node.js 22).
		// return openCode + string.replaceAll(closeCode, openCode) + closeCode;

		let result = openCode;
		let lastIndex = 0;

		while (index !== -1) {
			result += string.slice(lastIndex, index) + openCode;
			lastIndex = index + closeCode.length;
			index = string.indexOf(closeCode, lastIndex);
		}

		result += string.slice(lastIndex) + closeCode;

		return result;
	};
};
const bold = format$2(1, 22);
const italic = format$2(3, 23);
const underline = format$2(4, 24);
const red = format$2(31, 39);
const green = format$2(32, 39);
const yellow = format$2(33, 39);
const cyan = format$2(36, 39);
const gray = format$2(90, 39);
const blueBright = format$2(94, 39);

function cap(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
function pad$1(n) {
  return n < 10 ? "0" + n : n.toString();
}
function formatDate$1(date) {
  const year = date.getFullYear();
  const month = pad$1(date.getMonth() + 1);
  const day = pad$1(date.getDate());
  const hours = pad$1(date.getHours());
  const minutes = pad$1(date.getMinutes());
  const seconds = pad$1(date.getSeconds());
  return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
}
var severityValues = /* @__PURE__ */ ((severityValues2) => {
  severityValues2[severityValues2["debug"] = 1] = "debug";
  severityValues2[severityValues2["info"] = 2] = "info";
  severityValues2[severityValues2["warning"] = 3] = "warning";
  severityValues2[severityValues2["error"] = 4] = "error";
  severityValues2[severityValues2["special"] = 5] = "special";
  return severityValues2;
})(severityValues || {});
function severityToColor(severity, text) {
  switch (severity) {
    case "debug":
      return green(text);
    case "info":
      return blueBright(text);
    case "warning":
      return yellow(text);
    case "error":
      return red(text);
    case "special":
      return cyan(underline(text));
    default:
      console.log("Unknown severity " + severity);
      return italic(text);
  }
}
class Logger {
  logColors;
  logLevelInt;
  logSystem;
  logComponent;
  constructor(config, logSystem, logComponent) {
    this.logColors = typeof config?.logColors !== "undefined" ? config.logColors : true;
    this.logLevelInt = severityValues[config?.logLevel || "debug"];
    this.logSystem = logSystem;
    this.logComponent = logComponent;
  }
  log(severity, system, component, text, subcat) {
    if (severityValues[severity] < this.logLevelInt) {
      return;
    }
    let entryDesc = formatDate$1(/* @__PURE__ */ new Date()) + " [" + system + "]	";
    let logString = "";
    if (this.logColors) {
      entryDesc = severityToColor(severity, entryDesc);
      logString = entryDesc;
      if (component) {
        logString += italic("[" + component + "] ");
      }
      if (subcat) {
        logString += gray(bold("(" + subcat + ") "));
      }
      if (!component) {
        logString += text;
      } else {
        logString += gray(text);
      }
    } else {
      logString = entryDesc;
      if (component) {
        logString += "[" + component + "] ";
      }
      if (subcat) {
        logString += "(" + subcat + ") ";
      }
      logString += text;
    }
    console.log(logString);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  handleLog(logLevel, ...args) {
    const logSystem = this.logSystem;
    const logComponent = this.logComponent;
    if (!logSystem && args.length === 1) {
      return this.log(logLevel, cap(logLevel), logComponent, args[0]);
    }
    if (!logSystem && args.length === 2) {
      return this.log(logLevel, args[0], logComponent, args[1]);
    }
    if (logSystem && args.length === 1) {
      return this.log(logLevel, logSystem, logComponent, args[0]);
    }
    if (logSystem && args.length === 2) {
      return this.log(logLevel, logSystem, args[0], args[1]);
    }
    if (args.length === 3) {
      return this.log(logLevel, args[0], args[1], args[2]);
    }
    return this.log(logLevel, args[0], args[1], args[2], args[3]);
  }
  debug(...args) {
    this.handleLog("debug", ...args);
  }
  info(...args) {
    this.handleLog("info", ...args);
  }
  warning(...args) {
    this.handleLog("warning", ...args);
  }
  error(...args) {
    this.handleLog("error", ...args);
  }
  special(...args) {
    this.handleLog("special", ...args);
  }
}

const pkgJson = {
  "name": "ifconfig-server",
  "private": true,
  "version": "1.1.4",
  "description": "Fast, scalable ip lookup service server implementation powered by fastify and maxmind",
  "license": "MIT",
  "author": "CPUchain",
  "type": "module",
  "main": "./lib/index.cjs",
  "module": "./lib/index.js",
  "types": "./lib/index.d.ts",
  "exports": {
    ".": {
      "import": "./lib/index.js",
      "require": "./lib/index.cjs",
      "default": "./lib/index.js"
    }
  },
  "keywords": [
    "maxmind",
    "mmdb",
    "geo",
    "geoip",
    "geoip2",
    "geobase",
    "timezone",
    "asn",
    "ip",
    "ip lookup",
    "geo lookup"
  ],
  "repository": {
    "type": "git",
    "url": "git+https://github.com/cpuchain/ifconfig-server.git"
  },
  "scripts": {
    "lint": "eslint scripts/**/*.ts src/**/*.ts test/**/*.ts",
    "build:deps": "tsx ./scripts/deps.ts",
    "build:pkg": "tsx ./scripts/pkgJson.ts",
    "build:dist": "yarn build && pkg -d --no-native-build --no-signature --no-bytecode -c ./package.json ./lib/start.cjs",
    "build": "yarn build:pkg && tsc -p tsconfig.types.json --noEmit && rollup -c",
    "start": "node ./lib/start.js",
    "docs:dev": "vitepress dev docs",
    "docs:build": "vitepress build docs",
    "docs:preview": "vitepress preview docs",
    "test": 'vitest && istanbul-badges-readme --colors="red:50,yellow:60"'
  },
  "target": "node22",
  "pkg": {
    "scripts": "./lib/start.cjs",
    "assets": [
      "lib",
      "views"
    ],
    "targets": [
      "node22-linux-x64",
      "node22-macos-x64",
      "node22-win-x64"
    ],
    "outputPath": "."
  },
  "devDependencies": {
    "@cpuchain/eslint": "^1.0.9",
    "@cpuchain/rollup": "^1.0.4",
    "@fastify/cors": "^11.0.1",
    "@fastify/static": "^8.2.0",
    "@fastify/view": "^11.1.0",
    "@types/command-exists": "^1.2.3",
    "@types/ejs": "^3.1.5",
    "@types/node": "^24.1.0",
    "@vitest/coverage-v8": "^3.2.4",
    "@yao-pkg/pkg": "^6.6.0",
    "bootstrap": "^5.3.7",
    "bootstrap-icons": "^1.13.1",
    "command-exists": "^1.2.9",
    "cross-env": "^7.0.3",
    "dotenv": "^17.2.1",
    "ejs": "^3.1.10",
    "fastify": "^5.4.0",
    "glob": "^11.0.3",
    "istanbul-badges-readme": "^1.9.0",
    "logger-chain": "^1.0.3",
    "mmdb-lib": "^3.0.1",
    "tar": "^7.4.3",
    "ts-node": "^10.9.2",
    "tsc": "^2.0.4",
    "tsx": "^4.20.3",
    "typescript": "^5.8.3",
    "vitepress": "^1.6.3",
    "vitest": "^3.2.4"
  },
  "resolutions": {
    "fast-glob": ">=3.3.3"
  }
};

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var config$1 = {};

var main = {exports: {}};

var version$3 = "17.2.1";
var require$$4 = {
	version: version$3};

var hasRequiredMain;

function requireMain () {
	if (hasRequiredMain) return main.exports;
	hasRequiredMain = 1;
	const fs$1 = fs;
	const path$1 = path;
	const os = require$$2;
	const crypto = require$$3$2;
	const packageJson = require$$4;

	const version = packageJson.version;

	// Array of tips to display randomly
	const TIPS = [
	  'üîê encrypt with Dotenvx: https://dotenvx.com',
	  'üîê prevent committing .env to code: https://dotenvx.com/precommit',
	  'üîê prevent building .env in docker: https://dotenvx.com/prebuild',
	  'üì° observe env with Radar: https://dotenvx.com/radar',
	  'üì° auto-backup env with Radar: https://dotenvx.com/radar',
	  'üì° version env with Radar: https://dotenvx.com/radar',
	  'üõ†Ô∏è  run anywhere with `dotenvx run -- yourcommand`',
	  '‚öôÔ∏è  specify custom .env file path with { path: \'/custom/path/.env\' }',
	  '‚öôÔ∏è  enable debug logging with { debug: true }',
	  '‚öôÔ∏è  override existing env vars with { override: true }',
	  '‚öôÔ∏è  suppress all logs with { quiet: true }',
	  '‚öôÔ∏è  write to custom object with { processEnv: myObject }',
	  '‚öôÔ∏è  load multiple .env files with { path: [\'.env.local\', \'.env\'] }'
	];

	// Get a random tip from the tips array
	function _getRandomTip () {
	  return TIPS[Math.floor(Math.random() * TIPS.length)]
	}

	function parseBoolean (value) {
	  if (typeof value === 'string') {
	    return !['false', '0', 'no', 'off', ''].includes(value.toLowerCase())
	  }
	  return Boolean(value)
	}

	function supportsAnsi () {
	  return process.stdout.isTTY // && process.env.TERM !== 'dumb'
	}

	function dim (text) {
	  return supportsAnsi() ? `\x1b[2m${text}\x1b[0m` : text
	}

	const LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;

	// Parse src into an Object
	function parse (src) {
	  const obj = {};

	  // Convert buffer to string
	  let lines = src.toString();

	  // Convert line breaks to same format
	  lines = lines.replace(/\r\n?/mg, '\n');

	  let match;
	  while ((match = LINE.exec(lines)) != null) {
	    const key = match[1];

	    // Default undefined or null to empty string
	    let value = (match[2] || '');

	    // Remove whitespace
	    value = value.trim();

	    // Check if double quoted
	    const maybeQuote = value[0];

	    // Remove surrounding quotes
	    value = value.replace(/^(['"`])([\s\S]*)\1$/mg, '$2');

	    // Expand newlines if double quoted
	    if (maybeQuote === '"') {
	      value = value.replace(/\\n/g, '\n');
	      value = value.replace(/\\r/g, '\r');
	    }

	    // Add to object
	    obj[key] = value;
	  }

	  return obj
	}

	function _parseVault (options) {
	  options = options || {};

	  const vaultPath = _vaultPath(options);
	  options.path = vaultPath; // parse .env.vault
	  const result = DotenvModule.configDotenv(options);
	  if (!result.parsed) {
	    const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
	    err.code = 'MISSING_DATA';
	    throw err
	  }

	  // handle scenario for comma separated keys - for use with key rotation
	  // example: DOTENV_KEY="dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=prod,dotenv://:key_7890@dotenvx.com/vault/.env.vault?environment=prod"
	  const keys = _dotenvKey(options).split(',');
	  const length = keys.length;

	  let decrypted;
	  for (let i = 0; i < length; i++) {
	    try {
	      // Get full key
	      const key = keys[i].trim();

	      // Get instructions for decrypt
	      const attrs = _instructions(result, key);

	      // Decrypt
	      decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);

	      break
	    } catch (error) {
	      // last key
	      if (i + 1 >= length) {
	        throw error
	      }
	      // try next key
	    }
	  }

	  // Parse decrypted .env string
	  return DotenvModule.parse(decrypted)
	}

	function _warn (message) {
	  console.error(`[dotenv@${version}][WARN] ${message}`);
	}

	function _debug (message) {
	  console.log(`[dotenv@${version}][DEBUG] ${message}`);
	}

	function _log (message) {
	  console.log(`[dotenv@${version}] ${message}`);
	}

	function _dotenvKey (options) {
	  // prioritize developer directly setting options.DOTENV_KEY
	  if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {
	    return options.DOTENV_KEY
	  }

	  // secondary infra already contains a DOTENV_KEY environment variable
	  if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
	    return process.env.DOTENV_KEY
	  }

	  // fallback to empty string
	  return ''
	}

	function _instructions (result, dotenvKey) {
	  // Parse DOTENV_KEY. Format is a URI
	  let uri;
	  try {
	    uri = new URL(dotenvKey);
	  } catch (error) {
	    if (error.code === 'ERR_INVALID_URL') {
	      const err = new Error('INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development');
	      err.code = 'INVALID_DOTENV_KEY';
	      throw err
	    }

	    throw error
	  }

	  // Get decrypt key
	  const key = uri.password;
	  if (!key) {
	    const err = new Error('INVALID_DOTENV_KEY: Missing key part');
	    err.code = 'INVALID_DOTENV_KEY';
	    throw err
	  }

	  // Get environment
	  const environment = uri.searchParams.get('environment');
	  if (!environment) {
	    const err = new Error('INVALID_DOTENV_KEY: Missing environment part');
	    err.code = 'INVALID_DOTENV_KEY';
	    throw err
	  }

	  // Get ciphertext payload
	  const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
	  const ciphertext = result.parsed[environmentKey]; // DOTENV_VAULT_PRODUCTION
	  if (!ciphertext) {
	    const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
	    err.code = 'NOT_FOUND_DOTENV_ENVIRONMENT';
	    throw err
	  }

	  return { ciphertext, key }
	}

	function _vaultPath (options) {
	  let possibleVaultPath = null;

	  if (options && options.path && options.path.length > 0) {
	    if (Array.isArray(options.path)) {
	      for (const filepath of options.path) {
	        if (fs$1.existsSync(filepath)) {
	          possibleVaultPath = filepath.endsWith('.vault') ? filepath : `${filepath}.vault`;
	        }
	      }
	    } else {
	      possibleVaultPath = options.path.endsWith('.vault') ? options.path : `${options.path}.vault`;
	    }
	  } else {
	    possibleVaultPath = path$1.resolve(process.cwd(), '.env.vault');
	  }

	  if (fs$1.existsSync(possibleVaultPath)) {
	    return possibleVaultPath
	  }

	  return null
	}

	function _resolveHome (envPath) {
	  return envPath[0] === '~' ? path$1.join(os.homedir(), envPath.slice(1)) : envPath
	}

	function _configVault (options) {
	  const debug = parseBoolean(process.env.DOTENV_CONFIG_DEBUG || (options && options.debug));
	  const quiet = parseBoolean(process.env.DOTENV_CONFIG_QUIET || (options && options.quiet));

	  if (debug || !quiet) {
	    _log('Loading env from encrypted .env.vault');
	  }

	  const parsed = DotenvModule._parseVault(options);

	  let processEnv = process.env;
	  if (options && options.processEnv != null) {
	    processEnv = options.processEnv;
	  }

	  DotenvModule.populate(processEnv, parsed, options);

	  return { parsed }
	}

	function configDotenv (options) {
	  const dotenvPath = path$1.resolve(process.cwd(), '.env');
	  let encoding = 'utf8';
	  let processEnv = process.env;
	  if (options && options.processEnv != null) {
	    processEnv = options.processEnv;
	  }
	  let debug = parseBoolean(processEnv.DOTENV_CONFIG_DEBUG || (options && options.debug));
	  let quiet = parseBoolean(processEnv.DOTENV_CONFIG_QUIET || (options && options.quiet));

	  if (options && options.encoding) {
	    encoding = options.encoding;
	  } else {
	    if (debug) {
	      _debug('No encoding is specified. UTF-8 is used by default');
	    }
	  }

	  let optionPaths = [dotenvPath]; // default, look for .env
	  if (options && options.path) {
	    if (!Array.isArray(options.path)) {
	      optionPaths = [_resolveHome(options.path)];
	    } else {
	      optionPaths = []; // reset default
	      for (const filepath of options.path) {
	        optionPaths.push(_resolveHome(filepath));
	      }
	    }
	  }

	  // Build the parsed data in a temporary object (because we need to return it).  Once we have the final
	  // parsed data, we will combine it with process.env (or options.processEnv if provided).
	  let lastError;
	  const parsedAll = {};
	  for (const path of optionPaths) {
	    try {
	      // Specifying an encoding returns a string instead of a buffer
	      const parsed = DotenvModule.parse(fs$1.readFileSync(path, { encoding }));

	      DotenvModule.populate(parsedAll, parsed, options);
	    } catch (e) {
	      if (debug) {
	        _debug(`Failed to load ${path} ${e.message}`);
	      }
	      lastError = e;
	    }
	  }

	  const populated = DotenvModule.populate(processEnv, parsedAll, options);

	  // handle user settings DOTENV_CONFIG_ options inside .env file(s)
	  debug = parseBoolean(processEnv.DOTENV_CONFIG_DEBUG || debug);
	  quiet = parseBoolean(processEnv.DOTENV_CONFIG_QUIET || quiet);

	  if (debug || !quiet) {
	    const keysCount = Object.keys(populated).length;
	    const shortPaths = [];
	    for (const filePath of optionPaths) {
	      try {
	        const relative = path$1.relative(process.cwd(), filePath);
	        shortPaths.push(relative);
	      } catch (e) {
	        if (debug) {
	          _debug(`Failed to load ${filePath} ${e.message}`);
	        }
	        lastError = e;
	      }
	    }

	    _log(`injecting env (${keysCount}) from ${shortPaths.join(',')} ${dim(`-- tip: ${_getRandomTip()}`)}`);
	  }

	  if (lastError) {
	    return { parsed: parsedAll, error: lastError }
	  } else {
	    return { parsed: parsedAll }
	  }
	}

	// Populates process.env from .env file
	function config (options) {
	  // fallback to original dotenv if DOTENV_KEY is not set
	  if (_dotenvKey(options).length === 0) {
	    return DotenvModule.configDotenv(options)
	  }

	  const vaultPath = _vaultPath(options);

	  // dotenvKey exists but .env.vault file does not exist
	  if (!vaultPath) {
	    _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);

	    return DotenvModule.configDotenv(options)
	  }

	  return DotenvModule._configVault(options)
	}

	function decrypt (encrypted, keyStr) {
	  const key = Buffer.from(keyStr.slice(-64), 'hex');
	  let ciphertext = Buffer.from(encrypted, 'base64');

	  const nonce = ciphertext.subarray(0, 12);
	  const authTag = ciphertext.subarray(-16);
	  ciphertext = ciphertext.subarray(12, -16);

	  try {
	    const aesgcm = crypto.createDecipheriv('aes-256-gcm', key, nonce);
	    aesgcm.setAuthTag(authTag);
	    return `${aesgcm.update(ciphertext)}${aesgcm.final()}`
	  } catch (error) {
	    const isRange = error instanceof RangeError;
	    const invalidKeyLength = error.message === 'Invalid key length';
	    const decryptionFailed = error.message === 'Unsupported state or unable to authenticate data';

	    if (isRange || invalidKeyLength) {
	      const err = new Error('INVALID_DOTENV_KEY: It must be 64 characters long (or more)');
	      err.code = 'INVALID_DOTENV_KEY';
	      throw err
	    } else if (decryptionFailed) {
	      const err = new Error('DECRYPTION_FAILED: Please check your DOTENV_KEY');
	      err.code = 'DECRYPTION_FAILED';
	      throw err
	    } else {
	      throw error
	    }
	  }
	}

	// Populate process.env with parsed values
	function populate (processEnv, parsed, options = {}) {
	  const debug = Boolean(options && options.debug);
	  const override = Boolean(options && options.override);
	  const populated = {};

	  if (typeof parsed !== 'object') {
	    const err = new Error('OBJECT_REQUIRED: Please check the processEnv argument being passed to populate');
	    err.code = 'OBJECT_REQUIRED';
	    throw err
	  }

	  // Set process.env
	  for (const key of Object.keys(parsed)) {
	    if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
	      if (override === true) {
	        processEnv[key] = parsed[key];
	        populated[key] = parsed[key];
	      }

	      if (debug) {
	        if (override === true) {
	          _debug(`"${key}" is already defined and WAS overwritten`);
	        } else {
	          _debug(`"${key}" is already defined and was NOT overwritten`);
	        }
	      }
	    } else {
	      processEnv[key] = parsed[key];
	      populated[key] = parsed[key];
	    }
	  }

	  return populated
	}

	const DotenvModule = {
	  configDotenv,
	  _configVault,
	  _parseVault,
	  config,
	  decrypt,
	  parse,
	  populate
	};

	main.exports.configDotenv = DotenvModule.configDotenv;
	main.exports._configVault = DotenvModule._configVault;
	main.exports._parseVault = DotenvModule._parseVault;
	main.exports.config = DotenvModule.config;
	main.exports.decrypt = DotenvModule.decrypt;
	main.exports.parse = DotenvModule.parse;
	main.exports.populate = DotenvModule.populate;

	main.exports = DotenvModule;
	return main.exports;
}

var envOptions;
var hasRequiredEnvOptions;

function requireEnvOptions () {
	if (hasRequiredEnvOptions) return envOptions;
	hasRequiredEnvOptions = 1;
	// ../config.js accepts options via environment variables
	const options = {};

	if (process.env.DOTENV_CONFIG_ENCODING != null) {
	  options.encoding = process.env.DOTENV_CONFIG_ENCODING;
	}

	if (process.env.DOTENV_CONFIG_PATH != null) {
	  options.path = process.env.DOTENV_CONFIG_PATH;
	}

	if (process.env.DOTENV_CONFIG_QUIET != null) {
	  options.quiet = process.env.DOTENV_CONFIG_QUIET;
	}

	if (process.env.DOTENV_CONFIG_DEBUG != null) {
	  options.debug = process.env.DOTENV_CONFIG_DEBUG;
	}

	if (process.env.DOTENV_CONFIG_OVERRIDE != null) {
	  options.override = process.env.DOTENV_CONFIG_OVERRIDE;
	}

	if (process.env.DOTENV_CONFIG_DOTENV_KEY != null) {
	  options.DOTENV_KEY = process.env.DOTENV_CONFIG_DOTENV_KEY;
	}

	envOptions = options;
	return envOptions;
}

var cliOptions;
var hasRequiredCliOptions;

function requireCliOptions () {
	if (hasRequiredCliOptions) return cliOptions;
	hasRequiredCliOptions = 1;
	const re = /^dotenv_config_(encoding|path|quiet|debug|override|DOTENV_KEY)=(.+)$/;

	cliOptions = function optionMatcher (args) {
	  const options = args.reduce(function (acc, cur) {
	    const matches = cur.match(re);
	    if (matches) {
	      acc[matches[1]] = matches[2];
	    }
	    return acc
	  }, {});

	  if (!('quiet' in options)) {
	    options.quiet = 'true';
	  }

	  return options
	};
	return cliOptions;
}

var hasRequiredConfig;

function requireConfig () {
	if (hasRequiredConfig) return config$1;
	hasRequiredConfig = 1;
	(function () {
	  requireMain().config(
	    Object.assign(
	      {},
	      requireEnvOptions(),
	      requireCliOptions()(process.argv)
	    )
	  );
	})();
	return config$1;
}

requireConfig();

const __dirname$1 = path.dirname(require$$4$1.fileURLToPath((typeof document === 'undefined' ? require('u' + 'rl').pathToFileURL(__filename).href : (_documentCurrentScript && _documentCurrentScript.tagName.toUpperCase() === 'SCRIPT' && _documentCurrentScript.src || new URL('start.cjs', document.baseURI).href))));
const viewsDir = path.join(__dirname$1, "../views");
function configFactory() {
  const config = {
    host: process$1.env.HOST || "0.0.0.0",
    port: Number(process$1.env.PORT) || 3e3,
    workers: Number(process$1.env.WORKERS) || require$$2.cpus().length,
    logLevel: process$1.env.LOG_LEVEL || "debug",
    logColors: process$1.env.LOG_COLORS !== "false",
    licenseKey: process$1.env.LICENSE_KEY,
    dbRoot: process$1.env.DB_ROOT || path.join(process$1.cwd(), "./data"),
    updateInterval: process$1.env.UPDATE_INTERVAL ? Number(process$1.env.UPDATE_INTERVAL) * 1e3 : 86400 * 1e3,
    reverseProxy: process$1.env.REVERSE_PROXY === "true",
    name: process$1.env.NAME || pkgJson.name,
    description: process$1.env.DESCRIPTION || pkgJson.description,
    keywords: process$1.env.KEYWORDS || pkgJson.keywords.join(", "),
    publicEndpoint: process$1.env.PUBLIC_ENDPOINT || "",
    googleVerification: process$1.env.GOOGLE_VERIFICATION,
    noCloudflare: process$1.env.NO_CLOUDFLARE !== "false"
  };
  if (!config.publicEndpoint) {
    config.publicEndpoint = `http://${config.host}:${config.port}`;
  }
  return config;
}

function digestIP(ip) {
  return require$$3$2.webcrypto.subtle.digest("SHA-1", new TextEncoder().encode(ip)).then((d) => {
    return Array.from(new Uint8Array(d)).map((b) => b.toString(16).padStart(2, "0")).join("");
  });
}
class Stats {
  logger;
  visitors;
  visitorsCount;
  queryCount;
  updatedDB;
  dbVersion;
  lastUpdate;
  lastDBUpdate;
  constructor(config) {
    this.logger = new Logger(config, "Main", "Stats");
    this.visitors = /* @__PURE__ */ new Set();
    this.visitorsCount = 0;
    this.queryCount = 0;
    this.updatedDB = 0;
    this.dbVersion = 0;
    this.lastUpdate = "";
    this.lastDBUpdate = "";
  }
  serialize() {
    return {
      queryCount: this.queryCount,
      visitorsCount: this.visitorsCount,
      updatedDB: this.updatedDB,
      dbVersion: this.dbVersion,
      lastUpdate: this.lastUpdate,
      lastDBUpdate: this.lastDBUpdate
    };
  }
  async addVisitor(ip) {
    try {
      const hash = await digestIP(ip);
      if (!this.visitors.has(hash)) {
        this.visitorsCount++;
        this.visitors.add(hash);
      }
      this.queryCount++;
    } catch (err) {
      this.logger.error("Error while adding visitor");
      console.log(err);
    }
  }
  clearVisitors() {
    this.visitors = /* @__PURE__ */ new Set();
    this.visitorsCount = 0;
    this.queryCount = 0;
  }
}

function sleep(ms) {
  return new Promise((r) => setTimeout(r, ms));
}
function pad(n) {
  return n < 10 ? "0" + n : n.toString();
}
function formatDate(date) {
  const year = date.getFullYear();
  const month = pad(date.getMonth() + 1);
  const day = pad(date.getDate());
  const hours = pad(date.getHours());
  const minutes = pad(date.getMinutes());
  const seconds = pad(date.getSeconds());
  const matched = date.toString().match(/GMT[+-]\d{4}/);
  const timezone = matched?.[0] || "";
  return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}${timezone ? ` ${timezone}` : ""}`;
}

var fastify = {exports: {}};

var queue = {exports: {}};

var reusify_1;
var hasRequiredReusify;

function requireReusify () {
	if (hasRequiredReusify) return reusify_1;
	hasRequiredReusify = 1;

	function reusify (Constructor) {
	  var head = new Constructor();
	  var tail = head;

	  function get () {
	    var current = head;

	    if (current.next) {
	      head = current.next;
	    } else {
	      head = new Constructor();
	      tail = head;
	    }

	    current.next = null;

	    return current
	  }

	  function release (obj) {
	    tail.next = obj;
	    tail = obj;
	  }

	  return {
	    get: get,
	    release: release
	  }
	}

	reusify_1 = reusify;
	return reusify_1;
}

var hasRequiredQueue;

function requireQueue () {
	if (hasRequiredQueue) return queue.exports;
	hasRequiredQueue = 1;

	/* eslint-disable no-var */

	var reusify = requireReusify();

	function fastqueue (context, worker, _concurrency) {
	  if (typeof context === 'function') {
	    _concurrency = worker;
	    worker = context;
	    context = null;
	  }

	  if (!(_concurrency >= 1)) {
	    throw new Error('fastqueue concurrency must be equal to or greater than 1')
	  }

	  var cache = reusify(Task);
	  var queueHead = null;
	  var queueTail = null;
	  var _running = 0;
	  var errorHandler = null;

	  var self = {
	    push: push,
	    drain: noop,
	    saturated: noop,
	    pause: pause,
	    paused: false,

	    get concurrency () {
	      return _concurrency
	    },
	    set concurrency (value) {
	      if (!(value >= 1)) {
	        throw new Error('fastqueue concurrency must be equal to or greater than 1')
	      }
	      _concurrency = value;

	      if (self.paused) return
	      for (; queueHead && _running < _concurrency;) {
	        _running++;
	        release();
	      }
	    },

	    running: running,
	    resume: resume,
	    idle: idle,
	    length: length,
	    getQueue: getQueue,
	    unshift: unshift,
	    empty: noop,
	    kill: kill,
	    killAndDrain: killAndDrain,
	    error: error
	  };

	  return self

	  function running () {
	    return _running
	  }

	  function pause () {
	    self.paused = true;
	  }

	  function length () {
	    var current = queueHead;
	    var counter = 0;

	    while (current) {
	      current = current.next;
	      counter++;
	    }

	    return counter
	  }

	  function getQueue () {
	    var current = queueHead;
	    var tasks = [];

	    while (current) {
	      tasks.push(current.value);
	      current = current.next;
	    }

	    return tasks
	  }

	  function resume () {
	    if (!self.paused) return
	    self.paused = false;
	    if (queueHead === null) {
	      _running++;
	      release();
	      return
	    }
	    for (; queueHead && _running < _concurrency;) {
	      _running++;
	      release();
	    }
	  }

	  function idle () {
	    return _running === 0 && self.length() === 0
	  }

	  function push (value, done) {
	    var current = cache.get();

	    current.context = context;
	    current.release = release;
	    current.value = value;
	    current.callback = done || noop;
	    current.errorHandler = errorHandler;

	    if (_running >= _concurrency || self.paused) {
	      if (queueTail) {
	        queueTail.next = current;
	        queueTail = current;
	      } else {
	        queueHead = current;
	        queueTail = current;
	        self.saturated();
	      }
	    } else {
	      _running++;
	      worker.call(context, current.value, current.worked);
	    }
	  }

	  function unshift (value, done) {
	    var current = cache.get();

	    current.context = context;
	    current.release = release;
	    current.value = value;
	    current.callback = done || noop;
	    current.errorHandler = errorHandler;

	    if (_running >= _concurrency || self.paused) {
	      if (queueHead) {
	        current.next = queueHead;
	        queueHead = current;
	      } else {
	        queueHead = current;
	        queueTail = current;
	        self.saturated();
	      }
	    } else {
	      _running++;
	      worker.call(context, current.value, current.worked);
	    }
	  }

	  function release (holder) {
	    if (holder) {
	      cache.release(holder);
	    }
	    var next = queueHead;
	    if (next && _running <= _concurrency) {
	      if (!self.paused) {
	        if (queueTail === queueHead) {
	          queueTail = null;
	        }
	        queueHead = next.next;
	        next.next = null;
	        worker.call(context, next.value, next.worked);
	        if (queueTail === null) {
	          self.empty();
	        }
	      } else {
	        _running--;
	      }
	    } else if (--_running === 0) {
	      self.drain();
	    }
	  }

	  function kill () {
	    queueHead = null;
	    queueTail = null;
	    self.drain = noop;
	  }

	  function killAndDrain () {
	    queueHead = null;
	    queueTail = null;
	    self.drain();
	    self.drain = noop;
	  }

	  function error (handler) {
	    errorHandler = handler;
	  }
	}

	function noop () {}

	function Task () {
	  this.value = null;
	  this.callback = noop;
	  this.next = null;
	  this.release = noop;
	  this.context = null;
	  this.errorHandler = null;

	  var self = this;

	  this.worked = function worked (err, result) {
	    var callback = self.callback;
	    var errorHandler = self.errorHandler;
	    var val = self.value;
	    self.value = null;
	    self.callback = noop;
	    if (self.errorHandler) {
	      errorHandler(err, val);
	    }
	    callback.call(self.context, err, result);
	    self.release(self);
	  };
	}

	function queueAsPromised (context, worker, _concurrency) {
	  if (typeof context === 'function') {
	    _concurrency = worker;
	    worker = context;
	    context = null;
	  }

	  function asyncWrapper (arg, cb) {
	    worker.call(this, arg)
	      .then(function (res) {
	        cb(null, res);
	      }, cb);
	  }

	  var queue = fastqueue(context, asyncWrapper, _concurrency);

	  var pushCb = queue.push;
	  var unshiftCb = queue.unshift;

	  queue.push = push;
	  queue.unshift = unshift;
	  queue.drained = drained;

	  return queue

	  function push (value) {
	    var p = new Promise(function (resolve, reject) {
	      pushCb(value, function (err, result) {
	        if (err) {
	          reject(err);
	          return
	        }
	        resolve(result);
	      });
	    });

	    // Let's fork the promise chain to
	    // make the error bubble up to the user but
	    // not lead to a unhandledRejection
	    p.catch(noop);

	    return p
	  }

	  function unshift (value) {
	    var p = new Promise(function (resolve, reject) {
	      unshiftCb(value, function (err, result) {
	        if (err) {
	          reject(err);
	          return
	        }
	        resolve(result);
	      });
	    });

	    // Let's fork the promise chain to
	    // make the error bubble up to the user but
	    // not lead to a unhandledRejection
	    p.catch(noop);

	    return p
	  }

	  function drained () {
	    var p = new Promise(function (resolve) {
	      process.nextTick(function () {
	        if (queue.idle()) {
	          resolve();
	        } else {
	          var previousDrain = queue.drain;
	          queue.drain = function () {
	            if (typeof previousDrain === 'function') previousDrain();
	            resolve();
	            queue.drain = previousDrain;
	          };
	        }
	      });
	    });

	    return p
	  }
	}

	queue.exports = fastqueue;
	queue.exports.promise = queueAsPromised;
	return queue.exports;
}

var error$1 = {exports: {}};

var hasRequiredError$1;

function requireError$1 () {
	if (hasRequiredError$1) return error$1.exports;
	hasRequiredError$1 = 1;

	const { format } = require$$0$2;

	function toString () {
	  return `${this.name} [${this.code}]: ${this.message}`
	}

	const FastifyGenericErrorSymbol = Symbol.for('fastify-error-generic');

	function createError (code, message, statusCode = 500, Base = Error, captureStackTrace = createError.captureStackTrace) {
	  const shouldCreateFastifyGenericError = code === FastifyGenericErrorSymbol;

	  if (shouldCreateFastifyGenericError) {
	    code = 'FST_ERR';
	  }

	  if (!code) throw new Error('Fastify error code must not be empty')
	  if (!message) throw new Error('Fastify error message must not be empty')

	  code = code.toUpperCase();
	  !statusCode && (statusCode = undefined);

	  const FastifySpecificErrorSymbol = Symbol.for(`fastify-error ${code}`);

	  function FastifyError (...args) {
	    if (!new.target) {
	      return new FastifyError(...args)
	    }

	    this.code = code;
	    this.name = 'FastifyError';
	    this.statusCode = statusCode;

	    const lastElement = args.length - 1;
	    if (lastElement !== -1 && args[lastElement] && typeof args[lastElement] === 'object' && 'cause' in args[lastElement]) {
	      this.cause = args.pop().cause;
	    }

	    this.message = format(message, ...args);

	    Error.stackTraceLimit && captureStackTrace && Error.captureStackTrace(this, FastifyError);
	  }

	  FastifyError.prototype = Object.create(Base.prototype, {
	    constructor: {
	      value: FastifyError,
	      enumerable: false,
	      writable: true,
	      configurable: true
	    },
	    [FastifyGenericErrorSymbol]: {
	      value: true,
	      enumerable: false,
	      writable: false,
	      configurable: false
	    },
	    [FastifySpecificErrorSymbol]: {
	      value: true,
	      enumerable: false,
	      writable: false,
	      configurable: false
	    }
	  });

	  if (shouldCreateFastifyGenericError) {
	    Object.defineProperty(FastifyError, Symbol.hasInstance, {
	      value (instance) {
	        return instance && instance[FastifyGenericErrorSymbol]
	      },
	      configurable: false,
	      writable: false,
	      enumerable: false
	    });
	  } else {
	    Object.defineProperty(FastifyError, Symbol.hasInstance, {
	      value (instance) {
	        return instance && instance[FastifySpecificErrorSymbol]
	      },
	      configurable: false,
	      writable: false,
	      enumerable: false
	    });
	  }

	  FastifyError.prototype[Symbol.toStringTag] = 'Error';

	  FastifyError.prototype.toString = toString;

	  return FastifyError
	}

	createError.captureStackTrace = true;

	const FastifyErrorConstructor = createError(FastifyGenericErrorSymbol, 'Fastify Error', 500, Error);

	error$1.exports = createError;
	error$1.exports.FastifyError = FastifyErrorConstructor;
	error$1.exports.default = createError;
	error$1.exports.createError = createError;
	return error$1.exports;
}

var errors$3;
var hasRequiredErrors$3;

function requireErrors$3 () {
	if (hasRequiredErrors$3) return errors$3;
	hasRequiredErrors$3 = 1;

	const { createError } = requireError$1();

	errors$3 = {
	  AVV_ERR_EXPOSE_ALREADY_DEFINED: createError(
	    'AVV_ERR_EXPOSE_ALREADY_DEFINED',
	    "'%s' is already defined, specify an expose option for '%s'"
	  ),
	  AVV_ERR_ATTRIBUTE_ALREADY_DEFINED: createError(
	    'AVV_ERR_ATTRIBUTE_ALREADY_DEFINED',
	    "'%s' is already defined"
	  ),
	  AVV_ERR_CALLBACK_NOT_FN: createError(
	    'AVV_ERR_CALLBACK_NOT_FN',
	    "Callback for '%s' hook is not a function. Received: '%s'"
	  ),
	  AVV_ERR_PLUGIN_NOT_VALID: createError(
	    'AVV_ERR_PLUGIN_NOT_VALID',
	    "Plugin must be a function or a promise. Received: '%s'"
	  ),
	  AVV_ERR_ROOT_PLG_BOOTED: createError(
	    'AVV_ERR_ROOT_PLG_BOOTED',
	    'Root plugin has already booted'
	  ),
	  AVV_ERR_PARENT_PLG_LOADED: createError(
	    'AVV_ERR_PARENT_PLG_LOADED',
	    "Impossible to load '%s' plugin because the parent '%s' was already loaded"
	  ),
	  AVV_ERR_READY_TIMEOUT: createError(
	    'AVV_ERR_READY_TIMEOUT',
	    "Plugin did not start in time: '%s'. You may have forgotten to call 'done' function or to resolve a Promise"
	  ),
	  AVV_ERR_PLUGIN_EXEC_TIMEOUT: createError(
	    'AVV_ERR_PLUGIN_EXEC_TIMEOUT',
	    "Plugin did not start in time: '%s'. You may have forgotten to call 'done' function or to resolve a Promise"
	  )
	};
	return errors$3;
}

var symbols$2;
var hasRequiredSymbols$2;

function requireSymbols$2 () {
	if (hasRequiredSymbols$2) return symbols$2;
	hasRequiredSymbols$2 = 1;

	// Internal Symbols
	const kAvvio = Symbol('avvio.Boot');
	const kIsOnCloseHandler = Symbol('isOnCloseHandler');
	const kThenifyDoNotWrap = Symbol('avvio.ThenifyDoNotWrap');
	const kUntrackNode = Symbol('avvio.TimeTree.untrackNode');
	const kTrackNode = Symbol('avvio.TimeTree.trackNode');
	const kGetParent = Symbol('avvio.TimeTree.getParent');
	const kGetNode = Symbol('avvio.TimeTree.getNode');
	const kAddNode = Symbol('avvio.TimeTree.addNode');

	// Public Symbols
	const kPluginMeta = Symbol.for('plugin-meta');

	symbols$2 = {
	  kAvvio,
	  kIsOnCloseHandler,
	  kThenifyDoNotWrap,
	  kUntrackNode,
	  kTrackNode,
	  kGetParent,
	  kGetNode,
	  kAddNode,
	  kPluginMeta
	};
	return symbols$2;
}

var timeTree;
var hasRequiredTimeTree;

function requireTimeTree () {
	if (hasRequiredTimeTree) return timeTree;
	hasRequiredTimeTree = 1;

	const {
	  kUntrackNode,
	  kTrackNode,
	  kGetParent,
	  kGetNode,
	  kAddNode
	} = requireSymbols$2();

	/**
	 * Node of the TimeTree
	 * @typedef {object} TimeTreeNode
	 * @property {string} id
	 * @property {string|null} parent
	 * @property {string} label
	 * @property {Array<TimeTreeNode>} nodes
	 * @property {number} start
	 * @property {number|undefined} stop
	 * @property {number|undefined} diff
	 */

	class TimeTree {
	  constructor () {
	    /**
	     * @type {TimeTreeNode|null} root
	     * @public
	     */
	    this.root = null;

	    /**
	     * @type {Map<string, TimeTreeNode>} tableId
	     * @public
	     */
	    this.tableId = new Map();

	    /**
	     * @type {Map<string, Array<TimeTreeNode>>} tableLabel
	     * @public
	     */
	    this.tableLabel = new Map();
	  }

	  /**
	   * @param {TimeTreeNode} node
	   */
	  [kTrackNode] (node) {
	    this.tableId.set(node.id, node);
	    if (this.tableLabel.has(node.label)) {
	      this.tableLabel.get(node.label).push(node);
	    } else {
	      this.tableLabel.set(node.label, [node]);
	    }
	  }

	  /**
	   * @param {TimeTreeNode} node
	   */
	  [kUntrackNode] (node) {
	    this.tableId.delete(node.id);

	    const labelNode = this.tableLabel.get(node.label);
	    labelNode.pop();

	    if (labelNode.length === 0) {
	      this.tableLabel.delete(node.label);
	    }
	  }

	  /**
	   * @param {string} parent
	   * @returns {TimeTreeNode}
	   */
	  [kGetParent] (parent) {
	    if (parent === null) {
	      return null
	    } else if (this.tableLabel.has(parent)) {
	      const parentNode = this.tableLabel.get(parent);
	      return parentNode[parentNode.length - 1]
	    } else {
	      return null
	    }
	  }

	  /**
	   *
	   * @param {string} nodeId
	   * @returns {TimeTreeNode}
	   */
	  [kGetNode] (nodeId) {
	    return this.tableId.get(nodeId)
	  }

	  /**
	   * @param {string} parent
	   * @param {string} label
	   * @param {number} start
	   * @returns {TimeTreeNode["id"]}
	   */
	  [kAddNode] (parent, label, start) {
	    const parentNode = this[kGetParent](parent);
	    const isRoot = parentNode === null;

	    if (isRoot) {
	      this.root = {
	        parent: null,
	        id: 'root',
	        label,
	        nodes: [],
	        start,
	        stop: null,
	        diff: -1
	      };
	      this[kTrackNode](this.root);
	      return this.root.id
	    }

	    const nodeId = `${label}-${Math.random()}`;
	    /**
	     * @type {TimeTreeNode}
	     */
	    const childNode = {
	      parent,
	      id: nodeId,
	      label,
	      nodes: [],
	      start,
	      stop: null,
	      diff: -1
	    };
	    parentNode.nodes.push(childNode);
	    this[kTrackNode](childNode);
	    return nodeId
	  }

	  /**
	   * @param {string} parent
	   * @param {string} label
	   * @param {number|undefined} start
	   * @returns {TimeTreeNode["id"]}
	   */
	  start (parent, label, start = Date.now()) {
	    return this[kAddNode](parent, label, start)
	  }

	  /**
	   * @param {string} nodeId
	   * @param {number|undefined} stop
	   */
	  stop (nodeId, stop = Date.now()) {
	    const node = this[kGetNode](nodeId);
	    if (node) {
	      node.stop = stop;
	      node.diff = (node.stop - node.start) || 0;
	      this[kUntrackNode](node);
	    }
	  }

	  /**
	   * @returns {TimeTreeNode}
	   */
	  toJSON () {
	    return Object.assign({}, this.root)
	  }

	  /**
	   * @returns {string}
	   */
	  prettyPrint () {
	    return prettyPrintTimeTree(this.toJSON())
	  }
	}

	/**
	 * @param {TimeTreeNode} obj
	 * @param {string|undefined} prefix
	 * @returns {string}
	 */
	function prettyPrintTimeTree (obj, prefix = '') {
	  let result = prefix;

	  const nodesCount = obj.nodes.length;
	  const lastIndex = nodesCount - 1;
	  result += `${obj.label} ${obj.diff} ms\n`;

	  for (let i = 0; i < nodesCount; ++i) {
	    const node = obj.nodes[i];
	    const prefix_ = prefix + (i === lastIndex ? '  ' : '‚îÇ ');

	    result += prefix;
	    result += (i === lastIndex ? '‚îî‚îÄ' : '‚îú‚îÄ');
	    result += (node.nodes.length === 0 ? '‚îÄ ' : '‚î¨ ');
	    result += prettyPrintTimeTree(node, prefix_).slice(prefix.length + 2);
	  }
	  return result
	}

	timeTree = {
	  TimeTree
	};
	return timeTree;
}

var debug_1$1;
var hasRequiredDebug$1;

function requireDebug$1 () {
	if (hasRequiredDebug$1) return debug_1$1;
	hasRequiredDebug$1 = 1;

	const { debuglog } = require$$0$2;

	/**
	 * @callback DebugLogger
	 * @param {string} msg
	 * @param {...unknown} param
	 * @returns {void}
	 */

	/**
	 * @type {DebugLogger}
	 */
	const debug = debuglog('avvio');

	debug_1$1 = {
	  debug
	};
	return debug_1$1;
}

var createPromise_1;
var hasRequiredCreatePromise;

function requireCreatePromise () {
	if (hasRequiredCreatePromise) return createPromise_1;
	hasRequiredCreatePromise = 1;

	/**
	 * @callback PromiseResolve
	 * @param {any|PromiseLike<any>} value
	 * @returns {void}
	 */

	/**
	 * @callback PromiseReject
	 * @param {any} reason
	 * @returns {void}
	 */

	/**
	 * @typedef PromiseObject
	 * @property {Promise} promise
	 * @property {PromiseResolve} resolve
	 * @property {PromiseReject} reject
	 */

	/**
	 * @returns {PromiseObject}
	 */
	function createPromise () {
	  /**
	   * @type {PromiseObject}
	   */
	  const obj = {
	    resolve: null,
	    reject: null,
	    promise: null
	  };

	  obj.promise = new Promise((resolve, reject) => {
	    obj.resolve = resolve;
	    obj.reject = reject;
	  });

	  return obj
	}

	createPromise_1 = {
	  createPromise
	};
	return createPromise_1;
}

var getPluginName_1;
var hasRequiredGetPluginName$1;

function requireGetPluginName$1 () {
	if (hasRequiredGetPluginName$1) return getPluginName_1;
	hasRequiredGetPluginName$1 = 1;

	// this symbol is assigned by fastify-plugin
	const { kPluginMeta } = requireSymbols$2();

	/**
	 * @param {function} plugin
	 * @param {object} [options]
	 * @param {string} [options.name]
	 * @returns {string}
	 */
	function getPluginName (plugin, options) {
	  // use explicit function metadata if set
	  if (plugin[kPluginMeta] && plugin[kPluginMeta].name) {
	    return plugin[kPluginMeta].name
	  }

	  // use explicit name option if set
	  if (options && options.name) {
	    return options.name
	  }

	  // determine from the function
	  if (plugin.name) {
	    return plugin.name
	  } else {
	    // takes the first two lines of the function if nothing else works
	    return plugin.toString().split('\n').slice(0, 2).map(s => s.trim()).join(' -- ')
	  }
	}

	getPluginName_1 = {
	  getPluginName
	};
	return getPluginName_1;
}

var isPromiseLike_1;
var hasRequiredIsPromiseLike;

function requireIsPromiseLike () {
	if (hasRequiredIsPromiseLike) return isPromiseLike_1;
	hasRequiredIsPromiseLike = 1;

	/**
	 * @param {any} maybePromiseLike
	 * @returns {maybePromiseLike is PromiseLike}
	 */
	function isPromiseLike (maybePromiseLike) {
	  return (
	    maybePromiseLike !== null &&
	    typeof maybePromiseLike === 'object' &&
	    typeof maybePromiseLike.then === 'function'
	  )
	}

	isPromiseLike_1 = {
	  isPromiseLike
	};
	return isPromiseLike_1;
}

var plugin$1;
var hasRequiredPlugin$1;

function requirePlugin$1 () {
	if (hasRequiredPlugin$1) return plugin$1;
	hasRequiredPlugin$1 = 1;

	const { EventEmitter } = require$$0$3;
	const { inherits } = require$$0$2;
	const { debug } = requireDebug$1();
	const { createPromise } = requireCreatePromise();
	const { AVV_ERR_PLUGIN_EXEC_TIMEOUT } = requireErrors$3();
	const { getPluginName } = requireGetPluginName$1();
	const { isPromiseLike } = requireIsPromiseLike();

	/**
	 * @param {*} queue
	 * @param {*} func
	 * @param {*} options
	 * @param {boolean} isAfter
	 * @param {number} [timeout]
	 */
	function Plugin (queue, func, options, isAfter, timeout) {
	  this.queue = queue;
	  this.func = func;
	  this.options = options;

	  /**
	   * @type {boolean}
	   */
	  this.isAfter = isAfter;
	  /**
	   * @type {number}
	   */
	  this.timeout = timeout;

	  /**
	   * @type {boolean}
	   */
	  this.started = false;
	  /**
	   * @type {string}
	   */
	  this.name = getPluginName(func, options);

	  this.queue.pause();

	  /**
	   * @type {Error|null}
	   */
	  this._error = null;
	  /**
	   * @type {boolean}
	   */
	  this.loaded = false;

	  this._promise = null;

	  this.startTime = null;
	}

	inherits(Plugin, EventEmitter);

	/**
	 * @callback ExecCallback
	 * @param {Error|null} execErr
	 * @returns
	 */

	/**
	 *
	 * @param {*} server
	 * @param {ExecCallback} callback
	 * @returns
	 */
	Plugin.prototype.exec = function (server, callback) {
	  debug('exec', this.name);

	  this.server = server;
	  const func = this.func;
	  const name = this.name;
	  let completed = false;

	  this.options = typeof this.options === 'function' ? this.options(this.server) : this.options;

	  let timer = null;

	  /**
	   * @param {Error} [execErr]
	   */
	  const done = (execErr) => {
	    if (completed) {
	      debug('loading complete', name);
	      return
	    }

	    this._error = execErr;

	    if (execErr) {
	      debug('exec errored', name);
	    } else {
	      debug('exec completed', name);
	    }

	    completed = true;

	    if (timer) {
	      clearTimeout(timer);
	    }

	    callback(execErr);
	  };

	  if (this.timeout > 0) {
	    debug('setting up timeout', name, this.timeout);
	    timer = setTimeout(function () {
	      debug('timed out', name);
	      timer = null;
	      const readyTimeoutErr = new AVV_ERR_PLUGIN_EXEC_TIMEOUT(name);
	      // TODO Remove reference to function
	      readyTimeoutErr.fn = func;
	      done(readyTimeoutErr);
	    }, this.timeout);
	  }

	  this.started = true;
	  this.startTime = Date.now();
	  this.emit('start', this.server ? this.server.name : null, this.name, Date.now());

	  const maybePromiseLike = func(this.server, this.options, done);

	  if (isPromiseLike(maybePromiseLike)) {
	    debug('exec: resolving promise', name);

	    maybePromiseLike.then(
	      () => process.nextTick(done),
	      (e) => process.nextTick(done, e));
	  } else if (func.length < 3) {
	    done();
	  }
	};

	/**
	 * @returns {Promise}
	 */
	Plugin.prototype.loadedSoFar = function () {
	  debug('loadedSoFar', this.name);

	  if (this.loaded) {
	    return Promise.resolve()
	  }

	  const setup = () => {
	    this.server.after((afterErr, callback) => {
	      this._error = afterErr;
	      this.queue.pause();

	      if (this._promise) {
	        if (afterErr) {
	          debug('rejecting promise', this.name, afterErr);
	          this._promise.reject(afterErr);
	        } else {
	          debug('resolving promise', this.name);
	          this._promise.resolve();
	        }
	        this._promise = null;
	      }

	      process.nextTick(callback, afterErr);
	    });
	    this.queue.resume();
	  };

	  let res;

	  if (!this._promise) {
	    this._promise = createPromise();
	    res = this._promise.promise;

	    if (!this.server) {
	      this.on('start', setup);
	    } else {
	      setup();
	    }
	  } else {
	    res = Promise.resolve();
	  }

	  return res
	};

	/**
	 * @callback EnqueueCallback
	 * @param {Error|null} enqueueErr
	 * @param {Plugin} result
	 */

	/**
	 *
	 * @param {Plugin} plugin
	 * @param {EnqueueCallback} callback
	 */
	Plugin.prototype.enqueue = function (plugin, callback) {
	  debug('enqueue', this.name, plugin.name);

	  this.emit('enqueue', this.server ? this.server.name : null, this.name, Date.now());
	  this.queue.push(plugin, callback);
	};

	/**
	 * @callback FinishCallback
	 * @param {Error|null} finishErr
	 * @returns
	 */
	/**
	 *
	 * @param {Error|null} err
	 * @param {FinishCallback} callback
	 * @returns
	 */
	Plugin.prototype.finish = function (err, callback) {
	  debug('finish', this.name, err);

	  const done = () => {
	    if (this.loaded) {
	      return
	    }

	    debug('loaded', this.name);
	    this.emit('loaded', this.server ? this.server.name : null, this.name, Date.now());
	    this.loaded = true;

	    callback(err);
	  };

	  if (err) {
	    if (this._promise) {
	      this._promise.reject(err);
	      this._promise = null;
	    }
	    done();
	    return
	  }

	  const check = () => {
	    debug('check', this.name, this.queue.length(), this.queue.running(), this._promise);
	    if (this.queue.length() === 0 && this.queue.running() === 0) {
	      if (this._promise) {
	        const wrap = () => {
	          debug('wrap');
	          queueMicrotask(check);
	        };
	        this._promise.resolve();
	        this._promise.promise.then(wrap, wrap);
	        this._promise = null;
	      } else {
	        done();
	      }
	    } else {
	      debug('delayed', this.name);
	      // finish when the queue of nested plugins to load is empty
	      this.queue.drain = () => {
	        debug('drain', this.name);
	        this.queue.drain = noop;

	        // we defer the check, as a safety net for things
	        // that might be scheduled in the loading callback
	        queueMicrotask(check);
	      };
	    }
	  };

	  queueMicrotask(check);

	  // we start loading the dependents plugins only once
	  // the current level is finished
	  this.queue.resume();
	};

	function noop () {}

	plugin$1 = {
	  Plugin
	};
	return plugin$1;
}

var validatePlugin_1;
var hasRequiredValidatePlugin;

function requireValidatePlugin () {
	if (hasRequiredValidatePlugin) return validatePlugin_1;
	hasRequiredValidatePlugin = 1;

	const { AVV_ERR_PLUGIN_NOT_VALID } = requireErrors$3();

	/**
	 * @param {any} maybePlugin
	 * @throws {AVV_ERR_PLUGIN_NOT_VALID}
	 *
	 * @returns {asserts plugin is Function|PromiseLike}
	 */
	function validatePlugin (maybePlugin) {
	  // validate if plugin is a function or Promise
	  if (!(maybePlugin && (typeof maybePlugin === 'function' || typeof maybePlugin.then === 'function'))) {
	    if (Array.isArray(maybePlugin)) {
	      throw new AVV_ERR_PLUGIN_NOT_VALID('array')
	    } else if (maybePlugin === null) {
	      throw new AVV_ERR_PLUGIN_NOT_VALID('null')
	    } else {
	      throw new AVV_ERR_PLUGIN_NOT_VALID(typeof maybePlugin)
	    }
	  }
	}

	validatePlugin_1 = {
	  validatePlugin
	};
	return validatePlugin_1;
}

var isBundledOrTypescriptPlugin_1;
var hasRequiredIsBundledOrTypescriptPlugin;

function requireIsBundledOrTypescriptPlugin () {
	if (hasRequiredIsBundledOrTypescriptPlugin) return isBundledOrTypescriptPlugin_1;
	hasRequiredIsBundledOrTypescriptPlugin = 1;

	/**
	 * bundled or typescript plugin
	 * @typedef {object} BundledOrTypescriptPlugin
	 * @property {function} default
	 */

	/**
	 * @param {any} maybeBundledOrTypescriptPlugin
	 * @returns {plugin is BundledOrTypescriptPlugin}
	 */
	function isBundledOrTypescriptPlugin (maybeBundledOrTypescriptPlugin) {
	  return (
	    maybeBundledOrTypescriptPlugin !== null &&
	    typeof maybeBundledOrTypescriptPlugin === 'object' &&
	    typeof maybeBundledOrTypescriptPlugin.default === 'function'
	  )
	}

	isBundledOrTypescriptPlugin_1 = {
	  isBundledOrTypescriptPlugin
	};
	return isBundledOrTypescriptPlugin_1;
}

var thenify_1;
var hasRequiredThenify;

function requireThenify () {
	if (hasRequiredThenify) return thenify_1;
	hasRequiredThenify = 1;

	const { debug } = requireDebug$1();
	const { kThenifyDoNotWrap } = requireSymbols$2();

	/**
	 * @callback PromiseConstructorLikeResolve
	 * @param {any} value
	 * @returns {void}
	 */

	/**
	 * @callback PromiseConstructorLikeReject
	 * @param {reason} error
	 * @returns {void}
	 */

	/**
	 * @callback PromiseConstructorLike
	 * @param {PromiseConstructorLikeResolve} resolve
	 * @param {PromiseConstructorLikeReject} reject
	 * @returns {void}
	 */

	/**
	 * @returns {PromiseConstructorLike}
	 */
	function thenify () {
	  // If the instance is ready, then there is
	  // nothing to await. This is true during
	  // await server.ready() as ready() resolves
	  // with the server, end we will end up here
	  // because of automatic promise chaining.
	  if (this.booted) {
	    debug('thenify returning undefined because we are already booted');
	    return
	  }

	  // Calling resolve(this._server) would fetch the then
	  // property on the server, which will lead it here.
	  // If we do not break the recursion, we will loop
	  // forever.
	  if (this[kThenifyDoNotWrap]) {
	    this[kThenifyDoNotWrap] = false;
	    return
	  }

	  debug('thenify');
	  return (resolve, reject) => {
	    const p = this._loadRegistered();
	    return p.then(() => {
	      this[kThenifyDoNotWrap] = true;
	      return resolve(this._server)
	    }, reject)
	  }
	}

	thenify_1 = {
	  thenify
	};
	return thenify_1;
}

var executeWithThenable_1;
var hasRequiredExecuteWithThenable;

function requireExecuteWithThenable () {
	if (hasRequiredExecuteWithThenable) return executeWithThenable_1;
	hasRequiredExecuteWithThenable = 1;
	const { isPromiseLike } = requireIsPromiseLike();
	const { kAvvio } = requireSymbols$2();

	/**
	 * @callback ExecuteWithThenableCallback
	 * @param {Error} error
	 * @returns {void}
	 */

	/**
	 * @param {Function} func
	 * @param {Array<any>} args
	 * @param {ExecuteWithThenableCallback} [callback]
	 */
	function executeWithThenable (func, args, callback) {
	  const result = func.apply(func, args);
	  if (isPromiseLike(result) && !result[kAvvio]) {
	    // process promise but not avvio mock thenable
	    result.then(() => process.nextTick(callback), (error) => process.nextTick(callback, error));
	  } else if (callback) {
	    process.nextTick(callback);
	  }
	}

	executeWithThenable_1 = {
	  executeWithThenable
	};
	return executeWithThenable_1;
}

var boot;
var hasRequiredBoot;

function requireBoot () {
	if (hasRequiredBoot) return boot;
	hasRequiredBoot = 1;

	const fastq = requireQueue();
	const EE = require$$0$3.EventEmitter;
	const inherits = require$$0$2.inherits;
	const {
	  AVV_ERR_EXPOSE_ALREADY_DEFINED,
	  AVV_ERR_CALLBACK_NOT_FN,
	  AVV_ERR_ROOT_PLG_BOOTED,
	  AVV_ERR_READY_TIMEOUT,
	  AVV_ERR_ATTRIBUTE_ALREADY_DEFINED
	} = requireErrors$3();
	const {
	  kAvvio,
	  kIsOnCloseHandler
	} = requireSymbols$2();
	const { TimeTree } = requireTimeTree();
	const { Plugin } = requirePlugin$1();
	const { debug } = requireDebug$1();
	const { validatePlugin } = requireValidatePlugin();
	const { isBundledOrTypescriptPlugin } = requireIsBundledOrTypescriptPlugin();
	const { isPromiseLike } = requireIsPromiseLike();
	const { thenify } = requireThenify();
	const { executeWithThenable } = requireExecuteWithThenable();

	function Boot (server, opts, done) {
	  if (typeof server === 'function' && arguments.length === 1) {
	    done = server;
	    opts = {};
	    server = null;
	  }

	  if (typeof opts === 'function') {
	    done = opts;
	    opts = {};
	  }

	  opts = opts || {};
	  opts.autostart = opts.autostart !== false;
	  opts.timeout = Number(opts.timeout) || 0;
	  opts.expose = opts.expose || {};

	  if (!new.target) {
	    return new Boot(server, opts, done)
	  }

	  this._server = server || this;
	  this._opts = opts;

	  if (server) {
	    this._expose();
	  }

	  /**
	   * @type {Array<Plugin>}
	   */
	  this._current = [];

	  this._error = null;

	  this._lastUsed = null;

	  this.setMaxListeners(0);

	  if (done) {
	    this.once('start', done);
	  }

	  this.started = false;
	  this.booted = false;
	  this.pluginTree = new TimeTree();

	  this._readyQ = fastq(this, callWithCbOrNextTick, 1);
	  this._readyQ.pause();
	  this._readyQ.drain = () => {
	    this.emit('start');
	    // nooping this, we want to emit start only once
	    this._readyQ.drain = noop;
	  };

	  this._closeQ = fastq(this, closeWithCbOrNextTick, 1);
	  this._closeQ.pause();
	  this._closeQ.drain = () => {
	    this.emit('close');
	    // nooping this, we want to emit close only once
	    this._closeQ.drain = noop;
	  };

	  this._doStart = null;

	  const instance = this;
	  this._root = new Plugin(fastq(this, this._loadPluginNextTick, 1), function root (server, opts, done) {
	    instance._doStart = done;
	    opts.autostart && instance.start();
	  }, opts, false, 0);

	  this._trackPluginLoading(this._root);

	  this._loadPlugin(this._root, (err) => {
	    debug('root plugin ready');
	    try {
	      this.emit('preReady');
	      this._root = null;
	    } catch (preReadyError) {
	      err = err || this._error || preReadyError;
	    }

	    if (err) {
	      this._error = err;
	      if (this._readyQ.length() === 0) {
	        throw err
	      }
	    } else {
	      this.booted = true;
	    }
	    this._readyQ.resume();
	  });
	}

	inherits(Boot, EE);

	Boot.prototype.start = function () {
	  this.started = true;

	  // we need to wait any call to use() to happen
	  process.nextTick(this._doStart);
	  return this
	};

	// allows to override the instance of a server, given a plugin
	Boot.prototype.override = function (server, func, opts) {
	  return server
	};

	Boot.prototype[kAvvio] = true;

	// load a plugin
	Boot.prototype.use = function (plugin, opts) {
	  this._lastUsed = this._addPlugin(plugin, opts, false);
	  return this
	};

	Boot.prototype._loadRegistered = function () {
	  const plugin = this._current[0];
	  const weNeedToStart = !this.started && !this.booted;

	  // if the root plugin is not loaded, let's resume that
	  // so one can use after() before calling ready
	  if (weNeedToStart) {
	    process.nextTick(() => this._root.queue.resume());
	  }

	  if (!plugin) {
	    return Promise.resolve()
	  }

	  return plugin.loadedSoFar()
	};

	Object.defineProperty(Boot.prototype, 'then', { get: thenify });

	Boot.prototype._addPlugin = function (pluginFn, opts, isAfter) {
	  if (isBundledOrTypescriptPlugin(pluginFn)) {
	    pluginFn = pluginFn.default;
	  }
	  validatePlugin(pluginFn);
	  opts = opts || {};

	  if (this.booted) {
	    throw new AVV_ERR_ROOT_PLG_BOOTED()
	  }

	  // we always add plugins to load at the current element
	  const current = this._current[0];

	  let timeout = this._opts.timeout;

	  if (!current.loaded && current.timeout > 0) {
	    const delta = Date.now() - current.startTime;
	    // We need to decrease it by 3ms to make sure the internal timeout
	    // is triggered earlier than the parent
	    timeout = current.timeout - (delta + 3);
	  }

	  const plugin = new Plugin(fastq(this, this._loadPluginNextTick, 1), pluginFn, opts, isAfter, timeout);
	  this._trackPluginLoading(plugin);

	  if (current.loaded) {
	    throw new Error(plugin.name, current.name)
	  }

	  // we add the plugin to be loaded at the end of the current queue
	  current.enqueue(plugin, (err) => { err && (this._error = err); });

	  return plugin
	};

	Boot.prototype._expose = function _expose () {
	  const instance = this;
	  const server = instance._server;
	  const {
	    use: useKey = 'use',
	    after: afterKey = 'after',
	    ready: readyKey = 'ready',
	    onClose: onCloseKey = 'onClose',
	    close: closeKey = 'close'
	  } = this._opts.expose;

	  if (server[useKey]) {
	    throw new AVV_ERR_EXPOSE_ALREADY_DEFINED(useKey, 'use')
	  }
	  server[useKey] = function (fn, opts) {
	    instance.use(fn, opts);
	    return this
	  };

	  if (server[afterKey]) {
	    throw new AVV_ERR_EXPOSE_ALREADY_DEFINED(afterKey, 'after')
	  }
	  server[afterKey] = function (func) {
	    if (typeof func !== 'function') {
	      return instance._loadRegistered()
	    }
	    instance.after(encapsulateThreeParam(func, this));
	    return this
	  };

	  if (server[readyKey]) {
	    throw new AVV_ERR_EXPOSE_ALREADY_DEFINED(readyKey, 'ready')
	  }
	  server[readyKey] = function (func) {
	    if (func && typeof func !== 'function') {
	      throw new AVV_ERR_CALLBACK_NOT_FN(readyKey, typeof func)
	    }
	    return instance.ready(func ? encapsulateThreeParam(func, this) : undefined)
	  };

	  if (server[onCloseKey]) {
	    throw new AVV_ERR_EXPOSE_ALREADY_DEFINED(onCloseKey, 'onClose')
	  }
	  server[onCloseKey] = function (func) {
	    if (typeof func !== 'function') {
	      throw new AVV_ERR_CALLBACK_NOT_FN(onCloseKey, typeof func)
	    }
	    instance.onClose(encapsulateTwoParam(func, this));
	    return this
	  };

	  if (server[closeKey]) {
	    throw new AVV_ERR_EXPOSE_ALREADY_DEFINED(closeKey, 'close')
	  }
	  server[closeKey] = function (func) {
	    if (func && typeof func !== 'function') {
	      throw new AVV_ERR_CALLBACK_NOT_FN(closeKey, typeof func)
	    }

	    if (func) {
	      instance.close(encapsulateThreeParam(func, this));
	      return this
	    }

	    // this is a Promise
	    return instance.close()
	  };

	  if (server.then) {
	    throw new AVV_ERR_ATTRIBUTE_ALREADY_DEFINED('then')
	  }
	  Object.defineProperty(server, 'then', { get: thenify.bind(instance) });

	  server[kAvvio] = true;
	};

	Boot.prototype.after = function (func) {
	  if (!func) {
	    return this._loadRegistered()
	  }

	  this._addPlugin(_after.bind(this), {}, true);

	  function _after (s, opts, done) {
	    callWithCbOrNextTick.call(this, func, done);
	  }

	  return this
	};

	Boot.prototype.onClose = function (func) {
	  // this is used to distinguish between onClose and close handlers
	  // because they share the same queue but must be called with different signatures

	  if (typeof func !== 'function') {
	    throw new AVV_ERR_CALLBACK_NOT_FN('onClose', typeof func)
	  }

	  func[kIsOnCloseHandler] = true;
	  this._closeQ.unshift(func, (err) => { err && (this._error = err); });

	  return this
	};

	Boot.prototype.close = function (func) {
	  let promise;

	  if (func) {
	    if (typeof func !== 'function') {
	      throw new AVV_ERR_CALLBACK_NOT_FN('close', typeof func)
	    }
	  } else {
	    promise = new Promise(function (resolve, reject) {
	      func = function (err) {
	        if (err) {
	          return reject(err)
	        }
	        resolve();
	      };
	    });
	  }

	  this.ready(() => {
	    this._error = null;
	    this._closeQ.push(func);
	    process.nextTick(this._closeQ.resume.bind(this._closeQ));
	  });

	  return promise
	};

	Boot.prototype.ready = function (func) {
	  if (func) {
	    if (typeof func !== 'function') {
	      throw new AVV_ERR_CALLBACK_NOT_FN('ready', typeof func)
	    }
	    this._readyQ.push(func);
	    queueMicrotask(this.start.bind(this));
	    return
	  }

	  return new Promise((resolve, reject) => {
	    this._readyQ.push(readyPromiseCB);
	    this.start();

	    /**
	     * The `encapsulateThreeParam` let callback function
	     * bind to the right server instance.
	     * In promises we need to track the last server
	     * instance loaded, the first one in the _current queue.
	     */
	    const relativeContext = this._current[0].server;

	    function readyPromiseCB (err, context, done) {
	      // the context is always binded to the root server
	      if (err) {
	        reject(err);
	      } else {
	        resolve(relativeContext);
	      }
	      process.nextTick(done);
	    }
	  })
	};

	/**
	 * @param {Plugin} plugin
	 * @returns {void}
	 */
	Boot.prototype._trackPluginLoading = function (plugin) {
	  const parentName = this._current[0]?.name || null;
	  plugin.once('start', (serverName, funcName, time) => {
	    const nodeId = this.pluginTree.start(parentName || null, funcName, time);
	    plugin.once('loaded', (serverName, funcName, time) => {
	      this.pluginTree.stop(nodeId, time);
	    });
	  });
	};

	Boot.prototype.prettyPrint = function () {
	  return this.pluginTree.prettyPrint()
	};

	Boot.prototype.toJSON = function () {
	  return this.pluginTree.toJSON()
	};

	/**
	 * @callback LoadPluginCallback
	 * @param {Error} [err]
	 */

	/**
	 * Load a plugin
	 *
	 * @param {Plugin} plugin
	 * @param {LoadPluginCallback} callback
	 */
	Boot.prototype._loadPlugin = function (plugin, callback) {
	  const instance = this;
	  if (isPromiseLike(plugin.func)) {
	    plugin.func.then((fn) => {
	      if (typeof fn.default === 'function') {
	        fn = fn.default;
	      }
	      plugin.func = fn;
	      this._loadPlugin(plugin, callback);
	    }, callback);
	    return
	  }

	  const last = instance._current[0];

	  // place the plugin at the top of _current
	  instance._current.unshift(plugin);

	  if (instance._error && !plugin.isAfter) {
	    debug('skipping loading of plugin as instance errored and it is not an after', plugin.name);
	    process.nextTick(execCallback);
	    return
	  }

	  let server = (last && last.server) || instance._server;

	  if (!plugin.isAfter) {
	    // Skip override for after
	    try {
	      server = instance.override(server, plugin.func, plugin.options);
	    } catch (overrideErr) {
	      debug('override errored', plugin.name);
	      return execCallback(overrideErr)
	    }
	  }

	  plugin.exec(server, execCallback);

	  function execCallback (err) {
	    plugin.finish(err, (err) => {
	      instance._current.shift();
	      callback(err);
	    });
	  }
	};

	/**
	* Delays plugin loading until the next tick to ensure any bound `_after` callbacks have a chance
	* to run prior to executing the next plugin
	*/
	Boot.prototype._loadPluginNextTick = function (plugin, callback) {
	  process.nextTick(this._loadPlugin.bind(this), plugin, callback);
	};

	function noop () { }

	function callWithCbOrNextTick (func, cb) {
	  const context = this._server;
	  const err = this._error;

	  // with this the error will appear just in the next after/ready callback
	  this._error = null;
	  if (func.length === 0) {
	    this._error = err;
	    executeWithThenable(func, [], cb);
	  } else if (func.length === 1) {
	    executeWithThenable(func, [err], cb);
	  } else {
	    if (this._opts.timeout === 0) {
	      const wrapCb = (err) => {
	        this._error = err;
	        cb(this._error);
	      };

	      if (func.length === 2) {
	        func(err, wrapCb);
	      } else {
	        func(err, context, wrapCb);
	      }
	    } else {
	      timeoutCall.call(this, func, err, context, cb);
	    }
	  }
	}

	function timeoutCall (func, rootErr, context, cb) {
	  const name = func.unwrappedName ?? func.name;
	  debug('setting up ready timeout', name, this._opts.timeout);
	  let timer = setTimeout(() => {
	    debug('timed out', name);
	    timer = null;
	    const toutErr = new AVV_ERR_READY_TIMEOUT(name);
	    toutErr.fn = func;
	    this._error = toutErr;
	    cb(toutErr);
	  }, this._opts.timeout);

	  if (func.length === 2) {
	    func(rootErr, timeoutCb.bind(this));
	  } else {
	    func(rootErr, context, timeoutCb.bind(this));
	  }

	  function timeoutCb (err) {
	    if (timer) {
	      clearTimeout(timer);
	      this._error = err;
	      cb(this._error);
	    }
	  }
	}

	function closeWithCbOrNextTick (func, cb) {
	  const context = this._server;
	  const isOnCloseHandler = func[kIsOnCloseHandler];
	  if (func.length === 0 || func.length === 1) {
	    let promise;
	    if (isOnCloseHandler) {
	      promise = func(context);
	    } else {
	      promise = func(this._error);
	    }
	    if (promise && typeof promise.then === 'function') {
	      debug('resolving close/onClose promise');
	      promise.then(
	        () => process.nextTick(cb),
	        (e) => process.nextTick(cb, e));
	    } else {
	      process.nextTick(cb);
	    }
	  } else if (func.length === 2) {
	    if (isOnCloseHandler) {
	      func(context, cb);
	    } else {
	      func(this._error, cb);
	    }
	  } else {
	    if (isOnCloseHandler) {
	      func(context, cb);
	    } else {
	      func(this._error, context, cb);
	    }
	  }
	}

	function encapsulateTwoParam (func, that) {
	  return _encapsulateTwoParam.bind(that)
	  function _encapsulateTwoParam (context, cb) {
	    let res;
	    if (func.length === 0) {
	      res = func();
	      if (res && res.then) {
	        res.then(function () {
	          process.nextTick(cb);
	        }, cb);
	      } else {
	        process.nextTick(cb);
	      }
	    } else if (func.length === 1) {
	      res = func(this);

	      if (res && res.then) {
	        res.then(function () {
	          process.nextTick(cb);
	        }, cb);
	      } else {
	        process.nextTick(cb);
	      }
	    } else {
	      func(this, cb);
	    }
	  }
	}

	function encapsulateThreeParam (func, that) {
	  const wrapped = _encapsulateThreeParam.bind(that);
	  wrapped.unwrappedName = func.name;
	  return wrapped
	  function _encapsulateThreeParam (err, cb) {
	    let res;
	    if (!func) {
	      process.nextTick(cb);
	    } else if (func.length === 0) {
	      res = func();
	      if (res && res.then) {
	        res.then(function () {
	          process.nextTick(cb, err);
	        }, cb);
	      } else {
	        process.nextTick(cb, err);
	      }
	    } else if (func.length === 1) {
	      res = func(err);
	      if (res && res.then) {
	        res.then(function () {
	          process.nextTick(cb);
	        }, cb);
	      } else {
	        process.nextTick(cb);
	      }
	    } else if (func.length === 2) {
	      func(err, cb);
	    } else {
	      func(err, this, cb);
	    }
	  }
	}

	boot = Boot;
	return boot;
}

var symbols$1;
var hasRequiredSymbols$1;

function requireSymbols$1 () {
	if (hasRequiredSymbols$1) return symbols$1;
	hasRequiredSymbols$1 = 1;

	const keys = {
	  kAvvioBoot: Symbol('fastify.avvioBoot'),
	  kChildren: Symbol('fastify.children'),
	  kServerBindings: Symbol('fastify.serverBindings'),
	  kBodyLimit: Symbol('fastify.bodyLimit'),
	  kSupportedHTTPMethods: Symbol('fastify.acceptedHTTPMethods'),
	  kRoutePrefix: Symbol('fastify.routePrefix'),
	  kLogLevel: Symbol('fastify.logLevel'),
	  kLogSerializers: Symbol('fastify.logSerializers'),
	  kHooks: Symbol('fastify.hooks'),
	  kContentTypeParser: Symbol('fastify.contentTypeParser'),
	  kState: Symbol('fastify.state'),
	  kOptions: Symbol('fastify.options'),
	  kDisableRequestLogging: Symbol('fastify.disableRequestLogging'),
	  kPluginNameChain: Symbol('fastify.pluginNameChain'),
	  kRouteContext: Symbol('fastify.context'),
	  kGenReqId: Symbol('fastify.genReqId'),
	  // Schema
	  kSchemaController: Symbol('fastify.schemaController'),
	  kSchemaHeaders: Symbol('headers-schema'),
	  kSchemaParams: Symbol('params-schema'),
	  kSchemaQuerystring: Symbol('querystring-schema'),
	  kSchemaBody: Symbol('body-schema'),
	  kSchemaResponse: Symbol('response-schema'),
	  kSchemaErrorFormatter: Symbol('fastify.schemaErrorFormatter'),
	  kSchemaVisited: Symbol('fastify.schemas.visited'),
	  // Request
	  kRequest: Symbol('fastify.Request'),
	  kRequestPayloadStream: Symbol('fastify.RequestPayloadStream'),
	  kRequestAcceptVersion: Symbol('fastify.RequestAcceptVersion'),
	  kRequestCacheValidateFns: Symbol('fastify.request.cache.validateFns'),
	  kRequestOriginalUrl: Symbol('fastify.request.originalUrl'),
	  // 404
	  kFourOhFour: Symbol('fastify.404'),
	  kCanSetNotFoundHandler: Symbol('fastify.canSetNotFoundHandler'),
	  kFourOhFourLevelInstance: Symbol('fastify.404LogLevelInstance'),
	  kFourOhFourContext: Symbol('fastify.404ContextKey'),
	  kDefaultJsonParse: Symbol('fastify.defaultJSONParse'),
	  // Reply
	  kReply: Symbol('fastify.Reply'),
	  kReplySerializer: Symbol('fastify.reply.serializer'),
	  kReplyIsError: Symbol('fastify.reply.isError'),
	  kReplyHeaders: Symbol('fastify.reply.headers'),
	  kReplyTrailers: Symbol('fastify.reply.trailers'),
	  kReplyHasStatusCode: Symbol('fastify.reply.hasStatusCode'),
	  kReplyHijacked: Symbol('fastify.reply.hijacked'),
	  kReplyStartTime: Symbol('fastify.reply.startTime'),
	  kReplyNextErrorHandler: Symbol('fastify.reply.nextErrorHandler'),
	  kReplyEndTime: Symbol('fastify.reply.endTime'),
	  kReplyErrorHandlerCalled: Symbol('fastify.reply.errorHandlerCalled'),
	  kReplyIsRunningOnErrorHook: Symbol('fastify.reply.isRunningOnErrorHook'),
	  kReplySerializerDefault: Symbol('fastify.replySerializerDefault'),
	  kReplyCacheSerializeFns: Symbol('fastify.reply.cache.serializeFns'),
	  // This symbol is only meant to be used for fastify tests and should not be used for any other purpose
	  kTestInternals: Symbol('fastify.testInternals'),
	  kErrorHandler: Symbol('fastify.errorHandler'),
	  kErrorHandlerAlreadySet: Symbol('fastify.errorHandlerAlreadySet'),
	  kChildLoggerFactory: Symbol('fastify.childLoggerFactory'),
	  kHasBeenDecorated: Symbol('fastify.hasBeenDecorated'),
	  kKeepAliveConnections: Symbol('fastify.keepAliveConnections'),
	  kRouteByFastify: Symbol('fastify.routeByFastify')
	};

	symbols$1 = keys;
	return symbols$1;
}

var server = {};

var processWarning$1 = {exports: {}};

var hasRequiredProcessWarning$1;

function requireProcessWarning$1 () {
	if (hasRequiredProcessWarning$1) return processWarning$1.exports;
	hasRequiredProcessWarning$1 = 1;

	const { format } = require$$0$2;

	/**
	 * @namespace processWarning
	 */

	/**
	 * Represents a warning item with details.
	 * @typedef {Function} WarningItem
	 * @param {*} [a] Possible message interpolation value.
	 * @param {*} [b] Possible message interpolation value.
	 * @param {*} [c] Possible message interpolation value.
	 * @property {string} name - The name of the warning.
	 * @property {string} code - The code associated with the warning.
	 * @property {string} message - The warning message.
	 * @property {boolean} emitted - Indicates if the warning has been emitted.
	 * @property {function} format - Formats the warning message.
	 */

	/**
	 * Options for creating a process warning.
	 * @typedef {Object} ProcessWarningOptions
	 * @property {string} name - The name of the warning.
	 * @property {string} code - The code associated with the warning.
	 * @property {string} message - The warning message.
	 * @property {boolean} [unlimited=false] - If true, allows unlimited emissions of the warning.
	 */

	/**
	 * Represents the process warning functionality.
	 * @typedef {Object} ProcessWarning
	 * @property {function} createWarning - Creates a warning item.
	 * @property {function} createDeprecation - Creates a deprecation warning item.
	 */

	/**
	 * Creates a deprecation warning item.
	 * @function
	 * @memberof processWarning
	 * @param {ProcessWarningOptions} params - Options for creating the warning.
	 * @returns {WarningItem} The created deprecation warning item.
	 */
	function createDeprecation (params) {
	  return createWarning({ ...params, name: 'DeprecationWarning' })
	}

	/**
	 * Creates a warning item.
	 * @function
	 * @memberof processWarning
	 * @param {ProcessWarningOptions} params - Options for creating the warning.
	 * @returns {WarningItem} The created warning item.
	 * @throws {Error} Throws an error if name, code, or message is empty, or if opts.unlimited is not a boolean.
	 */
	function createWarning ({ name, code, message, unlimited = false } = {}) {
	  if (!name) throw new Error('Warning name must not be empty')
	  if (!code) throw new Error('Warning code must not be empty')
	  if (!message) throw new Error('Warning message must not be empty')
	  if (typeof unlimited !== 'boolean') throw new Error('Warning opts.unlimited must be a boolean')

	  code = code.toUpperCase();

	  let warningContainer = {
	    [name]: function (a, b, c) {
	      if (warning.emitted === true && warning.unlimited !== true) {
	        return
	      }
	      warning.emitted = true;
	      process.emitWarning(warning.format(a, b, c), warning.name, warning.code);
	    }
	  };
	  if (unlimited) {
	    warningContainer = {
	      [name]: function (a, b, c) {
	        warning.emitted = true;
	        process.emitWarning(warning.format(a, b, c), warning.name, warning.code);
	      }
	    };
	  }

	  const warning = warningContainer[name];

	  warning.emitted = false;
	  warning.message = message;
	  warning.unlimited = unlimited;
	  warning.code = code;

	  /**
	   * Formats the warning message.
	   * @param {*} [a] Possible message interpolation value.
	   * @param {*} [b] Possible message interpolation value.
	   * @param {*} [c] Possible message interpolation value.
	   * @returns {string} The formatted warning message.
	   */
	  warning.format = function (a, b, c) {
	    let formatted;
	    if (a && b && c) {
	      formatted = format(message, a, b, c);
	    } else if (a && b) {
	      formatted = format(message, a, b);
	    } else if (a) {
	      formatted = format(message, a);
	    } else {
	      formatted = message;
	    }
	    return formatted
	  };

	  return warning
	}

	/**
	 * Module exports containing the process warning functionality.
	 * @namespace
	 * @property {function} createWarning - Creates a warning item.
	 * @property {function} createDeprecation - Creates a deprecation warning item.
	 * @property {ProcessWarning} processWarning - Represents the process warning functionality.
	 */
	const out = { createWarning, createDeprecation };
	processWarning$1.exports = out;
	processWarning$1.exports.default = out;
	processWarning$1.exports.processWarning = out;
	return processWarning$1.exports;
}

var warnings;
var hasRequiredWarnings;

function requireWarnings () {
	if (hasRequiredWarnings) return warnings;
	hasRequiredWarnings = 1;

	const { createWarning } = requireProcessWarning$1();

	/**
	 * Deprecation codes:
	 *   - FSTWRN001
	 *   - FSTSEC001
	 *
	 * Deprecation Codes FSTDEP001 - FSTDEP021 were used by v4 and MUST NOT not be reused.
	 * Warning Codes FSTWRN001 - FSTWRN002 were used by v4 and MUST NOT not be reused.
	 */

	const FSTWRN001 = createWarning({
	  name: 'FastifyWarning',
	  code: 'FSTWRN001',
	  message: 'The %s schema for %s: %s is missing. This may indicate the schema is not well specified.',
	  unlimited: true
	});

	const FSTWRN003 = createWarning({
	  name: 'FastifyWarning',
	  code: 'FSTWRN003',
	  message: 'The %s mixes async and callback styles that may lead to unhandled rejections. Please use only one of them.',
	  unlimited: true
	});

	const FSTWRN004 = createWarning({
	  name: 'FastifyWarning',
	  code: 'FSTWRN004',
	  message: 'It seems that you are overriding an errorHandler in the same scope, which can lead to subtle bugs.',
	  unlimited: true
	});

	const FSTSEC001 = createWarning({
	  name: 'FastifySecurity',
	  code: 'FSTSEC001',
	  message: 'You are using /%s/ Content-Type which may be vulnerable to CORS attack. Please make sure your RegExp start with "^" or include ";?" to proper detection of the essence MIME type.',
	  unlimited: true
	});

	warnings = {
	  FSTWRN001,
	  FSTWRN003,
	  FSTWRN004,
	  FSTSEC001
	};
	return warnings;
}

var errors$2 = {exports: {}};

var hasRequiredErrors$2;

function requireErrors$2 () {
	if (hasRequiredErrors$2) return errors$2.exports;
	hasRequiredErrors$2 = 1;

	const createError = requireError$1();

	const codes = {
	  /**
	   * Basic
	   */
	  FST_ERR_NOT_FOUND: createError(
	    'FST_ERR_NOT_FOUND',
	    'Not Found',
	    404
	  ),
	  FST_ERR_OPTIONS_NOT_OBJ: createError(
	    'FST_ERR_OPTIONS_NOT_OBJ',
	    'Options must be an object',
	    500,
	    TypeError
	  ),
	  FST_ERR_QSP_NOT_FN: createError(
	    'FST_ERR_QSP_NOT_FN',
	    "querystringParser option should be a function, instead got '%s'",
	    500,
	    TypeError
	  ),
	  FST_ERR_SCHEMA_CONTROLLER_BUCKET_OPT_NOT_FN: createError(
	    'FST_ERR_SCHEMA_CONTROLLER_BUCKET_OPT_NOT_FN',
	    "schemaController.bucket option should be a function, instead got '%s'",
	    500,
	    TypeError
	  ),
	  FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN: createError(
	    'FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN',
	    "schemaErrorFormatter option should be a non async function. Instead got '%s'.",
	    500,
	    TypeError
	  ),
	  FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_OBJ: createError(
	    'FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_OBJ',
	    "ajv.customOptions option should be an object, instead got '%s'",
	    500,
	    TypeError
	  ),
	  FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_ARR: createError(
	    'FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_ARR',
	    "ajv.plugins option should be an array, instead got '%s'",
	    500,
	    TypeError
	  ),
	  FST_ERR_VALIDATION: createError(
	    'FST_ERR_VALIDATION',
	    '%s',
	    400
	  ),
	  FST_ERR_LISTEN_OPTIONS_INVALID: createError(
	    'FST_ERR_LISTEN_OPTIONS_INVALID',
	    "Invalid listen options: '%s'",
	    500,
	    TypeError
	  ),
	  FST_ERR_ERROR_HANDLER_NOT_FN: createError(
	    'FST_ERR_ERROR_HANDLER_NOT_FN',
	    'Error Handler must be a function',
	    500,
	    TypeError
	  ),
	  FST_ERR_ERROR_HANDLER_ALREADY_SET: createError(
	    'FST_ERR_ERROR_HANDLER_ALREADY_SET',
	    "Error Handler already set in this scope. Set 'allowErrorHandlerOverride: true' to allow overriding.",
	    500,
	    TypeError
	  ),

	  /**
	   * ContentTypeParser
	  */
	  FST_ERR_CTP_ALREADY_PRESENT: createError(
	    'FST_ERR_CTP_ALREADY_PRESENT',
	    "Content type parser '%s' already present."
	  ),
	  FST_ERR_CTP_INVALID_TYPE: createError(
	    'FST_ERR_CTP_INVALID_TYPE',
	    'The content type should be a string or a RegExp',
	    500,
	    TypeError
	  ),
	  FST_ERR_CTP_EMPTY_TYPE: createError(
	    'FST_ERR_CTP_EMPTY_TYPE',
	    'The content type cannot be an empty string',
	    500,
	    TypeError
	  ),
	  FST_ERR_CTP_INVALID_HANDLER: createError(
	    'FST_ERR_CTP_INVALID_HANDLER',
	    'The content type handler should be a function',
	    500,
	    TypeError
	  ),
	  FST_ERR_CTP_INVALID_PARSE_TYPE: createError(
	    'FST_ERR_CTP_INVALID_PARSE_TYPE',
	    "The body parser can only parse your data as 'string' or 'buffer', you asked '%s' which is not supported.",
	    500,
	    TypeError
	  ),
	  FST_ERR_CTP_BODY_TOO_LARGE: createError(
	    'FST_ERR_CTP_BODY_TOO_LARGE',
	    'Request body is too large',
	    413,
	    RangeError
	  ),
	  FST_ERR_CTP_INVALID_MEDIA_TYPE: createError(
	    'FST_ERR_CTP_INVALID_MEDIA_TYPE',
	    'Unsupported Media Type: %s',
	    415
	  ),
	  FST_ERR_CTP_INVALID_CONTENT_LENGTH: createError(
	    'FST_ERR_CTP_INVALID_CONTENT_LENGTH',
	    'Request body size did not match Content-Length',
	    400,
	    RangeError
	  ),
	  FST_ERR_CTP_EMPTY_JSON_BODY: createError(
	    'FST_ERR_CTP_EMPTY_JSON_BODY',
	    "Body cannot be empty when content-type is set to 'application/json'",
	    400
	  ),
	  FST_ERR_CTP_INSTANCE_ALREADY_STARTED: createError(
	    'FST_ERR_CTP_INSTANCE_ALREADY_STARTED',
	    'Cannot call "%s" when fastify instance is already started!',
	    400
	  ),

	  /**
	   * decorate
	  */
	  FST_ERR_DEC_ALREADY_PRESENT: createError(
	    'FST_ERR_DEC_ALREADY_PRESENT',
	    "The decorator '%s' has already been added!"
	  ),
	  FST_ERR_DEC_DEPENDENCY_INVALID_TYPE: createError(
	    'FST_ERR_DEC_DEPENDENCY_INVALID_TYPE',
	    "The dependencies of decorator '%s' must be of type Array.",
	    500,
	    TypeError
	  ),
	  FST_ERR_DEC_MISSING_DEPENDENCY: createError(
	    'FST_ERR_DEC_MISSING_DEPENDENCY',
	    "The decorator is missing dependency '%s'."
	  ),
	  FST_ERR_DEC_AFTER_START: createError(
	    'FST_ERR_DEC_AFTER_START',
	    "The decorator '%s' has been added after start!"
	  ),
	  FST_ERR_DEC_REFERENCE_TYPE: createError(
	    'FST_ERR_DEC_REFERENCE_TYPE',
	    "The decorator '%s' of type '%s' is a reference type. Use the { getter, setter } interface instead."
	  ),
	  FST_ERR_DEC_UNDECLARED: createError(
	    'FST_ERR_DEC_UNDECLARED',
	    "No decorator '%s' has been declared on %s."
	  ),

	  /**
	   * hooks
	  */
	  FST_ERR_HOOK_INVALID_TYPE: createError(
	    'FST_ERR_HOOK_INVALID_TYPE',
	    'The hook name must be a string',
	    500,
	    TypeError
	  ),
	  FST_ERR_HOOK_INVALID_HANDLER: createError(
	    'FST_ERR_HOOK_INVALID_HANDLER',
	    '%s hook should be a function, instead got %s',
	    500,
	    TypeError
	  ),
	  FST_ERR_HOOK_INVALID_ASYNC_HANDLER: createError(
	    'FST_ERR_HOOK_INVALID_ASYNC_HANDLER',
	    'Async function has too many arguments. Async hooks should not use the \'done\' argument.',
	    500,
	    TypeError
	  ),
	  FST_ERR_HOOK_NOT_SUPPORTED: createError(
	    'FST_ERR_HOOK_NOT_SUPPORTED',
	    '%s hook not supported!',
	    500,
	    TypeError
	  ),

	  /**
	   * Middlewares
	   */
	  FST_ERR_MISSING_MIDDLEWARE: createError(
	    'FST_ERR_MISSING_MIDDLEWARE',
	    'You must register a plugin for handling middlewares, visit fastify.dev/docs/latest/Reference/Middleware/ for more info.',
	    500
	  ),

	  FST_ERR_HOOK_TIMEOUT: createError(
	    'FST_ERR_HOOK_TIMEOUT',
	    "A callback for '%s' hook%s timed out. You may have forgotten to call 'done' function or to resolve a Promise"
	  ),

	  /**
	   * logger
	  */
	  FST_ERR_LOG_INVALID_DESTINATION: createError(
	    'FST_ERR_LOG_INVALID_DESTINATION',
	    'Cannot specify both logger.stream and logger.file options'
	  ),

	  FST_ERR_LOG_INVALID_LOGGER: createError(
	    'FST_ERR_LOG_INVALID_LOGGER',
	    "Invalid logger object provided. The logger instance should have these functions(s): '%s'.",
	    500,
	    TypeError
	  ),

	  FST_ERR_LOG_INVALID_LOGGER_INSTANCE: createError(
	    'FST_ERR_LOG_INVALID_LOGGER_INSTANCE',
	    'loggerInstance only accepts a logger instance.',
	    500,
	    TypeError
	  ),

	  FST_ERR_LOG_INVALID_LOGGER_CONFIG: createError(
	    'FST_ERR_LOG_INVALID_LOGGER_CONFIG',
	    'logger options only accepts a configuration object.',
	    500,
	    TypeError
	  ),

	  FST_ERR_LOG_LOGGER_AND_LOGGER_INSTANCE_PROVIDED: createError(
	    'FST_ERR_LOG_LOGGER_AND_LOGGER_INSTANCE_PROVIDED',
	    'You cannot provide both logger and loggerInstance. Please provide only one.',
	    500,
	    TypeError
	  ),

	  /**
	   * reply
	  */
	  FST_ERR_REP_INVALID_PAYLOAD_TYPE: createError(
	    'FST_ERR_REP_INVALID_PAYLOAD_TYPE',
	    "Attempted to send payload of invalid type '%s'. Expected a string or Buffer.",
	    500,
	    TypeError
	  ),
	  FST_ERR_REP_RESPONSE_BODY_CONSUMED: createError(
	    'FST_ERR_REP_RESPONSE_BODY_CONSUMED',
	    'Response.body is already consumed.'
	  ),
	  FST_ERR_REP_READABLE_STREAM_LOCKED: createError(
	    'FST_ERR_REP_READABLE_STREAM_LOCKED',
	    'ReadableStream was locked. You should call releaseLock() method on reader before sending.'
	  ),
	  FST_ERR_REP_ALREADY_SENT: createError(
	    'FST_ERR_REP_ALREADY_SENT',
	    'Reply was already sent, did you forget to "return reply" in "%s" (%s)?'
	  ),
	  FST_ERR_REP_SENT_VALUE: createError(
	    'FST_ERR_REP_SENT_VALUE',
	    'The only possible value for reply.sent is true.',
	    500,
	    TypeError
	  ),
	  FST_ERR_SEND_INSIDE_ONERR: createError(
	    'FST_ERR_SEND_INSIDE_ONERR',
	    'You cannot use `send` inside the `onError` hook'
	  ),
	  FST_ERR_SEND_UNDEFINED_ERR: createError(
	    'FST_ERR_SEND_UNDEFINED_ERR',
	    'Undefined error has occurred'
	  ),
	  FST_ERR_BAD_STATUS_CODE: createError(
	    'FST_ERR_BAD_STATUS_CODE',
	    'Called reply with an invalid status code: %s'
	  ),
	  FST_ERR_BAD_TRAILER_NAME: createError(
	    'FST_ERR_BAD_TRAILER_NAME',
	    'Called reply.trailer with an invalid header name: %s'
	  ),
	  FST_ERR_BAD_TRAILER_VALUE: createError(
	    'FST_ERR_BAD_TRAILER_VALUE',
	    "Called reply.trailer('%s', fn) with an invalid type: %s. Expected a function."
	  ),
	  FST_ERR_FAILED_ERROR_SERIALIZATION: createError(
	    'FST_ERR_FAILED_ERROR_SERIALIZATION',
	    'Failed to serialize an error. Error: %s. Original error: %s'
	  ),
	  FST_ERR_MISSING_SERIALIZATION_FN: createError(
	    'FST_ERR_MISSING_SERIALIZATION_FN',
	    'Missing serialization function. Key "%s"'
	  ),
	  FST_ERR_MISSING_CONTENTTYPE_SERIALIZATION_FN: createError(
	    'FST_ERR_MISSING_CONTENTTYPE_SERIALIZATION_FN',
	    'Missing serialization function. Key "%s:%s"'
	  ),
	  FST_ERR_REQ_INVALID_VALIDATION_INVOCATION: createError(
	    'FST_ERR_REQ_INVALID_VALIDATION_INVOCATION',
	    'Invalid validation invocation. Missing validation function for HTTP part "%s" nor schema provided.'
	  ),

	  /**
	   * schemas
	  */
	  FST_ERR_SCH_MISSING_ID: createError(
	    'FST_ERR_SCH_MISSING_ID',
	    'Missing schema $id property'
	  ),
	  FST_ERR_SCH_ALREADY_PRESENT: createError(
	    'FST_ERR_SCH_ALREADY_PRESENT',
	    "Schema with id '%s' already declared!"
	  ),
	  FST_ERR_SCH_CONTENT_MISSING_SCHEMA: createError(
	    'FST_ERR_SCH_CONTENT_MISSING_SCHEMA',
	    "Schema is missing for the content type '%s'"
	  ),
	  FST_ERR_SCH_DUPLICATE: createError(
	    'FST_ERR_SCH_DUPLICATE',
	    "Schema with '%s' already present!"
	  ),
	  FST_ERR_SCH_VALIDATION_BUILD: createError(
	    'FST_ERR_SCH_VALIDATION_BUILD',
	    'Failed building the validation schema for %s: %s, due to error %s'
	  ),
	  FST_ERR_SCH_SERIALIZATION_BUILD: createError(
	    'FST_ERR_SCH_SERIALIZATION_BUILD',
	    'Failed building the serialization schema for %s: %s, due to error %s'
	  ),
	  FST_ERR_SCH_RESPONSE_SCHEMA_NOT_NESTED_2XX: createError(
	    'FST_ERR_SCH_RESPONSE_SCHEMA_NOT_NESTED_2XX',
	    'response schemas should be nested under a valid status code, e.g { 2xx: { type: "object" } }'
	  ),

	  /**
	   * initialConfig
	   */
	  FST_ERR_INIT_OPTS_INVALID: createError(
	    'FST_ERR_INIT_OPTS_INVALID',
	    "Invalid initialization options: '%s'"
	  ),
	  FST_ERR_FORCE_CLOSE_CONNECTIONS_IDLE_NOT_AVAILABLE: createError(
	    'FST_ERR_FORCE_CLOSE_CONNECTIONS_IDLE_NOT_AVAILABLE',
	    "Cannot set forceCloseConnections to 'idle' as your HTTP server does not support closeIdleConnections method"
	  ),

	  /**
	   * router
	   */
	  FST_ERR_DUPLICATED_ROUTE: createError(
	    'FST_ERR_DUPLICATED_ROUTE',
	    "Method '%s' already declared for route '%s'"
	  ),
	  FST_ERR_BAD_URL: createError(
	    'FST_ERR_BAD_URL',
	    "'%s' is not a valid url component",
	    400,
	    URIError
	  ),
	  FST_ERR_ASYNC_CONSTRAINT: createError(
	    'FST_ERR_ASYNC_CONSTRAINT',
	    'Unexpected error from async constraint',
	    500
	  ),
	  FST_ERR_INVALID_URL: createError(
	    'FST_ERR_INVALID_URL',
	    "URL must be a string. Received '%s'",
	    400,
	    TypeError
	  ),
	  FST_ERR_ROUTE_OPTIONS_NOT_OBJ: createError(
	    'FST_ERR_ROUTE_OPTIONS_NOT_OBJ',
	    'Options for "%s:%s" route must be an object',
	    500,
	    TypeError
	  ),
	  FST_ERR_ROUTE_DUPLICATED_HANDLER: createError(
	    'FST_ERR_ROUTE_DUPLICATED_HANDLER',
	    'Duplicate handler for "%s:%s" route is not allowed!',
	    500
	  ),
	  FST_ERR_ROUTE_HANDLER_NOT_FN: createError(
	    'FST_ERR_ROUTE_HANDLER_NOT_FN',
	    'Error Handler for %s:%s route, if defined, must be a function',
	    500,
	    TypeError
	  ),
	  FST_ERR_ROUTE_MISSING_HANDLER: createError(
	    'FST_ERR_ROUTE_MISSING_HANDLER',
	    'Missing handler function for "%s:%s" route.',
	    500
	  ),
	  FST_ERR_ROUTE_METHOD_INVALID: createError(
	    'FST_ERR_ROUTE_METHOD_INVALID',
	    'Provided method is invalid!',
	    500,
	    TypeError
	  ),
	  FST_ERR_ROUTE_METHOD_NOT_SUPPORTED: createError(
	    'FST_ERR_ROUTE_METHOD_NOT_SUPPORTED',
	    '%s method is not supported.',
	    500
	  ),
	  FST_ERR_ROUTE_BODY_VALIDATION_SCHEMA_NOT_SUPPORTED: createError(
	    'FST_ERR_ROUTE_BODY_VALIDATION_SCHEMA_NOT_SUPPORTED',
	    'Body validation schema for %s:%s route is not supported!',
	    500
	  ),
	  FST_ERR_ROUTE_BODY_LIMIT_OPTION_NOT_INT: createError(
	    'FST_ERR_ROUTE_BODY_LIMIT_OPTION_NOT_INT',
	    "'bodyLimit' option must be an integer > 0. Got '%s'",
	    500,
	    TypeError
	  ),
	  FST_ERR_ROUTE_REWRITE_NOT_STR: createError(
	    'FST_ERR_ROUTE_REWRITE_NOT_STR',
	    'Rewrite url for "%s" needs to be of type "string" but received "%s"',
	    500,
	    TypeError
	  ),

	  /**
	   *  again listen when close server
	   */
	  FST_ERR_REOPENED_CLOSE_SERVER: createError(
	    'FST_ERR_REOPENED_CLOSE_SERVER',
	    'Fastify has already been closed and cannot be reopened'
	  ),
	  FST_ERR_REOPENED_SERVER: createError(
	    'FST_ERR_REOPENED_SERVER',
	    'Fastify is already listening'
	  ),
	  FST_ERR_INSTANCE_ALREADY_LISTENING: createError(
	    'FST_ERR_INSTANCE_ALREADY_LISTENING',
	    'Fastify instance is already listening. %s'
	  ),

	  /**
	   * plugin
	   */
	  FST_ERR_PLUGIN_VERSION_MISMATCH: createError(
	    'FST_ERR_PLUGIN_VERSION_MISMATCH',
	    "fastify-plugin: %s - expected '%s' fastify version, '%s' is installed"
	  ),
	  FST_ERR_PLUGIN_NOT_PRESENT_IN_INSTANCE: createError(
	    'FST_ERR_PLUGIN_NOT_PRESENT_IN_INSTANCE',
	    "The decorator '%s'%s is not present in %s"
	  ),
	  FST_ERR_PLUGIN_INVALID_ASYNC_HANDLER: createError(
	    'FST_ERR_PLUGIN_INVALID_ASYNC_HANDLER',
	    'The %s plugin being registered mixes async and callback styles. Async plugin should not mix async and callback style.',
	    500,
	    TypeError
	  ),

	  /**
	   *  Avvio Errors
	   */
	  FST_ERR_PLUGIN_CALLBACK_NOT_FN: createError(
	    'FST_ERR_PLUGIN_CALLBACK_NOT_FN',
	    'fastify-plugin: %s',
	    500,
	    TypeError
	  ),
	  FST_ERR_PLUGIN_NOT_VALID: createError(
	    'FST_ERR_PLUGIN_NOT_VALID',
	    'fastify-plugin: %s'
	  ),
	  FST_ERR_ROOT_PLG_BOOTED: createError(
	    'FST_ERR_ROOT_PLG_BOOTED',
	    'fastify-plugin: %s'
	  ),
	  FST_ERR_PARENT_PLUGIN_BOOTED: createError(
	    'FST_ERR_PARENT_PLUGIN_BOOTED',
	    'fastify-plugin: %s'
	  ),
	  FST_ERR_PLUGIN_TIMEOUT: createError(
	    'FST_ERR_PLUGIN_TIMEOUT',
	    'fastify-plugin: %s'
	  )
	};

	function appendStackTrace (oldErr, newErr) {
	  newErr.cause = oldErr;

	  return newErr
	}

	errors$2.exports = codes;
	errors$2.exports.appendStackTrace = appendStackTrace;
	errors$2.exports.AVVIO_ERRORS_MAP = {
	  AVV_ERR_CALLBACK_NOT_FN: codes.FST_ERR_PLUGIN_CALLBACK_NOT_FN,
	  AVV_ERR_PLUGIN_NOT_VALID: codes.FST_ERR_PLUGIN_NOT_VALID,
	  AVV_ERR_ROOT_PLG_BOOTED: codes.FST_ERR_ROOT_PLG_BOOTED,
	  AVV_ERR_PARENT_PLG_LOADED: codes.FST_ERR_PARENT_PLUGIN_BOOTED,
	  AVV_ERR_READY_TIMEOUT: codes.FST_ERR_PLUGIN_TIMEOUT,
	  AVV_ERR_PLUGIN_EXEC_TIMEOUT: codes.FST_ERR_PLUGIN_TIMEOUT
	};
	return errors$2.exports;
}

var hooks;
var hasRequiredHooks;

function requireHooks () {
	if (hasRequiredHooks) return hooks;
	hasRequiredHooks = 1;

	const applicationHooks = [
	  'onRoute',
	  'onRegister',
	  'onReady',
	  'onListen',
	  'preClose',
	  'onClose'
	];
	const lifecycleHooks = [
	  'onTimeout',
	  'onRequest',
	  'preParsing',
	  'preValidation',
	  'preSerialization',
	  'preHandler',
	  'onSend',
	  'onResponse',
	  'onError',
	  'onRequestAbort'
	];
	const supportedHooks = lifecycleHooks.concat(applicationHooks);
	const {
	  FST_ERR_HOOK_INVALID_TYPE,
	  FST_ERR_HOOK_INVALID_HANDLER,
	  FST_ERR_SEND_UNDEFINED_ERR,
	  FST_ERR_HOOK_TIMEOUT,
	  FST_ERR_HOOK_NOT_SUPPORTED,
	  AVVIO_ERRORS_MAP,
	  appendStackTrace
	} = requireErrors$2();

	const {
	  kChildren,
	  kHooks,
	  kRequestPayloadStream
	} = requireSymbols$1();

	function Hooks () {
	  this.onRequest = [];
	  this.preParsing = [];
	  this.preValidation = [];
	  this.preSerialization = [];
	  this.preHandler = [];
	  this.onResponse = [];
	  this.onSend = [];
	  this.onError = [];
	  this.onRoute = [];
	  this.onRegister = [];
	  this.onReady = [];
	  this.onListen = [];
	  this.onTimeout = [];
	  this.onRequestAbort = [];
	  this.preClose = [];
	}

	Hooks.prototype = Object.create(null);

	Hooks.prototype.validate = function (hook, fn) {
	  if (typeof hook !== 'string') throw new FST_ERR_HOOK_INVALID_TYPE()
	  if (Array.isArray(this[hook]) === false) {
	    throw new FST_ERR_HOOK_NOT_SUPPORTED(hook)
	  }
	  if (typeof fn !== 'function') throw new FST_ERR_HOOK_INVALID_HANDLER(hook, Object.prototype.toString.call(fn))
	};

	Hooks.prototype.add = function (hook, fn) {
	  this.validate(hook, fn);
	  this[hook].push(fn);
	};

	function buildHooks (h) {
	  const hooks = new Hooks();
	  hooks.onRequest = h.onRequest.slice();
	  hooks.preParsing = h.preParsing.slice();
	  hooks.preValidation = h.preValidation.slice();
	  hooks.preSerialization = h.preSerialization.slice();
	  hooks.preHandler = h.preHandler.slice();
	  hooks.onSend = h.onSend.slice();
	  hooks.onResponse = h.onResponse.slice();
	  hooks.onError = h.onError.slice();
	  hooks.onRoute = h.onRoute.slice();
	  hooks.onRegister = h.onRegister.slice();
	  hooks.onTimeout = h.onTimeout.slice();
	  hooks.onRequestAbort = h.onRequestAbort.slice();
	  hooks.onReady = [];
	  hooks.onListen = [];
	  hooks.preClose = [];
	  return hooks
	}

	function hookRunnerApplication (hookName, boot, server, cb) {
	  const hooks = server[kHooks][hookName];
	  let i = 0;
	  let c = 0;

	  next();

	  function exit (err) {
	    const hookFnName = hooks[i - 1]?.name;
	    const hookFnFragment = hookFnName ? ` "${hookFnName}"` : '';

	    if (err) {
	      if (err.code === 'AVV_ERR_READY_TIMEOUT') {
	        err = appendStackTrace(err, new FST_ERR_HOOK_TIMEOUT(hookName, hookFnFragment));
	      } else {
	        err = AVVIO_ERRORS_MAP[err.code] != null
	          ? appendStackTrace(err, new AVVIO_ERRORS_MAP[err.code](err.message))
	          : err;
	      }

	      cb(err);
	      return
	    }
	    cb();
	  }

	  function next (err) {
	    if (err) {
	      exit(err);
	      return
	    }

	    if (i === hooks.length && c === server[kChildren].length) {
	      if (i === 0 && c === 0) { // speed up start
	        exit();
	      } else {
	        // This is the last function executed for every fastify instance
	        boot(function manageTimeout (err, done) {
	          // this callback is needed by fastify to provide an hook interface without the error
	          // as first parameter and managing it on behalf the user
	          exit(err);

	          // this callback is needed by avvio to continue the loading of the next `register` plugins
	          done(err);
	        });
	      }
	      return
	    }

	    if (i === hooks.length && c < server[kChildren].length) {
	      const child = server[kChildren][c++];
	      hookRunnerApplication(hookName, boot, child, next);
	      return
	    }

	    boot(wrap(hooks[i++], server));
	    next();
	  }

	  function wrap (fn, server) {
	    return function (err, done) {
	      if (err) {
	        done(err);
	        return
	      }

	      if (fn.length === 1) {
	        try {
	          fn.call(server, done);
	        } catch (error) {
	          done(error);
	        }
	        return
	      }

	      try {
	        const ret = fn.call(server);
	        if (ret && typeof ret.then === 'function') {
	          ret.then(done, done);
	          return
	        }
	      } catch (error) {
	        err = error;
	      }

	      done(err); // auto done
	    }
	  }
	}

	function onListenHookRunner (server) {
	  const hooks = server[kHooks].onListen;
	  const hooksLen = hooks.length;

	  let i = 0;
	  let c = 0;

	  next();

	  function next (err) {
	    err && server.log.error(err);

	    if (
	      i === hooksLen
	    ) {
	      while (c < server[kChildren].length) {
	        const child = server[kChildren][c++];
	        onListenHookRunner(child);
	      }
	      return
	    }

	    wrap(hooks[i++], server, next);
	  }

	  async function wrap (fn, server, done) {
	    if (fn.length === 1) {
	      try {
	        fn.call(server, done);
	      } catch (e) {
	        done(e);
	      }
	      return
	    }
	    try {
	      const ret = fn.call(server);
	      if (ret && typeof ret.then === 'function') {
	        ret.then(done, done);
	        return
	      }
	      done();
	    } catch (error) {
	      done(error);
	    }
	  }
	}

	function hookRunnerGenerator (iterator) {
	  return function hookRunner (functions, request, reply, cb) {
	    let i = 0;

	    function next (err) {
	      if (err || i === functions.length) {
	        cb(err, request, reply);
	        return
	      }

	      let result;
	      try {
	        result = iterator(functions[i++], request, reply, next);
	      } catch (error) {
	        cb(error, request, reply);
	        return
	      }
	      if (result && typeof result.then === 'function') {
	        result.then(handleResolve, handleReject);
	      }
	    }

	    function handleResolve () {
	      next();
	    }

	    function handleReject (err) {
	      if (!err) {
	        err = new FST_ERR_SEND_UNDEFINED_ERR();
	      }

	      cb(err, request, reply);
	    }

	    next();
	  }
	}

	function onResponseHookIterator (fn, request, reply, next) {
	  return fn(request, reply, next)
	}

	const onResponseHookRunner = hookRunnerGenerator(onResponseHookIterator);
	const preValidationHookRunner = hookRunnerGenerator(hookIterator);
	const preHandlerHookRunner = hookRunnerGenerator(hookIterator);
	const onTimeoutHookRunner = hookRunnerGenerator(hookIterator);
	const onRequestHookRunner = hookRunnerGenerator(hookIterator);

	function onSendHookRunner (functions, request, reply, payload, cb) {
	  let i = 0;

	  function next (err, newPayload) {
	    if (err) {
	      cb(err, request, reply, payload);
	      return
	    }

	    if (newPayload !== undefined) {
	      payload = newPayload;
	    }

	    if (i === functions.length) {
	      cb(null, request, reply, payload);
	      return
	    }

	    let result;
	    try {
	      result = functions[i++](request, reply, payload, next);
	    } catch (error) {
	      cb(error, request, reply);
	      return
	    }
	    if (result && typeof result.then === 'function') {
	      result.then(handleResolve, handleReject);
	    }
	  }

	  function handleResolve (newPayload) {
	    next(null, newPayload);
	  }

	  function handleReject (err) {
	    if (!err) {
	      err = new FST_ERR_SEND_UNDEFINED_ERR();
	    }

	    cb(err, request, reply, payload);
	  }

	  next();
	}

	const preSerializationHookRunner = onSendHookRunner;

	function preParsingHookRunner (functions, request, reply, cb) {
	  let i = 0;

	  function next (err, newPayload) {
	    if (reply.sent) {
	      return
	    }

	    if (newPayload !== undefined) {
	      request[kRequestPayloadStream] = newPayload;
	    }

	    if (err || i === functions.length) {
	      cb(err, request, reply);
	      return
	    }

	    let result;
	    try {
	      result = functions[i++](request, reply, request[kRequestPayloadStream], next);
	    } catch (error) {
	      cb(error, request, reply);
	      return
	    }

	    if (result && typeof result.then === 'function') {
	      result.then(handleResolve, handleReject);
	    }
	  }

	  function handleResolve (newPayload) {
	    next(null, newPayload);
	  }

	  function handleReject (err) {
	    if (!err) {
	      err = new FST_ERR_SEND_UNDEFINED_ERR();
	    }

	    cb(err, request, reply);
	  }

	  next();
	}

	function onRequestAbortHookRunner (functions, request, cb) {
	  let i = 0;

	  function next (err) {
	    if (err || i === functions.length) {
	      cb(err, request);
	      return
	    }

	    let result;
	    try {
	      result = functions[i++](request, next);
	    } catch (error) {
	      cb(error, request);
	      return
	    }
	    if (result && typeof result.then === 'function') {
	      result.then(handleResolve, handleReject);
	    }
	  }

	  function handleResolve () {
	    next();
	  }

	  function handleReject (err) {
	    if (!err) {
	      err = new FST_ERR_SEND_UNDEFINED_ERR();
	    }

	    cb(err, request);
	  }

	  next();
	}

	function hookIterator (fn, request, reply, next) {
	  if (reply.sent === true) return undefined
	  return fn(request, reply, next)
	}

	hooks = {
	  Hooks,
	  buildHooks,
	  hookRunnerGenerator,
	  preParsingHookRunner,
	  onResponseHookRunner,
	  onSendHookRunner,
	  preSerializationHookRunner,
	  onRequestAbortHookRunner,
	  hookIterator,
	  hookRunnerApplication,
	  onListenHookRunner,
	  preHandlerHookRunner,
	  preValidationHookRunner,
	  onRequestHookRunner,
	  onTimeoutHookRunner,
	  lifecycleHooks,
	  supportedHooks
	};
	return hooks;
}

var hasRequiredServer;

function requireServer () {
	if (hasRequiredServer) return server;
	hasRequiredServer = 1;

	const http = require$$0$4;
	const https = require$$1;
	const http2 = require$$2$1;
	const dns = require$$3$3;
	const os = require$$0$5;

	const { kState, kOptions, kServerBindings } = requireSymbols$1();
	const { FSTWRN003 } = requireWarnings();
	const { onListenHookRunner } = requireHooks();
	const {
	  FST_ERR_REOPENED_CLOSE_SERVER,
	  FST_ERR_REOPENED_SERVER,
	  FST_ERR_LISTEN_OPTIONS_INVALID
	} = requireErrors$2();

	server.createServer = createServer;

	function defaultResolveServerListeningText (address) {
	  return `Server listening at ${address}`
	}

	function createServer (options, httpHandler) {
	  const server = getServerInstance(options, httpHandler);

	  // `this` is the Fastify object
	  function listen (
	    listenOptions = { port: 0, host: 'localhost' },
	    cb = undefined
	  ) {
	    if (typeof cb === 'function') {
	      if (cb.constructor.name === 'AsyncFunction') {
	        FSTWRN003('listen method');
	      }

	      listenOptions.cb = cb;
	    }
	    if (listenOptions.signal) {
	      if (typeof listenOptions.signal.on !== 'function' && typeof listenOptions.signal.addEventListener !== 'function') {
	        throw new FST_ERR_LISTEN_OPTIONS_INVALID('Invalid options.signal')
	      }

	      if (listenOptions.signal.aborted) {
	        this.close();
	      } else {
	        const onAborted = () => {
	          this.close();
	        };
	        listenOptions.signal.addEventListener('abort', onAborted, { once: true });
	      }
	    }

	    // If we have a path specified, don't default host to 'localhost' so we don't end up listening
	    // on both path and host
	    // See https://github.com/fastify/fastify/issues/4007
	    let host;
	    if (listenOptions.path == null) {
	      host = listenOptions.host ?? 'localhost';
	    } else {
	      host = listenOptions.host;
	    }
	    if (!Object.hasOwn(listenOptions, 'host') ||
	      listenOptions.host == null) {
	      listenOptions.host = host;
	    }
	    if (host === 'localhost') {
	      listenOptions.cb = (err, address) => {
	        if (err) {
	          // the server did not start
	          cb(err, address);
	          return
	        }

	        multipleBindings.call(this, server, httpHandler, options, listenOptions, () => {
	          this[kState].listening = true;
	          cb(null, address);
	          onListenHookRunner(this);
	        });
	      };
	    } else {
	      listenOptions.cb = (err, address) => {
	        // the server did not start
	        if (err) {
	          cb(err, address);
	          return
	        }
	        this[kState].listening = true;
	        cb(null, address);
	        onListenHookRunner(this);
	      };
	    }

	    // https://github.com/nodejs/node/issues/9390
	    // If listening to 'localhost', listen to both 127.0.0.1 or ::1 if they are available.
	    // If listening to 127.0.0.1, only listen to 127.0.0.1.
	    // If listening to ::1, only listen to ::1.

	    if (cb === undefined) {
	      const listening = listenPromise.call(this, server, listenOptions);
	      return listening.then(address => {
	        return new Promise((resolve, reject) => {
	          if (host === 'localhost') {
	            multipleBindings.call(this, server, httpHandler, options, listenOptions, () => {
	              this[kState].listening = true;
	              resolve(address);
	              onListenHookRunner(this);
	            });
	          } else {
	            resolve(address);
	            onListenHookRunner(this);
	          }
	        })
	      })
	    }

	    this.ready(listenCallback.call(this, server, listenOptions));
	  }

	  return { server, listen }
	}

	function multipleBindings (mainServer, httpHandler, serverOpts, listenOptions, onListen) {
	  // the main server is started, we need to start the secondary servers
	  this[kState].listening = false;

	  // let's check if we need to bind additional addresses
	  dns.lookup(listenOptions.host, { all: true }, (dnsErr, addresses) => {
	    if (dnsErr) {
	      // not blocking the main server listening
	      // this.log.warn('dns.lookup error:', dnsErr)
	      onListen();
	      return
	    }

	    const isMainServerListening = mainServer.listening && serverOpts.serverFactory;

	    let binding = 0;
	    let bound = 0;
	    if (!isMainServerListening) {
	      const primaryAddress = mainServer.address();
	      for (const adr of addresses) {
	        if (adr.address !== primaryAddress.address) {
	          binding++;
	          const secondaryOpts = Object.assign({}, listenOptions, {
	            host: adr.address,
	            port: primaryAddress.port,
	            cb: (_ignoreErr) => {
	              bound++;

	              if (!_ignoreErr) {
	                this[kServerBindings].push(secondaryServer);
	              }

	              if (bound === binding) {
	                // regardless of the error, we are done
	                onListen();
	              }
	            }
	          });

	          const secondaryServer = getServerInstance(serverOpts, httpHandler);
	          const closeSecondary = () => {
	            // To avoid falling into situations where the close of the
	            // secondary server is triggered before the preClose hook
	            // is done running, we better wait until the main server is closed.
	            // No new TCP connections are accepted
	            // We swallow any error from the secondary server
	            secondaryServer.close(() => {});
	            if (typeof secondaryServer.closeAllConnections === 'function' && serverOpts.forceCloseConnections === true) {
	              secondaryServer.closeAllConnections();
	            }
	          };

	          secondaryServer.on('upgrade', mainServer.emit.bind(mainServer, 'upgrade'));
	          mainServer.on('unref', closeSecondary);
	          mainServer.on('close', closeSecondary);
	          mainServer.on('error', closeSecondary);
	          this[kState].listening = false;
	          listenCallback.call(this, secondaryServer, secondaryOpts)();
	        }
	      }
	    }
	    // no extra bindings are necessary
	    if (binding === 0) {
	      onListen();
	      return
	    }

	    // in test files we are using unref so we need to propagate the unref event
	    // to the secondary servers. It is valid only when the user is
	    // listening on localhost
	    const originUnref = mainServer.unref;
	    mainServer.unref = function () {
	      originUnref.call(mainServer);
	      mainServer.emit('unref');
	    };
	  });
	}

	function listenCallback (server, listenOptions) {
	  const wrap = (err) => {
	    server.removeListener('error', wrap);
	    server.removeListener('listening', wrap);
	    if (!err) {
	      const address = logServerAddress.call(this, server, listenOptions.listenTextResolver || defaultResolveServerListeningText);
	      listenOptions.cb(null, address);
	    } else {
	      this[kState].listening = false;
	      listenOptions.cb(err, null);
	    }
	  };

	  return (err) => {
	    if (err != null) return listenOptions.cb(err)

	    if (this[kState].listening && this[kState].closing) {
	      return listenOptions.cb(new FST_ERR_REOPENED_CLOSE_SERVER(), null)
	    }
	    if (this[kState].listening) {
	      return listenOptions.cb(new FST_ERR_REOPENED_SERVER(), null)
	    }

	    server.once('error', wrap);
	    if (!this[kState].closing) {
	      server.once('listening', wrap);
	      server.listen(listenOptions);
	      this[kState].listening = true;
	    }
	  }
	}

	function listenPromise (server, listenOptions) {
	  if (this[kState].listening && this[kState].closing) {
	    return Promise.reject(new FST_ERR_REOPENED_CLOSE_SERVER())
	  }
	  if (this[kState].listening) {
	    return Promise.reject(new FST_ERR_REOPENED_SERVER())
	  }

	  return this.ready().then(() => {
	    let errEventHandler;
	    let listeningEventHandler;
	    function cleanup () {
	      server.removeListener('error', errEventHandler);
	      server.removeListener('listening', listeningEventHandler);
	    }
	    const errEvent = new Promise((resolve, reject) => {
	      errEventHandler = (err) => {
	        cleanup();
	        this[kState].listening = false;
	        reject(err);
	      };
	      server.once('error', errEventHandler);
	    });
	    const listeningEvent = new Promise((resolve, reject) => {
	      listeningEventHandler = () => {
	        cleanup();
	        this[kState].listening = true;
	        resolve(logServerAddress.call(this, server, listenOptions.listenTextResolver || defaultResolveServerListeningText));
	      };
	      server.once('listening', listeningEventHandler);
	    });

	    server.listen(listenOptions);

	    return Promise.race([
	      errEvent, // e.g invalid port range error is always emitted before the server listening
	      listeningEvent
	    ])
	  })
	}

	function getServerInstance (options, httpHandler) {
	  if (options.serverFactory) {
	    // User provided server instance
	    return options.serverFactory(httpHandler, options)
	  }

	  // We have accepted true as a valid way to init https but node requires an options obj
	  const httpsOptions = options.https === true ? {} : options.https;

	  if (options.http2) {
	    const server = typeof httpsOptions === 'object' ? http2.createSecureServer(httpsOptions, httpHandler) : http2.createServer(options.http, httpHandler);
	    server.on('session', (session) => session.setTimeout(options.http2SessionTimeout, function closeSession () {
	      this.close();
	    }));

	    server.setTimeout(options.connectionTimeout);

	    return server
	  }

	  // HTTP1 server instance
	  const server = httpsOptions ? https.createServer(httpsOptions, httpHandler) : http.createServer(options.http, httpHandler);
	  server.keepAliveTimeout = options.keepAliveTimeout;
	  server.requestTimeout = options.requestTimeout;
	  server.setTimeout(options.connectionTimeout);
	  // We treat zero as null(node default) so we do not pass zero to the server instance
	  if (options.maxRequestsPerSocket > 0) {
	    server.maxRequestsPerSocket = options.maxRequestsPerSocket;
	  }

	  return server
	}

	/**
	 * Inspects the provided `server.address` object and returns a
	 * normalized list of IP address strings. Normalization in this
	 * case refers to mapping wildcard `0.0.0.0` to the list of IP
	 * addresses the wildcard refers to.
	 *
	 * @see https://nodejs.org/docs/latest/api/net.html#serveraddress
	 *
	 * @param {object} A server address object as described in the
	 * linked docs.
	 *
	 * @returns {string[]}
	 */
	function getAddresses (address) {
	  if (address.address === '0.0.0.0') {
	    return Object.values(os.networkInterfaces()).flatMap((iface) => {
	      return iface.filter((iface) => iface.family === 'IPv4')
	    }).sort((iface) => {
	      /* c8 ignore next 2 */
	      // Order the interfaces so that internal ones come first
	      return iface.internal ? -1 : 1
	    }).map((iface) => { return iface.address })
	  }
	  return [address.address]
	}

	function logServerAddress (server, listenTextResolver) {
	  let addresses;
	  const isUnixSocket = typeof server.address() === 'string';
	  if (!isUnixSocket) {
	    if (server.address().address.indexOf(':') === -1) {
	      // IPv4
	      addresses = getAddresses(server.address()).map((address) => address + ':' + server.address().port);
	    } else {
	      // IPv6
	      addresses = ['[' + server.address().address + ']:' + server.address().port];
	    }

	    addresses = addresses.map((address) => ('http' + (this[kOptions].https ? 's' : '') + '://') + address);
	  } else {
	    addresses = [server.address()];
	  }

	  for (const address of addresses) {
	    this.log.info(listenTextResolver(address));
	  }
	  return addresses[0]
	}
	return server;
}

var reply = {exports: {}};

var handleRequest = {exports: {}};

var validation$1;
var hasRequiredValidation$1;

function requireValidation$1 () {
	if (hasRequiredValidation$1) return validation$1;
	hasRequiredValidation$1 = 1;

	const {
	  kSchemaHeaders: headersSchema,
	  kSchemaParams: paramsSchema,
	  kSchemaQuerystring: querystringSchema,
	  kSchemaBody: bodySchema,
	  kSchemaResponse: responseSchema
	} = requireSymbols$1();
	const scChecker = /^[1-5](?:\d{2}|xx)$|^default$/;

	const {
	  FST_ERR_SCH_RESPONSE_SCHEMA_NOT_NESTED_2XX
	} = requireErrors$2();

	const { FSTWRN001 } = requireWarnings();

	function compileSchemasForSerialization (context, compile) {
	  if (!context.schema || !context.schema.response) {
	    return
	  }
	  const { method, url } = context.config || {};
	  context[responseSchema] = Object.keys(context.schema.response)
	    .reduce(function (acc, statusCode) {
	      const schema = context.schema.response[statusCode];
	      statusCode = statusCode.toLowerCase();
	      if (!scChecker.test(statusCode)) {
	        throw new FST_ERR_SCH_RESPONSE_SCHEMA_NOT_NESTED_2XX()
	      }

	      if (schema.content) {
	        const contentTypesSchemas = {};
	        for (const mediaName of Object.keys(schema.content)) {
	          const contentSchema = schema.content[mediaName].schema;
	          contentTypesSchemas[mediaName] = compile({
	            schema: contentSchema,
	            url,
	            method,
	            httpStatus: statusCode,
	            contentType: mediaName
	          });
	        }
	        acc[statusCode] = contentTypesSchemas;
	      } else {
	        acc[statusCode] = compile({
	          schema,
	          url,
	          method,
	          httpStatus: statusCode
	        });
	      }

	      return acc
	    }, {});
	}

	function compileSchemasForValidation (context, compile, isCustom) {
	  const { schema } = context;
	  if (!schema) {
	    return
	  }

	  const { method, url } = context.config || {};

	  const headers = schema.headers;
	  // the or part is used for backward compatibility
	  if (headers && (isCustom || Object.getPrototypeOf(headers) !== Object.prototype)) {
	    // do not mess with schema when custom validator applied, e.g. Joi, Typebox
	    context[headersSchema] = compile({ schema: headers, method, url, httpPart: 'headers' });
	  } else if (headers) {
	    // The header keys are case insensitive
	    //  https://datatracker.ietf.org/doc/html/rfc2616#section-4.2
	    const headersSchemaLowerCase = {};
	    Object.keys(headers).forEach(k => { headersSchemaLowerCase[k] = headers[k]; });
	    if (headersSchemaLowerCase.required instanceof Array) {
	      headersSchemaLowerCase.required = headersSchemaLowerCase.required.map(h => h.toLowerCase());
	    }
	    if (headers.properties) {
	      headersSchemaLowerCase.properties = {};
	      Object.keys(headers.properties).forEach(k => {
	        headersSchemaLowerCase.properties[k.toLowerCase()] = headers.properties[k];
	      });
	    }
	    context[headersSchema] = compile({ schema: headersSchemaLowerCase, method, url, httpPart: 'headers' });
	  } else if (Object.hasOwn(schema, 'headers')) {
	    FSTWRN001('headers', method, url);
	  }

	  if (schema.body) {
	    const contentProperty = schema.body.content;
	    if (contentProperty) {
	      const contentTypeSchemas = {};
	      for (const contentType of Object.keys(contentProperty)) {
	        const contentSchema = contentProperty[contentType].schema;
	        contentTypeSchemas[contentType] = compile({ schema: contentSchema, method, url, httpPart: 'body', contentType });
	      }
	      context[bodySchema] = contentTypeSchemas;
	    } else {
	      context[bodySchema] = compile({ schema: schema.body, method, url, httpPart: 'body' });
	    }
	  } else if (Object.hasOwn(schema, 'body')) {
	    FSTWRN001('body', method, url);
	  }

	  if (schema.querystring) {
	    context[querystringSchema] = compile({ schema: schema.querystring, method, url, httpPart: 'querystring' });
	  } else if (Object.hasOwn(schema, 'querystring')) {
	    FSTWRN001('querystring', method, url);
	  }

	  if (schema.params) {
	    context[paramsSchema] = compile({ schema: schema.params, method, url, httpPart: 'params' });
	  } else if (Object.hasOwn(schema, 'params')) {
	    FSTWRN001('params', method, url);
	  }
	}

	function validateParam (validatorFunction, request, paramName) {
	  const isUndefined = request[paramName] === undefined;
	  const ret = validatorFunction && validatorFunction(isUndefined ? null : request[paramName]);

	  if (ret && typeof ret.then === 'function') {
	    return ret
	      .then((res) => { return answer(res) })
	      .catch(err => { return err }) // return as simple error (not throw)
	  }

	  return answer(ret)

	  function answer (ret) {
	    if (ret === false) return validatorFunction.errors
	    if (ret && ret.error) return ret.error
	    if (ret && ret.value) request[paramName] = ret.value;
	    return false
	  }
	}

	function validate (context, request, execution) {
	  const runExecution = execution === undefined;

	  if (runExecution || !execution.skipParams) {
	    const params = validateParam(context[paramsSchema], request, 'params');
	    if (params) {
	      if (typeof params.then !== 'function') {
	        return wrapValidationError(params, 'params', context.schemaErrorFormatter)
	      } else {
	        return validateAsyncParams(params, context, request)
	      }
	    }
	  }

	  if (runExecution || !execution.skipBody) {
	    let validatorFunction = null;
	    if (typeof context[bodySchema] === 'function') {
	      validatorFunction = context[bodySchema];
	    } else if (context[bodySchema]) {
	      // TODO: add request.contentType and reuse it here
	      const contentType = getEssenceMediaType(request.headers['content-type']);
	      const contentSchema = context[bodySchema][contentType];
	      if (contentSchema) {
	        validatorFunction = contentSchema;
	      }
	    }
	    const body = validateParam(validatorFunction, request, 'body');
	    if (body) {
	      if (typeof body.then !== 'function') {
	        return wrapValidationError(body, 'body', context.schemaErrorFormatter)
	      } else {
	        return validateAsyncBody(body, context, request)
	      }
	    }
	  }

	  if (runExecution || !execution.skipQuery) {
	    const query = validateParam(context[querystringSchema], request, 'query');
	    if (query) {
	      if (typeof query.then !== 'function') {
	        return wrapValidationError(query, 'querystring', context.schemaErrorFormatter)
	      } else {
	        return validateAsyncQuery(query, context, request)
	      }
	    }
	  }

	  const headers = validateParam(context[headersSchema], request, 'headers');
	  if (headers) {
	    if (typeof headers.then !== 'function') {
	      return wrapValidationError(headers, 'headers', context.schemaErrorFormatter)
	    } else {
	      return validateAsyncHeaders(headers, context)
	    }
	  }

	  return false
	}

	function validateAsyncParams (validatePromise, context, request) {
	  return validatePromise
	    .then((paramsResult) => {
	      if (paramsResult) {
	        return wrapValidationError(paramsResult, 'params', context.schemaErrorFormatter)
	      }

	      return validate(context, request, { skipParams: true })
	    })
	}

	function validateAsyncBody (validatePromise, context, request) {
	  return validatePromise
	    .then((bodyResult) => {
	      if (bodyResult) {
	        return wrapValidationError(bodyResult, 'body', context.schemaErrorFormatter)
	      }

	      return validate(context, request, { skipParams: true, skipBody: true })
	    })
	}

	function validateAsyncQuery (validatePromise, context, request) {
	  return validatePromise
	    .then((queryResult) => {
	      if (queryResult) {
	        return wrapValidationError(queryResult, 'querystring', context.schemaErrorFormatter)
	      }

	      return validate(context, request, { skipParams: true, skipBody: true, skipQuery: true })
	    })
	}

	function validateAsyncHeaders (validatePromise, context, request) {
	  return validatePromise
	    .then((headersResult) => {
	      if (headersResult) {
	        return wrapValidationError(headersResult, 'headers', context.schemaErrorFormatter)
	      }

	      return false
	    })
	}

	function wrapValidationError (result, dataVar, schemaErrorFormatter) {
	  if (result instanceof Error) {
	    result.statusCode = result.statusCode || 400;
	    result.code = result.code || 'FST_ERR_VALIDATION';
	    result.validationContext = result.validationContext || dataVar;
	    return result
	  }

	  const error = schemaErrorFormatter(result, dataVar);
	  error.statusCode = error.statusCode || 400;
	  error.code = error.code || 'FST_ERR_VALIDATION';
	  error.validation = result;
	  error.validationContext = dataVar;
	  return error
	}

	/**
	 * simple function to retrieve the essence media type
	 * @param {string} header
	 * @returns {string} Mimetype string.
	 */
	function getEssenceMediaType (header) {
	  if (!header) return ''
	  return header.split(/[ ;]/, 1)[0].trim().toLowerCase()
	}

	validation$1 = {
	  symbols: { bodySchema, querystringSchema, responseSchema, paramsSchema, headersSchema },
	  compileSchemasForValidation,
	  compileSchemasForSerialization,
	  validate
	};
	return validation$1;
}

var wrapThenable_1;
var hasRequiredWrapThenable;

function requireWrapThenable () {
	if (hasRequiredWrapThenable) return wrapThenable_1;
	hasRequiredWrapThenable = 1;

	const {
	  kReplyIsError,
	  kReplyHijacked
	} = requireSymbols$1();

	const diagnostics = require$$1$1;
	const channels = diagnostics.tracingChannel('fastify.request.handler');

	function wrapThenable (thenable, reply, store) {
	  if (store) store.async = true;
	  thenable.then(function (payload) {
	    if (reply[kReplyHijacked] === true) {
	      return
	    }

	    if (store) {
	      channels.asyncStart.publish(store);
	    }

	    try {
	      // this is for async functions that are using reply.send directly
	      //
	      // since wrap-thenable will be called when using reply.send directly
	      // without actual return. the response can be sent already or
	      // the request may be terminated during the reply. in this situation,
	      // it require an extra checking of request.aborted to see whether
	      // the request is killed by client.
	      if (payload !== undefined || //
	        (reply.sent === false && //
	          reply.raw.headersSent === false &&
	          reply.request.raw.aborted === false &&
	          reply.request.socket &&
	          !reply.request.socket.destroyed
	        )
	      ) {
	        // we use a try-catch internally to avoid adding a catch to another
	        // promise, increase promise perf by 10%
	        try {
	          reply.send(payload);
	        } catch (err) {
	          reply[kReplyIsError] = true;
	          reply.send(err);
	        }
	      }
	    } finally {
	      if (store) {
	        channels.asyncEnd.publish(store);
	      }
	    }
	  }, function (err) {
	    if (store) {
	      store.error = err;
	      channels.error.publish(store); // note that error happens before asyncStart
	      channels.asyncStart.publish(store);
	    }

	    try {
	      if (reply.sent === true) {
	        reply.log.error({ err }, 'Promise errored, but reply.sent = true was set');
	        return
	      }

	      reply[kReplyIsError] = true;

	      reply.send(err);
	      // The following should not happen
	      /* c8 ignore next 3 */
	    } catch (err) {
	      // try-catch allow to re-throw error in error handler for async handler
	      reply.send(err);
	    } finally {
	      if (store) {
	        channels.asyncEnd.publish(store);
	      }
	    }
	  });
	}

	wrapThenable_1 = wrapThenable;
	return wrapThenable_1;
}

var hasRequiredHandleRequest;

function requireHandleRequest () {
	if (hasRequiredHandleRequest) return handleRequest.exports;
	hasRequiredHandleRequest = 1;
	(function (module) {

		const diagnostics = require$$1$1;
		const { validate: validateSchema } = requireValidation$1();
		const { preValidationHookRunner, preHandlerHookRunner } = requireHooks();
		const wrapThenable = requireWrapThenable();
		const {
		  kReplyIsError,
		  kRouteContext,
		  kFourOhFourContext,
		  kSupportedHTTPMethods
		} = requireSymbols$1();

		const channels = diagnostics.tracingChannel('fastify.request.handler');

		function handleRequest (err, request, reply) {
		  if (reply.sent === true) return
		  if (err != null) {
		    reply[kReplyIsError] = true;
		    reply.send(err);
		    return
		  }

		  const method = request.raw.method;
		  const headers = request.headers;
		  const context = request[kRouteContext];

		  if (this[kSupportedHTTPMethods].bodyless.has(method)) {
		    handler(request, reply);
		    return
		  }

		  if (this[kSupportedHTTPMethods].bodywith.has(method)) {
		    const contentType = headers['content-type'];
		    const contentLength = headers['content-length'];
		    const transferEncoding = headers['transfer-encoding'];

		    if (contentType === undefined) {
		      if (
		        (contentLength === undefined || contentLength === '0') &&
		        transferEncoding === undefined
		      ) {
		        // Request has no body to parse
		        handler(request, reply);
		      } else {
		        context.contentTypeParser.run('', handler, request, reply);
		      }
		    } else {
		      if (contentLength === undefined && transferEncoding === undefined && method === 'OPTIONS') {
		        // OPTIONS can have a Content-Type header without a body
		        handler(request, reply);
		        return
		      }
		      context.contentTypeParser.run(contentType, handler, request, reply);
		    }
		    return
		  }

		  // Return 404 instead of 405 see https://github.com/fastify/fastify/pull/862 for discussion
		  handler(request, reply);
		}

		function handler (request, reply) {
		  try {
		    if (request[kRouteContext].preValidation !== null) {
		      preValidationHookRunner(
		        request[kRouteContext].preValidation,
		        request,
		        reply,
		        preValidationCallback
		      );
		    } else {
		      preValidationCallback(null, request, reply);
		    }
		  } catch (err) {
		    preValidationCallback(err, request, reply);
		  }
		}

		function preValidationCallback (err, request, reply) {
		  if (reply.sent === true) return

		  if (err != null) {
		    reply[kReplyIsError] = true;
		    reply.send(err);
		    return
		  }

		  const validationErr = validateSchema(reply[kRouteContext], request);
		  const isAsync = (validationErr && typeof validationErr.then === 'function') || false;

		  if (isAsync) {
		    const cb = validationCompleted.bind(null, request, reply);
		    validationErr.then(cb, cb);
		  } else {
		    validationCompleted(request, reply, validationErr);
		  }
		}

		function validationCompleted (request, reply, validationErr) {
		  if (validationErr) {
		    if (reply[kRouteContext].attachValidation === false) {
		      reply.send(validationErr);
		      return
		    }

		    reply.request.validationError = validationErr;
		  }

		  // preHandler hook
		  if (request[kRouteContext].preHandler !== null) {
		    preHandlerHookRunner(
		      request[kRouteContext].preHandler,
		      request,
		      reply,
		      preHandlerCallback
		    );
		  } else {
		    preHandlerCallback(null, request, reply);
		  }
		}

		function preHandlerCallback (err, request, reply) {
		  if (reply.sent) return

		  const context = request[kRouteContext];

		  if (!channels.hasSubscribers || context[kFourOhFourContext] === null) {
		    preHandlerCallbackInner(err, request, reply);
		  } else {
		    const store = {
		      request,
		      reply,
		      async: false,
		      route: {
		        url: context.config.url,
		        method: context.config.method
		      }
		    };
		    channels.start.runStores(store, preHandlerCallbackInner, undefined, err, request, reply, store);
		  }
		}

		function preHandlerCallbackInner (err, request, reply, store) {
		  const context = request[kRouteContext];

		  try {
		    if (err != null) {
		      reply[kReplyIsError] = true;
		      reply.send(err);
		      if (store) {
		        store.error = err;
		        channels.error.publish(store);
		      }
		      return
		    }

		    let result;

		    try {
		      result = context.handler(request, reply);
		    } catch (err) {
		      if (store) {
		        store.error = err;
		        channels.error.publish(store);
		      }

		      reply[kReplyIsError] = true;
		      reply.send(err);
		      return
		    }

		    if (result !== undefined) {
		      if (result !== null && typeof result.then === 'function') {
		        wrapThenable(result, reply, store);
		      } else {
		        reply.send(result);
		      }
		    }
		  } finally {
		    if (store) channels.end.publish(store);
		  }
		}

		module.exports = handleRequest;
		module.exports[Symbol.for('internals')] = { handler, preHandlerCallback }; 
	} (handleRequest));
	return handleRequest.exports;
}

var abstractLogging = {exports: {}};

abstractLogging.exports;

var hasRequiredAbstractLogging;

function requireAbstractLogging () {
	if (hasRequiredAbstractLogging) return abstractLogging.exports;
	hasRequiredAbstractLogging = 1;
	(function (module) {

		function noop () { }

		const proto = {
		  fatal: noop,
		  error: noop,
		  warn: noop,
		  info: noop,
		  debug: noop,
		  trace: noop
		};

		Object.defineProperty(module, 'exports', {
		  get () {
		    return Object.create(proto)
		  }
		}); 
	} (abstractLogging));
	return abstractLogging.exports;
}

var pino = {exports: {}};

var errHelpers;
var hasRequiredErrHelpers;

function requireErrHelpers () {
	if (hasRequiredErrHelpers) return errHelpers;
	hasRequiredErrHelpers = 1;

	// **************************************************************
	// * Code initially copied/adapted from "pony-cause" npm module *
	// * Please upstream improvements there                         *
	// **************************************************************

	const isErrorLike = (err) => {
	  return err && typeof err.message === 'string'
	};

	/**
	 * @param {Error|{ cause?: unknown|(()=>err)}} err
	 * @returns {Error|Object|undefined}
	 */
	const getErrorCause = (err) => {
	  if (!err) return

	  /** @type {unknown} */
	  // @ts-ignore
	  const cause = err.cause;

	  // VError / NError style causes
	  if (typeof cause === 'function') {
	    // @ts-ignore
	    const causeResult = err.cause();

	    return isErrorLike(causeResult)
	      ? causeResult
	      : undefined
	  } else {
	    return isErrorLike(cause)
	      ? cause
	      : undefined
	  }
	};

	/**
	 * Internal method that keeps a track of which error we have already added, to avoid circular recursion
	 *
	 * @private
	 * @param {Error} err
	 * @param {Set<Error>} seen
	 * @returns {string}
	 */
	const _stackWithCauses = (err, seen) => {
	  if (!isErrorLike(err)) return ''

	  const stack = err.stack || '';

	  // Ensure we don't go circular or crazily deep
	  if (seen.has(err)) {
	    return stack + '\ncauses have become circular...'
	  }

	  const cause = getErrorCause(err);

	  if (cause) {
	    seen.add(err);
	    return (stack + '\ncaused by: ' + _stackWithCauses(cause, seen))
	  } else {
	    return stack
	  }
	};

	/**
	 * @param {Error} err
	 * @returns {string}
	 */
	const stackWithCauses = (err) => _stackWithCauses(err, new Set());

	/**
	 * Internal method that keeps a track of which error we have already added, to avoid circular recursion
	 *
	 * @private
	 * @param {Error} err
	 * @param {Set<Error>} seen
	 * @param {boolean} [skip]
	 * @returns {string}
	 */
	const _messageWithCauses = (err, seen, skip) => {
	  if (!isErrorLike(err)) return ''

	  const message = skip ? '' : (err.message || '');

	  // Ensure we don't go circular or crazily deep
	  if (seen.has(err)) {
	    return message + ': ...'
	  }

	  const cause = getErrorCause(err);

	  if (cause) {
	    seen.add(err);

	    // @ts-ignore
	    const skipIfVErrorStyleCause = typeof err.cause === 'function';

	    return (message +
	      (skipIfVErrorStyleCause ? '' : ': ') +
	      _messageWithCauses(cause, seen, skipIfVErrorStyleCause))
	  } else {
	    return message
	  }
	};

	/**
	 * @param {Error} err
	 * @returns {string}
	 */
	const messageWithCauses = (err) => _messageWithCauses(err, new Set());

	errHelpers = {
	  isErrorLike,
	  getErrorCause,
	  stackWithCauses,
	  messageWithCauses
	};
	return errHelpers;
}

var errProto;
var hasRequiredErrProto;

function requireErrProto () {
	if (hasRequiredErrProto) return errProto;
	hasRequiredErrProto = 1;

	const seen = Symbol('circular-ref-tag');
	const rawSymbol = Symbol('pino-raw-err-ref');

	const pinoErrProto = Object.create({}, {
	  type: {
	    enumerable: true,
	    writable: true,
	    value: undefined
	  },
	  message: {
	    enumerable: true,
	    writable: true,
	    value: undefined
	  },
	  stack: {
	    enumerable: true,
	    writable: true,
	    value: undefined
	  },
	  aggregateErrors: {
	    enumerable: true,
	    writable: true,
	    value: undefined
	  },
	  raw: {
	    enumerable: false,
	    get: function () {
	      return this[rawSymbol]
	    },
	    set: function (val) {
	      this[rawSymbol] = val;
	    }
	  }
	});
	Object.defineProperty(pinoErrProto, rawSymbol, {
	  writable: true,
	  value: {}
	});

	errProto = {
	  pinoErrProto,
	  pinoErrorSymbols: {
	    seen,
	    rawSymbol
	  }
	};
	return errProto;
}

var err;
var hasRequiredErr;

function requireErr () {
	if (hasRequiredErr) return err;
	hasRequiredErr = 1;

	err = errSerializer;

	const { messageWithCauses, stackWithCauses, isErrorLike } = requireErrHelpers();
	const { pinoErrProto, pinoErrorSymbols } = requireErrProto();
	const { seen } = pinoErrorSymbols;

	const { toString } = Object.prototype;

	function errSerializer (err) {
	  if (!isErrorLike(err)) {
	    return err
	  }

	  err[seen] = undefined; // tag to prevent re-looking at this
	  const _err = Object.create(pinoErrProto);
	  _err.type = toString.call(err.constructor) === '[object Function]'
	    ? err.constructor.name
	    : err.name;
	  _err.message = messageWithCauses(err);
	  _err.stack = stackWithCauses(err);

	  if (Array.isArray(err.errors)) {
	    _err.aggregateErrors = err.errors.map(err => errSerializer(err));
	  }

	  for (const key in err) {
	    if (_err[key] === undefined) {
	      const val = err[key];
	      if (isErrorLike(val)) {
	        // We append cause messages and stacks to _err, therefore skipping causes here
	        if (key !== 'cause' && !Object.prototype.hasOwnProperty.call(val, seen)) {
	          _err[key] = errSerializer(val);
	        }
	      } else {
	        _err[key] = val;
	      }
	    }
	  }

	  delete err[seen]; // clean up tag in case err is serialized again later
	  _err.raw = err;
	  return _err
	}
	return err;
}

var errWithCause;
var hasRequiredErrWithCause;

function requireErrWithCause () {
	if (hasRequiredErrWithCause) return errWithCause;
	hasRequiredErrWithCause = 1;

	errWithCause = errWithCauseSerializer;

	const { isErrorLike } = requireErrHelpers();
	const { pinoErrProto, pinoErrorSymbols } = requireErrProto();
	const { seen } = pinoErrorSymbols;

	const { toString } = Object.prototype;

	function errWithCauseSerializer (err) {
	  if (!isErrorLike(err)) {
	    return err
	  }

	  err[seen] = undefined; // tag to prevent re-looking at this
	  const _err = Object.create(pinoErrProto);
	  _err.type = toString.call(err.constructor) === '[object Function]'
	    ? err.constructor.name
	    : err.name;
	  _err.message = err.message;
	  _err.stack = err.stack;

	  if (Array.isArray(err.errors)) {
	    _err.aggregateErrors = err.errors.map(err => errWithCauseSerializer(err));
	  }

	  if (isErrorLike(err.cause) && !Object.prototype.hasOwnProperty.call(err.cause, seen)) {
	    _err.cause = errWithCauseSerializer(err.cause);
	  }

	  for (const key in err) {
	    if (_err[key] === undefined) {
	      const val = err[key];
	      if (isErrorLike(val)) {
	        if (!Object.prototype.hasOwnProperty.call(val, seen)) {
	          _err[key] = errWithCauseSerializer(val);
	        }
	      } else {
	        _err[key] = val;
	      }
	    }
	  }

	  delete err[seen]; // clean up tag in case err is serialized again later
	  _err.raw = err;
	  return _err
	}
	return errWithCause;
}

var req;
var hasRequiredReq;

function requireReq () {
	if (hasRequiredReq) return req;
	hasRequiredReq = 1;

	req = {
	  mapHttpRequest,
	  reqSerializer
	};

	const rawSymbol = Symbol('pino-raw-req-ref');
	const pinoReqProto = Object.create({}, {
	  id: {
	    enumerable: true,
	    writable: true,
	    value: ''
	  },
	  method: {
	    enumerable: true,
	    writable: true,
	    value: ''
	  },
	  url: {
	    enumerable: true,
	    writable: true,
	    value: ''
	  },
	  query: {
	    enumerable: true,
	    writable: true,
	    value: ''
	  },
	  params: {
	    enumerable: true,
	    writable: true,
	    value: ''
	  },
	  headers: {
	    enumerable: true,
	    writable: true,
	    value: {}
	  },
	  remoteAddress: {
	    enumerable: true,
	    writable: true,
	    value: ''
	  },
	  remotePort: {
	    enumerable: true,
	    writable: true,
	    value: ''
	  },
	  raw: {
	    enumerable: false,
	    get: function () {
	      return this[rawSymbol]
	    },
	    set: function (val) {
	      this[rawSymbol] = val;
	    }
	  }
	});
	Object.defineProperty(pinoReqProto, rawSymbol, {
	  writable: true,
	  value: {}
	});

	function reqSerializer (req) {
	  // req.info is for hapi compat.
	  const connection = req.info || req.socket;
	  const _req = Object.create(pinoReqProto);
	  _req.id = (typeof req.id === 'function' ? req.id() : (req.id || (req.info ? req.info.id : undefined)));
	  _req.method = req.method;
	  // req.originalUrl is for expressjs compat.
	  if (req.originalUrl) {
	    _req.url = req.originalUrl;
	  } else {
	    const path = req.path;
	    // path for safe hapi compat.
	    _req.url = typeof path === 'string' ? path : (req.url ? req.url.path || req.url : undefined);
	  }

	  if (req.query) {
	    _req.query = req.query;
	  }

	  if (req.params) {
	    _req.params = req.params;
	  }

	  _req.headers = req.headers;
	  _req.remoteAddress = connection && connection.remoteAddress;
	  _req.remotePort = connection && connection.remotePort;
	  // req.raw is  for hapi compat/equivalence
	  _req.raw = req.raw || req;
	  return _req
	}

	function mapHttpRequest (req) {
	  return {
	    req: reqSerializer(req)
	  }
	}
	return req;
}

var res;
var hasRequiredRes;

function requireRes () {
	if (hasRequiredRes) return res;
	hasRequiredRes = 1;

	res = {
	  mapHttpResponse,
	  resSerializer
	};

	const rawSymbol = Symbol('pino-raw-res-ref');
	const pinoResProto = Object.create({}, {
	  statusCode: {
	    enumerable: true,
	    writable: true,
	    value: 0
	  },
	  headers: {
	    enumerable: true,
	    writable: true,
	    value: ''
	  },
	  raw: {
	    enumerable: false,
	    get: function () {
	      return this[rawSymbol]
	    },
	    set: function (val) {
	      this[rawSymbol] = val;
	    }
	  }
	});
	Object.defineProperty(pinoResProto, rawSymbol, {
	  writable: true,
	  value: {}
	});

	function resSerializer (res) {
	  const _res = Object.create(pinoResProto);
	  _res.statusCode = res.headersSent ? res.statusCode : null;
	  _res.headers = res.getHeaders ? res.getHeaders() : res._headers;
	  _res.raw = res;
	  return _res
	}

	function mapHttpResponse (res) {
	  return {
	    res: resSerializer(res)
	  }
	}
	return res;
}

var pinoStdSerializers;
var hasRequiredPinoStdSerializers;

function requirePinoStdSerializers () {
	if (hasRequiredPinoStdSerializers) return pinoStdSerializers;
	hasRequiredPinoStdSerializers = 1;

	const errSerializer = requireErr();
	const errWithCauseSerializer = requireErrWithCause();
	const reqSerializers = requireReq();
	const resSerializers = requireRes();

	pinoStdSerializers = {
	  err: errSerializer,
	  errWithCause: errWithCauseSerializer,
	  mapHttpRequest: reqSerializers.mapHttpRequest,
	  mapHttpResponse: resSerializers.mapHttpResponse,
	  req: reqSerializers.reqSerializer,
	  res: resSerializers.resSerializer,

	  wrapErrorSerializer: function wrapErrorSerializer (customSerializer) {
	    if (customSerializer === errSerializer) return customSerializer
	    return function wrapErrSerializer (err) {
	      return customSerializer(errSerializer(err))
	    }
	  },

	  wrapRequestSerializer: function wrapRequestSerializer (customSerializer) {
	    if (customSerializer === reqSerializers.reqSerializer) return customSerializer
	    return function wrappedReqSerializer (req) {
	      return customSerializer(reqSerializers.reqSerializer(req))
	    }
	  },

	  wrapResponseSerializer: function wrapResponseSerializer (customSerializer) {
	    if (customSerializer === resSerializers.resSerializer) return customSerializer
	    return function wrappedResSerializer (res) {
	      return customSerializer(resSerializers.resSerializer(res))
	    }
	  }
	};
	return pinoStdSerializers;
}

var caller;
var hasRequiredCaller;

function requireCaller () {
	if (hasRequiredCaller) return caller;
	hasRequiredCaller = 1;

	function noOpPrepareStackTrace (_, stack) {
	  return stack
	}

	caller = function getCallers () {
	  const originalPrepare = Error.prepareStackTrace;
	  Error.prepareStackTrace = noOpPrepareStackTrace;
	  const stack = new Error().stack;
	  Error.prepareStackTrace = originalPrepare;

	  if (!Array.isArray(stack)) {
	    return undefined
	  }

	  const entries = stack.slice(2);

	  const fileNames = [];

	  for (const entry of entries) {
	    if (!entry) {
	      continue
	    }

	    fileNames.push(entry.getFileName());
	  }

	  return fileNames
	};
	return caller;
}

var validator_1;
var hasRequiredValidator$1;

function requireValidator$1 () {
	if (hasRequiredValidator$1) return validator_1;
	hasRequiredValidator$1 = 1;

	validator_1 = validator;

	function validator (opts = {}) {
	  const {
	    ERR_PATHS_MUST_BE_STRINGS = () => 'fast-redact - Paths must be (non-empty) strings',
	    ERR_INVALID_PATH = (s) => `fast-redact ‚Äì Invalid path (${s})`
	  } = opts;

	  return function validate ({ paths }) {
	    paths.forEach((s) => {
	      if (typeof s !== 'string') {
	        throw Error(ERR_PATHS_MUST_BE_STRINGS())
	      }
	      try {
	        if (/„Äá/.test(s)) throw Error()
	        const expr = (s[0] === '[' ? '' : '.') + s.replace(/^\*/, '„Äá').replace(/\.\*/g, '.„Äá').replace(/\[\*\]/g, '[„Äá]');
	        if (/\n|\r|;/.test(expr)) throw Error()
	        if (/\/\*/.test(expr)) throw Error()
	        /* eslint-disable-next-line */
	        Function(`
            'use strict'
            const o = new Proxy({}, { get: () => o, set: () => { throw Error() } });
            const „Äá = null;
            o${expr}
            if ([o${expr}].length !== 1) throw Error()`)();
	      } catch (e) {
	        throw Error(ERR_INVALID_PATH(s))
	      }
	    });
	  }
	}
	return validator_1;
}

var rx;
var hasRequiredRx;

function requireRx () {
	if (hasRequiredRx) return rx;
	hasRequiredRx = 1;

	rx = /[^.[\]]+|\[((?:.)*?)\]/g;

	/*
	Regular expression explanation:

	Alt 1: /[^.[\]]+/ - Match one or more characters that are *not* a dot (.)
	                    opening square bracket ([) or closing square bracket (])

	Alt 2: /\[((?:.)*?)\]/ - If the char IS dot or square bracket, then create a capture
	                         group (which will be capture group $1) that matches anything
	                         within square brackets. Expansion is lazy so it will
	                         stop matching as soon as the first closing bracket is met `]`
	                         (rather than continuing to match until the final closing bracket).
	*/
	return rx;
}

var parse_1$2;
var hasRequiredParse$3;

function requireParse$3 () {
	if (hasRequiredParse$3) return parse_1$2;
	hasRequiredParse$3 = 1;

	const rx = requireRx();

	parse_1$2 = parse;

	function parse ({ paths }) {
	  const wildcards = [];
	  var wcLen = 0;
	  const secret = paths.reduce(function (o, strPath, ix) {
	    var path = strPath.match(rx).map((p) => p.replace(/'|"|`/g, ''));
	    const leadingBracket = strPath[0] === '[';
	    path = path.map((p) => {
	      if (p[0] === '[') return p.substr(1, p.length - 2)
	      else return p
	    });
	    const star = path.indexOf('*');
	    if (star > -1) {
	      const before = path.slice(0, star);
	      const beforeStr = before.join('.');
	      const after = path.slice(star + 1, path.length);
	      const nested = after.length > 0;
	      wcLen++;
	      wildcards.push({
	        before,
	        beforeStr,
	        after,
	        nested
	      });
	    } else {
	      o[strPath] = {
	        path: path,
	        val: undefined,
	        precensored: false,
	        circle: '',
	        escPath: JSON.stringify(strPath),
	        leadingBracket: leadingBracket
	      };
	    }
	    return o
	  }, {});

	  return { wildcards, wcLen, secret }
	}
	return parse_1$2;
}

var redactor_1;
var hasRequiredRedactor;

function requireRedactor () {
	if (hasRequiredRedactor) return redactor_1;
	hasRequiredRedactor = 1;

	const rx = requireRx();

	redactor_1 = redactor;

	function redactor ({ secret, serialize, wcLen, strict, isCensorFct, censorFctTakesPath }, state) {
	  /* eslint-disable-next-line */
	  const redact = Function('o', `
    if (typeof o !== 'object' || o == null) {
      ${strictImpl(strict, serialize)}
    }
    const { censor, secret } = this
    const originalSecret = {}
    const secretKeys = Object.keys(secret)
    for (var i = 0; i < secretKeys.length; i++) {
      originalSecret[secretKeys[i]] = secret[secretKeys[i]]
    }

    ${redactTmpl(secret, isCensorFct, censorFctTakesPath)}
    this.compileRestore()
    ${dynamicRedactTmpl(wcLen > 0, isCensorFct, censorFctTakesPath)}
    this.secret = originalSecret
    ${resultTmpl(serialize)}
  `).bind(state);

	  redact.state = state;

	  if (serialize === false) {
	    redact.restore = (o) => state.restore(o);
	  }

	  return redact
	}

	function redactTmpl (secret, isCensorFct, censorFctTakesPath) {
	  return Object.keys(secret).map((path) => {
	    const { escPath, leadingBracket, path: arrPath } = secret[path];
	    const skip = leadingBracket ? 1 : 0;
	    const delim = leadingBracket ? '' : '.';
	    const hops = [];
	    var match;
	    while ((match = rx.exec(path)) !== null) {
	      const [ , ix ] = match;
	      const { index, input } = match;
	      if (index > skip) hops.push(input.substring(0, index - (ix ? 0 : 1)));
	    }
	    var existence = hops.map((p) => `o${delim}${p}`).join(' && ');
	    if (existence.length === 0) existence += `o${delim}${path} != null`;
	    else existence += ` && o${delim}${path} != null`;

	    const circularDetection = `
      switch (true) {
        ${hops.reverse().map((p) => `
          case o${delim}${p} === censor:
            secret[${escPath}].circle = ${JSON.stringify(p)}
            break
        `).join('\n')}
      }
    `;

	    const censorArgs = censorFctTakesPath
	      ? `val, ${JSON.stringify(arrPath)}`
	      : `val`;

	    return `
      if (${existence}) {
        const val = o${delim}${path}
        if (val === censor) {
          secret[${escPath}].precensored = true
        } else {
          secret[${escPath}].val = val
          o${delim}${path} = ${isCensorFct ? `censor(${censorArgs})` : 'censor'}
          ${circularDetection}
        }
      }
    `
	  }).join('\n')
	}

	function dynamicRedactTmpl (hasWildcards, isCensorFct, censorFctTakesPath) {
	  return hasWildcards === true ? `
    {
      const { wildcards, wcLen, groupRedact, nestedRedact } = this
      for (var i = 0; i < wcLen; i++) {
        const { before, beforeStr, after, nested } = wildcards[i]
        if (nested === true) {
          secret[beforeStr] = secret[beforeStr] || []
          nestedRedact(secret[beforeStr], o, before, after, censor, ${isCensorFct}, ${censorFctTakesPath})
        } else secret[beforeStr] = groupRedact(o, before, censor, ${isCensorFct}, ${censorFctTakesPath})
      }
    }
  ` : ''
	}

	function resultTmpl (serialize) {
	  return serialize === false ? `return o` : `
    var s = this.serialize(o)
    this.restore(o)
    return s
  `
	}

	function strictImpl (strict, serialize) {
	  return strict === true
	    ? `throw Error('fast-redact: primitives cannot be redacted')`
	    : serialize === false ? `return o` : `return this.serialize(o)`
	}
	return redactor_1;
}

var modifiers;
var hasRequiredModifiers;

function requireModifiers () {
	if (hasRequiredModifiers) return modifiers;
	hasRequiredModifiers = 1;

	modifiers = {
	  groupRedact,
	  groupRestore,
	  nestedRedact,
	  nestedRestore
	};

	function groupRestore ({ keys, values, target }) {
	  if (target == null || typeof target === 'string') return
	  const length = keys.length;
	  for (var i = 0; i < length; i++) {
	    const k = keys[i];
	    target[k] = values[i];
	  }
	}

	function groupRedact (o, path, censor, isCensorFct, censorFctTakesPath) {
	  const target = get(o, path);
	  if (target == null || typeof target === 'string') return { keys: null, values: null, target, flat: true }
	  const keys = Object.keys(target);
	  const keysLength = keys.length;
	  const pathLength = path.length;
	  const pathWithKey = censorFctTakesPath ? [...path] : undefined;
	  const values = new Array(keysLength);

	  for (var i = 0; i < keysLength; i++) {
	    const key = keys[i];
	    values[i] = target[key];

	    if (censorFctTakesPath) {
	      pathWithKey[pathLength] = key;
	      target[key] = censor(target[key], pathWithKey);
	    } else if (isCensorFct) {
	      target[key] = censor(target[key]);
	    } else {
	      target[key] = censor;
	    }
	  }
	  return { keys, values, target, flat: true }
	}

	/**
	 * @param {RestoreInstruction[]} instructions a set of instructions for restoring values to objects
	 */
	function nestedRestore (instructions) {
	  for (let i = 0; i < instructions.length; i++) {
	    const { target, path, value } = instructions[i];
	    let current = target;
	    for (let i = path.length - 1; i > 0; i--) {
	      current = current[path[i]];
	    }
	    current[path[0]] = value;
	  }
	}

	function nestedRedact (store, o, path, ns, censor, isCensorFct, censorFctTakesPath) {
	  const target = get(o, path);
	  if (target == null) return
	  const keys = Object.keys(target);
	  const keysLength = keys.length;
	  for (var i = 0; i < keysLength; i++) {
	    const key = keys[i];
	    specialSet(store, target, key, path, ns, censor, isCensorFct, censorFctTakesPath);
	  }
	  return store
	}

	function has (obj, prop) {
	  return obj !== undefined && obj !== null
	    ? ('hasOwn' in Object ? Object.hasOwn(obj, prop) : Object.prototype.hasOwnProperty.call(obj, prop))
	    : false
	}

	function specialSet (store, o, k, path, afterPath, censor, isCensorFct, censorFctTakesPath) {
	  const afterPathLen = afterPath.length;
	  const lastPathIndex = afterPathLen - 1;
	  const originalKey = k;
	  var i = -1;
	  var n;
	  var nv;
	  var ov;
	  var wc = null;
	  var kIsWc;
	  var wcov;
	  var consecutive = false;
	  var level = 0;
	  // need to track depth of the `redactPath` tree
	  var depth = 0;
	  var redactPathCurrent = tree();
	  ov = n = o[k];
	  if (typeof n !== 'object') return
	  while (n != null && ++i < afterPathLen) {
	    depth += 1;
	    k = afterPath[i];
	    if (k !== '*' && !wc && !(typeof n === 'object' && k in n)) {
	      break
	    }
	    if (k === '*') {
	      if (wc === '*') {
	        consecutive = true;
	      }
	      wc = k;
	      if (i !== lastPathIndex) {
	        continue
	      }
	    }
	    if (wc) {
	      const wcKeys = Object.keys(n);
	      for (var j = 0; j < wcKeys.length; j++) {
	        const wck = wcKeys[j];
	        wcov = n[wck];
	        kIsWc = k === '*';
	        if (consecutive) {
	          redactPathCurrent = node(redactPathCurrent, wck, depth);
	          level = i;
	          ov = iterateNthLevel(wcov, level - 1, k, path, afterPath, censor, isCensorFct, censorFctTakesPath, originalKey, n, nv, ov, kIsWc, wck, i, lastPathIndex, redactPathCurrent, store, o[originalKey], depth + 1);
	        } else {
	          if (kIsWc || (typeof wcov === 'object' && wcov !== null && k in wcov)) {
	            if (kIsWc) {
	              ov = wcov;
	            } else {
	              ov = wcov[k];
	            }
	            nv = (i !== lastPathIndex)
	              ? ov
	              : (isCensorFct
	                ? (censorFctTakesPath ? censor(ov, [...path, originalKey, ...afterPath]) : censor(ov))
	                : censor);
	            if (kIsWc) {
	              const rv = restoreInstr(node(redactPathCurrent, wck, depth), ov, o[originalKey]);
	              store.push(rv);
	              n[wck] = nv;
	            } else {
	              if (wcov[k] === nv) ; else if ((nv === undefined && censor !== undefined) || (has(wcov, k) && nv === ov)) {
	                redactPathCurrent = node(redactPathCurrent, wck, depth);
	              } else {
	                redactPathCurrent = node(redactPathCurrent, wck, depth);
	                const rv = restoreInstr(node(redactPathCurrent, k, depth + 1), ov, o[originalKey]);
	                store.push(rv);
	                wcov[k] = nv;
	              }
	            }
	          }
	        }
	      }
	      wc = null;
	    } else {
	      ov = n[k];
	      redactPathCurrent = node(redactPathCurrent, k, depth);
	      nv = (i !== lastPathIndex)
	        ? ov
	        : (isCensorFct
	          ? (censorFctTakesPath ? censor(ov, [...path, originalKey, ...afterPath]) : censor(ov))
	          : censor);
	      if ((has(n, k) && nv === ov) || (nv === undefined && censor !== undefined)) ; else {
	        const rv = restoreInstr(redactPathCurrent, ov, o[originalKey]);
	        store.push(rv);
	        n[k] = nv;
	      }
	      n = n[k];
	    }
	    if (typeof n !== 'object') break
	  }
	}

	function get (o, p) {
	  var i = -1;
	  var l = p.length;
	  var n = o;
	  while (n != null && ++i < l) {
	    n = n[p[i]];
	  }
	  return n
	}

	function iterateNthLevel (wcov, level, k, path, afterPath, censor, isCensorFct, censorFctTakesPath, originalKey, n, nv, ov, kIsWc, wck, i, lastPathIndex, redactPathCurrent, store, parent, depth) {
	  if (level === 0) {
	    if (kIsWc || (typeof wcov === 'object' && wcov !== null && k in wcov)) {
	      if (kIsWc) {
	        ov = wcov;
	      } else {
	        ov = wcov[k];
	      }
	      nv = (i !== lastPathIndex)
	        ? ov
	        : (isCensorFct
	          ? (censorFctTakesPath ? censor(ov, [...path, originalKey, ...afterPath]) : censor(ov))
	          : censor);
	      if (kIsWc) {
	        const rv = restoreInstr(redactPathCurrent, ov, parent);
	        store.push(rv);
	        n[wck] = nv;
	      } else {
	        if (wcov[k] === nv) ; else if ((nv === undefined && censor !== undefined) || (has(wcov, k) && nv === ov)) ; else {
	          const rv = restoreInstr(node(redactPathCurrent, k, depth + 1), ov, parent);
	          store.push(rv);
	          wcov[k] = nv;
	        }
	      }
	    }
	  }
	  for (const key in wcov) {
	    if (typeof wcov[key] === 'object') {
	      redactPathCurrent = node(redactPathCurrent, key, depth);
	      iterateNthLevel(wcov[key], level - 1, k, path, afterPath, censor, isCensorFct, censorFctTakesPath, originalKey, n, nv, ov, kIsWc, wck, i, lastPathIndex, redactPathCurrent, store, parent, depth + 1);
	    }
	  }
	}

	/**
	 * @typedef {object} TreeNode
	 * @prop {TreeNode} [parent] reference to the parent of this node in the tree, or `null` if there is no parent
	 * @prop {string} key the key that this node represents (key here being part of the path being redacted
	 * @prop {TreeNode[]} children the child nodes of this node
	 * @prop {number} depth the depth of this node in the tree
	 */

	/**
	 * instantiate a new, empty tree
	 * @returns {TreeNode}
	 */
	function tree () {
	  return { parent: null, key: null, children: [], depth: 0 }
	}

	/**
	 * creates a new node in the tree, attaching it as a child of the provided parent node
	 * if the specified depth matches the parent depth, adds the new node as a _sibling_ of the parent instead
	  * @param {TreeNode} parent the parent node to add a new node to (if the parent depth matches the provided `depth` value, will instead add as a sibling of this
	  * @param {string} key the key that the new node represents (key here being part of the path being redacted)
	  * @param {number} depth the depth of the new node in the tree - used to determing whether to add the new node as a child or sibling of the provided `parent` node
	  * @returns {TreeNode} a reference to the newly created node in the tree
	 */
	function node (parent, key, depth) {
	  if (parent.depth === depth) {
	    return node(parent.parent, key, depth)
	  }

	  var child = {
	    parent,
	    key,
	    depth,
	    children: []
	  };

	  parent.children.push(child);

	  return child
	}

	/**
	 * @typedef {object} RestoreInstruction
	 * @prop {string[]} path a reverse-order path that can be used to find the correct insertion point to restore a `value` for the given `parent` object
	 * @prop {*} value the value to restore
	 * @prop {object} target the object to restore the `value` in
	 */

	/**
	 * create a restore instruction for the given redactPath node
	 * generates a path in reverse order by walking up the redactPath tree
	 * @param {TreeNode} node a tree node that should be at the bottom of the redact path (i.e. have no children) - this will be used to walk up the redact path tree to construct the path needed to restore
	 * @param {*} value the value to restore
	 * @param {object} target a reference to the parent object to apply the restore instruction to
	 * @returns {RestoreInstruction} an instruction used to restore a nested value for a specific object
	 */
	function restoreInstr (node, value, target) {
	  let current = node;
	  const path = [];
	  do {
	    path.push(current.key);
	    current = current.parent;
	  } while (current.parent != null)

	  return { path, value, target }
	}
	return modifiers;
}

var restorer_1;
var hasRequiredRestorer;

function requireRestorer () {
	if (hasRequiredRestorer) return restorer_1;
	hasRequiredRestorer = 1;

	const { groupRestore, nestedRestore } = requireModifiers();

	restorer_1 = restorer;

	function restorer () {
	  return function compileRestore () {
	    if (this.restore) {
	      this.restore.state.secret = this.secret;
	      return
	    }
	    const { secret, wcLen } = this;
	    const paths = Object.keys(secret);
	    const resetters = resetTmpl(secret, paths);
	    const hasWildcards = wcLen > 0;
	    const state = hasWildcards ? { secret, groupRestore, nestedRestore } : { secret };
	    /* eslint-disable-next-line */
	    this.restore = Function(
	      'o',
	      restoreTmpl(resetters, paths, hasWildcards)
	    ).bind(state);
	    this.restore.state = state;
	  }
	}

	/**
	 * Mutates the original object to be censored by restoring its original values
	 * prior to censoring.
	 *
	 * @param {object} secret Compiled object describing which target fields should
	 * be censored and the field states.
	 * @param {string[]} paths The list of paths to censor as provided at
	 * initialization time.
	 *
	 * @returns {string} String of JavaScript to be used by `Function()`. The
	 * string compiles to the function that does the work in the description.
	 */
	function resetTmpl (secret, paths) {
	  return paths.map((path) => {
	    const { circle, escPath, leadingBracket } = secret[path];
	    const delim = leadingBracket ? '' : '.';
	    const reset = circle
	      ? `o.${circle} = secret[${escPath}].val`
	      : `o${delim}${path} = secret[${escPath}].val`;
	    const clear = `secret[${escPath}].val = undefined`;
	    return `
      if (secret[${escPath}].val !== undefined) {
        try { ${reset} } catch (e) {}
        ${clear}
      }
    `
	  }).join('')
	}

	/**
	 * Creates the body of the restore function
	 *
	 * Restoration of the redacted object happens
	 * backwards, in reverse order of redactions,
	 * so that repeated redactions on the same object
	 * property can be eventually rolled back to the
	 * original value.
	 *
	 * This way dynamic redactions are restored first,
	 * starting from the last one working backwards and
	 * followed by the static ones.
	 *
	 * @returns {string} the body of the restore function
	 */
	function restoreTmpl (resetters, paths, hasWildcards) {
	  const dynamicReset = hasWildcards === true ? `
    const keys = Object.keys(secret)
    const len = keys.length
    for (var i = len - 1; i >= ${paths.length}; i--) {
      const k = keys[i]
      const o = secret[k]
      if (o) {
        if (o.flat === true) this.groupRestore(o)
        else this.nestedRestore(o)
        secret[k] = null
      }
    }
  ` : '';

	  return `
    const secret = this.secret
    ${dynamicReset}
    ${resetters}
    return o
  `
	}
	return restorer_1;
}

var state_1;
var hasRequiredState;

function requireState () {
	if (hasRequiredState) return state_1;
	hasRequiredState = 1;

	state_1 = state;

	function state (o) {
	  const {
	    secret,
	    censor,
	    compileRestore,
	    serialize,
	    groupRedact,
	    nestedRedact,
	    wildcards,
	    wcLen
	  } = o;
	  const builder = [{ secret, censor, compileRestore }];
	  if (serialize !== false) builder.push({ serialize });
	  if (wcLen > 0) builder.push({ groupRedact, nestedRedact, wildcards, wcLen });
	  return Object.assign(...builder)
	}
	return state_1;
}

var fastRedact_1;
var hasRequiredFastRedact;

function requireFastRedact () {
	if (hasRequiredFastRedact) return fastRedact_1;
	hasRequiredFastRedact = 1;

	const validator = requireValidator$1();
	const parse = requireParse$3();
	const redactor = requireRedactor();
	const restorer = requireRestorer();
	const { groupRedact, nestedRedact } = requireModifiers();
	const state = requireState();
	const rx = requireRx();
	const validate = validator();
	const noop = (o) => o;
	noop.restore = noop;

	const DEFAULT_CENSOR = '[REDACTED]';
	fastRedact.rx = rx;
	fastRedact.validator = validator;

	fastRedact_1 = fastRedact;

	function fastRedact (opts = {}) {
	  const paths = Array.from(new Set(opts.paths || []));
	  const serialize = 'serialize' in opts ? (
	    opts.serialize === false ? opts.serialize
	      : (typeof opts.serialize === 'function' ? opts.serialize : JSON.stringify)
	  ) : JSON.stringify;
	  const remove = opts.remove;
	  if (remove === true && serialize !== JSON.stringify) {
	    throw Error('fast-redact ‚Äì remove option may only be set when serializer is JSON.stringify')
	  }
	  const censor = remove === true
	    ? undefined
	    : 'censor' in opts ? opts.censor : DEFAULT_CENSOR;

	  const isCensorFct = typeof censor === 'function';
	  const censorFctTakesPath = isCensorFct && censor.length > 1;

	  if (paths.length === 0) return serialize || noop

	  validate({ paths, serialize, censor });

	  const { wildcards, wcLen, secret } = parse({ paths, censor });

	  const compileRestore = restorer();
	  const strict = 'strict' in opts ? opts.strict : true;

	  return redactor({ secret, wcLen, serialize, strict, isCensorFct, censorFctTakesPath }, state({
	    secret,
	    censor,
	    compileRestore,
	    serialize,
	    groupRedact,
	    nestedRedact,
	    wildcards,
	    wcLen
	  }))
	}
	return fastRedact_1;
}

var symbols;
var hasRequiredSymbols;

function requireSymbols () {
	if (hasRequiredSymbols) return symbols;
	hasRequiredSymbols = 1;

	const setLevelSym = Symbol('pino.setLevel');
	const getLevelSym = Symbol('pino.getLevel');
	const levelValSym = Symbol('pino.levelVal');
	const levelCompSym = Symbol('pino.levelComp');
	const useLevelLabelsSym = Symbol('pino.useLevelLabels');
	const useOnlyCustomLevelsSym = Symbol('pino.useOnlyCustomLevels');
	const mixinSym = Symbol('pino.mixin');

	const lsCacheSym = Symbol('pino.lsCache');
	const chindingsSym = Symbol('pino.chindings');

	const asJsonSym = Symbol('pino.asJson');
	const writeSym = Symbol('pino.write');
	const redactFmtSym = Symbol('pino.redactFmt');

	const timeSym = Symbol('pino.time');
	const timeSliceIndexSym = Symbol('pino.timeSliceIndex');
	const streamSym = Symbol('pino.stream');
	const stringifySym = Symbol('pino.stringify');
	const stringifySafeSym = Symbol('pino.stringifySafe');
	const stringifiersSym = Symbol('pino.stringifiers');
	const endSym = Symbol('pino.end');
	const formatOptsSym = Symbol('pino.formatOpts');
	const messageKeySym = Symbol('pino.messageKey');
	const errorKeySym = Symbol('pino.errorKey');
	const nestedKeySym = Symbol('pino.nestedKey');
	const nestedKeyStrSym = Symbol('pino.nestedKeyStr');
	const mixinMergeStrategySym = Symbol('pino.mixinMergeStrategy');
	const msgPrefixSym = Symbol('pino.msgPrefix');

	const wildcardFirstSym = Symbol('pino.wildcardFirst');

	// public symbols, no need to use the same pino
	// version for these
	const serializersSym = Symbol.for('pino.serializers');
	const formattersSym = Symbol.for('pino.formatters');
	const hooksSym = Symbol.for('pino.hooks');
	const needsMetadataGsym = Symbol.for('pino.metadata');

	symbols = {
	  setLevelSym,
	  getLevelSym,
	  levelValSym,
	  levelCompSym,
	  useLevelLabelsSym,
	  mixinSym,
	  lsCacheSym,
	  chindingsSym,
	  asJsonSym,
	  writeSym,
	  serializersSym,
	  redactFmtSym,
	  timeSym,
	  timeSliceIndexSym,
	  streamSym,
	  stringifySym,
	  stringifySafeSym,
	  stringifiersSym,
	  endSym,
	  formatOptsSym,
	  messageKeySym,
	  errorKeySym,
	  nestedKeySym,
	  wildcardFirstSym,
	  needsMetadataGsym,
	  useOnlyCustomLevelsSym,
	  formattersSym,
	  hooksSym,
	  nestedKeyStrSym,
	  mixinMergeStrategySym,
	  msgPrefixSym
	};
	return symbols;
}

var redaction_1;
var hasRequiredRedaction;

function requireRedaction () {
	if (hasRequiredRedaction) return redaction_1;
	hasRequiredRedaction = 1;

	const fastRedact = requireFastRedact();
	const { redactFmtSym, wildcardFirstSym } = requireSymbols();
	const { rx, validator } = fastRedact;

	const validate = validator({
	  ERR_PATHS_MUST_BE_STRINGS: () => 'pino ‚Äì redacted paths must be strings',
	  ERR_INVALID_PATH: (s) => `pino ‚Äì redact paths array contains an invalid path (${s})`
	});

	const CENSOR = '[Redacted]';
	const strict = false; // TODO should this be configurable?

	function redaction (opts, serialize) {
	  const { paths, censor } = handle(opts);

	  const shape = paths.reduce((o, str) => {
	    rx.lastIndex = 0;
	    const first = rx.exec(str);
	    const next = rx.exec(str);

	    // ns is the top-level path segment, brackets + quoting removed.
	    let ns = first[1] !== undefined
	      ? first[1].replace(/^(?:"|'|`)(.*)(?:"|'|`)$/, '$1')
	      : first[0];

	    if (ns === '*') {
	      ns = wildcardFirstSym;
	    }

	    // top level key:
	    if (next === null) {
	      o[ns] = null;
	      return o
	    }

	    // path with at least two segments:
	    // if ns is already redacted at the top level, ignore lower level redactions
	    if (o[ns] === null) {
	      return o
	    }

	    const { index } = next;
	    const nextPath = `${str.substr(index, str.length - 1)}`;

	    o[ns] = o[ns] || [];

	    // shape is a mix of paths beginning with literal values and wildcard
	    // paths [ "a.b.c", "*.b.z" ] should reduce to a shape of
	    // { "a": [ "b.c", "b.z" ], *: [ "b.z" ] }
	    // note: "b.z" is in both "a" and * arrays because "a" matches the wildcard.
	    // (* entry has wildcardFirstSym as key)
	    if (ns !== wildcardFirstSym && o[ns].length === 0) {
	      // first time ns's get all '*' redactions so far
	      o[ns].push(...(o[wildcardFirstSym] || []));
	    }

	    if (ns === wildcardFirstSym) {
	      // new * path gets added to all previously registered literal ns's.
	      Object.keys(o).forEach(function (k) {
	        if (o[k]) {
	          o[k].push(nextPath);
	        }
	      });
	    }

	    o[ns].push(nextPath);
	    return o
	  }, {});

	  // the redactor assigned to the format symbol key
	  // provides top level redaction for instances where
	  // an object is interpolated into the msg string
	  const result = {
	    [redactFmtSym]: fastRedact({ paths, censor, serialize, strict })
	  };

	  const topCensor = (...args) => {
	    return typeof censor === 'function' ? serialize(censor(...args)) : serialize(censor)
	  };

	  return [...Object.keys(shape), ...Object.getOwnPropertySymbols(shape)].reduce((o, k) => {
	    // top level key:
	    if (shape[k] === null) {
	      o[k] = (value) => topCensor(value, [k]);
	    } else {
	      const wrappedCensor = typeof censor === 'function'
	        ? (value, path) => {
	            return censor(value, [k, ...path])
	          }
	        : censor;
	      o[k] = fastRedact({
	        paths: shape[k],
	        censor: wrappedCensor,
	        serialize,
	        strict
	      });
	    }
	    return o
	  }, result)
	}

	function handle (opts) {
	  if (Array.isArray(opts)) {
	    opts = { paths: opts, censor: CENSOR };
	    validate(opts);
	    return opts
	  }
	  let { paths, censor = CENSOR, remove } = opts;
	  if (Array.isArray(paths) === false) { throw Error('pino ‚Äì redact must contain an array of strings') }
	  if (remove === true) censor = undefined;
	  validate({ paths, censor });

	  return { paths, censor }
	}

	redaction_1 = redaction;
	return redaction_1;
}

var time;
var hasRequiredTime;

function requireTime () {
	if (hasRequiredTime) return time;
	hasRequiredTime = 1;

	const nullTime = () => '';

	const epochTime = () => `,"time":${Date.now()}`;

	const unixTime = () => `,"time":${Math.round(Date.now() / 1000.0)}`;

	const isoTime = () => `,"time":"${new Date(Date.now()).toISOString()}"`; // using Date.now() for testability

	time = { nullTime, epochTime, unixTime, isoTime };
	return time;
}

var quickFormatUnescaped;
var hasRequiredQuickFormatUnescaped;

function requireQuickFormatUnescaped () {
	if (hasRequiredQuickFormatUnescaped) return quickFormatUnescaped;
	hasRequiredQuickFormatUnescaped = 1;
	function tryStringify (o) {
	  try { return JSON.stringify(o) } catch(e) { return '"[Circular]"' }
	}

	quickFormatUnescaped = format;

	function format(f, args, opts) {
	  var ss = (opts && opts.stringify) || tryStringify;
	  var offset = 1;
	  if (typeof f === 'object' && f !== null) {
	    var len = args.length + offset;
	    if (len === 1) return f
	    var objects = new Array(len);
	    objects[0] = ss(f);
	    for (var index = 1; index < len; index++) {
	      objects[index] = ss(args[index]);
	    }
	    return objects.join(' ')
	  }
	  if (typeof f !== 'string') {
	    return f
	  }
	  var argLen = args.length;
	  if (argLen === 0) return f
	  var str = '';
	  var a = 1 - offset;
	  var lastPos = -1;
	  var flen = (f && f.length) || 0;
	  for (var i = 0; i < flen;) {
	    if (f.charCodeAt(i) === 37 && i + 1 < flen) {
	      lastPos = lastPos > -1 ? lastPos : 0;
	      switch (f.charCodeAt(i + 1)) {
	        case 100: // 'd'
	        case 102: // 'f'
	          if (a >= argLen)
	            break
	          if (args[a] == null)  break
	          if (lastPos < i)
	            str += f.slice(lastPos, i);
	          str += Number(args[a]);
	          lastPos = i + 2;
	          i++;
	          break
	        case 105: // 'i'
	          if (a >= argLen)
	            break
	          if (args[a] == null)  break
	          if (lastPos < i)
	            str += f.slice(lastPos, i);
	          str += Math.floor(Number(args[a]));
	          lastPos = i + 2;
	          i++;
	          break
	        case 79: // 'O'
	        case 111: // 'o'
	        case 106: // 'j'
	          if (a >= argLen)
	            break
	          if (args[a] === undefined) break
	          if (lastPos < i)
	            str += f.slice(lastPos, i);
	          var type = typeof args[a];
	          if (type === 'string') {
	            str += '\'' + args[a] + '\'';
	            lastPos = i + 2;
	            i++;
	            break
	          }
	          if (type === 'function') {
	            str += args[a].name || '<anonymous>';
	            lastPos = i + 2;
	            i++;
	            break
	          }
	          str += ss(args[a]);
	          lastPos = i + 2;
	          i++;
	          break
	        case 115: // 's'
	          if (a >= argLen)
	            break
	          if (lastPos < i)
	            str += f.slice(lastPos, i);
	          str += String(args[a]);
	          lastPos = i + 2;
	          i++;
	          break
	        case 37: // '%'
	          if (lastPos < i)
	            str += f.slice(lastPos, i);
	          str += '%';
	          lastPos = i + 2;
	          i++;
	          a--;
	          break
	      }
	      ++a;
	    }
	    ++i;
	  }
	  if (lastPos === -1)
	    return f
	  else if (lastPos < flen) {
	    str += f.slice(lastPos);
	  }

	  return str
	}
	return quickFormatUnescaped;
}

var atomicSleep = {exports: {}};

var hasRequiredAtomicSleep;

function requireAtomicSleep () {
	if (hasRequiredAtomicSleep) return atomicSleep.exports;
	hasRequiredAtomicSleep = 1;

	/* global SharedArrayBuffer, Atomics */

	if (typeof SharedArrayBuffer !== 'undefined' && typeof Atomics !== 'undefined') {
	  const nil = new Int32Array(new SharedArrayBuffer(4));

	  function sleep (ms) {
	    // also filters out NaN, non-number types, including empty strings, but allows bigints
	    const valid = ms > 0 && ms < Infinity; 
	    if (valid === false) {
	      if (typeof ms !== 'number' && typeof ms !== 'bigint') {
	        throw TypeError('sleep: ms must be a number')
	      }
	      throw RangeError('sleep: ms must be a number that is greater than 0 but less than Infinity')
	    }

	    Atomics.wait(nil, 0, 0, Number(ms));
	  }
	  atomicSleep.exports = sleep;
	} else {

	  function sleep (ms) {
	    // also filters out NaN, non-number types, including empty strings, but allows bigints
	    const valid = ms > 0 && ms < Infinity; 
	    if (valid === false) {
	      if (typeof ms !== 'number' && typeof ms !== 'bigint') {
	        throw TypeError('sleep: ms must be a number')
	      }
	      throw RangeError('sleep: ms must be a number that is greater than 0 but less than Infinity')
	    }
	  }

	  atomicSleep.exports = sleep;

	}
	return atomicSleep.exports;
}

var sonicBoom;
var hasRequiredSonicBoom;

function requireSonicBoom () {
	if (hasRequiredSonicBoom) return sonicBoom;
	hasRequiredSonicBoom = 1;

	const fs$1 = fs;
	const EventEmitter = require$$1$2;
	const inherits = require$$2$2.inherits;
	const path$1 = path;
	const sleep = requireAtomicSleep();
	const assert$1 = assert;

	const BUSY_WRITE_TIMEOUT = 100;
	const kEmptyBuffer = Buffer.allocUnsafe(0);

	// 16 KB. Don't write more than docker buffer size.
	// https://github.com/moby/moby/blob/513ec73831269947d38a644c278ce3cac36783b2/daemon/logger/copier.go#L13
	const MAX_WRITE = 16 * 1024;

	const kContentModeBuffer = 'buffer';
	const kContentModeUtf8 = 'utf8';

	const [major, minor] = (process.versions.node || '0.0').split('.').map(Number);
	const kCopyBuffer = major >= 22 && minor >= 7;

	function openFile (file, sonic) {
	  sonic._opening = true;
	  sonic._writing = true;
	  sonic._asyncDrainScheduled = false;

	  // NOTE: 'error' and 'ready' events emitted below only relevant when sonic.sync===false
	  // for sync mode, there is no way to add a listener that will receive these

	  function fileOpened (err, fd) {
	    if (err) {
	      sonic._reopening = false;
	      sonic._writing = false;
	      sonic._opening = false;

	      if (sonic.sync) {
	        process.nextTick(() => {
	          if (sonic.listenerCount('error') > 0) {
	            sonic.emit('error', err);
	          }
	        });
	      } else {
	        sonic.emit('error', err);
	      }
	      return
	    }

	    const reopening = sonic._reopening;

	    sonic.fd = fd;
	    sonic.file = file;
	    sonic._reopening = false;
	    sonic._opening = false;
	    sonic._writing = false;

	    if (sonic.sync) {
	      process.nextTick(() => sonic.emit('ready'));
	    } else {
	      sonic.emit('ready');
	    }

	    if (sonic.destroyed) {
	      return
	    }

	    // start
	    if ((!sonic._writing && sonic._len > sonic.minLength) || sonic._flushPending) {
	      sonic._actualWrite();
	    } else if (reopening) {
	      process.nextTick(() => sonic.emit('drain'));
	    }
	  }

	  const flags = sonic.append ? 'a' : 'w';
	  const mode = sonic.mode;

	  if (sonic.sync) {
	    try {
	      if (sonic.mkdir) fs$1.mkdirSync(path$1.dirname(file), { recursive: true });
	      const fd = fs$1.openSync(file, flags, mode);
	      fileOpened(null, fd);
	    } catch (err) {
	      fileOpened(err);
	      throw err
	    }
	  } else if (sonic.mkdir) {
	    fs$1.mkdir(path$1.dirname(file), { recursive: true }, (err) => {
	      if (err) return fileOpened(err)
	      fs$1.open(file, flags, mode, fileOpened);
	    });
	  } else {
	    fs$1.open(file, flags, mode, fileOpened);
	  }
	}

	function SonicBoom (opts) {
	  if (!(this instanceof SonicBoom)) {
	    return new SonicBoom(opts)
	  }

	  let { fd, dest, minLength, maxLength, maxWrite, periodicFlush, sync, append = true, mkdir, retryEAGAIN, fsync, contentMode, mode } = opts || {};

	  fd = fd || dest;

	  this._len = 0;
	  this.fd = -1;
	  this._bufs = [];
	  this._lens = [];
	  this._writing = false;
	  this._ending = false;
	  this._reopening = false;
	  this._asyncDrainScheduled = false;
	  this._flushPending = false;
	  this._hwm = Math.max(minLength || 0, 16387);
	  this.file = null;
	  this.destroyed = false;
	  this.minLength = minLength || 0;
	  this.maxLength = maxLength || 0;
	  this.maxWrite = maxWrite || MAX_WRITE;
	  this._periodicFlush = periodicFlush || 0;
	  this._periodicFlushTimer = undefined;
	  this.sync = sync || false;
	  this.writable = true;
	  this._fsync = fsync || false;
	  this.append = append || false;
	  this.mode = mode;
	  this.retryEAGAIN = retryEAGAIN || (() => true);
	  this.mkdir = mkdir || false;

	  let fsWriteSync;
	  let fsWrite;
	  if (contentMode === kContentModeBuffer) {
	    this._writingBuf = kEmptyBuffer;
	    this.write = writeBuffer;
	    this.flush = flushBuffer;
	    this.flushSync = flushBufferSync;
	    this._actualWrite = actualWriteBuffer;
	    fsWriteSync = () => fs$1.writeSync(this.fd, this._writingBuf);
	    fsWrite = () => fs$1.write(this.fd, this._writingBuf, this.release);
	  } else if (contentMode === undefined || contentMode === kContentModeUtf8) {
	    this._writingBuf = '';
	    this.write = write;
	    this.flush = flush;
	    this.flushSync = flushSync;
	    this._actualWrite = actualWrite;
	    fsWriteSync = () => fs$1.writeSync(this.fd, this._writingBuf, 'utf8');
	    fsWrite = () => fs$1.write(this.fd, this._writingBuf, 'utf8', this.release);
	  } else {
	    throw new Error(`SonicBoom supports "${kContentModeUtf8}" and "${kContentModeBuffer}", but passed ${contentMode}`)
	  }

	  if (typeof fd === 'number') {
	    this.fd = fd;
	    process.nextTick(() => this.emit('ready'));
	  } else if (typeof fd === 'string') {
	    openFile(fd, this);
	  } else {
	    throw new Error('SonicBoom supports only file descriptors and files')
	  }
	  if (this.minLength >= this.maxWrite) {
	    throw new Error(`minLength should be smaller than maxWrite (${this.maxWrite})`)
	  }

	  this.release = (err, n) => {
	    if (err) {
	      if ((err.code === 'EAGAIN' || err.code === 'EBUSY') && this.retryEAGAIN(err, this._writingBuf.length, this._len - this._writingBuf.length)) {
	        if (this.sync) {
	          // This error code should not happen in sync mode, because it is
	          // not using the underlining operating system asynchronous functions.
	          // However it happens, and so we handle it.
	          // Ref: https://github.com/pinojs/pino/issues/783
	          try {
	            sleep(BUSY_WRITE_TIMEOUT);
	            this.release(undefined, 0);
	          } catch (err) {
	            this.release(err);
	          }
	        } else {
	          // Let's give the destination some time to process the chunk.
	          setTimeout(fsWrite, BUSY_WRITE_TIMEOUT);
	        }
	      } else {
	        this._writing = false;

	        this.emit('error', err);
	      }
	      return
	    }

	    this.emit('write', n);
	    const releasedBufObj = releaseWritingBuf(this._writingBuf, this._len, n);
	    this._len = releasedBufObj.len;
	    this._writingBuf = releasedBufObj.writingBuf;

	    if (this._writingBuf.length) {
	      if (!this.sync) {
	        fsWrite();
	        return
	      }

	      try {
	        do {
	          const n = fsWriteSync();
	          const releasedBufObj = releaseWritingBuf(this._writingBuf, this._len, n);
	          this._len = releasedBufObj.len;
	          this._writingBuf = releasedBufObj.writingBuf;
	        } while (this._writingBuf.length)
	      } catch (err) {
	        this.release(err);
	        return
	      }
	    }

	    if (this._fsync) {
	      fs$1.fsyncSync(this.fd);
	    }

	    const len = this._len;
	    if (this._reopening) {
	      this._writing = false;
	      this._reopening = false;
	      this.reopen();
	    } else if (len > this.minLength) {
	      this._actualWrite();
	    } else if (this._ending) {
	      if (len > 0) {
	        this._actualWrite();
	      } else {
	        this._writing = false;
	        actualClose(this);
	      }
	    } else {
	      this._writing = false;
	      if (this.sync) {
	        if (!this._asyncDrainScheduled) {
	          this._asyncDrainScheduled = true;
	          process.nextTick(emitDrain, this);
	        }
	      } else {
	        this.emit('drain');
	      }
	    }
	  };

	  this.on('newListener', function (name) {
	    if (name === 'drain') {
	      this._asyncDrainScheduled = false;
	    }
	  });

	  if (this._periodicFlush !== 0) {
	    this._periodicFlushTimer = setInterval(() => this.flush(null), this._periodicFlush);
	    this._periodicFlushTimer.unref();
	  }
	}

	/**
	 * Release the writingBuf after fs.write n bytes data
	 * @param {string | Buffer} writingBuf - currently writing buffer, usually be instance._writingBuf.
	 * @param {number} len - currently buffer length, usually be instance._len.
	 * @param {number} n - number of bytes fs already written
	 * @returns {{writingBuf: string | Buffer, len: number}} released writingBuf and length
	 */
	function releaseWritingBuf (writingBuf, len, n) {
	  // if Buffer.byteLength is equal to n, that means writingBuf contains no multi-byte character
	  if (typeof writingBuf === 'string' && Buffer.byteLength(writingBuf) !== n) {
	    // Since the fs.write callback parameter `n` means how many bytes the passed of string
	    // We calculate the original string length for avoiding the multi-byte character issue
	    n = Buffer.from(writingBuf).subarray(0, n).toString().length;
	  }
	  len = Math.max(len - n, 0);
	  writingBuf = writingBuf.slice(n);
	  return { writingBuf, len }
	}

	function emitDrain (sonic) {
	  const hasListeners = sonic.listenerCount('drain') > 0;
	  if (!hasListeners) return
	  sonic._asyncDrainScheduled = false;
	  sonic.emit('drain');
	}

	inherits(SonicBoom, EventEmitter);

	function mergeBuf (bufs, len) {
	  if (bufs.length === 0) {
	    return kEmptyBuffer
	  }

	  if (bufs.length === 1) {
	    return bufs[0]
	  }

	  return Buffer.concat(bufs, len)
	}

	function write (data) {
	  if (this.destroyed) {
	    throw new Error('SonicBoom destroyed')
	  }

	  const len = this._len + data.length;
	  const bufs = this._bufs;

	  if (this.maxLength && len > this.maxLength) {
	    this.emit('drop', data);
	    return this._len < this._hwm
	  }

	  if (
	    bufs.length === 0 ||
	    bufs[bufs.length - 1].length + data.length > this.maxWrite
	  ) {
	    bufs.push('' + data);
	  } else {
	    bufs[bufs.length - 1] += data;
	  }

	  this._len = len;

	  if (!this._writing && this._len >= this.minLength) {
	    this._actualWrite();
	  }

	  return this._len < this._hwm
	}

	function writeBuffer (data) {
	  if (this.destroyed) {
	    throw new Error('SonicBoom destroyed')
	  }

	  const len = this._len + data.length;
	  const bufs = this._bufs;
	  const lens = this._lens;

	  if (this.maxLength && len > this.maxLength) {
	    this.emit('drop', data);
	    return this._len < this._hwm
	  }

	  if (
	    bufs.length === 0 ||
	    lens[lens.length - 1] + data.length > this.maxWrite
	  ) {
	    bufs.push([data]);
	    lens.push(data.length);
	  } else {
	    bufs[bufs.length - 1].push(data);
	    lens[lens.length - 1] += data.length;
	  }

	  this._len = len;

	  if (!this._writing && this._len >= this.minLength) {
	    this._actualWrite();
	  }

	  return this._len < this._hwm
	}

	function callFlushCallbackOnDrain (cb) {
	  this._flushPending = true;
	  const onDrain = () => {
	    // only if _fsync is false to avoid double fsync
	    if (!this._fsync) {
	      try {
	        fs$1.fsync(this.fd, (err) => {
	          this._flushPending = false;
	          cb(err);
	        });
	      } catch (err) {
	        cb(err);
	      }
	    } else {
	      this._flushPending = false;
	      cb();
	    }
	    this.off('error', onError);
	  };
	  const onError = (err) => {
	    this._flushPending = false;
	    cb(err);
	    this.off('drain', onDrain);
	  };

	  this.once('drain', onDrain);
	  this.once('error', onError);
	}

	function flush (cb) {
	  if (cb != null && typeof cb !== 'function') {
	    throw new Error('flush cb must be a function')
	  }

	  if (this.destroyed) {
	    const error = new Error('SonicBoom destroyed');
	    if (cb) {
	      cb(error);
	      return
	    }

	    throw error
	  }

	  if (this.minLength <= 0) {
	    cb?.();
	    return
	  }

	  if (cb) {
	    callFlushCallbackOnDrain.call(this, cb);
	  }

	  if (this._writing) {
	    return
	  }

	  if (this._bufs.length === 0) {
	    this._bufs.push('');
	  }

	  this._actualWrite();
	}

	function flushBuffer (cb) {
	  if (cb != null && typeof cb !== 'function') {
	    throw new Error('flush cb must be a function')
	  }

	  if (this.destroyed) {
	    const error = new Error('SonicBoom destroyed');
	    if (cb) {
	      cb(error);
	      return
	    }

	    throw error
	  }

	  if (this.minLength <= 0) {
	    cb?.();
	    return
	  }

	  if (cb) {
	    callFlushCallbackOnDrain.call(this, cb);
	  }

	  if (this._writing) {
	    return
	  }

	  if (this._bufs.length === 0) {
	    this._bufs.push([]);
	    this._lens.push(0);
	  }

	  this._actualWrite();
	}

	SonicBoom.prototype.reopen = function (file) {
	  if (this.destroyed) {
	    throw new Error('SonicBoom destroyed')
	  }

	  if (this._opening) {
	    this.once('ready', () => {
	      this.reopen(file);
	    });
	    return
	  }

	  if (this._ending) {
	    return
	  }

	  if (!this.file) {
	    throw new Error('Unable to reopen a file descriptor, you must pass a file to SonicBoom')
	  }

	  if (file) {
	    this.file = file;
	  }
	  this._reopening = true;

	  if (this._writing) {
	    return
	  }

	  const fd = this.fd;
	  this.once('ready', () => {
	    if (fd !== this.fd) {
	      fs$1.close(fd, (err) => {
	        if (err) {
	          return this.emit('error', err)
	        }
	      });
	    }
	  });

	  openFile(this.file, this);
	};

	SonicBoom.prototype.end = function () {
	  if (this.destroyed) {
	    throw new Error('SonicBoom destroyed')
	  }

	  if (this._opening) {
	    this.once('ready', () => {
	      this.end();
	    });
	    return
	  }

	  if (this._ending) {
	    return
	  }

	  this._ending = true;

	  if (this._writing) {
	    return
	  }

	  if (this._len > 0 && this.fd >= 0) {
	    this._actualWrite();
	  } else {
	    actualClose(this);
	  }
	};

	function flushSync () {
	  if (this.destroyed) {
	    throw new Error('SonicBoom destroyed')
	  }

	  if (this.fd < 0) {
	    throw new Error('sonic boom is not ready yet')
	  }

	  if (!this._writing && this._writingBuf.length > 0) {
	    this._bufs.unshift(this._writingBuf);
	    this._writingBuf = '';
	  }

	  let buf = '';
	  while (this._bufs.length || buf) {
	    if (buf.length <= 0) {
	      buf = this._bufs[0];
	    }
	    try {
	      const n = fs$1.writeSync(this.fd, buf, 'utf8');
	      const releasedBufObj = releaseWritingBuf(buf, this._len, n);
	      buf = releasedBufObj.writingBuf;
	      this._len = releasedBufObj.len;
	      if (buf.length <= 0) {
	        this._bufs.shift();
	      }
	    } catch (err) {
	      const shouldRetry = err.code === 'EAGAIN' || err.code === 'EBUSY';
	      if (shouldRetry && !this.retryEAGAIN(err, buf.length, this._len - buf.length)) {
	        throw err
	      }

	      sleep(BUSY_WRITE_TIMEOUT);
	    }
	  }

	  try {
	    fs$1.fsyncSync(this.fd);
	  } catch {
	    // Skip the error. The fd might not support fsync.
	  }
	}

	function flushBufferSync () {
	  if (this.destroyed) {
	    throw new Error('SonicBoom destroyed')
	  }

	  if (this.fd < 0) {
	    throw new Error('sonic boom is not ready yet')
	  }

	  if (!this._writing && this._writingBuf.length > 0) {
	    this._bufs.unshift([this._writingBuf]);
	    this._writingBuf = kEmptyBuffer;
	  }

	  let buf = kEmptyBuffer;
	  while (this._bufs.length || buf.length) {
	    if (buf.length <= 0) {
	      buf = mergeBuf(this._bufs[0], this._lens[0]);
	    }
	    try {
	      const n = fs$1.writeSync(this.fd, buf);
	      buf = buf.subarray(n);
	      this._len = Math.max(this._len - n, 0);
	      if (buf.length <= 0) {
	        this._bufs.shift();
	        this._lens.shift();
	      }
	    } catch (err) {
	      const shouldRetry = err.code === 'EAGAIN' || err.code === 'EBUSY';
	      if (shouldRetry && !this.retryEAGAIN(err, buf.length, this._len - buf.length)) {
	        throw err
	      }

	      sleep(BUSY_WRITE_TIMEOUT);
	    }
	  }
	}

	SonicBoom.prototype.destroy = function () {
	  if (this.destroyed) {
	    return
	  }
	  actualClose(this);
	};

	function actualWrite () {
	  const release = this.release;
	  this._writing = true;
	  this._writingBuf = this._writingBuf || this._bufs.shift() || '';

	  if (this.sync) {
	    try {
	      const written = fs$1.writeSync(this.fd, this._writingBuf, 'utf8');
	      release(null, written);
	    } catch (err) {
	      release(err);
	    }
	  } else {
	    fs$1.write(this.fd, this._writingBuf, 'utf8', release);
	  }
	}

	function actualWriteBuffer () {
	  const release = this.release;
	  this._writing = true;
	  this._writingBuf = this._writingBuf.length ? this._writingBuf : mergeBuf(this._bufs.shift(), this._lens.shift());

	  if (this.sync) {
	    try {
	      const written = fs$1.writeSync(this.fd, this._writingBuf);
	      release(null, written);
	    } catch (err) {
	      release(err);
	    }
	  } else {
	    // fs.write will need to copy string to buffer anyway so
	    // we do it here to avoid the overhead of calculating the buffer size
	    // in releaseWritingBuf.
	    if (kCopyBuffer) {
	      this._writingBuf = Buffer.from(this._writingBuf);
	    }
	    fs$1.write(this.fd, this._writingBuf, release);
	  }
	}

	function actualClose (sonic) {
	  if (sonic.fd === -1) {
	    sonic.once('ready', actualClose.bind(null, sonic));
	    return
	  }

	  if (sonic._periodicFlushTimer !== undefined) {
	    clearInterval(sonic._periodicFlushTimer);
	  }

	  sonic.destroyed = true;
	  sonic._bufs = [];
	  sonic._lens = [];

	  assert$1(typeof sonic.fd === 'number', `sonic.fd must be a number, got ${typeof sonic.fd}`);
	  try {
	    fs$1.fsync(sonic.fd, closeWrapped);
	  } catch {
	  }

	  function closeWrapped () {
	    // We skip errors in fsync

	    if (sonic.fd !== 1 && sonic.fd !== 2) {
	      fs$1.close(sonic.fd, done);
	    } else {
	      done();
	    }
	  }

	  function done (err) {
	    if (err) {
	      sonic.emit('error', err);
	      return
	    }

	    if (sonic._ending && !sonic._writing) {
	      sonic.emit('finish');
	    }
	    sonic.emit('close');
	  }
	}

	/**
	 * These export configurations enable JS and TS developers
	 * to consumer SonicBoom in whatever way best suits their needs.
	 * Some examples of supported import syntax includes:
	 * - `const SonicBoom = require('SonicBoom')`
	 * - `const { SonicBoom } = require('SonicBoom')`
	 * - `import * as SonicBoom from 'SonicBoom'`
	 * - `import { SonicBoom } from 'SonicBoom'`
	 * - `import SonicBoom from 'SonicBoom'`
	 */
	SonicBoom.SonicBoom = SonicBoom;
	SonicBoom.default = SonicBoom;
	sonicBoom = SonicBoom;
	return sonicBoom;
}

var onExitLeakFree;
var hasRequiredOnExitLeakFree;

function requireOnExitLeakFree () {
	if (hasRequiredOnExitLeakFree) return onExitLeakFree;
	hasRequiredOnExitLeakFree = 1;

	const refs = {
	  exit: [],
	  beforeExit: []
	};
	const functions = {
	  exit: onExit,
	  beforeExit: onBeforeExit
	};

	let registry;

	function ensureRegistry () {
	  if (registry === undefined) {
	    registry = new FinalizationRegistry(clear);
	  }
	}

	function install (event) {
	  if (refs[event].length > 0) {
	    return
	  }

	  process.on(event, functions[event]);
	}

	function uninstall (event) {
	  if (refs[event].length > 0) {
	    return
	  }
	  process.removeListener(event, functions[event]);
	  if (refs.exit.length === 0 && refs.beforeExit.length === 0) {
	    registry = undefined;
	  }
	}

	function onExit () {
	  callRefs('exit');
	}

	function onBeforeExit () {
	  callRefs('beforeExit');
	}

	function callRefs (event) {
	  for (const ref of refs[event]) {
	    const obj = ref.deref();
	    const fn = ref.fn;

	    // This should always happen, however GC is
	    // undeterministic so it might not happen.
	    /* istanbul ignore else */
	    if (obj !== undefined) {
	      fn(obj, event);
	    }
	  }
	  refs[event] = [];
	}

	function clear (ref) {
	  for (const event of ['exit', 'beforeExit']) {
	    const index = refs[event].indexOf(ref);
	    refs[event].splice(index, index + 1);
	    uninstall(event);
	  }
	}

	function _register (event, obj, fn) {
	  if (obj === undefined) {
	    throw new Error('the object can\'t be undefined')
	  }
	  install(event);
	  const ref = new WeakRef(obj);
	  ref.fn = fn;

	  ensureRegistry();
	  registry.register(obj, ref);
	  refs[event].push(ref);
	}

	function register (obj, fn) {
	  _register('exit', obj, fn);
	}

	function registerBeforeExit (obj, fn) {
	  _register('beforeExit', obj, fn);
	}

	function unregister (obj) {
	  if (registry === undefined) {
	    return
	  }
	  registry.unregister(obj);
	  for (const event of ['exit', 'beforeExit']) {
	    refs[event] = refs[event].filter((ref) => {
	      const _obj = ref.deref();
	      return _obj && _obj !== obj
	    });
	    uninstall(event);
	  }
	}

	onExitLeakFree = {
	  register,
	  registerBeforeExit,
	  unregister
	};
	return onExitLeakFree;
}

var version$2 = "3.1.0";
var require$$0$1 = {
	version: version$2};

var wait_1;
var hasRequiredWait;

function requireWait () {
	if (hasRequiredWait) return wait_1;
	hasRequiredWait = 1;

	const MAX_TIMEOUT = 1000;

	function wait (state, index, expected, timeout, done) {
	  const max = Date.now() + timeout;
	  let current = Atomics.load(state, index);
	  if (current === expected) {
	    done(null, 'ok');
	    return
	  }
	  let prior = current;
	  const check = (backoff) => {
	    if (Date.now() > max) {
	      done(null, 'timed-out');
	    } else {
	      setTimeout(() => {
	        prior = current;
	        current = Atomics.load(state, index);
	        if (current === prior) {
	          check(backoff >= MAX_TIMEOUT ? MAX_TIMEOUT : backoff * 2);
	        } else {
	          if (current === expected) done(null, 'ok');
	          else done(null, 'not-equal');
	        }
	      }, backoff);
	    }
	  };
	  check(1);
	}

	// let waitDiffCount = 0
	function waitDiff (state, index, expected, timeout, done) {
	  // const id = waitDiffCount++
	  // process._rawDebug(`>>> waitDiff ${id}`)
	  const max = Date.now() + timeout;
	  let current = Atomics.load(state, index);
	  if (current !== expected) {
	    done(null, 'ok');
	    return
	  }
	  const check = (backoff) => {
	    // process._rawDebug(`${id} ${index} current ${current} expected ${expected}`)
	    // process._rawDebug('' + backoff)
	    if (Date.now() > max) {
	      done(null, 'timed-out');
	    } else {
	      setTimeout(() => {
	        current = Atomics.load(state, index);
	        if (current !== expected) {
	          done(null, 'ok');
	        } else {
	          check(backoff >= MAX_TIMEOUT ? MAX_TIMEOUT : backoff * 2);
	        }
	      }, backoff);
	    }
	  };
	  check(1);
	}

	wait_1 = { wait, waitDiff };
	return wait_1;
}

var indexes;
var hasRequiredIndexes;

function requireIndexes () {
	if (hasRequiredIndexes) return indexes;
	hasRequiredIndexes = 1;

	const WRITE_INDEX = 4;
	const READ_INDEX = 8;

	indexes = {
	  WRITE_INDEX,
	  READ_INDEX
	};
	return indexes;
}

var threadStream;
var hasRequiredThreadStream;

function requireThreadStream () {
	if (hasRequiredThreadStream) return threadStream;
	hasRequiredThreadStream = 1;

	const { version } = require$$0$1;
	const { EventEmitter } = require$$1$2;
	const { Worker } = require$$2$3;
	const { join } = path;
	const { pathToFileURL } = require$$4$1;
	const { wait } = requireWait();
	const {
	  WRITE_INDEX,
	  READ_INDEX
	} = requireIndexes();
	const buffer = require$$7;
	const assert$1 = assert;

	const kImpl = Symbol('kImpl');

	// V8 limit for string size
	const MAX_STRING = buffer.constants.MAX_STRING_LENGTH;

	class FakeWeakRef {
	  constructor (value) {
	    this._value = value;
	  }

	  deref () {
	    return this._value
	  }
	}

	class FakeFinalizationRegistry {
	  register () {}

	  unregister () {}
	}

	// Currently using FinalizationRegistry with code coverage breaks the world
	// Ref: https://github.com/nodejs/node/issues/49344
	const FinalizationRegistry = process.env.NODE_V8_COVERAGE ? FakeFinalizationRegistry : commonjsGlobal.FinalizationRegistry || FakeFinalizationRegistry;
	const WeakRef = process.env.NODE_V8_COVERAGE ? FakeWeakRef : commonjsGlobal.WeakRef || FakeWeakRef;

	const registry = new FinalizationRegistry((worker) => {
	  if (worker.exited) {
	    return
	  }
	  worker.terminate();
	});

	function createWorker (stream, opts) {
	  const { filename, workerData } = opts;

	  const bundlerOverrides = '__bundlerPathsOverrides' in globalThis ? globalThis.__bundlerPathsOverrides : {};
	  const toExecute = bundlerOverrides['thread-stream-worker'] || join(__dirname, 'lib', 'worker.js');

	  const worker = new Worker(toExecute, {
	    ...opts.workerOpts,
	    trackUnmanagedFds: false,
	    workerData: {
	      filename: filename.indexOf('file://') === 0
	        ? filename
	        : pathToFileURL(filename).href,
	      dataBuf: stream[kImpl].dataBuf,
	      stateBuf: stream[kImpl].stateBuf,
	      workerData: {
	        $context: {
	          threadStreamVersion: version
	        },
	        ...workerData
	      }
	    }
	  });

	  // We keep a strong reference for now,
	  // we need to start writing first
	  worker.stream = new FakeWeakRef(stream);

	  worker.on('message', onWorkerMessage);
	  worker.on('exit', onWorkerExit);
	  registry.register(stream, worker);

	  return worker
	}

	function drain (stream) {
	  assert$1(!stream[kImpl].sync);
	  if (stream[kImpl].needDrain) {
	    stream[kImpl].needDrain = false;
	    stream.emit('drain');
	  }
	}

	function nextFlush (stream) {
	  const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
	  let leftover = stream[kImpl].data.length - writeIndex;

	  if (leftover > 0) {
	    if (stream[kImpl].buf.length === 0) {
	      stream[kImpl].flushing = false;

	      if (stream[kImpl].ending) {
	        end(stream);
	      } else if (stream[kImpl].needDrain) {
	        process.nextTick(drain, stream);
	      }

	      return
	    }

	    let toWrite = stream[kImpl].buf.slice(0, leftover);
	    let toWriteBytes = Buffer.byteLength(toWrite);
	    if (toWriteBytes <= leftover) {
	      stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
	      // process._rawDebug('writing ' + toWrite.length)
	      write(stream, toWrite, nextFlush.bind(null, stream));
	    } else {
	      // multi-byte utf-8
	      stream.flush(() => {
	        // err is already handled in flush()
	        if (stream.destroyed) {
	          return
	        }

	        Atomics.store(stream[kImpl].state, READ_INDEX, 0);
	        Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);

	        // Find a toWrite length that fits the buffer
	        // it must exists as the buffer is at least 4 bytes length
	        // and the max utf-8 length for a char is 4 bytes.
	        while (toWriteBytes > stream[kImpl].data.length) {
	          leftover = leftover / 2;
	          toWrite = stream[kImpl].buf.slice(0, leftover);
	          toWriteBytes = Buffer.byteLength(toWrite);
	        }
	        stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
	        write(stream, toWrite, nextFlush.bind(null, stream));
	      });
	    }
	  } else if (leftover === 0) {
	    if (writeIndex === 0 && stream[kImpl].buf.length === 0) {
	      // we had a flushSync in the meanwhile
	      return
	    }
	    stream.flush(() => {
	      Atomics.store(stream[kImpl].state, READ_INDEX, 0);
	      Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
	      nextFlush(stream);
	    });
	  } else {
	    // This should never happen
	    destroy(stream, new Error('overwritten'));
	  }
	}

	function onWorkerMessage (msg) {
	  const stream = this.stream.deref();
	  if (stream === undefined) {
	    this.exited = true;
	    // Terminate the worker.
	    this.terminate();
	    return
	  }

	  switch (msg.code) {
	    case 'READY':
	      // Replace the FakeWeakRef with a
	      // proper one.
	      this.stream = new WeakRef(stream);

	      stream.flush(() => {
	        stream[kImpl].ready = true;
	        stream.emit('ready');
	      });
	      break
	    case 'ERROR':
	      destroy(stream, msg.err);
	      break
	    case 'EVENT':
	      if (Array.isArray(msg.args)) {
	        stream.emit(msg.name, ...msg.args);
	      } else {
	        stream.emit(msg.name, msg.args);
	      }
	      break
	    case 'WARNING':
	      process.emitWarning(msg.err);
	      break
	    default:
	      destroy(stream, new Error('this should not happen: ' + msg.code));
	  }
	}

	function onWorkerExit (code) {
	  const stream = this.stream.deref();
	  if (stream === undefined) {
	    // Nothing to do, the worker already exit
	    return
	  }
	  registry.unregister(stream);
	  stream.worker.exited = true;
	  stream.worker.off('exit', onWorkerExit);
	  destroy(stream, code !== 0 ? new Error('the worker thread exited') : null);
	}

	class ThreadStream extends EventEmitter {
	  constructor (opts = {}) {
	    super();

	    if (opts.bufferSize < 4) {
	      throw new Error('bufferSize must at least fit a 4-byte utf-8 char')
	    }

	    this[kImpl] = {};
	    this[kImpl].stateBuf = new SharedArrayBuffer(128);
	    this[kImpl].state = new Int32Array(this[kImpl].stateBuf);
	    this[kImpl].dataBuf = new SharedArrayBuffer(opts.bufferSize || 4 * 1024 * 1024);
	    this[kImpl].data = Buffer.from(this[kImpl].dataBuf);
	    this[kImpl].sync = opts.sync || false;
	    this[kImpl].ending = false;
	    this[kImpl].ended = false;
	    this[kImpl].needDrain = false;
	    this[kImpl].destroyed = false;
	    this[kImpl].flushing = false;
	    this[kImpl].ready = false;
	    this[kImpl].finished = false;
	    this[kImpl].errored = null;
	    this[kImpl].closed = false;
	    this[kImpl].buf = '';

	    // TODO (fix): Make private?
	    this.worker = createWorker(this, opts); // TODO (fix): make private
	    this.on('message', (message, transferList) => {
	      this.worker.postMessage(message, transferList);
	    });
	  }

	  write (data) {
	    if (this[kImpl].destroyed) {
	      error(this, new Error('the worker has exited'));
	      return false
	    }

	    if (this[kImpl].ending) {
	      error(this, new Error('the worker is ending'));
	      return false
	    }

	    if (this[kImpl].flushing && this[kImpl].buf.length + data.length >= MAX_STRING) {
	      try {
	        writeSync(this);
	        this[kImpl].flushing = true;
	      } catch (err) {
	        destroy(this, err);
	        return false
	      }
	    }

	    this[kImpl].buf += data;

	    if (this[kImpl].sync) {
	      try {
	        writeSync(this);
	        return true
	      } catch (err) {
	        destroy(this, err);
	        return false
	      }
	    }

	    if (!this[kImpl].flushing) {
	      this[kImpl].flushing = true;
	      setImmediate(nextFlush, this);
	    }

	    this[kImpl].needDrain = this[kImpl].data.length - this[kImpl].buf.length - Atomics.load(this[kImpl].state, WRITE_INDEX) <= 0;
	    return !this[kImpl].needDrain
	  }

	  end () {
	    if (this[kImpl].destroyed) {
	      return
	    }

	    this[kImpl].ending = true;
	    end(this);
	  }

	  flush (cb) {
	    if (this[kImpl].destroyed) {
	      if (typeof cb === 'function') {
	        process.nextTick(cb, new Error('the worker has exited'));
	      }
	      return
	    }

	    // TODO write all .buf
	    const writeIndex = Atomics.load(this[kImpl].state, WRITE_INDEX);
	    // process._rawDebug(`(flush) readIndex (${Atomics.load(this.state, READ_INDEX)}) writeIndex (${Atomics.load(this.state, WRITE_INDEX)})`)
	    wait(this[kImpl].state, READ_INDEX, writeIndex, Infinity, (err, res) => {
	      if (err) {
	        destroy(this, err);
	        process.nextTick(cb, err);
	        return
	      }
	      if (res === 'not-equal') {
	        // TODO handle deadlock
	        this.flush(cb);
	        return
	      }
	      process.nextTick(cb);
	    });
	  }

	  flushSync () {
	    if (this[kImpl].destroyed) {
	      return
	    }

	    writeSync(this);
	    flushSync(this);
	  }

	  unref () {
	    this.worker.unref();
	  }

	  ref () {
	    this.worker.ref();
	  }

	  get ready () {
	    return this[kImpl].ready
	  }

	  get destroyed () {
	    return this[kImpl].destroyed
	  }

	  get closed () {
	    return this[kImpl].closed
	  }

	  get writable () {
	    return !this[kImpl].destroyed && !this[kImpl].ending
	  }

	  get writableEnded () {
	    return this[kImpl].ending
	  }

	  get writableFinished () {
	    return this[kImpl].finished
	  }

	  get writableNeedDrain () {
	    return this[kImpl].needDrain
	  }

	  get writableObjectMode () {
	    return false
	  }

	  get writableErrored () {
	    return this[kImpl].errored
	  }
	}

	function error (stream, err) {
	  setImmediate(() => {
	    stream.emit('error', err);
	  });
	}

	function destroy (stream, err) {
	  if (stream[kImpl].destroyed) {
	    return
	  }
	  stream[kImpl].destroyed = true;

	  if (err) {
	    stream[kImpl].errored = err;
	    error(stream, err);
	  }

	  if (!stream.worker.exited) {
	    stream.worker.terminate()
	      .catch(() => {})
	      .then(() => {
	        stream[kImpl].closed = true;
	        stream.emit('close');
	      });
	  } else {
	    setImmediate(() => {
	      stream[kImpl].closed = true;
	      stream.emit('close');
	    });
	  }
	}

	function write (stream, data, cb) {
	  // data is smaller than the shared buffer length
	  const current = Atomics.load(stream[kImpl].state, WRITE_INDEX);
	  const length = Buffer.byteLength(data);
	  stream[kImpl].data.write(data, current);
	  Atomics.store(stream[kImpl].state, WRITE_INDEX, current + length);
	  Atomics.notify(stream[kImpl].state, WRITE_INDEX);
	  cb();
	  return true
	}

	function end (stream) {
	  if (stream[kImpl].ended || !stream[kImpl].ending || stream[kImpl].flushing) {
	    return
	  }
	  stream[kImpl].ended = true;

	  try {
	    stream.flushSync();

	    let readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);

	    // process._rawDebug('writing index')
	    Atomics.store(stream[kImpl].state, WRITE_INDEX, -1);
	    // process._rawDebug(`(end) readIndex (${Atomics.load(stream.state, READ_INDEX)}) writeIndex (${Atomics.load(stream.state, WRITE_INDEX)})`)
	    Atomics.notify(stream[kImpl].state, WRITE_INDEX);

	    // Wait for the process to complete
	    let spins = 0;
	    while (readIndex !== -1) {
	      // process._rawDebug(`read = ${read}`)
	      Atomics.wait(stream[kImpl].state, READ_INDEX, readIndex, 1000);
	      readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);

	      if (readIndex === -2) {
	        destroy(stream, new Error('end() failed'));
	        return
	      }

	      if (++spins === 10) {
	        destroy(stream, new Error('end() took too long (10s)'));
	        return
	      }
	    }

	    process.nextTick(() => {
	      stream[kImpl].finished = true;
	      stream.emit('finish');
	    });
	  } catch (err) {
	    destroy(stream, err);
	  }
	  // process._rawDebug('end finished...')
	}

	function writeSync (stream) {
	  const cb = () => {
	    if (stream[kImpl].ending) {
	      end(stream);
	    } else if (stream[kImpl].needDrain) {
	      process.nextTick(drain, stream);
	    }
	  };
	  stream[kImpl].flushing = false;

	  while (stream[kImpl].buf.length !== 0) {
	    const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
	    let leftover = stream[kImpl].data.length - writeIndex;
	    if (leftover === 0) {
	      flushSync(stream);
	      Atomics.store(stream[kImpl].state, READ_INDEX, 0);
	      Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
	      continue
	    } else if (leftover < 0) {
	      // stream should never happen
	      throw new Error('overwritten')
	    }

	    let toWrite = stream[kImpl].buf.slice(0, leftover);
	    let toWriteBytes = Buffer.byteLength(toWrite);
	    if (toWriteBytes <= leftover) {
	      stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
	      // process._rawDebug('writing ' + toWrite.length)
	      write(stream, toWrite, cb);
	    } else {
	      // multi-byte utf-8
	      flushSync(stream);
	      Atomics.store(stream[kImpl].state, READ_INDEX, 0);
	      Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);

	      // Find a toWrite length that fits the buffer
	      // it must exists as the buffer is at least 4 bytes length
	      // and the max utf-8 length for a char is 4 bytes.
	      while (toWriteBytes > stream[kImpl].buf.length) {
	        leftover = leftover / 2;
	        toWrite = stream[kImpl].buf.slice(0, leftover);
	        toWriteBytes = Buffer.byteLength(toWrite);
	      }
	      stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
	      write(stream, toWrite, cb);
	    }
	  }
	}

	function flushSync (stream) {
	  if (stream[kImpl].flushing) {
	    throw new Error('unable to flush while flushing')
	  }

	  // process._rawDebug('flushSync started')

	  const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);

	  let spins = 0;

	  // TODO handle deadlock
	  while (true) {
	    const readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);

	    if (readIndex === -2) {
	      throw Error('_flushSync failed')
	    }

	    // process._rawDebug(`(flushSync) readIndex (${readIndex}) writeIndex (${writeIndex})`)
	    if (readIndex !== writeIndex) {
	      // TODO stream timeouts for some reason.
	      Atomics.wait(stream[kImpl].state, READ_INDEX, readIndex, 1000);
	    } else {
	      break
	    }

	    if (++spins === 10) {
	      throw new Error('_flushSync took too long (10s)')
	    }
	  }
	  // process._rawDebug('flushSync finished')
	}

	threadStream = ThreadStream;
	return threadStream;
}

var transport_1;
var hasRequiredTransport;

function requireTransport () {
	if (hasRequiredTransport) return transport_1;
	hasRequiredTransport = 1;

	const { createRequire } = require$$0$6;
	const getCallers = requireCaller();
	const { join, isAbsolute, sep } = path$1;
	const sleep = requireAtomicSleep();
	const onExit = requireOnExitLeakFree();
	const ThreadStream = requireThreadStream();

	function setupOnExit (stream) {
	  // This is leak free, it does not leave event handlers
	  onExit.register(stream, autoEnd);
	  onExit.registerBeforeExit(stream, flush);

	  stream.on('close', function () {
	    onExit.unregister(stream);
	  });
	}

	function buildStream (filename, workerData, workerOpts, sync) {
	  const stream = new ThreadStream({
	    filename,
	    workerData,
	    workerOpts,
	    sync
	  });

	  stream.on('ready', onReady);
	  stream.on('close', function () {
	    process.removeListener('exit', onExit);
	  });

	  process.on('exit', onExit);

	  function onReady () {
	    process.removeListener('exit', onExit);
	    stream.unref();

	    if (workerOpts.autoEnd !== false) {
	      setupOnExit(stream);
	    }
	  }

	  function onExit () {
	    /* istanbul ignore next */
	    if (stream.closed) {
	      return
	    }
	    stream.flushSync();
	    // Apparently there is a very sporadic race condition
	    // that in certain OS would prevent the messages to be flushed
	    // because the thread might not have been created still.
	    // Unfortunately we need to sleep(100) in this case.
	    sleep(100);
	    stream.end();
	  }

	  return stream
	}

	function autoEnd (stream) {
	  stream.ref();
	  stream.flushSync();
	  stream.end();
	  stream.once('close', function () {
	    stream.unref();
	  });
	}

	function flush (stream) {
	  stream.flushSync();
	}

	function transport (fullOptions) {
	  const { pipeline, targets, levels, dedupe, worker = {}, caller = getCallers(), sync = false } = fullOptions;

	  const options = {
	    ...fullOptions.options
	  };

	  // Backwards compatibility
	  const callers = typeof caller === 'string' ? [caller] : caller;

	  // This will be eventually modified by bundlers
	  const bundlerOverrides = '__bundlerPathsOverrides' in globalThis ? globalThis.__bundlerPathsOverrides : {};

	  let target = fullOptions.target;

	  if (target && targets) {
	    throw new Error('only one of target or targets can be specified')
	  }

	  if (targets) {
	    target = bundlerOverrides['pino-worker'] || join(__dirname, 'worker.js');
	    options.targets = targets.filter(dest => dest.target).map((dest) => {
	      return {
	        ...dest,
	        target: fixTarget(dest.target)
	      }
	    });
	    options.pipelines = targets.filter(dest => dest.pipeline).map((dest) => {
	      return dest.pipeline.map((t) => {
	        return {
	          ...t,
	          level: dest.level, // duplicate the pipeline `level` property defined in the upper level
	          target: fixTarget(t.target)
	        }
	      })
	    });
	  } else if (pipeline) {
	    target = bundlerOverrides['pino-worker'] || join(__dirname, 'worker.js');
	    options.pipelines = [pipeline.map((dest) => {
	      return {
	        ...dest,
	        target: fixTarget(dest.target)
	      }
	    })];
	  }

	  if (levels) {
	    options.levels = levels;
	  }

	  if (dedupe) {
	    options.dedupe = dedupe;
	  }

	  options.pinoWillSendConfig = true;

	  return buildStream(fixTarget(target), options, worker, sync)

	  function fixTarget (origin) {
	    origin = bundlerOverrides[origin] || origin;

	    if (isAbsolute(origin) || origin.indexOf('file://') === 0) {
	      return origin
	    }

	    if (origin === 'pino/file') {
	      return join(__dirname, '..', 'file.js')
	    }

	    let fixTarget;

	    for (const filePath of callers) {
	      try {
	        const context = filePath === 'node:repl'
	          ? process.cwd() + sep
	          : filePath;

	        fixTarget = createRequire(context).resolve(origin);
	        break
	      } catch (err) {
	        // Silent catch
	        continue
	      }
	    }

	    if (!fixTarget) {
	      throw new Error(`unable to determine transport target for "${origin}"`)
	    }

	    return fixTarget
	  }
	}

	transport_1 = transport;
	return transport_1;
}

var tools;
var hasRequiredTools;

function requireTools () {
	if (hasRequiredTools) return tools;
	hasRequiredTools = 1;

	/* eslint no-prototype-builtins: 0 */

	const format = requireQuickFormatUnescaped();
	const { mapHttpRequest, mapHttpResponse } = requirePinoStdSerializers();
	const SonicBoom = requireSonicBoom();
	const onExit = requireOnExitLeakFree();
	const {
	  lsCacheSym,
	  chindingsSym,
	  writeSym,
	  serializersSym,
	  formatOptsSym,
	  endSym,
	  stringifiersSym,
	  stringifySym,
	  stringifySafeSym,
	  wildcardFirstSym,
	  nestedKeySym,
	  formattersSym,
	  messageKeySym,
	  errorKeySym,
	  nestedKeyStrSym,
	  msgPrefixSym
	} = requireSymbols();
	const { isMainThread } = require$$2$3;
	const transport = requireTransport();

	function noop () {
	}

	function genLog (level, hook) {
	  if (!hook) return LOG

	  return function hookWrappedLog (...args) {
	    hook.call(this, args, LOG, level);
	  }

	  function LOG (o, ...n) {
	    if (typeof o === 'object') {
	      let msg = o;
	      if (o !== null) {
	        if (o.method && o.headers && o.socket) {
	          o = mapHttpRequest(o);
	        } else if (typeof o.setHeader === 'function') {
	          o = mapHttpResponse(o);
	        }
	      }
	      let formatParams;
	      if (msg === null && n.length === 0) {
	        formatParams = [null];
	      } else {
	        msg = n.shift();
	        formatParams = n;
	      }
	      // We do not use a coercive check for `msg` as it is
	      // measurably slower than the explicit checks.
	      if (typeof this[msgPrefixSym] === 'string' && msg !== undefined && msg !== null) {
	        msg = this[msgPrefixSym] + msg;
	      }
	      this[writeSym](o, format(msg, formatParams, this[formatOptsSym]), level);
	    } else {
	      let msg = o === undefined ? n.shift() : o;

	      // We do not use a coercive check for `msg` as it is
	      // measurably slower than the explicit checks.
	      if (typeof this[msgPrefixSym] === 'string' && msg !== undefined && msg !== null) {
	        msg = this[msgPrefixSym] + msg;
	      }
	      this[writeSym](null, format(msg, n, this[formatOptsSym]), level);
	    }
	  }
	}

	// magically escape strings for json
	// relying on their charCodeAt
	// everything below 32 needs JSON.stringify()
	// 34 and 92 happens all the time, so we
	// have a fast case for them
	function asString (str) {
	  let result = '';
	  let last = 0;
	  let found = false;
	  let point = 255;
	  const l = str.length;
	  if (l > 100) {
	    return JSON.stringify(str)
	  }
	  for (var i = 0; i < l && point >= 32; i++) {
	    point = str.charCodeAt(i);
	    if (point === 34 || point === 92) {
	      result += str.slice(last, i) + '\\';
	      last = i;
	      found = true;
	    }
	  }
	  if (!found) {
	    result = str;
	  } else {
	    result += str.slice(last);
	  }
	  return point < 32 ? JSON.stringify(str) : '"' + result + '"'
	}

	function asJson (obj, msg, num, time) {
	  const stringify = this[stringifySym];
	  const stringifySafe = this[stringifySafeSym];
	  const stringifiers = this[stringifiersSym];
	  const end = this[endSym];
	  const chindings = this[chindingsSym];
	  const serializers = this[serializersSym];
	  const formatters = this[formattersSym];
	  const messageKey = this[messageKeySym];
	  const errorKey = this[errorKeySym];
	  let data = this[lsCacheSym][num] + time;

	  // we need the child bindings added to the output first so instance logged
	  // objects can take precedence when JSON.parse-ing the resulting log line
	  data = data + chindings;

	  let value;
	  if (formatters.log) {
	    obj = formatters.log(obj);
	  }
	  const wildcardStringifier = stringifiers[wildcardFirstSym];
	  let propStr = '';
	  for (const key in obj) {
	    value = obj[key];
	    if (Object.prototype.hasOwnProperty.call(obj, key) && value !== undefined) {
	      if (serializers[key]) {
	        value = serializers[key](value);
	      } else if (key === errorKey && serializers.err) {
	        value = serializers.err(value);
	      }

	      const stringifier = stringifiers[key] || wildcardStringifier;

	      switch (typeof value) {
	        case 'undefined':
	        case 'function':
	          continue
	        case 'number':
	          /* eslint no-fallthrough: "off" */
	          if (Number.isFinite(value) === false) {
	            value = null;
	          }
	        // this case explicitly falls through to the next one
	        case 'boolean':
	          if (stringifier) value = stringifier(value);
	          break
	        case 'string':
	          value = (stringifier || asString)(value);
	          break
	        default:
	          value = (stringifier || stringify)(value, stringifySafe);
	      }
	      if (value === undefined) continue
	      const strKey = asString(key);
	      propStr += ',' + strKey + ':' + value;
	    }
	  }

	  let msgStr = '';
	  if (msg !== undefined) {
	    value = serializers[messageKey] ? serializers[messageKey](msg) : msg;
	    const stringifier = stringifiers[messageKey] || wildcardStringifier;

	    switch (typeof value) {
	      case 'function':
	        break
	      case 'number':
	        /* eslint no-fallthrough: "off" */
	        if (Number.isFinite(value) === false) {
	          value = null;
	        }
	      // this case explicitly falls through to the next one
	      case 'boolean':
	        if (stringifier) value = stringifier(value);
	        msgStr = ',"' + messageKey + '":' + value;
	        break
	      case 'string':
	        value = (stringifier || asString)(value);
	        msgStr = ',"' + messageKey + '":' + value;
	        break
	      default:
	        value = (stringifier || stringify)(value, stringifySafe);
	        msgStr = ',"' + messageKey + '":' + value;
	    }
	  }

	  if (this[nestedKeySym] && propStr) {
	    // place all the obj properties under the specified key
	    // the nested key is already formatted from the constructor
	    return data + this[nestedKeyStrSym] + propStr.slice(1) + '}' + msgStr + end
	  } else {
	    return data + propStr + msgStr + end
	  }
	}

	function asChindings (instance, bindings) {
	  let value;
	  let data = instance[chindingsSym];
	  const stringify = instance[stringifySym];
	  const stringifySafe = instance[stringifySafeSym];
	  const stringifiers = instance[stringifiersSym];
	  const wildcardStringifier = stringifiers[wildcardFirstSym];
	  const serializers = instance[serializersSym];
	  const formatter = instance[formattersSym].bindings;
	  bindings = formatter(bindings);

	  for (const key in bindings) {
	    value = bindings[key];
	    const valid = key !== 'level' &&
	      key !== 'serializers' &&
	      key !== 'formatters' &&
	      key !== 'customLevels' &&
	      bindings.hasOwnProperty(key) &&
	      value !== undefined;
	    if (valid === true) {
	      value = serializers[key] ? serializers[key](value) : value;
	      value = (stringifiers[key] || wildcardStringifier || stringify)(value, stringifySafe);
	      if (value === undefined) continue
	      data += ',"' + key + '":' + value;
	    }
	  }
	  return data
	}

	function hasBeenTampered (stream) {
	  return stream.write !== stream.constructor.prototype.write
	}

	function buildSafeSonicBoom (opts) {
	  const stream = new SonicBoom(opts);
	  stream.on('error', filterBrokenPipe);
	  // If we are sync: false, we must flush on exit
	  if (!opts.sync && isMainThread) {
	    onExit.register(stream, autoEnd);

	    stream.on('close', function () {
	      onExit.unregister(stream);
	    });
	  }
	  return stream

	  function filterBrokenPipe (err) {
	    // Impossible to replicate across all operating systems
	    /* istanbul ignore next */
	    if (err.code === 'EPIPE') {
	      // If we get EPIPE, we should stop logging here
	      // however we have no control to the consumer of
	      // SonicBoom, so we just overwrite the write method
	      stream.write = noop;
	      stream.end = noop;
	      stream.flushSync = noop;
	      stream.destroy = noop;
	      return
	    }
	    stream.removeListener('error', filterBrokenPipe);
	    stream.emit('error', err);
	  }
	}

	function autoEnd (stream, eventName) {
	  // This check is needed only on some platforms
	  /* istanbul ignore next */
	  if (stream.destroyed) {
	    return
	  }

	  if (eventName === 'beforeExit') {
	    // We still have an event loop, let's use it
	    stream.flush();
	    stream.on('drain', function () {
	      stream.end();
	    });
	  } else {
	    // For some reason istanbul is not detecting this, but it's there
	    /* istanbul ignore next */
	    // We do not have an event loop, so flush synchronously
	    stream.flushSync();
	  }
	}

	function createArgsNormalizer (defaultOptions) {
	  return function normalizeArgs (instance, caller, opts = {}, stream) {
	    // support stream as a string
	    if (typeof opts === 'string') {
	      stream = buildSafeSonicBoom({ dest: opts });
	      opts = {};
	    } else if (typeof stream === 'string') {
	      if (opts && opts.transport) {
	        throw Error('only one of option.transport or stream can be specified')
	      }
	      stream = buildSafeSonicBoom({ dest: stream });
	    } else if (opts instanceof SonicBoom || opts.writable || opts._writableState) {
	      stream = opts;
	      opts = {};
	    } else if (opts.transport) {
	      if (opts.transport instanceof SonicBoom || opts.transport.writable || opts.transport._writableState) {
	        throw Error('option.transport do not allow stream, please pass to option directly. e.g. pino(transport)')
	      }
	      if (opts.transport.targets && opts.transport.targets.length && opts.formatters && typeof opts.formatters.level === 'function') {
	        throw Error('option.transport.targets do not allow custom level formatters')
	      }

	      let customLevels;
	      if (opts.customLevels) {
	        customLevels = opts.useOnlyCustomLevels ? opts.customLevels : Object.assign({}, opts.levels, opts.customLevels);
	      }
	      stream = transport({ caller, ...opts.transport, levels: customLevels });
	    }
	    opts = Object.assign({}, defaultOptions, opts);
	    opts.serializers = Object.assign({}, defaultOptions.serializers, opts.serializers);
	    opts.formatters = Object.assign({}, defaultOptions.formatters, opts.formatters);

	    if (opts.prettyPrint) {
	      throw new Error('prettyPrint option is no longer supported, see the pino-pretty package (https://github.com/pinojs/pino-pretty)')
	    }

	    const { enabled, onChild } = opts;
	    if (enabled === false) opts.level = 'silent';
	    if (!onChild) opts.onChild = noop;
	    if (!stream) {
	      if (!hasBeenTampered(process.stdout)) {
	        // If process.stdout.fd is undefined, it means that we are running
	        // in a worker thread. Let's assume we are logging to file descriptor 1.
	        stream = buildSafeSonicBoom({ fd: process.stdout.fd || 1 });
	      } else {
	        stream = process.stdout;
	      }
	    }
	    return { opts, stream }
	  }
	}

	function stringify (obj, stringifySafeFn) {
	  try {
	    return JSON.stringify(obj)
	  } catch (_) {
	    try {
	      const stringify = stringifySafeFn || this[stringifySafeSym];
	      return stringify(obj)
	    } catch (_) {
	      return '"[unable to serialize, circular reference is too complex to analyze]"'
	    }
	  }
	}

	function buildFormatters (level, bindings, log) {
	  return {
	    level,
	    bindings,
	    log
	  }
	}

	/**
	 * Convert a string integer file descriptor to a proper native integer
	 * file descriptor.
	 *
	 * @param {string} destination The file descriptor string to attempt to convert.
	 *
	 * @returns {Number}
	 */
	function normalizeDestFileDescriptor (destination) {
	  const fd = Number(destination);
	  if (typeof destination === 'string' && Number.isFinite(fd)) {
	    return fd
	  }
	  // destination could be undefined if we are in a worker
	  if (destination === undefined) {
	    // This is stdout in UNIX systems
	    return 1
	  }
	  return destination
	}

	tools = {
	  noop,
	  buildSafeSonicBoom,
	  asChindings,
	  asJson,
	  genLog,
	  createArgsNormalizer,
	  stringify,
	  buildFormatters,
	  normalizeDestFileDescriptor
	};
	return tools;
}

/**
 * Represents default log level values
 *
 * @enum {number}
 */

var constants$2;
var hasRequiredConstants$1;

function requireConstants$1 () {
	if (hasRequiredConstants$1) return constants$2;
	hasRequiredConstants$1 = 1;
	const DEFAULT_LEVELS = {
	  trace: 10,
	  debug: 20,
	  info: 30,
	  warn: 40,
	  error: 50,
	  fatal: 60
	};

	/**
	 * Represents sort order direction: `ascending` or `descending`
	 *
	 * @enum {string}
	 */
	const SORTING_ORDER = {
	  ASC: 'ASC',
	  DESC: 'DESC'
	};

	constants$2 = {
	  DEFAULT_LEVELS,
	  SORTING_ORDER
	};
	return constants$2;
}

var levels;
var hasRequiredLevels;

function requireLevels () {
	if (hasRequiredLevels) return levels;
	hasRequiredLevels = 1;
	/* eslint no-prototype-builtins: 0 */
	const {
	  lsCacheSym,
	  levelValSym,
	  useOnlyCustomLevelsSym,
	  streamSym,
	  formattersSym,
	  hooksSym,
	  levelCompSym
	} = requireSymbols();
	const { noop, genLog } = requireTools();
	const { DEFAULT_LEVELS, SORTING_ORDER } = requireConstants$1();

	const levelMethods = {
	  fatal: (hook) => {
	    const logFatal = genLog(DEFAULT_LEVELS.fatal, hook);
	    return function (...args) {
	      const stream = this[streamSym];
	      logFatal.call(this, ...args);
	      if (typeof stream.flushSync === 'function') {
	        try {
	          stream.flushSync();
	        } catch (e) {
	          // https://github.com/pinojs/pino/pull/740#discussion_r346788313
	        }
	      }
	    }
	  },
	  error: (hook) => genLog(DEFAULT_LEVELS.error, hook),
	  warn: (hook) => genLog(DEFAULT_LEVELS.warn, hook),
	  info: (hook) => genLog(DEFAULT_LEVELS.info, hook),
	  debug: (hook) => genLog(DEFAULT_LEVELS.debug, hook),
	  trace: (hook) => genLog(DEFAULT_LEVELS.trace, hook)
	};

	const nums = Object.keys(DEFAULT_LEVELS).reduce((o, k) => {
	  o[DEFAULT_LEVELS[k]] = k;
	  return o
	}, {});

	const initialLsCache = Object.keys(nums).reduce((o, k) => {
	  o[k] = '{"level":' + Number(k);
	  return o
	}, {});

	function genLsCache (instance) {
	  const formatter = instance[formattersSym].level;
	  const { labels } = instance.levels;
	  const cache = {};
	  for (const label in labels) {
	    const level = formatter(labels[label], Number(label));
	    cache[label] = JSON.stringify(level).slice(0, -1);
	  }
	  instance[lsCacheSym] = cache;
	  return instance
	}

	function isStandardLevel (level, useOnlyCustomLevels) {
	  if (useOnlyCustomLevels) {
	    return false
	  }

	  switch (level) {
	    case 'fatal':
	    case 'error':
	    case 'warn':
	    case 'info':
	    case 'debug':
	    case 'trace':
	      return true
	    default:
	      return false
	  }
	}

	function setLevel (level) {
	  const { labels, values } = this.levels;
	  if (typeof level === 'number') {
	    if (labels[level] === undefined) throw Error('unknown level value' + level)
	    level = labels[level];
	  }
	  if (values[level] === undefined) throw Error('unknown level ' + level)
	  const preLevelVal = this[levelValSym];
	  const levelVal = this[levelValSym] = values[level];
	  const useOnlyCustomLevelsVal = this[useOnlyCustomLevelsSym];
	  const levelComparison = this[levelCompSym];
	  const hook = this[hooksSym].logMethod;

	  for (const key in values) {
	    if (levelComparison(values[key], levelVal) === false) {
	      this[key] = noop;
	      continue
	    }
	    this[key] = isStandardLevel(key, useOnlyCustomLevelsVal) ? levelMethods[key](hook) : genLog(values[key], hook);
	  }

	  this.emit(
	    'level-change',
	    level,
	    levelVal,
	    labels[preLevelVal],
	    preLevelVal,
	    this
	  );
	}

	function getLevel (level) {
	  const { levels, levelVal } = this;
	  // protection against potential loss of Pino scope from serializers (edge case with circular refs - https://github.com/pinojs/pino/issues/833)
	  return (levels && levels.labels) ? levels.labels[levelVal] : ''
	}

	function isLevelEnabled (logLevel) {
	  const { values } = this.levels;
	  const logLevelVal = values[logLevel];
	  return logLevelVal !== undefined && this[levelCompSym](logLevelVal, this[levelValSym])
	}

	/**
	 * Determine if the given `current` level is enabled by comparing it
	 * against the current threshold (`expected`).
	 *
	 * @param {SORTING_ORDER} direction comparison direction "ASC" or "DESC"
	 * @param {number} current current log level number representation
	 * @param {number} expected threshold value to compare with
	 * @returns {boolean}
	 */
	function compareLevel (direction, current, expected) {
	  if (direction === SORTING_ORDER.DESC) {
	    return current <= expected
	  }

	  return current >= expected
	}

	/**
	 * Create a level comparison function based on `levelComparison`
	 * it could a default function which compares levels either in "ascending" or "descending" order or custom comparison function
	 *
	 * @param {SORTING_ORDER | Function} levelComparison sort levels order direction or custom comparison function
	 * @returns Function
	 */
	function genLevelComparison (levelComparison) {
	  if (typeof levelComparison === 'string') {
	    return compareLevel.bind(null, levelComparison)
	  }

	  return levelComparison
	}

	function mappings (customLevels = null, useOnlyCustomLevels = false) {
	  const customNums = customLevels
	    /* eslint-disable */
	    ? Object.keys(customLevels).reduce((o, k) => {
	        o[customLevels[k]] = k;
	        return o
	      }, {})
	    : null;
	    /* eslint-enable */

	  const labels = Object.assign(
	    Object.create(Object.prototype, { Infinity: { value: 'silent' } }),
	    useOnlyCustomLevels ? null : nums,
	    customNums
	  );
	  const values = Object.assign(
	    Object.create(Object.prototype, { silent: { value: Infinity } }),
	    useOnlyCustomLevels ? null : DEFAULT_LEVELS,
	    customLevels
	  );
	  return { labels, values }
	}

	function assertDefaultLevelFound (defaultLevel, customLevels, useOnlyCustomLevels) {
	  if (typeof defaultLevel === 'number') {
	    const values = [].concat(
	      Object.keys(customLevels || {}).map(key => customLevels[key]),
	      useOnlyCustomLevels ? [] : Object.keys(nums).map(level => +level),
	      Infinity
	    );
	    if (!values.includes(defaultLevel)) {
	      throw Error(`default level:${defaultLevel} must be included in custom levels`)
	    }
	    return
	  }

	  const labels = Object.assign(
	    Object.create(Object.prototype, { silent: { value: Infinity } }),
	    useOnlyCustomLevels ? null : DEFAULT_LEVELS,
	    customLevels
	  );
	  if (!(defaultLevel in labels)) {
	    throw Error(`default level:${defaultLevel} must be included in custom levels`)
	  }
	}

	function assertNoLevelCollisions (levels, customLevels) {
	  const { labels, values } = levels;
	  for (const k in customLevels) {
	    if (k in values) {
	      throw Error('levels cannot be overridden')
	    }
	    if (customLevels[k] in labels) {
	      throw Error('pre-existing level values cannot be used for new levels')
	    }
	  }
	}

	/**
	 * Validates whether `levelComparison` is correct
	 *
	 * @throws Error
	 * @param {SORTING_ORDER | Function} levelComparison - value to validate
	 * @returns
	 */
	function assertLevelComparison (levelComparison) {
	  if (typeof levelComparison === 'function') {
	    return
	  }

	  if (typeof levelComparison === 'string' && Object.values(SORTING_ORDER).includes(levelComparison)) {
	    return
	  }

	  throw new Error('Levels comparison should be one of "ASC", "DESC" or "function" type')
	}

	levels = {
	  initialLsCache,
	  genLsCache,
	  levelMethods,
	  getLevel,
	  setLevel,
	  isLevelEnabled,
	  mappings,
	  assertNoLevelCollisions,
	  assertDefaultLevelFound,
	  genLevelComparison,
	  assertLevelComparison
	};
	return levels;
}

var meta;
var hasRequiredMeta;

function requireMeta () {
	if (hasRequiredMeta) return meta;
	hasRequiredMeta = 1;

	meta = { version: '9.7.0' };
	return meta;
}

var proto;
var hasRequiredProto;

function requireProto () {
	if (hasRequiredProto) return proto;
	hasRequiredProto = 1;

	/* eslint no-prototype-builtins: 0 */

	const { EventEmitter } = require$$0$3;
	const {
	  lsCacheSym,
	  levelValSym,
	  setLevelSym,
	  getLevelSym,
	  chindingsSym,
	  parsedChindingsSym,
	  mixinSym,
	  asJsonSym,
	  writeSym,
	  mixinMergeStrategySym,
	  timeSym,
	  timeSliceIndexSym,
	  streamSym,
	  serializersSym,
	  formattersSym,
	  errorKeySym,
	  messageKeySym,
	  useOnlyCustomLevelsSym,
	  needsMetadataGsym,
	  redactFmtSym,
	  stringifySym,
	  formatOptsSym,
	  stringifiersSym,
	  msgPrefixSym,
	  hooksSym
	} = requireSymbols();
	const {
	  getLevel,
	  setLevel,
	  isLevelEnabled,
	  mappings,
	  initialLsCache,
	  genLsCache,
	  assertNoLevelCollisions
	} = requireLevels();
	const {
	  asChindings,
	  asJson,
	  buildFormatters,
	  stringify
	} = requireTools();
	const {
	  version
	} = requireMeta();
	const redaction = requireRedaction();

	// note: use of class is satirical
	// https://github.com/pinojs/pino/pull/433#pullrequestreview-127703127
	const constructor = class Pino {};
	const prototype = {
	  constructor,
	  child,
	  bindings,
	  setBindings,
	  flush,
	  isLevelEnabled,
	  version,
	  get level () { return this[getLevelSym]() },
	  set level (lvl) { this[setLevelSym](lvl); },
	  get levelVal () { return this[levelValSym] },
	  set levelVal (n) { throw Error('levelVal is read-only') },
	  [lsCacheSym]: initialLsCache,
	  [writeSym]: write,
	  [asJsonSym]: asJson,
	  [getLevelSym]: getLevel,
	  [setLevelSym]: setLevel
	};

	Object.setPrototypeOf(prototype, EventEmitter.prototype);

	// exporting and consuming the prototype object using factory pattern fixes scoping issues with getters when serializing
	proto = function () {
	  return Object.create(prototype)
	};

	const resetChildingsFormatter = bindings => bindings;
	function child (bindings, options) {
	  if (!bindings) {
	    throw Error('missing bindings for child Pino')
	  }
	  options = options || {}; // default options to empty object
	  const serializers = this[serializersSym];
	  const formatters = this[formattersSym];
	  const instance = Object.create(this);

	  if (options.hasOwnProperty('serializers') === true) {
	    instance[serializersSym] = Object.create(null);

	    for (const k in serializers) {
	      instance[serializersSym][k] = serializers[k];
	    }
	    const parentSymbols = Object.getOwnPropertySymbols(serializers);
	    /* eslint no-var: off */
	    for (var i = 0; i < parentSymbols.length; i++) {
	      const ks = parentSymbols[i];
	      instance[serializersSym][ks] = serializers[ks];
	    }

	    for (const bk in options.serializers) {
	      instance[serializersSym][bk] = options.serializers[bk];
	    }
	    const bindingsSymbols = Object.getOwnPropertySymbols(options.serializers);
	    for (var bi = 0; bi < bindingsSymbols.length; bi++) {
	      const bks = bindingsSymbols[bi];
	      instance[serializersSym][bks] = options.serializers[bks];
	    }
	  } else instance[serializersSym] = serializers;
	  if (options.hasOwnProperty('formatters')) {
	    const { level, bindings: chindings, log } = options.formatters;
	    instance[formattersSym] = buildFormatters(
	      level || formatters.level,
	      chindings || resetChildingsFormatter,
	      log || formatters.log
	    );
	  } else {
	    instance[formattersSym] = buildFormatters(
	      formatters.level,
	      resetChildingsFormatter,
	      formatters.log
	    );
	  }
	  if (options.hasOwnProperty('customLevels') === true) {
	    assertNoLevelCollisions(this.levels, options.customLevels);
	    instance.levels = mappings(options.customLevels, instance[useOnlyCustomLevelsSym]);
	    genLsCache(instance);
	  }

	  // redact must place before asChindings and only replace if exist
	  if ((typeof options.redact === 'object' && options.redact !== null) || Array.isArray(options.redact)) {
	    instance.redact = options.redact; // replace redact directly
	    const stringifiers = redaction(instance.redact, stringify);
	    const formatOpts = { stringify: stringifiers[redactFmtSym] };
	    instance[stringifySym] = stringify;
	    instance[stringifiersSym] = stringifiers;
	    instance[formatOptsSym] = formatOpts;
	  }

	  if (typeof options.msgPrefix === 'string') {
	    instance[msgPrefixSym] = (this[msgPrefixSym] || '') + options.msgPrefix;
	  }

	  instance[chindingsSym] = asChindings(instance, bindings);
	  const childLevel = options.level || this.level;
	  instance[setLevelSym](childLevel);
	  this.onChild(instance);
	  return instance
	}

	function bindings () {
	  const chindings = this[chindingsSym];
	  const chindingsJson = `{${chindings.substr(1)}}`; // at least contains ,"pid":7068,"hostname":"myMac"
	  const bindingsFromJson = JSON.parse(chindingsJson);
	  delete bindingsFromJson.pid;
	  delete bindingsFromJson.hostname;
	  return bindingsFromJson
	}

	function setBindings (newBindings) {
	  const chindings = asChindings(this, newBindings);
	  this[chindingsSym] = chindings;
	  delete this[parsedChindingsSym];
	}

	/**
	 * Default strategy for creating `mergeObject` from arguments and the result from `mixin()`.
	 * Fields from `mergeObject` have higher priority in this strategy.
	 *
	 * @param {Object} mergeObject The object a user has supplied to the logging function.
	 * @param {Object} mixinObject The result of the `mixin` method.
	 * @return {Object}
	 */
	function defaultMixinMergeStrategy (mergeObject, mixinObject) {
	  return Object.assign(mixinObject, mergeObject)
	}

	function write (_obj, msg, num) {
	  const t = this[timeSym]();
	  const mixin = this[mixinSym];
	  const errorKey = this[errorKeySym];
	  const messageKey = this[messageKeySym];
	  const mixinMergeStrategy = this[mixinMergeStrategySym] || defaultMixinMergeStrategy;
	  let obj;
	  const streamWriteHook = this[hooksSym].streamWrite;

	  if (_obj === undefined || _obj === null) {
	    obj = {};
	  } else if (_obj instanceof Error) {
	    obj = { [errorKey]: _obj };
	    if (msg === undefined) {
	      msg = _obj.message;
	    }
	  } else {
	    obj = _obj;
	    if (msg === undefined && _obj[messageKey] === undefined && _obj[errorKey]) {
	      msg = _obj[errorKey].message;
	    }
	  }

	  if (mixin) {
	    obj = mixinMergeStrategy(obj, mixin(obj, num, this));
	  }

	  const s = this[asJsonSym](obj, msg, num, t);

	  const stream = this[streamSym];
	  if (stream[needsMetadataGsym] === true) {
	    stream.lastLevel = num;
	    stream.lastObj = obj;
	    stream.lastMsg = msg;
	    stream.lastTime = t.slice(this[timeSliceIndexSym]);
	    stream.lastLogger = this; // for child loggers
	  }
	  stream.write(streamWriteHook ? streamWriteHook(s) : s);
	}

	function noop () {}

	function flush (cb) {
	  if (cb != null && typeof cb !== 'function') {
	    throw Error('callback must be a function')
	  }

	  const stream = this[streamSym];

	  if (typeof stream.flush === 'function') {
	    stream.flush(cb || noop);
	  } else if (cb) cb();
	}
	return proto;
}

var safeStableStringify = {exports: {}};

var hasRequiredSafeStableStringify;

function requireSafeStableStringify () {
	if (hasRequiredSafeStableStringify) return safeStableStringify.exports;
	hasRequiredSafeStableStringify = 1;
	(function (module, exports) {

		const { hasOwnProperty } = Object.prototype;

		const stringify = configure();

		// @ts-expect-error
		stringify.configure = configure;
		// @ts-expect-error
		stringify.stringify = stringify;

		// @ts-expect-error
		stringify.default = stringify;

		// @ts-expect-error used for named export
		exports.stringify = stringify;
		// @ts-expect-error used for named export
		exports.configure = configure;

		module.exports = stringify;

		// eslint-disable-next-line no-control-regex
		const strEscapeSequencesRegExp = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/;

		// Escape C0 control characters, double quotes, the backslash and every code
		// unit with a numeric value in the inclusive range 0xD800 to 0xDFFF.
		function strEscape (str) {
		  // Some magic numbers that worked out fine while benchmarking with v8 8.0
		  if (str.length < 5000 && !strEscapeSequencesRegExp.test(str)) {
		    return `"${str}"`
		  }
		  return JSON.stringify(str)
		}

		function sort (array, comparator) {
		  // Insertion sort is very efficient for small input sizes, but it has a bad
		  // worst case complexity. Thus, use native array sort for bigger values.
		  if (array.length > 2e2 || comparator) {
		    return array.sort(comparator)
		  }
		  for (let i = 1; i < array.length; i++) {
		    const currentValue = array[i];
		    let position = i;
		    while (position !== 0 && array[position - 1] > currentValue) {
		      array[position] = array[position - 1];
		      position--;
		    }
		    array[position] = currentValue;
		  }
		  return array
		}

		const typedArrayPrototypeGetSymbolToStringTag =
		  Object.getOwnPropertyDescriptor(
		    Object.getPrototypeOf(
		      Object.getPrototypeOf(
		        new Int8Array()
		      )
		    ),
		    Symbol.toStringTag
		  ).get;

		function isTypedArrayWithEntries (value) {
		  return typedArrayPrototypeGetSymbolToStringTag.call(value) !== undefined && value.length !== 0
		}

		function stringifyTypedArray (array, separator, maximumBreadth) {
		  if (array.length < maximumBreadth) {
		    maximumBreadth = array.length;
		  }
		  const whitespace = separator === ',' ? '' : ' ';
		  let res = `"0":${whitespace}${array[0]}`;
		  for (let i = 1; i < maximumBreadth; i++) {
		    res += `${separator}"${i}":${whitespace}${array[i]}`;
		  }
		  return res
		}

		function getCircularValueOption (options) {
		  if (hasOwnProperty.call(options, 'circularValue')) {
		    const circularValue = options.circularValue;
		    if (typeof circularValue === 'string') {
		      return `"${circularValue}"`
		    }
		    if (circularValue == null) {
		      return circularValue
		    }
		    if (circularValue === Error || circularValue === TypeError) {
		      return {
		        toString () {
		          throw new TypeError('Converting circular structure to JSON')
		        }
		      }
		    }
		    throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined')
		  }
		  return '"[Circular]"'
		}

		function getDeterministicOption (options) {
		  let value;
		  if (hasOwnProperty.call(options, 'deterministic')) {
		    value = options.deterministic;
		    if (typeof value !== 'boolean' && typeof value !== 'function') {
		      throw new TypeError('The "deterministic" argument must be of type boolean or comparator function')
		    }
		  }
		  return value === undefined ? true : value
		}

		function getBooleanOption (options, key) {
		  let value;
		  if (hasOwnProperty.call(options, key)) {
		    value = options[key];
		    if (typeof value !== 'boolean') {
		      throw new TypeError(`The "${key}" argument must be of type boolean`)
		    }
		  }
		  return value === undefined ? true : value
		}

		function getPositiveIntegerOption (options, key) {
		  let value;
		  if (hasOwnProperty.call(options, key)) {
		    value = options[key];
		    if (typeof value !== 'number') {
		      throw new TypeError(`The "${key}" argument must be of type number`)
		    }
		    if (!Number.isInteger(value)) {
		      throw new TypeError(`The "${key}" argument must be an integer`)
		    }
		    if (value < 1) {
		      throw new RangeError(`The "${key}" argument must be >= 1`)
		    }
		  }
		  return value === undefined ? Infinity : value
		}

		function getItemCount (number) {
		  if (number === 1) {
		    return '1 item'
		  }
		  return `${number} items`
		}

		function getUniqueReplacerSet (replacerArray) {
		  const replacerSet = new Set();
		  for (const value of replacerArray) {
		    if (typeof value === 'string' || typeof value === 'number') {
		      replacerSet.add(String(value));
		    }
		  }
		  return replacerSet
		}

		function getStrictOption (options) {
		  if (hasOwnProperty.call(options, 'strict')) {
		    const value = options.strict;
		    if (typeof value !== 'boolean') {
		      throw new TypeError('The "strict" argument must be of type boolean')
		    }
		    if (value) {
		      return (value) => {
		        let message = `Object can not safely be stringified. Received type ${typeof value}`;
		        if (typeof value !== 'function') message += ` (${value.toString()})`;
		        throw new Error(message)
		      }
		    }
		  }
		}

		function configure (options) {
		  options = { ...options };
		  const fail = getStrictOption(options);
		  if (fail) {
		    if (options.bigint === undefined) {
		      options.bigint = false;
		    }
		    if (!('circularValue' in options)) {
		      options.circularValue = Error;
		    }
		  }
		  const circularValue = getCircularValueOption(options);
		  const bigint = getBooleanOption(options, 'bigint');
		  const deterministic = getDeterministicOption(options);
		  const comparator = typeof deterministic === 'function' ? deterministic : undefined;
		  const maximumDepth = getPositiveIntegerOption(options, 'maximumDepth');
		  const maximumBreadth = getPositiveIntegerOption(options, 'maximumBreadth');

		  function stringifyFnReplacer (key, parent, stack, replacer, spacer, indentation) {
		    let value = parent[key];

		    if (typeof value === 'object' && value !== null && typeof value.toJSON === 'function') {
		      value = value.toJSON(key);
		    }
		    value = replacer.call(parent, key, value);

		    switch (typeof value) {
		      case 'string':
		        return strEscape(value)
		      case 'object': {
		        if (value === null) {
		          return 'null'
		        }
		        if (stack.indexOf(value) !== -1) {
		          return circularValue
		        }

		        let res = '';
		        let join = ',';
		        const originalIndentation = indentation;

		        if (Array.isArray(value)) {
		          if (value.length === 0) {
		            return '[]'
		          }
		          if (maximumDepth < stack.length + 1) {
		            return '"[Array]"'
		          }
		          stack.push(value);
		          if (spacer !== '') {
		            indentation += spacer;
		            res += `\n${indentation}`;
		            join = `,\n${indentation}`;
		          }
		          const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
		          let i = 0;
		          for (; i < maximumValuesToStringify - 1; i++) {
		            const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
		            res += tmp !== undefined ? tmp : 'null';
		            res += join;
		          }
		          const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
		          res += tmp !== undefined ? tmp : 'null';
		          if (value.length - 1 > maximumBreadth) {
		            const removedKeys = value.length - maximumBreadth - 1;
		            res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
		          }
		          if (spacer !== '') {
		            res += `\n${originalIndentation}`;
		          }
		          stack.pop();
		          return `[${res}]`
		        }

		        let keys = Object.keys(value);
		        const keyLength = keys.length;
		        if (keyLength === 0) {
		          return '{}'
		        }
		        if (maximumDepth < stack.length + 1) {
		          return '"[Object]"'
		        }
		        let whitespace = '';
		        let separator = '';
		        if (spacer !== '') {
		          indentation += spacer;
		          join = `,\n${indentation}`;
		          whitespace = ' ';
		        }
		        const maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
		        if (deterministic && !isTypedArrayWithEntries(value)) {
		          keys = sort(keys, comparator);
		        }
		        stack.push(value);
		        for (let i = 0; i < maximumPropertiesToStringify; i++) {
		          const key = keys[i];
		          const tmp = stringifyFnReplacer(key, value, stack, replacer, spacer, indentation);
		          if (tmp !== undefined) {
		            res += `${separator}${strEscape(key)}:${whitespace}${tmp}`;
		            separator = join;
		          }
		        }
		        if (keyLength > maximumBreadth) {
		          const removedKeys = keyLength - maximumBreadth;
		          res += `${separator}"...":${whitespace}"${getItemCount(removedKeys)} not stringified"`;
		          separator = join;
		        }
		        if (spacer !== '' && separator.length > 1) {
		          res = `\n${indentation}${res}\n${originalIndentation}`;
		        }
		        stack.pop();
		        return `{${res}}`
		      }
		      case 'number':
		        return isFinite(value) ? String(value) : fail ? fail(value) : 'null'
		      case 'boolean':
		        return value === true ? 'true' : 'false'
		      case 'undefined':
		        return undefined
		      case 'bigint':
		        if (bigint) {
		          return String(value)
		        }
		        // fallthrough
		      default:
		        return fail ? fail(value) : undefined
		    }
		  }

		  function stringifyArrayReplacer (key, value, stack, replacer, spacer, indentation) {
		    if (typeof value === 'object' && value !== null && typeof value.toJSON === 'function') {
		      value = value.toJSON(key);
		    }

		    switch (typeof value) {
		      case 'string':
		        return strEscape(value)
		      case 'object': {
		        if (value === null) {
		          return 'null'
		        }
		        if (stack.indexOf(value) !== -1) {
		          return circularValue
		        }

		        const originalIndentation = indentation;
		        let res = '';
		        let join = ',';

		        if (Array.isArray(value)) {
		          if (value.length === 0) {
		            return '[]'
		          }
		          if (maximumDepth < stack.length + 1) {
		            return '"[Array]"'
		          }
		          stack.push(value);
		          if (spacer !== '') {
		            indentation += spacer;
		            res += `\n${indentation}`;
		            join = `,\n${indentation}`;
		          }
		          const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
		          let i = 0;
		          for (; i < maximumValuesToStringify - 1; i++) {
		            const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
		            res += tmp !== undefined ? tmp : 'null';
		            res += join;
		          }
		          const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
		          res += tmp !== undefined ? tmp : 'null';
		          if (value.length - 1 > maximumBreadth) {
		            const removedKeys = value.length - maximumBreadth - 1;
		            res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
		          }
		          if (spacer !== '') {
		            res += `\n${originalIndentation}`;
		          }
		          stack.pop();
		          return `[${res}]`
		        }
		        stack.push(value);
		        let whitespace = '';
		        if (spacer !== '') {
		          indentation += spacer;
		          join = `,\n${indentation}`;
		          whitespace = ' ';
		        }
		        let separator = '';
		        for (const key of replacer) {
		          const tmp = stringifyArrayReplacer(key, value[key], stack, replacer, spacer, indentation);
		          if (tmp !== undefined) {
		            res += `${separator}${strEscape(key)}:${whitespace}${tmp}`;
		            separator = join;
		          }
		        }
		        if (spacer !== '' && separator.length > 1) {
		          res = `\n${indentation}${res}\n${originalIndentation}`;
		        }
		        stack.pop();
		        return `{${res}}`
		      }
		      case 'number':
		        return isFinite(value) ? String(value) : fail ? fail(value) : 'null'
		      case 'boolean':
		        return value === true ? 'true' : 'false'
		      case 'undefined':
		        return undefined
		      case 'bigint':
		        if (bigint) {
		          return String(value)
		        }
		        // fallthrough
		      default:
		        return fail ? fail(value) : undefined
		    }
		  }

		  function stringifyIndent (key, value, stack, spacer, indentation) {
		    switch (typeof value) {
		      case 'string':
		        return strEscape(value)
		      case 'object': {
		        if (value === null) {
		          return 'null'
		        }
		        if (typeof value.toJSON === 'function') {
		          value = value.toJSON(key);
		          // Prevent calling `toJSON` again.
		          if (typeof value !== 'object') {
		            return stringifyIndent(key, value, stack, spacer, indentation)
		          }
		          if (value === null) {
		            return 'null'
		          }
		        }
		        if (stack.indexOf(value) !== -1) {
		          return circularValue
		        }
		        const originalIndentation = indentation;

		        if (Array.isArray(value)) {
		          if (value.length === 0) {
		            return '[]'
		          }
		          if (maximumDepth < stack.length + 1) {
		            return '"[Array]"'
		          }
		          stack.push(value);
		          indentation += spacer;
		          let res = `\n${indentation}`;
		          const join = `,\n${indentation}`;
		          const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
		          let i = 0;
		          for (; i < maximumValuesToStringify - 1; i++) {
		            const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation);
		            res += tmp !== undefined ? tmp : 'null';
		            res += join;
		          }
		          const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation);
		          res += tmp !== undefined ? tmp : 'null';
		          if (value.length - 1 > maximumBreadth) {
		            const removedKeys = value.length - maximumBreadth - 1;
		            res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
		          }
		          res += `\n${originalIndentation}`;
		          stack.pop();
		          return `[${res}]`
		        }

		        let keys = Object.keys(value);
		        const keyLength = keys.length;
		        if (keyLength === 0) {
		          return '{}'
		        }
		        if (maximumDepth < stack.length + 1) {
		          return '"[Object]"'
		        }
		        indentation += spacer;
		        const join = `,\n${indentation}`;
		        let res = '';
		        let separator = '';
		        let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
		        if (isTypedArrayWithEntries(value)) {
		          res += stringifyTypedArray(value, join, maximumBreadth);
		          keys = keys.slice(value.length);
		          maximumPropertiesToStringify -= value.length;
		          separator = join;
		        }
		        if (deterministic) {
		          keys = sort(keys, comparator);
		        }
		        stack.push(value);
		        for (let i = 0; i < maximumPropertiesToStringify; i++) {
		          const key = keys[i];
		          const tmp = stringifyIndent(key, value[key], stack, spacer, indentation);
		          if (tmp !== undefined) {
		            res += `${separator}${strEscape(key)}: ${tmp}`;
		            separator = join;
		          }
		        }
		        if (keyLength > maximumBreadth) {
		          const removedKeys = keyLength - maximumBreadth;
		          res += `${separator}"...": "${getItemCount(removedKeys)} not stringified"`;
		          separator = join;
		        }
		        if (separator !== '') {
		          res = `\n${indentation}${res}\n${originalIndentation}`;
		        }
		        stack.pop();
		        return `{${res}}`
		      }
		      case 'number':
		        return isFinite(value) ? String(value) : fail ? fail(value) : 'null'
		      case 'boolean':
		        return value === true ? 'true' : 'false'
		      case 'undefined':
		        return undefined
		      case 'bigint':
		        if (bigint) {
		          return String(value)
		        }
		        // fallthrough
		      default:
		        return fail ? fail(value) : undefined
		    }
		  }

		  function stringifySimple (key, value, stack) {
		    switch (typeof value) {
		      case 'string':
		        return strEscape(value)
		      case 'object': {
		        if (value === null) {
		          return 'null'
		        }
		        if (typeof value.toJSON === 'function') {
		          value = value.toJSON(key);
		          // Prevent calling `toJSON` again
		          if (typeof value !== 'object') {
		            return stringifySimple(key, value, stack)
		          }
		          if (value === null) {
		            return 'null'
		          }
		        }
		        if (stack.indexOf(value) !== -1) {
		          return circularValue
		        }

		        let res = '';

		        const hasLength = value.length !== undefined;
		        if (hasLength && Array.isArray(value)) {
		          if (value.length === 0) {
		            return '[]'
		          }
		          if (maximumDepth < stack.length + 1) {
		            return '"[Array]"'
		          }
		          stack.push(value);
		          const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
		          let i = 0;
		          for (; i < maximumValuesToStringify - 1; i++) {
		            const tmp = stringifySimple(String(i), value[i], stack);
		            res += tmp !== undefined ? tmp : 'null';
		            res += ',';
		          }
		          const tmp = stringifySimple(String(i), value[i], stack);
		          res += tmp !== undefined ? tmp : 'null';
		          if (value.length - 1 > maximumBreadth) {
		            const removedKeys = value.length - maximumBreadth - 1;
		            res += `,"... ${getItemCount(removedKeys)} not stringified"`;
		          }
		          stack.pop();
		          return `[${res}]`
		        }

		        let keys = Object.keys(value);
		        const keyLength = keys.length;
		        if (keyLength === 0) {
		          return '{}'
		        }
		        if (maximumDepth < stack.length + 1) {
		          return '"[Object]"'
		        }
		        let separator = '';
		        let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
		        if (hasLength && isTypedArrayWithEntries(value)) {
		          res += stringifyTypedArray(value, ',', maximumBreadth);
		          keys = keys.slice(value.length);
		          maximumPropertiesToStringify -= value.length;
		          separator = ',';
		        }
		        if (deterministic) {
		          keys = sort(keys, comparator);
		        }
		        stack.push(value);
		        for (let i = 0; i < maximumPropertiesToStringify; i++) {
		          const key = keys[i];
		          const tmp = stringifySimple(key, value[key], stack);
		          if (tmp !== undefined) {
		            res += `${separator}${strEscape(key)}:${tmp}`;
		            separator = ',';
		          }
		        }
		        if (keyLength > maximumBreadth) {
		          const removedKeys = keyLength - maximumBreadth;
		          res += `${separator}"...":"${getItemCount(removedKeys)} not stringified"`;
		        }
		        stack.pop();
		        return `{${res}}`
		      }
		      case 'number':
		        return isFinite(value) ? String(value) : fail ? fail(value) : 'null'
		      case 'boolean':
		        return value === true ? 'true' : 'false'
		      case 'undefined':
		        return undefined
		      case 'bigint':
		        if (bigint) {
		          return String(value)
		        }
		        // fallthrough
		      default:
		        return fail ? fail(value) : undefined
		    }
		  }

		  function stringify (value, replacer, space) {
		    if (arguments.length > 1) {
		      let spacer = '';
		      if (typeof space === 'number') {
		        spacer = ' '.repeat(Math.min(space, 10));
		      } else if (typeof space === 'string') {
		        spacer = space.slice(0, 10);
		      }
		      if (replacer != null) {
		        if (typeof replacer === 'function') {
		          return stringifyFnReplacer('', { '': value }, [], replacer, spacer, '')
		        }
		        if (Array.isArray(replacer)) {
		          return stringifyArrayReplacer('', value, [], getUniqueReplacerSet(replacer), spacer, '')
		        }
		      }
		      if (spacer.length !== 0) {
		        return stringifyIndent('', value, [], spacer, '')
		      }
		    }
		    return stringifySimple('', value, [])
		  }

		  return stringify
		} 
	} (safeStableStringify, safeStableStringify.exports));
	return safeStableStringify.exports;
}

var multistream_1;
var hasRequiredMultistream;

function requireMultistream () {
	if (hasRequiredMultistream) return multistream_1;
	hasRequiredMultistream = 1;

	const metadata = Symbol.for('pino.metadata');
	const { DEFAULT_LEVELS } = requireConstants$1();

	const DEFAULT_INFO_LEVEL = DEFAULT_LEVELS.info;

	function multistream (streamsArray, opts) {
	  let counter = 0;
	  streamsArray = streamsArray || [];
	  opts = opts || { dedupe: false };

	  const streamLevels = Object.create(DEFAULT_LEVELS);
	  streamLevels.silent = Infinity;
	  if (opts.levels && typeof opts.levels === 'object') {
	    Object.keys(opts.levels).forEach(i => {
	      streamLevels[i] = opts.levels[i];
	    });
	  }

	  const res = {
	    write,
	    add,
	    emit,
	    flushSync,
	    end,
	    minLevel: 0,
	    streams: [],
	    clone,
	    [metadata]: true,
	    streamLevels
	  };

	  if (Array.isArray(streamsArray)) {
	    streamsArray.forEach(add, res);
	  } else {
	    add.call(res, streamsArray);
	  }

	  // clean this object up
	  // or it will stay allocated forever
	  // as it is closed on the following closures
	  streamsArray = null;

	  return res

	  // we can exit early because the streams are ordered by level
	  function write (data) {
	    let dest;
	    const level = this.lastLevel;
	    const { streams } = this;
	    // for handling situation when several streams has the same level
	    let recordedLevel = 0;
	    let stream;

	    // if dedupe set to true we send logs to the stream with the highest level
	    // therefore, we have to change sorting order
	    for (let i = initLoopVar(streams.length, opts.dedupe); checkLoopVar(i, streams.length, opts.dedupe); i = adjustLoopVar(i, opts.dedupe)) {
	      dest = streams[i];
	      if (dest.level <= level) {
	        if (recordedLevel !== 0 && recordedLevel !== dest.level) {
	          break
	        }
	        stream = dest.stream;
	        if (stream[metadata]) {
	          const { lastTime, lastMsg, lastObj, lastLogger } = this;
	          stream.lastLevel = level;
	          stream.lastTime = lastTime;
	          stream.lastMsg = lastMsg;
	          stream.lastObj = lastObj;
	          stream.lastLogger = lastLogger;
	        }
	        stream.write(data);
	        if (opts.dedupe) {
	          recordedLevel = dest.level;
	        }
	      } else if (!opts.dedupe) {
	        break
	      }
	    }
	  }

	  function emit (...args) {
	    for (const { stream } of this.streams) {
	      if (typeof stream.emit === 'function') {
	        stream.emit(...args);
	      }
	    }
	  }

	  function flushSync () {
	    for (const { stream } of this.streams) {
	      if (typeof stream.flushSync === 'function') {
	        stream.flushSync();
	      }
	    }
	  }

	  function add (dest) {
	    if (!dest) {
	      return res
	    }

	    // Check that dest implements either StreamEntry or DestinationStream
	    const isStream = typeof dest.write === 'function' || dest.stream;
	    const stream_ = dest.write ? dest : dest.stream;
	    // This is necessary to provide a meaningful error message, otherwise it throws somewhere inside write()
	    if (!isStream) {
	      throw Error('stream object needs to implement either StreamEntry or DestinationStream interface')
	    }

	    const { streams, streamLevels } = this;

	    let level;
	    if (typeof dest.levelVal === 'number') {
	      level = dest.levelVal;
	    } else if (typeof dest.level === 'string') {
	      level = streamLevels[dest.level];
	    } else if (typeof dest.level === 'number') {
	      level = dest.level;
	    } else {
	      level = DEFAULT_INFO_LEVEL;
	    }

	    const dest_ = {
	      stream: stream_,
	      level,
	      levelVal: undefined,
	      id: counter++
	    };

	    streams.unshift(dest_);
	    streams.sort(compareByLevel);

	    this.minLevel = streams[0].level;

	    return res
	  }

	  function end () {
	    for (const { stream } of this.streams) {
	      if (typeof stream.flushSync === 'function') {
	        stream.flushSync();
	      }
	      stream.end();
	    }
	  }

	  function clone (level) {
	    const streams = new Array(this.streams.length);

	    for (let i = 0; i < streams.length; i++) {
	      streams[i] = {
	        level,
	        stream: this.streams[i].stream
	      };
	    }

	    return {
	      write,
	      add,
	      minLevel: level,
	      streams,
	      clone,
	      emit,
	      flushSync,
	      [metadata]: true
	    }
	  }
	}

	function compareByLevel (a, b) {
	  return a.level - b.level
	}

	function initLoopVar (length, dedupe) {
	  return dedupe ? length - 1 : 0
	}

	function adjustLoopVar (i, dedupe) {
	  return dedupe ? i - 1 : i + 1
	}

	function checkLoopVar (i, length, dedupe) {
	  return dedupe ? i >= 0 : i < length
	}

	multistream_1 = multistream;
	return multistream_1;
}

var hasRequiredPino;

function requirePino () {
	if (hasRequiredPino) return pino.exports;
	hasRequiredPino = 1;

	const os = require$$0$5;
	const stdSerializers = requirePinoStdSerializers();
	const caller = requireCaller();
	const redaction = requireRedaction();
	const time = requireTime();
	const proto = requireProto();
	const symbols = requireSymbols();
	const { configure } = requireSafeStableStringify();
	const { assertDefaultLevelFound, mappings, genLsCache, genLevelComparison, assertLevelComparison } = requireLevels();
	const { DEFAULT_LEVELS, SORTING_ORDER } = requireConstants$1();
	const {
	  createArgsNormalizer,
	  asChindings,
	  buildSafeSonicBoom,
	  buildFormatters,
	  stringify,
	  normalizeDestFileDescriptor,
	  noop
	} = requireTools();
	const { version } = requireMeta();
	const {
	  chindingsSym,
	  redactFmtSym,
	  serializersSym,
	  timeSym,
	  timeSliceIndexSym,
	  streamSym,
	  stringifySym,
	  stringifySafeSym,
	  stringifiersSym,
	  setLevelSym,
	  endSym,
	  formatOptsSym,
	  messageKeySym,
	  errorKeySym,
	  nestedKeySym,
	  mixinSym,
	  levelCompSym,
	  useOnlyCustomLevelsSym,
	  formattersSym,
	  hooksSym,
	  nestedKeyStrSym,
	  mixinMergeStrategySym,
	  msgPrefixSym
	} = symbols;
	const { epochTime, nullTime } = time;
	const { pid } = process;
	const hostname = os.hostname();
	const defaultErrorSerializer = stdSerializers.err;
	const defaultOptions = {
	  level: 'info',
	  levelComparison: SORTING_ORDER.ASC,
	  levels: DEFAULT_LEVELS,
	  messageKey: 'msg',
	  errorKey: 'err',
	  nestedKey: null,
	  enabled: true,
	  base: { pid, hostname },
	  serializers: Object.assign(Object.create(null), {
	    err: defaultErrorSerializer
	  }),
	  formatters: Object.assign(Object.create(null), {
	    bindings (bindings) {
	      return bindings
	    },
	    level (label, number) {
	      return { level: number }
	    }
	  }),
	  hooks: {
	    logMethod: undefined,
	    streamWrite: undefined
	  },
	  timestamp: epochTime,
	  name: undefined,
	  redact: null,
	  customLevels: null,
	  useOnlyCustomLevels: false,
	  depthLimit: 5,
	  edgeLimit: 100
	};

	const normalize = createArgsNormalizer(defaultOptions);

	const serializers = Object.assign(Object.create(null), stdSerializers);

	function pino$1 (...args) {
	  const instance = {};
	  const { opts, stream } = normalize(instance, caller(), ...args);

	  if (opts.level && typeof opts.level === 'string' && DEFAULT_LEVELS[opts.level.toLowerCase()] !== undefined) opts.level = opts.level.toLowerCase();

	  const {
	    redact,
	    crlf,
	    serializers,
	    timestamp,
	    messageKey,
	    errorKey,
	    nestedKey,
	    base,
	    name,
	    level,
	    customLevels,
	    levelComparison,
	    mixin,
	    mixinMergeStrategy,
	    useOnlyCustomLevels,
	    formatters,
	    hooks,
	    depthLimit,
	    edgeLimit,
	    onChild,
	    msgPrefix
	  } = opts;

	  const stringifySafe = configure({
	    maximumDepth: depthLimit,
	    maximumBreadth: edgeLimit
	  });

	  const allFormatters = buildFormatters(
	    formatters.level,
	    formatters.bindings,
	    formatters.log
	  );

	  const stringifyFn = stringify.bind({
	    [stringifySafeSym]: stringifySafe
	  });
	  const stringifiers = redact ? redaction(redact, stringifyFn) : {};
	  const formatOpts = redact
	    ? { stringify: stringifiers[redactFmtSym] }
	    : { stringify: stringifyFn };
	  const end = '}' + (crlf ? '\r\n' : '\n');
	  const coreChindings = asChindings.bind(null, {
	    [chindingsSym]: '',
	    [serializersSym]: serializers,
	    [stringifiersSym]: stringifiers,
	    [stringifySym]: stringify,
	    [stringifySafeSym]: stringifySafe,
	    [formattersSym]: allFormatters
	  });

	  let chindings = '';
	  if (base !== null) {
	    if (name === undefined) {
	      chindings = coreChindings(base);
	    } else {
	      chindings = coreChindings(Object.assign({}, base, { name }));
	    }
	  }

	  const time = (timestamp instanceof Function)
	    ? timestamp
	    : (timestamp ? epochTime : nullTime);
	  const timeSliceIndex = time().indexOf(':') + 1;

	  if (useOnlyCustomLevels && !customLevels) throw Error('customLevels is required if useOnlyCustomLevels is set true')
	  if (mixin && typeof mixin !== 'function') throw Error(`Unknown mixin type "${typeof mixin}" - expected "function"`)
	  if (msgPrefix && typeof msgPrefix !== 'string') throw Error(`Unknown msgPrefix type "${typeof msgPrefix}" - expected "string"`)

	  assertDefaultLevelFound(level, customLevels, useOnlyCustomLevels);
	  const levels = mappings(customLevels, useOnlyCustomLevels);

	  if (typeof stream.emit === 'function') {
	    stream.emit('message', { code: 'PINO_CONFIG', config: { levels, messageKey, errorKey } });
	  }

	  assertLevelComparison(levelComparison);
	  const levelCompFunc = genLevelComparison(levelComparison);

	  Object.assign(instance, {
	    levels,
	    [levelCompSym]: levelCompFunc,
	    [useOnlyCustomLevelsSym]: useOnlyCustomLevels,
	    [streamSym]: stream,
	    [timeSym]: time,
	    [timeSliceIndexSym]: timeSliceIndex,
	    [stringifySym]: stringify,
	    [stringifySafeSym]: stringifySafe,
	    [stringifiersSym]: stringifiers,
	    [endSym]: end,
	    [formatOptsSym]: formatOpts,
	    [messageKeySym]: messageKey,
	    [errorKeySym]: errorKey,
	    [nestedKeySym]: nestedKey,
	    // protect against injection
	    [nestedKeyStrSym]: nestedKey ? `,${JSON.stringify(nestedKey)}:{` : '',
	    [serializersSym]: serializers,
	    [mixinSym]: mixin,
	    [mixinMergeStrategySym]: mixinMergeStrategy,
	    [chindingsSym]: chindings,
	    [formattersSym]: allFormatters,
	    [hooksSym]: hooks,
	    silent: noop,
	    onChild,
	    [msgPrefixSym]: msgPrefix
	  });

	  Object.setPrototypeOf(instance, proto());

	  genLsCache(instance);

	  instance[setLevelSym](level);

	  return instance
	}

	pino.exports = pino$1;

	pino.exports.destination = (dest = process.stdout.fd) => {
	  if (typeof dest === 'object') {
	    dest.dest = normalizeDestFileDescriptor(dest.dest || process.stdout.fd);
	    return buildSafeSonicBoom(dest)
	  } else {
	    return buildSafeSonicBoom({ dest: normalizeDestFileDescriptor(dest), minLength: 0 })
	  }
	};

	pino.exports.transport = requireTransport();
	pino.exports.multistream = requireMultistream();

	pino.exports.levels = mappings();
	pino.exports.stdSerializers = serializers;
	pino.exports.stdTimeFunctions = Object.assign({}, time);
	pino.exports.symbols = symbols;
	pino.exports.version = version;

	// Enables default and name export with TypeScript and Babel
	pino.exports.default = pino$1;
	pino.exports.pino = pino$1;
	return pino.exports;
}

var loggerPino;
var hasRequiredLoggerPino;

function requireLoggerPino () {
	if (hasRequiredLoggerPino) return loggerPino;
	hasRequiredLoggerPino = 1;

	/**
	 * Code imported from `pino-http`
	 * Repo: https://github.com/pinojs/pino-http
	 * License: MIT (https://raw.githubusercontent.com/pinojs/pino-http/master/LICENSE)
	 */

	const pino = requirePino();
	const { serializersSym } = pino.symbols;
	const {
	  FST_ERR_LOG_INVALID_DESTINATION
	} = requireErrors$2();

	function createPinoLogger (opts) {
	  if (opts.stream && opts.file) {
	    throw new FST_ERR_LOG_INVALID_DESTINATION()
	  } else if (opts.file) {
	    // we do not have stream
	    opts.stream = pino.destination(opts.file);
	    delete opts.file;
	  }

	  const prevLogger = opts.logger;
	  const prevGenReqId = opts.genReqId;
	  let logger = null;

	  if (prevLogger) {
	    opts.logger = undefined;
	    opts.genReqId = undefined;
	    // we need to tap into pino internals because in v5 it supports
	    // adding serializers in child loggers
	    if (prevLogger[serializersSym]) {
	      opts.serializers = Object.assign({}, opts.serializers, prevLogger[serializersSym]);
	    }
	    logger = prevLogger.child({}, opts);
	    opts.logger = prevLogger;
	    opts.genReqId = prevGenReqId;
	  } else {
	    logger = pino(opts, opts.stream);
	  }

	  return logger
	}

	const serializers = {
	  req: function asReqValue (req) {
	    return {
	      method: req.method,
	      url: req.url,
	      version: req.headers && req.headers['accept-version'],
	      host: req.host,
	      remoteAddress: req.ip,
	      remotePort: req.socket ? req.socket.remotePort : undefined
	    }
	  },
	  err: pino.stdSerializers.err,
	  res: function asResValue (reply) {
	    return {
	      statusCode: reply.statusCode
	    }
	  }
	};

	loggerPino = {
	  serializers,
	  createPinoLogger
	};
	return loggerPino;
}

var loggerFactory;
var hasRequiredLoggerFactory;

function requireLoggerFactory () {
	if (hasRequiredLoggerFactory) return loggerFactory;
	hasRequiredLoggerFactory = 1;

	const {
	  FST_ERR_LOG_LOGGER_AND_LOGGER_INSTANCE_PROVIDED,
	  FST_ERR_LOG_INVALID_LOGGER_CONFIG,
	  FST_ERR_LOG_INVALID_LOGGER_INSTANCE,
	  FST_ERR_LOG_INVALID_LOGGER
	} = requireErrors$2();

	/**
	 * Utility for creating a child logger with the appropriate bindings, logger factory
	 * and validation.
	 * @param {object} context
	 * @param {import('../fastify').FastifyBaseLogger} logger
	 * @param {import('../fastify').RawRequestDefaultExpression<any>} req
	 * @param {string} reqId
	 * @param {import('../types/logger.js').ChildLoggerOptions?} loggerOpts
	 *
	 * @returns {object} New logger instance, inheriting all parent bindings,
	 * with child bindings added.
	 */
	function createChildLogger (context, logger, req, reqId, loggerOpts) {
	  const loggerBindings = {
	    [context.requestIdLogLabel]: reqId
	  };
	  const child = context.childLoggerFactory.call(context.server, logger, loggerBindings, loggerOpts || {}, req);

	  // Optimization: bypass validation if the factory is our own default factory
	  if (context.childLoggerFactory !== defaultChildLoggerFactory) {
	    validateLogger(child, true); // throw if the child is not a valid logger
	  }

	  return child
	}

	/** Default factory to create child logger instance
	 *
	 * @param {import('../fastify.js').FastifyBaseLogger} logger
	 * @param {import('../types/logger.js').Bindings} bindings
	 * @param {import('../types/logger.js').ChildLoggerOptions} opts
	 *
	 * @returns {import('../types/logger.js').FastifyBaseLogger}
	 */
	function defaultChildLoggerFactory (logger, bindings, opts) {
	  return logger.child(bindings, opts)
	}

	/**
	 * Determines if a provided logger object meets the requirements
	 * of a Fastify compatible logger.
	 *
	 * @param {object} logger Object to validate.
	 * @param {boolean?} strict `true` if the object must be a logger (always throw if any methods missing)
	 *
	 * @returns {boolean} `true` when the logger meets the requirements.
	 *
	 * @throws {FST_ERR_LOG_INVALID_LOGGER} When the logger object is
	 * missing required methods.
	 */
	function validateLogger (logger, strict) {
	  const methods = ['info', 'error', 'debug', 'fatal', 'warn', 'trace', 'child'];
	  const missingMethods = logger
	    ? methods.filter(method => !logger[method] || typeof logger[method] !== 'function')
	    : methods;

	  if (!missingMethods.length) {
	    return true
	  } else if ((missingMethods.length === methods.length) && !strict) {
	    return false
	  } else {
	    throw FST_ERR_LOG_INVALID_LOGGER(missingMethods.join(','))
	  }
	}

	function createLogger (options) {
	  if (options.logger && options.loggerInstance) {
	    throw new FST_ERR_LOG_LOGGER_AND_LOGGER_INSTANCE_PROVIDED()
	  }

	  if (!options.loggerInstance && !options.logger) {
	    const nullLogger = requireAbstractLogging();
	    const logger = nullLogger;
	    logger.child = () => logger;
	    return { logger, hasLogger: false }
	  }

	  const { createPinoLogger, serializers } = requireLoggerPino();

	  // check if the logger instance has all required properties
	  if (validateLogger(options.loggerInstance)) {
	    const logger = createPinoLogger({
	      logger: options.loggerInstance,
	      serializers: Object.assign({}, serializers, options.loggerInstance.serializers)
	    });
	    return { logger, hasLogger: true }
	  }

	  // if a logger instance is passed to logger, throw an exception
	  if (validateLogger(options.logger)) {
	    throw FST_ERR_LOG_INVALID_LOGGER_CONFIG()
	  }

	  if (options.loggerInstance) {
	    throw FST_ERR_LOG_INVALID_LOGGER_INSTANCE()
	  }

	  const localLoggerOptions = {};
	  if (Object.prototype.toString.call(options.logger) === '[object Object]') {
	    Reflect.ownKeys(options.logger).forEach(prop => {
	      Object.defineProperty(localLoggerOptions, prop, {
	        value: options.logger[prop],
	        writable: true,
	        enumerable: true,
	        configurable: true
	      });
	    });
	  }
	  localLoggerOptions.level = localLoggerOptions.level || 'info';
	  localLoggerOptions.serializers = Object.assign({}, serializers, localLoggerOptions.serializers);
	  options.logger = localLoggerOptions;
	  const logger = createPinoLogger(options.logger);
	  return { logger, hasLogger: true }
	}

	function now () {
	  const ts = process.hrtime();
	  return (ts[0] * 1e3) + (ts[1] / 1e6)
	}

	loggerFactory = {
	  createChildLogger,
	  defaultChildLoggerFactory,
	  createLogger,
	  validateLogger,
	  now
	};
	return loggerFactory;
}

var rfdc_1;
var hasRequiredRfdc;

function requireRfdc () {
	if (hasRequiredRfdc) return rfdc_1;
	hasRequiredRfdc = 1;
	rfdc_1 = rfdc;

	function copyBuffer (cur) {
	  if (cur instanceof Buffer) {
	    return Buffer.from(cur)
	  }

	  return new cur.constructor(cur.buffer.slice(), cur.byteOffset, cur.length)
	}

	function rfdc (opts) {
	  opts = opts || {};
	  if (opts.circles) return rfdcCircles(opts)

	  const constructorHandlers = new Map();
	  constructorHandlers.set(Date, (o) => new Date(o));
	  constructorHandlers.set(Map, (o, fn) => new Map(cloneArray(Array.from(o), fn)));
	  constructorHandlers.set(Set, (o, fn) => new Set(cloneArray(Array.from(o), fn)));
	  if (opts.constructorHandlers) {
	    for (const handler of opts.constructorHandlers) {
	      constructorHandlers.set(handler[0], handler[1]);
	    }
	  }

	  let handler = null;

	  return opts.proto ? cloneProto : clone

	  function cloneArray (a, fn) {
	    const keys = Object.keys(a);
	    const a2 = new Array(keys.length);
	    for (let i = 0; i < keys.length; i++) {
	      const k = keys[i];
	      const cur = a[k];
	      if (typeof cur !== 'object' || cur === null) {
	        a2[k] = cur;
	      } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
	        a2[k] = handler(cur, fn);
	      } else if (ArrayBuffer.isView(cur)) {
	        a2[k] = copyBuffer(cur);
	      } else {
	        a2[k] = fn(cur);
	      }
	    }
	    return a2
	  }

	  function clone (o) {
	    if (typeof o !== 'object' || o === null) return o
	    if (Array.isArray(o)) return cloneArray(o, clone)
	    if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
	      return handler(o, clone)
	    }
	    const o2 = {};
	    for (const k in o) {
	      if (Object.hasOwnProperty.call(o, k) === false) continue
	      const cur = o[k];
	      if (typeof cur !== 'object' || cur === null) {
	        o2[k] = cur;
	      } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
	        o2[k] = handler(cur, clone);
	      } else if (ArrayBuffer.isView(cur)) {
	        o2[k] = copyBuffer(cur);
	      } else {
	        o2[k] = clone(cur);
	      }
	    }
	    return o2
	  }

	  function cloneProto (o) {
	    if (typeof o !== 'object' || o === null) return o
	    if (Array.isArray(o)) return cloneArray(o, cloneProto)
	    if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
	      return handler(o, cloneProto)
	    }
	    const o2 = {};
	    for (const k in o) {
	      const cur = o[k];
	      if (typeof cur !== 'object' || cur === null) {
	        o2[k] = cur;
	      } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
	        o2[k] = handler(cur, cloneProto);
	      } else if (ArrayBuffer.isView(cur)) {
	        o2[k] = copyBuffer(cur);
	      } else {
	        o2[k] = cloneProto(cur);
	      }
	    }
	    return o2
	  }
	}

	function rfdcCircles (opts) {
	  const refs = [];
	  const refsNew = [];

	  const constructorHandlers = new Map();
	  constructorHandlers.set(Date, (o) => new Date(o));
	  constructorHandlers.set(Map, (o, fn) => new Map(cloneArray(Array.from(o), fn)));
	  constructorHandlers.set(Set, (o, fn) => new Set(cloneArray(Array.from(o), fn)));
	  if (opts.constructorHandlers) {
	    for (const handler of opts.constructorHandlers) {
	      constructorHandlers.set(handler[0], handler[1]);
	    }
	  }

	  let handler = null;
	  return opts.proto ? cloneProto : clone

	  function cloneArray (a, fn) {
	    const keys = Object.keys(a);
	    const a2 = new Array(keys.length);
	    for (let i = 0; i < keys.length; i++) {
	      const k = keys[i];
	      const cur = a[k];
	      if (typeof cur !== 'object' || cur === null) {
	        a2[k] = cur;
	      } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
	        a2[k] = handler(cur, fn);
	      } else if (ArrayBuffer.isView(cur)) {
	        a2[k] = copyBuffer(cur);
	      } else {
	        const index = refs.indexOf(cur);
	        if (index !== -1) {
	          a2[k] = refsNew[index];
	        } else {
	          a2[k] = fn(cur);
	        }
	      }
	    }
	    return a2
	  }

	  function clone (o) {
	    if (typeof o !== 'object' || o === null) return o
	    if (Array.isArray(o)) return cloneArray(o, clone)
	    if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
	      return handler(o, clone)
	    }
	    const o2 = {};
	    refs.push(o);
	    refsNew.push(o2);
	    for (const k in o) {
	      if (Object.hasOwnProperty.call(o, k) === false) continue
	      const cur = o[k];
	      if (typeof cur !== 'object' || cur === null) {
	        o2[k] = cur;
	      } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
	        o2[k] = handler(cur, clone);
	      } else if (ArrayBuffer.isView(cur)) {
	        o2[k] = copyBuffer(cur);
	      } else {
	        const i = refs.indexOf(cur);
	        if (i !== -1) {
	          o2[k] = refsNew[i];
	        } else {
	          o2[k] = clone(cur);
	        }
	      }
	    }
	    refs.pop();
	    refsNew.pop();
	    return o2
	  }

	  function cloneProto (o) {
	    if (typeof o !== 'object' || o === null) return o
	    if (Array.isArray(o)) return cloneArray(o, cloneProto)
	    if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
	      return handler(o, cloneProto)
	    }
	    const o2 = {};
	    refs.push(o);
	    refsNew.push(o2);
	    for (const k in o) {
	      const cur = o[k];
	      if (typeof cur !== 'object' || cur === null) {
	        o2[k] = cur;
	      } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
	        o2[k] = handler(cur, cloneProto);
	      } else if (ArrayBuffer.isView(cur)) {
	        o2[k] = copyBuffer(cur);
	      } else {
	        const i = refs.indexOf(cur);
	        if (i !== -1) {
	          o2[k] = refsNew[i];
	        } else {
	          o2[k] = cloneProto(cur);
	        }
	      }
	    }
	    refs.pop();
	    refsNew.pop();
	    return o2
	  }
	}
	return rfdc_1;
}

var schemas;
var hasRequiredSchemas;

function requireSchemas () {
	if (hasRequiredSchemas) return schemas;
	hasRequiredSchemas = 1;

	const fastClone = requireRfdc()({ circles: false, proto: true });
	const { kSchemaVisited, kSchemaResponse } = requireSymbols$1();
	const kFluentSchema = Symbol.for('fluent-schema-object');

	const {
	  FST_ERR_SCH_MISSING_ID,
	  FST_ERR_SCH_ALREADY_PRESENT,
	  FST_ERR_SCH_DUPLICATE,
	  FST_ERR_SCH_CONTENT_MISSING_SCHEMA
	} = requireErrors$2();

	const SCHEMAS_SOURCE = ['params', 'body', 'querystring', 'query', 'headers'];

	function Schemas (initStore) {
	  this.store = initStore || {};
	}

	Schemas.prototype.add = function (inputSchema) {
	  const schema = fastClone((inputSchema.isFluentSchema || inputSchema.isFluentJSONSchema || inputSchema[kFluentSchema])
	    ? inputSchema.valueOf()
	    : inputSchema
	  );

	  // developers can add schemas without $id, but with $def instead
	  const id = schema.$id;
	  if (!id) {
	    throw new FST_ERR_SCH_MISSING_ID()
	  }

	  if (this.store[id]) {
	    throw new FST_ERR_SCH_ALREADY_PRESENT(id)
	  }

	  this.store[id] = schema;
	};

	Schemas.prototype.getSchemas = function () {
	  return Object.assign({}, this.store)
	};

	Schemas.prototype.getSchema = function (schemaId) {
	  return this.store[schemaId]
	};

	/**
	 * Checks whether a schema is a non-plain object.
	 *
	 * @param {*} schema the schema to check
	 * @returns {boolean} true if schema has a custom prototype
	 */
	function isCustomSchemaPrototype (schema) {
	  return typeof schema === 'object' && Object.getPrototypeOf(schema) !== Object.prototype
	}

	function normalizeSchema (routeSchemas, serverOptions) {
	  if (routeSchemas[kSchemaVisited]) {
	    return routeSchemas
	  }

	  // alias query to querystring schema
	  if (routeSchemas.query) {
	    // check if our schema has both querystring and query
	    if (routeSchemas.querystring) {
	      throw new FST_ERR_SCH_DUPLICATE('querystring')
	    }
	    routeSchemas.querystring = routeSchemas.query;
	  }

	  generateFluentSchema(routeSchemas);

	  for (const key of SCHEMAS_SOURCE) {
	    const schema = routeSchemas[key];
	    if (schema && !isCustomSchemaPrototype(schema)) {
	      if (key === 'body' && schema.content) {
	        const contentProperty = schema.content;
	        const keys = Object.keys(contentProperty);
	        for (let i = 0; i < keys.length; i++) {
	          const contentType = keys[i];
	          const contentSchema = contentProperty[contentType].schema;
	          if (!contentSchema) {
	            throw new FST_ERR_SCH_CONTENT_MISSING_SCHEMA(contentType)
	          }
	        }
	        continue
	      }
	    }
	  }

	  if (routeSchemas.response) {
	    const httpCodes = Object.keys(routeSchemas.response);
	    for (const code of httpCodes) {
	      if (isCustomSchemaPrototype(routeSchemas.response[code])) {
	        continue
	      }

	      const contentProperty = routeSchemas.response[code].content;

	      if (contentProperty) {
	        const keys = Object.keys(contentProperty);
	        for (let i = 0; i < keys.length; i++) {
	          const mediaName = keys[i];
	          if (!contentProperty[mediaName].schema) {
	            throw new FST_ERR_SCH_CONTENT_MISSING_SCHEMA(mediaName)
	          }
	        }
	      }
	    }
	  }

	  routeSchemas[kSchemaVisited] = true;
	  return routeSchemas
	}

	function generateFluentSchema (schema) {
	  for (const key of SCHEMAS_SOURCE) {
	    if (schema[key] && (schema[key].isFluentSchema || schema[key][kFluentSchema])) {
	      schema[key] = schema[key].valueOf();
	    }
	  }

	  if (schema.response) {
	    const httpCodes = Object.keys(schema.response);
	    for (const code of httpCodes) {
	      if (schema.response[code].isFluentSchema || schema.response[code][kFluentSchema]) {
	        schema.response[code] = schema.response[code].valueOf();
	      }
	    }
	  }
	}

	/**
	 * Search for the right JSON schema compiled function in the request context
	 * setup by the route configuration `schema.response`.
	 * It will look for the exact match (eg 200) or generic (eg 2xx)
	 *
	 * @param {object} context the request context
	 * @param {number} statusCode the http status code
	 * @param {string} [contentType] the reply content type
	 * @returns {function|false} the right JSON Schema function to serialize
	 * the reply or false if it is not set
	 */
	function getSchemaSerializer (context, statusCode, contentType) {
	  const responseSchemaDef = context[kSchemaResponse];
	  if (!responseSchemaDef) {
	    return false
	  }
	  if (responseSchemaDef[statusCode]) {
	    if (responseSchemaDef[statusCode].constructor === Object && contentType) {
	      const mediaName = contentType.split(';', 1)[0];
	      if (responseSchemaDef[statusCode][mediaName]) {
	        return responseSchemaDef[statusCode][mediaName]
	      }

	      // fallback to match all media-type
	      if (responseSchemaDef[statusCode]['*/*']) {
	        return responseSchemaDef[statusCode]['*/*']
	      }

	      return false
	    }
	    return responseSchemaDef[statusCode]
	  }
	  const fallbackStatusCode = (statusCode + '')[0] + 'xx';
	  if (responseSchemaDef[fallbackStatusCode]) {
	    if (responseSchemaDef[fallbackStatusCode].constructor === Object && contentType) {
	      const mediaName = contentType.split(';', 1)[0];
	      if (responseSchemaDef[fallbackStatusCode][mediaName]) {
	        return responseSchemaDef[fallbackStatusCode][mediaName]
	      }

	      // fallback to match all media-type
	      if (responseSchemaDef[fallbackStatusCode]['*/*']) {
	        return responseSchemaDef[fallbackStatusCode]['*/*']
	      }

	      return false
	    }

	    return responseSchemaDef[fallbackStatusCode]
	  }
	  if (responseSchemaDef.default) {
	    if (responseSchemaDef.default.constructor === Object && contentType) {
	      const mediaName = contentType.split(';', 1)[0];
	      if (responseSchemaDef.default[mediaName]) {
	        return responseSchemaDef.default[mediaName]
	      }

	      // fallback to match all media-type
	      if (responseSchemaDef.default['*/*']) {
	        return responseSchemaDef.default['*/*']
	      }

	      return false
	    }

	    return responseSchemaDef.default
	  }
	  return false
	}

	schemas = {
	  buildSchemas (initStore) { return new Schemas(initStore) },
	  getSchemaSerializer,
	  normalizeSchema
	};
	return schemas;
}

var serializer;
var hasRequiredSerializer;

function requireSerializer () {
	if (hasRequiredSerializer) return serializer;
	hasRequiredSerializer = 1;

	// eslint-disable-next-line
	const STR_ESCAPE = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/;

	serializer = class Serializer {
	  constructor (options) {
	    switch (options && options.rounding) {
	      case 'floor':
	        this.parseInteger = Math.floor;
	        break
	      case 'ceil':
	        this.parseInteger = Math.ceil;
	        break
	      case 'round':
	        this.parseInteger = Math.round;
	        break
	      case 'trunc':
	      default:
	        this.parseInteger = Math.trunc;
	        break
	    }
	    this._options = options;
	  }

	  asInteger (i) {
	    if (Number.isInteger(i)) {
	      return '' + i
	    } else if (typeof i === 'bigint') {
	      return i.toString()
	    }
	    /* eslint no-undef: "off" */
	    const integer = this.parseInteger(i);
	    // check if number is Infinity or NaN
	    // eslint-disable-next-line no-self-compare
	    if (integer === Infinity || integer === -Infinity || integer !== integer) {
	      throw new Error(`The value "${i}" cannot be converted to an integer.`)
	    }
	    return '' + integer
	  }

	  asNumber (i) {
	    // fast cast to number
	    const num = Number(i);
	    // check if number is NaN
	    // eslint-disable-next-line no-self-compare
	    if (num !== num) {
	      throw new Error(`The value "${i}" cannot be converted to a number.`)
	    } else if (num === Infinity || num === -Infinity) {
	      return 'null'
	    } else {
	      return '' + num
	    }
	  }

	  asBoolean (bool) {
	    return bool && 'true' || 'false' // eslint-disable-line
	  }

	  asDateTime (date) {
	    if (date === null) return '""'
	    if (date instanceof Date) {
	      return '"' + date.toISOString() + '"'
	    }
	    if (typeof date === 'string') {
	      return '"' + date + '"'
	    }
	    throw new Error(`The value "${date}" cannot be converted to a date-time.`)
	  }

	  asDate (date) {
	    if (date === null) return '""'
	    if (date instanceof Date) {
	      return '"' + new Date(date.getTime() - (date.getTimezoneOffset() * 60000)).toISOString().slice(0, 10) + '"'
	    }
	    if (typeof date === 'string') {
	      return '"' + date + '"'
	    }
	    throw new Error(`The value "${date}" cannot be converted to a date.`)
	  }

	  asTime (date) {
	    if (date === null) return '""'
	    if (date instanceof Date) {
	      return '"' + new Date(date.getTime() - (date.getTimezoneOffset() * 60000)).toISOString().slice(11, 19) + '"'
	    }
	    if (typeof date === 'string') {
	      return '"' + date + '"'
	    }
	    throw new Error(`The value "${date}" cannot be converted to a time.`)
	  }

	  asString (str) {
	    const len = str.length;
	    if (len < 42) {
	      // magically escape strings for json
	      // relying on their charCodeAt
	      // everything below 32 needs JSON.stringify()
	      // every string that contain surrogate needs JSON.stringify()
	      // 34 and 92 happens all the time, so we
	      // have a fast case for them
	      let result = '';
	      let last = -1;
	      let point = 255;
	      for (let i = 0; i < len; i++) {
	        point = str.charCodeAt(i);
	        if (
	          point === 0x22 || // '"'
	          point === 0x5c // '\'
	        ) {
	          last === -1 && (last = 0);
	          result += str.slice(last, i) + '\\';
	          last = i;
	        } else if (point < 32 || (point >= 0xD800 && point <= 0xDFFF)) {
	          // The current character is non-printable characters or a surrogate.
	          return JSON.stringify(str)
	        }
	      }
	      return (last === -1 && ('"' + str + '"')) || ('"' + result + str.slice(last) + '"')
	    } else if (len < 5000 && STR_ESCAPE.test(str) === false) {
	      // Only use the regular expression for shorter input. The overhead is otherwise too much.
	      return '"' + str + '"'
	    } else {
	      return JSON.stringify(str)
	    }
	  }

	  asUnsafeString (str) {
	    return '"' + str + '"'
	  }

	  getState () {
	    return this._options
	  }

	  static restoreFromState (state) {
	    return new Serializer(state)
	  }
	};
	return serializer;
}

var errorSerializer;
var hasRequiredErrorSerializer;

function requireErrorSerializer () {
	if (hasRequiredErrorSerializer) return errorSerializer;
	hasRequiredErrorSerializer = 1;

	  const Serializer = requireSerializer();
	  const serializerState = {"mode":"standalone"};
	  const serializer = Serializer.restoreFromState(serializerState);

	  const validator = null;


	  errorSerializer = function anonymous(validator,serializer
	) {

	    const JSON_STR_BEGIN_OBJECT = '{';
	    const JSON_STR_END_OBJECT = '}';
	    const JSON_STR_COMMA = ',';
	    const JSON_STR_QUOTE = '"';
	    const JSON_STR_EMPTY_OBJECT = JSON_STR_BEGIN_OBJECT + JSON_STR_END_OBJECT;
	    const JSON_STR_EMPTY_STRING = JSON_STR_QUOTE + JSON_STR_QUOTE;
	  
	    
	  
	    // #
	    function anonymous0 (input) {
	      const obj = (input && typeof input.toJSON === 'function')
	    ? input.toJSON()
	    : input;
	  
	      if (obj === null) return JSON_STR_EMPTY_OBJECT

	      let value;
	let json = JSON_STR_BEGIN_OBJECT;
	let addComma = false;

	      value = obj["statusCode"];
	      if (value !== undefined) {
	        !addComma && (addComma = true) || (json += JSON_STR_COMMA);
	        json += "\"statusCode\":";
	        json += serializer.asNumber(value);
	      }

	      value = obj["code"];
	      if (value !== undefined) {
	        !addComma && (addComma = true) || (json += JSON_STR_COMMA);
	        json += "\"code\":";
	        
	        if (typeof value !== 'string') {
	          if (value === null) {
	            json += JSON_STR_EMPTY_STRING;
	          } else if (value instanceof Date) {
	            json += JSON_STR_QUOTE + value.toISOString() + JSON_STR_QUOTE;
	          } else if (value instanceof RegExp) {
	            json += serializer.asString(value.source);
	          } else {
	            json += serializer.asString(value.toString());
	          }
	        } else {
	          json += serializer.asString(value);
	        }
	        
	      }

	      value = obj["error"];
	      if (value !== undefined) {
	        !addComma && (addComma = true) || (json += JSON_STR_COMMA);
	        json += "\"error\":";
	        
	        if (typeof value !== 'string') {
	          if (value === null) {
	            json += JSON_STR_EMPTY_STRING;
	          } else if (value instanceof Date) {
	            json += JSON_STR_QUOTE + value.toISOString() + JSON_STR_QUOTE;
	          } else if (value instanceof RegExp) {
	            json += serializer.asString(value.source);
	          } else {
	            json += serializer.asString(value.toString());
	          }
	        } else {
	          json += serializer.asString(value);
	        }
	        
	      }

	      value = obj["message"];
	      if (value !== undefined) {
	        !addComma && (addComma = true) || (json += JSON_STR_COMMA);
	        json += "\"message\":";
	        
	        if (typeof value !== 'string') {
	          if (value === null) {
	            json += JSON_STR_EMPTY_STRING;
	          } else if (value instanceof Date) {
	            json += JSON_STR_QUOTE + value.toISOString() + JSON_STR_QUOTE;
	          } else if (value instanceof RegExp) {
	            json += serializer.asString(value.source);
	          } else {
	            json += serializer.asString(value.toString());
	          }
	        } else {
	          json += serializer.asString(value);
	        }
	        
	      }

	    return json + JSON_STR_END_OBJECT
	  
	    }
	  
	    const main = anonymous0;
	    return main
	    
	}(validator, serializer);
	/* c8 ignore stop */
	return errorSerializer;
}

var errorHandler;
var hasRequiredErrorHandler;

function requireErrorHandler () {
	if (hasRequiredErrorHandler) return errorHandler;
	hasRequiredErrorHandler = 1;

	const statusCodes = require$$0$4.STATUS_CODES;
	const wrapThenable = requireWrapThenable();
	const {
	  kReplyHeaders,
	  kReplyNextErrorHandler,
	  kReplyIsRunningOnErrorHook,
	  kReplyHasStatusCode,
	  kRouteContext,
	  kDisableRequestLogging
	} = requireSymbols$1();

	const {
	  FST_ERR_REP_INVALID_PAYLOAD_TYPE,
	  FST_ERR_FAILED_ERROR_SERIALIZATION
	} = requireErrors$2();

	const { getSchemaSerializer } = requireSchemas();

	const serializeError = requireErrorSerializer();

	const rootErrorHandler = {
	  func: defaultErrorHandler,
	  toJSON () {
	    return this.func.name.toString() + '()'
	  }
	};

	function handleError (reply, error, cb) {
	  reply[kReplyIsRunningOnErrorHook] = false;

	  const context = reply[kRouteContext];
	  if (reply[kReplyNextErrorHandler] === false) {
	    fallbackErrorHandler(error, reply, function (reply, payload) {
	      try {
	        reply.raw.writeHead(reply.raw.statusCode, reply[kReplyHeaders]);
	      } catch (error) {
	        if (!reply.log[kDisableRequestLogging]) {
	          reply.log.warn(
	            { req: reply.request, res: reply, err: error },
	            error && error.message
	          );
	        }
	        reply.raw.writeHead(reply.raw.statusCode);
	      }
	      reply.raw.end(payload);
	    });
	    return
	  }
	  const errorHandler = reply[kReplyNextErrorHandler] || context.errorHandler;

	  // In case the error handler throws, we set the next errorHandler so we can error again
	  reply[kReplyNextErrorHandler] = Object.getPrototypeOf(errorHandler);

	  // we need to remove content-type to allow content-type guessing for serialization
	  delete reply[kReplyHeaders]['content-type'];
	  delete reply[kReplyHeaders]['content-length'];

	  const func = errorHandler.func;

	  if (!func) {
	    reply[kReplyNextErrorHandler] = false;
	    fallbackErrorHandler(error, reply, cb);
	    return
	  }

	  try {
	    const result = func(error, reply.request, reply);
	    if (result !== undefined) {
	      if (result !== null && typeof result.then === 'function') {
	        wrapThenable(result, reply);
	      } else {
	        reply.send(result);
	      }
	    }
	  } catch (err) {
	    reply.send(err);
	  }
	}

	function defaultErrorHandler (error, request, reply) {
	  setErrorHeaders(error, reply);
	  if (!reply[kReplyHasStatusCode] || reply.statusCode === 200) {
	    const statusCode = error.statusCode || error.status;
	    reply.code(statusCode >= 400 ? statusCode : 500);
	  }
	  if (reply.statusCode < 500) {
	    if (!reply.log[kDisableRequestLogging]) {
	      reply.log.info(
	        { res: reply, err: error },
	        error && error.message
	      );
	    }
	  } else {
	    if (!reply.log[kDisableRequestLogging]) {
	      reply.log.error(
	        { req: request, res: reply, err: error },
	        error && error.message
	      );
	    }
	  }
	  reply.send(error);
	}

	function fallbackErrorHandler (error, reply, cb) {
	  const res = reply.raw;
	  const statusCode = reply.statusCode;
	  reply[kReplyHeaders]['content-type'] = reply[kReplyHeaders]['content-type'] ?? 'application/json; charset=utf-8';
	  let payload;
	  try {
	    const serializerFn = getSchemaSerializer(reply[kRouteContext], statusCode, reply[kReplyHeaders]['content-type']);
	    if (serializerFn === false) {
	      payload = serializeError({
	        error: statusCodes[statusCode + ''],
	        code: error.code,
	        message: error.message,
	        statusCode
	      });
	    } else {
	      payload = serializerFn(Object.create(error, {
	        error: { value: statusCodes[statusCode + ''] },
	        message: { value: error.message },
	        statusCode: { value: statusCode }
	      }));
	    }
	  } catch (err) {
	    if (!reply.log[kDisableRequestLogging]) {
	      // error is always FST_ERR_SCH_SERIALIZATION_BUILD because this is called from route/compileSchemasForSerialization
	      reply.log.error({ err, statusCode: res.statusCode }, 'The serializer for the given status code failed');
	    }
	    reply.code(500);
	    payload = serializeError(new FST_ERR_FAILED_ERROR_SERIALIZATION(err.message, error.message));
	  }

	  if (typeof payload !== 'string' && !Buffer.isBuffer(payload)) {
	    payload = serializeError(new FST_ERR_REP_INVALID_PAYLOAD_TYPE(typeof payload));
	  }

	  reply[kReplyHeaders]['content-length'] = '' + Buffer.byteLength(payload);

	  cb(reply, payload);
	}

	function buildErrorHandler (parent = rootErrorHandler, func) {
	  if (!func) {
	    return parent
	  }

	  const errorHandler = Object.create(parent);
	  errorHandler.func = func;
	  return errorHandler
	}

	function setErrorHeaders (error, reply) {
	  const res = reply.raw;
	  let statusCode = res.statusCode;
	  statusCode = (statusCode >= 400) ? statusCode : 500;
	  // treat undefined and null as same
	  if (error != null) {
	    if (error.headers !== undefined) {
	      reply.headers(error.headers);
	    }
	    if (error.status >= 400) {
	      statusCode = error.status;
	    } else if (error.statusCode >= 400) {
	      statusCode = error.statusCode;
	    }
	  }
	  res.statusCode = statusCode;
	}

	errorHandler = {
	  buildErrorHandler,
	  handleError
	};
	return errorHandler;
}

var decorate_1;
var hasRequiredDecorate;

function requireDecorate () {
	if (hasRequiredDecorate) return decorate_1;
	hasRequiredDecorate = 1;

	const {
	  kReply,
	  kRequest,
	  kState,
	  kHasBeenDecorated
	} = requireSymbols$1();

	const {
	  FST_ERR_DEC_ALREADY_PRESENT,
	  FST_ERR_DEC_MISSING_DEPENDENCY,
	  FST_ERR_DEC_AFTER_START,
	  FST_ERR_DEC_REFERENCE_TYPE,
	  FST_ERR_DEC_DEPENDENCY_INVALID_TYPE,
	  FST_ERR_DEC_UNDECLARED
	} = requireErrors$2();

	function decorate (instance, name, fn, dependencies) {
	  if (Object.hasOwn(instance, name)) {
	    throw new FST_ERR_DEC_ALREADY_PRESENT(name)
	  }

	  checkDependencies(instance, name, dependencies);

	  if (fn && (typeof fn.getter === 'function' || typeof fn.setter === 'function')) {
	    Object.defineProperty(instance, name, {
	      get: fn.getter,
	      set: fn.setter
	    });
	  } else {
	    instance[name] = fn;
	  }
	}

	function getInstanceDecorator (name) {
	  if (!checkExistence(this, name)) {
	    throw new FST_ERR_DEC_UNDECLARED(name, 'instance')
	  }

	  if (typeof this[name] === 'function') {
	    return this[name].bind(this)
	  }

	  return this[name]
	}

	function decorateConstructor (konstructor, name, fn, dependencies) {
	  const instance = konstructor.prototype;
	  if (Object.hasOwn(instance, name) || hasKey(konstructor, name)) {
	    throw new FST_ERR_DEC_ALREADY_PRESENT(name)
	  }

	  konstructor[kHasBeenDecorated] = true;
	  checkDependencies(konstructor, name, dependencies);

	  if (fn && (typeof fn.getter === 'function' || typeof fn.setter === 'function')) {
	    Object.defineProperty(instance, name, {
	      get: fn.getter,
	      set: fn.setter
	    });
	  } else if (typeof fn === 'function') {
	    instance[name] = fn;
	  } else {
	    konstructor.props.push({ key: name, value: fn });
	  }
	}

	function checkReferenceType (name, fn) {
	  if (typeof fn === 'object' && fn && !(typeof fn.getter === 'function' || typeof fn.setter === 'function')) {
	    throw new FST_ERR_DEC_REFERENCE_TYPE(name, typeof fn)
	  }
	}

	function decorateFastify (name, fn, dependencies) {
	  assertNotStarted(this, name);
	  decorate(this, name, fn, dependencies);
	  return this
	}

	function checkExistence (instance, name) {
	  if (name) {
	    return name in instance || (instance.prototype && name in instance.prototype) || hasKey(instance, name)
	  }

	  return instance in this
	}

	function hasKey (fn, name) {
	  if (fn.props) {
	    return fn.props.find(({ key }) => key === name)
	  }
	  return false
	}

	function checkRequestExistence (name) {
	  if (name && hasKey(this[kRequest], name)) return true
	  return checkExistence(this[kRequest].prototype, name)
	}

	function checkReplyExistence (name) {
	  if (name && hasKey(this[kReply], name)) return true
	  return checkExistence(this[kReply].prototype, name)
	}

	function checkDependencies (instance, name, deps) {
	  if (deps === undefined || deps === null) {
	    return
	  }

	  if (!Array.isArray(deps)) {
	    throw new FST_ERR_DEC_DEPENDENCY_INVALID_TYPE(name)
	  }

	  for (let i = 0; i !== deps.length; ++i) {
	    if (!checkExistence(instance, deps[i])) {
	      throw new FST_ERR_DEC_MISSING_DEPENDENCY(deps[i])
	    }
	  }
	}

	function decorateReply (name, fn, dependencies) {
	  assertNotStarted(this, name);
	  checkReferenceType(name, fn);
	  decorateConstructor(this[kReply], name, fn, dependencies);
	  return this
	}

	function decorateRequest (name, fn, dependencies) {
	  assertNotStarted(this, name);
	  checkReferenceType(name, fn);
	  decorateConstructor(this[kRequest], name, fn, dependencies);
	  return this
	}

	function assertNotStarted (instance, name) {
	  if (instance[kState].started) {
	    throw new FST_ERR_DEC_AFTER_START(name)
	  }
	}

	decorate_1 = {
	  add: decorateFastify,
	  exist: checkExistence,
	  existRequest: checkRequestExistence,
	  existReply: checkReplyExistence,
	  dependencies: checkDependencies,
	  decorateReply,
	  decorateRequest,
	  getInstanceDecorator,
	  hasKey
	};
	return decorate_1;
}

var hasRequiredReply;

function requireReply () {
	if (hasRequiredReply) return reply.exports;
	hasRequiredReply = 1;

	const eos = require$$0$7.finished;
	const Readable = require$$0$7.Readable;

	const {
	  kFourOhFourContext,
	  kReplyErrorHandlerCalled,
	  kReplyHijacked,
	  kReplyStartTime,
	  kReplyEndTime,
	  kReplySerializer,
	  kReplySerializerDefault,
	  kReplyIsError,
	  kReplyHeaders,
	  kReplyTrailers,
	  kReplyHasStatusCode,
	  kReplyIsRunningOnErrorHook,
	  kReplyNextErrorHandler,
	  kDisableRequestLogging,
	  kSchemaResponse,
	  kReplyCacheSerializeFns,
	  kSchemaController,
	  kOptions,
	  kRouteContext
	} = requireSymbols$1();
	const {
	  onSendHookRunner,
	  onResponseHookRunner,
	  preHandlerHookRunner,
	  preSerializationHookRunner
	} = requireHooks();

	const internals = requireHandleRequest()[Symbol.for('internals')];
	const loggerUtils = requireLoggerFactory();
	const now = loggerUtils.now;
	const { handleError } = requireErrorHandler();
	const { getSchemaSerializer } = requireSchemas();

	const CONTENT_TYPE = {
	  JSON: 'application/json; charset=utf-8',
	  PLAIN: 'text/plain; charset=utf-8',
	  OCTET: 'application/octet-stream'
	};
	const {
	  FST_ERR_REP_INVALID_PAYLOAD_TYPE,
	  FST_ERR_REP_RESPONSE_BODY_CONSUMED,
	  FST_ERR_REP_READABLE_STREAM_LOCKED,
	  FST_ERR_REP_ALREADY_SENT,
	  FST_ERR_SEND_INSIDE_ONERR,
	  FST_ERR_BAD_STATUS_CODE,
	  FST_ERR_BAD_TRAILER_NAME,
	  FST_ERR_BAD_TRAILER_VALUE,
	  FST_ERR_MISSING_SERIALIZATION_FN,
	  FST_ERR_MISSING_CONTENTTYPE_SERIALIZATION_FN,
	  FST_ERR_DEC_UNDECLARED
	} = requireErrors$2();
	const decorators = requireDecorate();

	const toString = Object.prototype.toString;

	function Reply (res, request, log) {
	  this.raw = res;
	  this[kReplySerializer] = null;
	  this[kReplyErrorHandlerCalled] = false;
	  this[kReplyIsError] = false;
	  this[kReplyIsRunningOnErrorHook] = false;
	  this.request = request;
	  this[kReplyHeaders] = {};
	  this[kReplyTrailers] = null;
	  this[kReplyHasStatusCode] = false;
	  this[kReplyStartTime] = undefined;
	  this.log = log;
	}
	Reply.props = [];

	Object.defineProperties(Reply.prototype, {
	  [kRouteContext]: {
	    get () {
	      return this.request[kRouteContext]
	    }
	  },
	  elapsedTime: {
	    get () {
	      if (this[kReplyStartTime] === undefined) {
	        return 0
	      }
	      return (this[kReplyEndTime] || now()) - this[kReplyStartTime]
	    }
	  },
	  server: {
	    get () {
	      return this.request[kRouteContext].server
	    }
	  },
	  sent: {
	    enumerable: true,
	    get () {
	      // We are checking whether reply was hijacked or the response has ended.
	      return (this[kReplyHijacked] || this.raw.writableEnded) === true
	    }
	  },
	  statusCode: {
	    get () {
	      return this.raw.statusCode
	    },
	    set (value) {
	      this.code(value);
	    }
	  },
	  routeOptions: {
	    get () {
	      return this.request.routeOptions
	    }
	  }
	});

	Reply.prototype.writeEarlyHints = function (hints, callback) {
	  this.raw.writeEarlyHints(hints, callback);
	  return this
	};

	Reply.prototype.hijack = function () {
	  this[kReplyHijacked] = true;
	  return this
	};

	Reply.prototype.send = function (payload) {
	  if (this[kReplyIsRunningOnErrorHook] === true) {
	    throw new FST_ERR_SEND_INSIDE_ONERR()
	  }

	  if (this.sent) {
	    this.log.warn({ err: new FST_ERR_REP_ALREADY_SENT(this.request.url, this.request.method) });
	    return this
	  }

	  if (payload instanceof Error || this[kReplyIsError] === true) {
	    this[kReplyIsError] = false;
	    onErrorHook(this, payload, onSendHook);
	    return this
	  }

	  if (payload === undefined) {
	    onSendHook(this, payload);
	    return this
	  }

	  const contentType = this.getHeader('content-type');
	  const hasContentType = contentType !== undefined;

	  if (payload !== null) {
	    if (
	      // node:stream
	      typeof payload.pipe === 'function' ||
	      // node:stream/web
	      typeof payload.getReader === 'function' ||
	      // Response
	      toString.call(payload) === '[object Response]'
	    ) {
	      onSendHook(this, payload);
	      return this
	    }

	    if (payload?.buffer instanceof ArrayBuffer) {
	      if (hasContentType === false) {
	        this[kReplyHeaders]['content-type'] = CONTENT_TYPE.OCTET;
	      }
	      const payloadToSend = Buffer.isBuffer(payload) ? payload : Buffer.from(payload.buffer, payload.byteOffset, payload.byteLength);
	      onSendHook(this, payloadToSend);
	      return this
	    }

	    if (hasContentType === false && typeof payload === 'string') {
	      this[kReplyHeaders]['content-type'] = CONTENT_TYPE.PLAIN;
	      onSendHook(this, payload);
	      return this
	    }
	  }

	  if (this[kReplySerializer] !== null) {
	    if (typeof payload !== 'string') {
	      preSerializationHook(this, payload);
	      return this
	    } else {
	      payload = this[kReplySerializer](payload);
	    }

	    // The indexOf below also matches custom json mimetypes such as 'application/hal+json' or 'application/ld+json'
	  } else if (hasContentType === false || contentType.indexOf('json') > -1) {
	    if (hasContentType === false) {
	      this[kReplyHeaders]['content-type'] = CONTENT_TYPE.JSON;
	    } else {
	      // If user doesn't set charset, we will set charset to utf-8
	      if (contentType.indexOf('charset') === -1) {
	        const customContentType = contentType.trim();
	        if (customContentType.endsWith(';')) {
	          // custom content-type is ended with ';'
	          this[kReplyHeaders]['content-type'] = `${customContentType} charset=utf-8`;
	        } else {
	          this[kReplyHeaders]['content-type'] = `${customContentType}; charset=utf-8`;
	        }
	      }
	    }
	    if (typeof payload !== 'string') {
	      preSerializationHook(this, payload);
	      return this
	    }
	  }

	  onSendHook(this, payload);

	  return this
	};

	Reply.prototype.getHeader = function (key) {
	  key = key.toLowerCase();
	  const value = this[kReplyHeaders][key];
	  return value !== undefined ? value : this.raw.getHeader(key)
	};

	Reply.prototype.getHeaders = function () {
	  return {
	    ...this.raw.getHeaders(),
	    ...this[kReplyHeaders]
	  }
	};

	Reply.prototype.hasHeader = function (key) {
	  key = key.toLowerCase();

	  return this[kReplyHeaders][key] !== undefined || this.raw.hasHeader(key)
	};

	Reply.prototype.removeHeader = function (key) {
	  // Node.js does not like headers with keys set to undefined,
	  // so we have to delete the key.
	  delete this[kReplyHeaders][key.toLowerCase()];
	  return this
	};

	Reply.prototype.header = function (key, value = '') {
	  key = key.toLowerCase();

	  if (this[kReplyHeaders][key] && key === 'set-cookie') {
	    // https://datatracker.ietf.org/doc/html/rfc7230#section-3.2.2
	    if (typeof this[kReplyHeaders][key] === 'string') {
	      this[kReplyHeaders][key] = [this[kReplyHeaders][key]];
	    }

	    if (Array.isArray(value)) {
	      Array.prototype.push.apply(this[kReplyHeaders][key], value);
	    } else {
	      this[kReplyHeaders][key].push(value);
	    }
	  } else {
	    this[kReplyHeaders][key] = value;
	  }

	  return this
	};

	Reply.prototype.headers = function (headers) {
	  const keys = Object.keys(headers);
	  for (let i = 0; i !== keys.length; ++i) {
	    const key = keys[i];
	    this.header(key, headers[key]);
	  }

	  return this
	};

	// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Trailer#directives
	// https://datatracker.ietf.org/doc/html/rfc7230.html#chunked.trailer.part
	const INVALID_TRAILERS = new Set([
	  'transfer-encoding',
	  'content-length',
	  'host',
	  'cache-control',
	  'max-forwards',
	  'te',
	  'authorization',
	  'set-cookie',
	  'content-encoding',
	  'content-type',
	  'content-range',
	  'trailer'
	]);

	Reply.prototype.trailer = function (key, fn) {
	  key = key.toLowerCase();
	  if (INVALID_TRAILERS.has(key)) {
	    throw new FST_ERR_BAD_TRAILER_NAME(key)
	  }
	  if (typeof fn !== 'function') {
	    throw new FST_ERR_BAD_TRAILER_VALUE(key, typeof fn)
	  }
	  if (this[kReplyTrailers] === null) this[kReplyTrailers] = {};
	  this[kReplyTrailers][key] = fn;
	  return this
	};

	Reply.prototype.hasTrailer = function (key) {
	  return this[kReplyTrailers]?.[key.toLowerCase()] !== undefined
	};

	Reply.prototype.removeTrailer = function (key) {
	  if (this[kReplyTrailers] === null) return this
	  this[kReplyTrailers][key.toLowerCase()] = undefined;
	  return this
	};

	Reply.prototype.code = function (code) {
	  const statusCode = +code;
	  if (!(statusCode >= 100 && statusCode <= 599)) {
	    throw new FST_ERR_BAD_STATUS_CODE(code || String(code))
	  }

	  this.raw.statusCode = statusCode;
	  this[kReplyHasStatusCode] = true;
	  return this
	};

	Reply.prototype.status = Reply.prototype.code;

	Reply.prototype.getSerializationFunction = function (schemaOrStatus, contentType) {
	  let serialize;

	  if (typeof schemaOrStatus === 'string' || typeof schemaOrStatus === 'number') {
	    if (typeof contentType === 'string') {
	      serialize = this[kRouteContext][kSchemaResponse]?.[schemaOrStatus]?.[contentType];
	    } else {
	      serialize = this[kRouteContext][kSchemaResponse]?.[schemaOrStatus];
	    }
	  } else if (typeof schemaOrStatus === 'object') {
	    serialize = this[kRouteContext][kReplyCacheSerializeFns]?.get(schemaOrStatus);
	  }

	  return serialize
	};

	Reply.prototype.compileSerializationSchema = function (schema, httpStatus = null, contentType = null) {
	  const { request } = this;
	  const { method, url } = request;

	  // Check if serialize function already compiled
	  if (this[kRouteContext][kReplyCacheSerializeFns]?.has(schema)) {
	    return this[kRouteContext][kReplyCacheSerializeFns].get(schema)
	  }

	  const serializerCompiler = this[kRouteContext].serializerCompiler ||
	    this.server[kSchemaController].serializerCompiler ||
	    (
	      // We compile the schemas if no custom serializerCompiler is provided
	      // nor set
	      this.server[kSchemaController].setupSerializer(this.server[kOptions]) ||
	      this.server[kSchemaController].serializerCompiler
	    );

	  const serializeFn = serializerCompiler({
	    schema,
	    method,
	    url,
	    httpStatus,
	    contentType
	  });

	  // We create a WeakMap to compile the schema only once
	  // Its done lazily to avoid add overhead by creating the WeakMap
	  // if it is not used
	  // TODO: Explore a central cache for all the schemas shared across
	  // encapsulated contexts
	  if (this[kRouteContext][kReplyCacheSerializeFns] == null) {
	    this[kRouteContext][kReplyCacheSerializeFns] = new WeakMap();
	  }

	  this[kRouteContext][kReplyCacheSerializeFns].set(schema, serializeFn);

	  return serializeFn
	};

	Reply.prototype.serializeInput = function (input, schema, httpStatus, contentType) {
	  const possibleContentType = httpStatus;
	  let serialize;
	  httpStatus = typeof schema === 'string' || typeof schema === 'number'
	    ? schema
	    : httpStatus;

	  contentType = httpStatus && possibleContentType !== httpStatus
	    ? possibleContentType
	    : contentType;

	  if (httpStatus != null) {
	    if (contentType != null) {
	      serialize = this[kRouteContext][kSchemaResponse]?.[httpStatus]?.[contentType];
	    } else {
	      serialize = this[kRouteContext][kSchemaResponse]?.[httpStatus];
	    }

	    if (serialize == null) {
	      if (contentType) throw new FST_ERR_MISSING_CONTENTTYPE_SERIALIZATION_FN(httpStatus, contentType)
	      throw new FST_ERR_MISSING_SERIALIZATION_FN(httpStatus)
	    }
	  } else {
	    // Check if serialize function already compiled
	    if (this[kRouteContext][kReplyCacheSerializeFns]?.has(schema)) {
	      serialize = this[kRouteContext][kReplyCacheSerializeFns].get(schema);
	    } else {
	      serialize = this.compileSerializationSchema(schema, httpStatus, contentType);
	    }
	  }

	  return serialize(input)
	};

	Reply.prototype.serialize = function (payload) {
	  if (this[kReplySerializer] !== null) {
	    return this[kReplySerializer](payload)
	  } else {
	    if (this[kRouteContext] && this[kRouteContext][kReplySerializerDefault]) {
	      return this[kRouteContext][kReplySerializerDefault](payload, this.raw.statusCode)
	    } else {
	      return serialize(this[kRouteContext], payload, this.raw.statusCode)
	    }
	  }
	};

	Reply.prototype.serializer = function (fn) {
	  this[kReplySerializer] = fn;
	  return this
	};

	Reply.prototype.type = function (type) {
	  this[kReplyHeaders]['content-type'] = type;
	  return this
	};

	Reply.prototype.redirect = function (url, code) {
	  if (!code) {
	    code = this[kReplyHasStatusCode] ? this.raw.statusCode : 302;
	  }

	  return this.header('location', url).code(code).send()
	};

	Reply.prototype.callNotFound = function () {
	  notFound(this);
	  return this
	};

	// Make reply a thenable, so it could be used with async/await.
	// See
	// - https://github.com/fastify/fastify/issues/1864 for the discussions
	// - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then for the signature
	Reply.prototype.then = function (fulfilled, rejected) {
	  if (this.sent) {
	    fulfilled();
	    return
	  }

	  eos(this.raw, (err) => {
	    // We must not treat ERR_STREAM_PREMATURE_CLOSE as
	    // an error because it is created by eos, not by the stream.
	    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
	      if (rejected) {
	        rejected(err);
	      } else {
	        this.log && this.log.warn('unhandled rejection on reply.then');
	      }
	    } else {
	      fulfilled();
	    }
	  });
	};

	Reply.prototype.getDecorator = function (name) {
	  if (!decorators.hasKey(this, name) && !decorators.exist(this, name)) {
	    throw new FST_ERR_DEC_UNDECLARED(name, 'reply')
	  }

	  const decorator = this[name];
	  if (typeof decorator === 'function') {
	    return decorator.bind(this)
	  }

	  return decorator
	};

	function preSerializationHook (reply, payload) {
	  if (reply[kRouteContext].preSerialization !== null) {
	    preSerializationHookRunner(
	      reply[kRouteContext].preSerialization,
	      reply.request,
	      reply,
	      payload,
	      preSerializationHookEnd
	    );
	  } else {
	    preSerializationHookEnd(null, undefined, reply, payload);
	  }
	}

	function preSerializationHookEnd (err, _request, reply, payload) {
	  if (err != null) {
	    onErrorHook(reply, err);
	    return
	  }

	  try {
	    if (reply[kReplySerializer] !== null) {
	      payload = reply[kReplySerializer](payload);
	    } else if (reply[kRouteContext] && reply[kRouteContext][kReplySerializerDefault]) {
	      payload = reply[kRouteContext][kReplySerializerDefault](payload, reply.raw.statusCode);
	    } else {
	      payload = serialize(reply[kRouteContext], payload, reply.raw.statusCode, reply[kReplyHeaders]['content-type']);
	    }
	  } catch (e) {
	    wrapSerializationError(e, reply);
	    onErrorHook(reply, e);
	    return
	  }

	  onSendHook(reply, payload);
	}

	function wrapSerializationError (error, reply) {
	  error.serialization = reply[kRouteContext].config;
	}

	function onSendHook (reply, payload) {
	  if (reply[kRouteContext].onSend !== null) {
	    onSendHookRunner(
	      reply[kRouteContext].onSend,
	      reply.request,
	      reply,
	      payload,
	      wrapOnSendEnd
	    );
	  } else {
	    onSendEnd(reply, payload);
	  }
	}

	function wrapOnSendEnd (err, request, reply, payload) {
	  if (err != null) {
	    onErrorHook(reply, err);
	  } else {
	    onSendEnd(reply, payload);
	  }
	}

	function safeWriteHead (reply, statusCode) {
	  const res = reply.raw;
	  try {
	    res.writeHead(statusCode, reply[kReplyHeaders]);
	  } catch (err) {
	    if (err.code === 'ERR_HTTP_HEADERS_SENT') {
	      reply.log.warn(`Reply was already sent, did you forget to "return reply" in the "${reply.request.raw.url}" (${reply.request.raw.method}) route?`);
	    }
	    throw err
	  }
	}

	function onSendEnd (reply, payload) {
	  const res = reply.raw;
	  const req = reply.request;

	  // we check if we need to update the trailers header and set it
	  if (reply[kReplyTrailers] !== null) {
	    const trailerHeaders = Object.keys(reply[kReplyTrailers]);
	    let header = '';
	    for (const trailerName of trailerHeaders) {
	      if (typeof reply[kReplyTrailers][trailerName] !== 'function') continue
	      header += ' ';
	      header += trailerName;
	    }
	    // it must be chunked for trailer to work
	    reply.header('Transfer-Encoding', 'chunked');
	    reply.header('Trailer', header.trim());
	  }

	  // since Response contain status code, headers and body,
	  // we need to update the status, add the headers and use it's body as payload
	  // before continuing
	  if (toString.call(payload) === '[object Response]') {
	    // https://developer.mozilla.org/en-US/docs/Web/API/Response/status
	    if (typeof payload.status === 'number') {
	      reply.code(payload.status);
	    }

	    // https://developer.mozilla.org/en-US/docs/Web/API/Response/headers
	    if (typeof payload.headers === 'object' && typeof payload.headers.forEach === 'function') {
	      for (const [headerName, headerValue] of payload.headers) {
	        reply.header(headerName, headerValue);
	      }
	    }

	    // https://developer.mozilla.org/en-US/docs/Web/API/Response/body
	    if (payload.body !== null) {
	      if (payload.bodyUsed) {
	        throw new FST_ERR_REP_RESPONSE_BODY_CONSUMED()
	      }
	    }
	    // Keep going, body is either null or ReadableStream
	    payload = payload.body;
	  }
	  const statusCode = res.statusCode;

	  if (payload === undefined || payload === null) {
	    // according to https://datatracker.ietf.org/doc/html/rfc7230#section-3.3.2
	    // we cannot send a content-length for 304 and 204, and all status code
	    // < 200
	    // A sender MUST NOT send a Content-Length header field in any message
	    // that contains a Transfer-Encoding header field.
	    // For HEAD we don't overwrite the `content-length`
	    if (statusCode >= 200 && statusCode !== 204 && statusCode !== 304 && req.method !== 'HEAD' && reply[kReplyTrailers] === null) {
	      reply[kReplyHeaders]['content-length'] = '0';
	    }

	    safeWriteHead(reply, statusCode);
	    sendTrailer(payload, res, reply);
	    return
	  }

	  if ((statusCode >= 100 && statusCode < 200) || statusCode === 204) {
	    // Responses without a content body must not send content-type
	    // or content-length headers.
	    // See https://www.rfc-editor.org/rfc/rfc9110.html#section-8.6.
	    reply.removeHeader('content-type');
	    reply.removeHeader('content-length');
	    safeWriteHead(reply, statusCode);
	    sendTrailer(undefined, res, reply);
	    if (typeof payload.resume === 'function') {
	      payload.on('error', noop);
	      payload.resume();
	    }
	    return
	  }

	  // node:stream
	  if (typeof payload.pipe === 'function') {
	    sendStream(payload, res, reply);
	    return
	  }

	  // node:stream/web
	  if (typeof payload.getReader === 'function') {
	    sendWebStream(payload, res, reply);
	    return
	  }

	  if (typeof payload !== 'string' && !Buffer.isBuffer(payload)) {
	    throw new FST_ERR_REP_INVALID_PAYLOAD_TYPE(typeof payload)
	  }

	  if (reply[kReplyTrailers] === null) {
	    const contentLength = reply[kReplyHeaders]['content-length'];
	    if (!contentLength ||
	      (req.raw.method !== 'HEAD' &&
	        Number(contentLength) !== Buffer.byteLength(payload)
	      )
	    ) {
	      reply[kReplyHeaders]['content-length'] = '' + Buffer.byteLength(payload);
	    }
	  }

	  safeWriteHead(reply, statusCode);
	  // write payload first
	  res.write(payload);
	  // then send trailers
	  sendTrailer(payload, res, reply);
	}

	function logStreamError (logger, err, res) {
	  if (err.code === 'ERR_STREAM_PREMATURE_CLOSE') {
	    if (!logger[kDisableRequestLogging]) {
	      logger.info({ res }, 'stream closed prematurely');
	    }
	  } else {
	    logger.warn({ err }, 'response terminated with an error with headers already sent');
	  }
	}

	function sendWebStream (payload, res, reply) {
	  if (payload.locked) {
	    throw FST_ERR_REP_READABLE_STREAM_LOCKED()
	  }
	  const nodeStream = Readable.fromWeb(payload);
	  sendStream(nodeStream, res, reply);
	}

	function sendStream (payload, res, reply) {
	  let sourceOpen = true;
	  let errorLogged = false;

	  // set trailer when stream ended
	  sendStreamTrailer(payload, res, reply);

	  eos(payload, { readable: true, writable: false }, function (err) {
	    sourceOpen = false;
	    if (err != null) {
	      if (res.headersSent || reply.request.raw.aborted === true) {
	        if (!errorLogged) {
	          errorLogged = true;
	          logStreamError(reply.log, err, reply);
	        }
	        res.destroy();
	      } else {
	        onErrorHook(reply, err);
	      }
	    }
	    // there is nothing to do if there is not an error
	  });

	  eos(res, function (err) {
	    if (sourceOpen) {
	      if (err != null && res.headersSent && !errorLogged) {
	        errorLogged = true;
	        logStreamError(reply.log, err, res);
	      }
	      if (typeof payload.destroy === 'function') {
	        payload.destroy();
	      } else if (typeof payload.close === 'function') {
	        payload.close(noop);
	      } else if (typeof payload.abort === 'function') {
	        payload.abort();
	      } else {
	        reply.log.warn('stream payload does not end properly');
	      }
	    }
	  });

	  // streams will error asynchronously, and we want to handle that error
	  // appropriately, e.g. a 404 for a missing file. So we cannot use
	  // writeHead, and we need to resort to setHeader, which will trigger
	  // a writeHead when there is data to send.
	  if (!res.headersSent) {
	    for (const key in reply[kReplyHeaders]) {
	      res.setHeader(key, reply[kReplyHeaders][key]);
	    }
	  } else {
	    reply.log.warn('response will send, but you shouldn\'t use res.writeHead in stream mode');
	  }
	  payload.pipe(res);
	}

	function sendTrailer (payload, res, reply) {
	  if (reply[kReplyTrailers] === null) {
	    // when no trailer, we close the stream
	    res.end(null, null, null); // avoid ArgumentsAdaptorTrampoline from V8
	    return
	  }
	  const trailerHeaders = Object.keys(reply[kReplyTrailers]);
	  const trailers = {};
	  let handled = 0;
	  let skipped = true;
	  function send () {
	    // add trailers when all handler handled
	    /* istanbul ignore else */
	    if (handled === 0) {
	      res.addTrailers(trailers);
	      // we need to properly close the stream
	      // after trailers sent
	      res.end(null, null, null); // avoid ArgumentsAdaptorTrampoline from V8
	    }
	  }

	  for (const trailerName of trailerHeaders) {
	    if (typeof reply[kReplyTrailers][trailerName] !== 'function') continue
	    skipped = false;
	    handled--;

	    function cb (err, value) {
	      // TODO: we may protect multiple callback calls
	      //       or mixing async-await with callback
	      handled++;

	      // we can safely ignore error for trailer
	      // since it does affect the client
	      // we log in here only for debug usage
	      if (err) reply.log.debug(err);
	      else trailers[trailerName] = value;

	      // we push the check to the end of event
	      // loop, so the registration continue to
	      // process.
	      process.nextTick(send);
	    }

	    const result = reply[kReplyTrailers][trailerName](reply, payload, cb);
	    if (typeof result === 'object' && typeof result.then === 'function') {
	      result.then((v) => cb(null, v), cb);
	    }
	  }

	  // when all trailers are skipped
	  // we need to close the stream
	  if (skipped) res.end(null, null, null); // avoid ArgumentsAdaptorTrampoline from V8
	}

	function sendStreamTrailer (payload, res, reply) {
	  if (reply[kReplyTrailers] === null) return
	  payload.on('end', () => sendTrailer(null, res, reply));
	}

	function onErrorHook (reply, error, cb) {
	  if (reply[kRouteContext].onError !== null && !reply[kReplyNextErrorHandler]) {
	    reply[kReplyIsRunningOnErrorHook] = true;
	    onSendHookRunner(
	      reply[kRouteContext].onError,
	      reply.request,
	      reply,
	      error,
	      () => handleError(reply, error, cb)
	    );
	  } else {
	    handleError(reply, error, cb);
	  }
	}

	function setupResponseListeners (reply) {
	  reply[kReplyStartTime] = now();

	  const onResFinished = err => {
	    reply[kReplyEndTime] = now();
	    reply.raw.removeListener('finish', onResFinished);
	    reply.raw.removeListener('error', onResFinished);

	    const ctx = reply[kRouteContext];

	    if (ctx && ctx.onResponse !== null) {
	      onResponseHookRunner(
	        ctx.onResponse,
	        reply.request,
	        reply,
	        onResponseCallback
	      );
	    } else {
	      onResponseCallback(err, reply.request, reply);
	    }
	  };

	  reply.raw.on('finish', onResFinished);
	  reply.raw.on('error', onResFinished);
	}

	function onResponseCallback (err, request, reply) {
	  if (reply.log[kDisableRequestLogging]) {
	    return
	  }

	  const responseTime = reply.elapsedTime;

	  if (err != null) {
	    reply.log.error({
	      res: reply,
	      err,
	      responseTime
	    }, 'request errored');
	    return
	  }

	  reply.log.info({
	    res: reply,
	    responseTime
	  }, 'request completed');
	}

	function buildReply (R) {
	  const props = R.props.slice();

	  function _Reply (res, request, log) {
	    this.raw = res;
	    this[kReplyIsError] = false;
	    this[kReplyErrorHandlerCalled] = false;
	    this[kReplyHijacked] = false;
	    this[kReplySerializer] = null;
	    this.request = request;
	    this[kReplyHeaders] = {};
	    this[kReplyTrailers] = null;
	    this[kReplyStartTime] = undefined;
	    this[kReplyEndTime] = undefined;
	    this.log = log;

	    let prop;

	    for (let i = 0; i < props.length; i++) {
	      prop = props[i];
	      this[prop.key] = prop.value;
	    }
	  }
	  Object.setPrototypeOf(_Reply.prototype, R.prototype);
	  Object.setPrototypeOf(_Reply, R);
	  _Reply.parent = R;
	  _Reply.props = props;
	  return _Reply
	}

	function notFound (reply) {
	  if (reply[kRouteContext][kFourOhFourContext] === null) {
	    reply.log.warn('Trying to send a NotFound error inside a 404 handler. Sending basic 404 response.');
	    reply.code(404).send('404 Not Found');
	    return
	  }

	  reply.request[kRouteContext] = reply[kRouteContext][kFourOhFourContext];

	  // preHandler hook
	  if (reply[kRouteContext].preHandler !== null) {
	    preHandlerHookRunner(
	      reply[kRouteContext].preHandler,
	      reply.request,
	      reply,
	      internals.preHandlerCallback
	    );
	  } else {
	    internals.preHandlerCallback(null, reply.request, reply);
	  }
	}

	/**
	 * This function runs when a payload that is not a string|buffer|stream or null
	 * should be serialized to be streamed to the response.
	 * This is the default serializer that can be customized by the user using the replySerializer
	 *
	 * @param {object} context the request context
	 * @param {object} data the JSON payload to serialize
	 * @param {number} statusCode the http status code
	 * @param {string} [contentType] the reply content type
	 * @returns {string} the serialized payload
	 */
	function serialize (context, data, statusCode, contentType) {
	  const fnSerialize = getSchemaSerializer(context, statusCode, contentType);
	  if (fnSerialize) {
	    return fnSerialize(data)
	  }
	  return JSON.stringify(data)
	}

	function noop () { }

	reply.exports = Reply;
	reply.exports.buildReply = buildReply;
	reply.exports.setupResponseListeners = setupResponseListeners;
	return reply.exports;
}

var request$1 = {exports: {}};

var proxyAddr = {exports: {}};

var forwarded = {exports: {}};

/*!
 * forwarded
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */

var hasRequiredForwarded;

function requireForwarded () {
	if (hasRequiredForwarded) return forwarded.exports;
	hasRequiredForwarded = 1;

	/**
	 * Get all addresses in the request used in the `X-Forwarded-For` header.
	 */
	function forwarded$1 (req) {
	  if (!req) {
	    throw new TypeError('argument req is required')
	  }

	  const header = req.headers['x-forwarded-for'];
	  const socketAddr = req.socket.remoteAddress;

	  if (!header || typeof header !== 'string') {
	    return [socketAddr]
	  } else if (header.indexOf(',') === -1) {
	    const remote = header.trim();
	    return (remote.length)
	      ? [socketAddr, remote]
	      : [socketAddr]
	  } else {
	    return parse(header, socketAddr)
	  }
	}

	function parse (header, socketAddr) {
	  const result = [socketAddr];

	  let end = header.length;
	  let start = end;
	  let char;
	  let i;

	  for (i = end - 1; i >= 0; --i) {
	    char = header[i];
	    if (char === ' ') {
	      (start === end) && (start = end = i);
	    } else if (char === ',') {
	      (start !== end) && result.push(header.slice(start, end));
	      start = end = i;
	    } else {
	      start = i;
	    }
	  }

	  (start !== end) && result.push(header.substring(start, end));

	  return result
	}

	forwarded.exports = forwarded$1;
	forwarded.exports.default = forwarded$1;
	forwarded.exports.forwarded = forwarded$1;
	return forwarded.exports;
}

var ipaddr$1 = {exports: {}};

var ipaddr = ipaddr$1.exports;

var hasRequiredIpaddr;

function requireIpaddr () {
	if (hasRequiredIpaddr) return ipaddr$1.exports;
	hasRequiredIpaddr = 1;
	(function (module) {
		(function (root) {
		    // A list of regular expressions that match arbitrary IPv4 addresses,
		    // for which a number of weird notations exist.
		    // Note that an address like 0010.0xa5.1.1 is considered legal.
		    const ipv4Part = '(0?\\d+|0x[a-f0-9]+)';
		    const ipv4Regexes = {
		        fourOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}$`, 'i'),
		        threeOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}$`, 'i'),
		        twoOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}$`, 'i'),
		        longValue: new RegExp(`^${ipv4Part}$`, 'i')
		    };

		    // Regular Expression for checking Octal numbers
		    const octalRegex = new RegExp(`^0[0-7]+$`, 'i');
		    const hexRegex = new RegExp(`^0x[a-f0-9]+$`, 'i');

		    const zoneIndex = '%[0-9a-z]{1,}';

		    // IPv6-matching regular expressions.
		    // For IPv6, the task is simpler: it is enough to match the colon-delimited
		    // hexadecimal IPv6 and a transitional variant with dotted-decimal IPv4 at
		    // the end.
		    const ipv6Part = '(?:[0-9a-f]+::?)+';
		    const ipv6Regexes = {
		        zoneIndex: new RegExp(zoneIndex, 'i'),
		        'native': new RegExp(`^(::)?(${ipv6Part})?([0-9a-f]+)?(::)?(${zoneIndex})?$`, 'i'),
		        deprecatedTransitional: new RegExp(`^(?:::)(${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}(${zoneIndex})?)$`, 'i'),
		        transitional: new RegExp(`^((?:${ipv6Part})|(?:::)(?:${ipv6Part})?)${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}(${zoneIndex})?$`, 'i')
		    };

		    // Expand :: in an IPv6 address or address part consisting of `parts` groups.
		    function expandIPv6 (string, parts) {
		        // More than one '::' means invalid adddress
		        if (string.indexOf('::') !== string.lastIndexOf('::')) {
		            return null;
		        }

		        let colonCount = 0;
		        let lastColon = -1;
		        let zoneId = (string.match(ipv6Regexes.zoneIndex) || [])[0];
		        let replacement, replacementCount;

		        // Remove zone index and save it for later
		        if (zoneId) {
		            zoneId = zoneId.substring(1);
		            string = string.replace(/%.+$/, '');
		        }

		        // How many parts do we already have?
		        while ((lastColon = string.indexOf(':', lastColon + 1)) >= 0) {
		            colonCount++;
		        }

		        // 0::0 is two parts more than ::
		        if (string.substr(0, 2) === '::') {
		            colonCount--;
		        }

		        if (string.substr(-2, 2) === '::') {
		            colonCount--;
		        }

		        // The following loop would hang if colonCount > parts
		        if (colonCount > parts) {
		            return null;
		        }

		        // replacement = ':' + '0:' * (parts - colonCount)
		        replacementCount = parts - colonCount;
		        replacement = ':';
		        while (replacementCount--) {
		            replacement += '0:';
		        }

		        // Insert the missing zeroes
		        string = string.replace('::', replacement);

		        // Trim any garbage which may be hanging around if :: was at the edge in
		        // the source strin
		        if (string[0] === ':') {
		            string = string.slice(1);
		        }

		        if (string[string.length - 1] === ':') {
		            string = string.slice(0, -1);
		        }

		        parts = (function () {
		            const ref = string.split(':');
		            const results = [];

		            for (let i = 0; i < ref.length; i++) {
		                results.push(parseInt(ref[i], 16));
		            }

		            return results;
		        })();

		        return {
		            parts: parts,
		            zoneId: zoneId
		        };
		    }

		    // A generic CIDR (Classless Inter-Domain Routing) RFC1518 range matcher.
		    function matchCIDR (first, second, partSize, cidrBits) {
		        if (first.length !== second.length) {
		            throw new Error('ipaddr: cannot match CIDR for objects with different lengths');
		        }

		        let part = 0;
		        let shift;

		        while (cidrBits > 0) {
		            shift = partSize - cidrBits;
		            if (shift < 0) {
		                shift = 0;
		            }

		            if (first[part] >> shift !== second[part] >> shift) {
		                return false;
		            }

		            cidrBits -= partSize;
		            part += 1;
		        }

		        return true;
		    }

		    function parseIntAuto (string) {
		        // Hexadedimal base 16 (0x#)
		        if (hexRegex.test(string)) {
		            return parseInt(string, 16);
		        }
		        // While octal representation is discouraged by ECMAScript 3
		        // and forbidden by ECMAScript 5, we silently allow it to
		        // work only if the rest of the string has numbers less than 8.
		        if (string[0] === '0' && !isNaN(parseInt(string[1], 10))) {
		        if (octalRegex.test(string)) {
		            return parseInt(string, 8);
		        }
		            throw new Error(`ipaddr: cannot parse ${string} as octal`);
		        }
		        // Always include the base 10 radix!
		        return parseInt(string, 10);
		    }

		    function padPart (part, length) {
		        while (part.length < length) {
		            part = `0${part}`;
		        }

		        return part;
		    }

		    const ipaddr = {};

		    // An IPv4 address (RFC791).
		    ipaddr.IPv4 = (function () {
		        // Constructs a new IPv4 address from an array of four octets
		        // in network order (MSB first)
		        // Verifies the input.
		        function IPv4 (octets) {
		            if (octets.length !== 4) {
		                throw new Error('ipaddr: ipv4 octet count should be 4');
		            }

		            let i, octet;

		            for (i = 0; i < octets.length; i++) {
		                octet = octets[i];
		                if (!((0 <= octet && octet <= 255))) {
		                    throw new Error('ipaddr: ipv4 octet should fit in 8 bits');
		                }
		            }

		            this.octets = octets;
		        }

		        // Special IPv4 address ranges.
		        // See also https://en.wikipedia.org/wiki/Reserved_IP_addresses
		        IPv4.prototype.SpecialRanges = {
		            unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
		            broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
		            // RFC3171
		            multicast: [[new IPv4([224, 0, 0, 0]), 4]],
		            // RFC3927
		            linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
		            // RFC5735
		            loopback: [[new IPv4([127, 0, 0, 0]), 8]],
		            // RFC6598
		            carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],
		            // RFC1918
		            'private': [
		                [new IPv4([10, 0, 0, 0]), 8],
		                [new IPv4([172, 16, 0, 0]), 12],
		                [new IPv4([192, 168, 0, 0]), 16]
		            ],
		            // Reserved and testing-only ranges; RFCs 5735, 5737, 2544, 1700
		            reserved: [
		                [new IPv4([192, 0, 0, 0]), 24],
		                [new IPv4([192, 0, 2, 0]), 24],
		                [new IPv4([192, 88, 99, 0]), 24],
		                [new IPv4([198, 18, 0, 0]), 15],
		                [new IPv4([198, 51, 100, 0]), 24],
		                [new IPv4([203, 0, 113, 0]), 24],
		                [new IPv4([240, 0, 0, 0]), 4]
		            ],
		            // RFC7534, RFC7535
		            as112: [
		                [new IPv4([192, 175, 48, 0]), 24],
		                [new IPv4([192, 31, 196, 0]), 24],
		            ],
		            // RFC7450
		            amt: [
		                [new IPv4([192, 52, 193, 0]), 24],
		            ],
		        };

		        // The 'kind' method exists on both IPv4 and IPv6 classes.
		        IPv4.prototype.kind = function () {
		            return 'ipv4';
		        };

		        // Checks if this address matches other one within given CIDR range.
		        IPv4.prototype.match = function (other, cidrRange) {
		            let ref;
		            if (cidrRange === undefined) {
		                ref = other;
		                other = ref[0];
		                cidrRange = ref[1];
		            }

		            if (other.kind() !== 'ipv4') {
		                throw new Error('ipaddr: cannot match ipv4 address with non-ipv4 one');
		            }

		            return matchCIDR(this.octets, other.octets, 8, cidrRange);
		        };

		        // returns a number of leading ones in IPv4 address, making sure that
		        // the rest is a solid sequence of 0's (valid netmask)
		        // returns either the CIDR length or null if mask is not valid
		        IPv4.prototype.prefixLengthFromSubnetMask = function () {
		            let cidr = 0;
		            // non-zero encountered stop scanning for zeroes
		            let stop = false;
		            // number of zeroes in octet
		            const zerotable = {
		                0: 8,
		                128: 7,
		                192: 6,
		                224: 5,
		                240: 4,
		                248: 3,
		                252: 2,
		                254: 1,
		                255: 0
		            };
		            let i, octet, zeros;

		            for (i = 3; i >= 0; i -= 1) {
		                octet = this.octets[i];
		                if (octet in zerotable) {
		                    zeros = zerotable[octet];
		                    if (stop && zeros !== 0) {
		                        return null;
		                    }

		                    if (zeros !== 8) {
		                        stop = true;
		                    }

		                    cidr += zeros;
		                } else {
		                    return null;
		                }
		            }

		            return 32 - cidr;
		        };

		        // Checks if the address corresponds to one of the special ranges.
		        IPv4.prototype.range = function () {
		            return ipaddr.subnetMatch(this, this.SpecialRanges);
		        };

		        // Returns an array of byte-sized values in network order (MSB first)
		        IPv4.prototype.toByteArray = function () {
		            return this.octets.slice(0);
		        };

		        // Converts this IPv4 address to an IPv4-mapped IPv6 address.
		        IPv4.prototype.toIPv4MappedAddress = function () {
		            return ipaddr.IPv6.parse(`::ffff:${this.toString()}`);
		        };

		        // Symmetrical method strictly for aligning with the IPv6 methods.
		        IPv4.prototype.toNormalizedString = function () {
		            return this.toString();
		        };

		        // Returns the address in convenient, decimal-dotted format.
		        IPv4.prototype.toString = function () {
		            return this.octets.join('.');
		        };

		        return IPv4;
		    })();

		    // A utility function to return broadcast address given the IPv4 interface and prefix length in CIDR notation
		    ipaddr.IPv4.broadcastAddressFromCIDR = function (string) {

		        try {
		            const cidr = this.parseCIDR(string);
		            const ipInterfaceOctets = cidr[0].toByteArray();
		            const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
		            const octets = [];
		            let i = 0;
		            while (i < 4) {
		                // Broadcast address is bitwise OR between ip interface and inverted mask
		                octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
		                i++;
		            }

		            return new this(octets);
		        } catch (e) {
		            throw new Error('ipaddr: the address does not have IPv4 CIDR format');
		        }
		    };

		    // Checks if a given string is formatted like IPv4 address.
		    ipaddr.IPv4.isIPv4 = function (string) {
		        return this.parser(string) !== null;
		    };

		    // Checks if a given string is a valid IPv4 address.
		    ipaddr.IPv4.isValid = function (string) {
		        try {
		            new this(this.parser(string));
		            return true;
		        } catch (e) {
		            return false;
		        }
		    };

		    // Checks if a given string is a valid IPv4 address in CIDR notation.
		    ipaddr.IPv4.isValidCIDR = function (string) {
		        try {
		            this.parseCIDR(string);
		            return true;
		        } catch (e) {
		            return false;
		        }
		    };

		    // Checks if a given string is a full four-part IPv4 Address.
		    ipaddr.IPv4.isValidFourPartDecimal = function (string) {
		        if (ipaddr.IPv4.isValid(string) && string.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) {
		            return true;
		        } else {
		            return false;
		        }
		    };

		    // A utility function to return network address given the IPv4 interface and prefix length in CIDR notation
		    ipaddr.IPv4.networkAddressFromCIDR = function (string) {
		        let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;

		        try {
		            cidr = this.parseCIDR(string);
		            ipInterfaceOctets = cidr[0].toByteArray();
		            subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
		            octets = [];
		            i = 0;
		            while (i < 4) {
		                // Network address is bitwise AND between ip interface and mask
		                octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
		                i++;
		            }

		            return new this(octets);
		        } catch (e) {
		            throw new Error('ipaddr: the address does not have IPv4 CIDR format');
		        }
		    };

		    // Tries to parse and validate a string with IPv4 address.
		    // Throws an error if it fails.
		    ipaddr.IPv4.parse = function (string) {
		        const parts = this.parser(string);

		        if (parts === null) {
		            throw new Error('ipaddr: string is not formatted like an IPv4 Address');
		        }

		        return new this(parts);
		    };

		    // Parses the string as an IPv4 Address with CIDR Notation.
		    ipaddr.IPv4.parseCIDR = function (string) {
		        let match;

		        if ((match = string.match(/^(.+)\/(\d+)$/))) {
		            const maskLength = parseInt(match[2]);
		            if (maskLength >= 0 && maskLength <= 32) {
		                const parsed = [this.parse(match[1]), maskLength];
		                Object.defineProperty(parsed, 'toString', {
		                    value: function () {
		                        return this.join('/');
		                    }
		                });
		                return parsed;
		            }
		        }

		        throw new Error('ipaddr: string is not formatted like an IPv4 CIDR range');
		    };

		    // Classful variants (like a.b, where a is an octet, and b is a 24-bit
		    // value representing last three octets; this corresponds to a class C
		    // address) are omitted due to classless nature of modern Internet.
		    ipaddr.IPv4.parser = function (string) {
		        let match, part, value;

		        // parseInt recognizes all that octal & hexadecimal weirdness for us
		        if ((match = string.match(ipv4Regexes.fourOctet))) {
		            return (function () {
		                const ref = match.slice(1, 6);
		                const results = [];

		                for (let i = 0; i < ref.length; i++) {
		                    part = ref[i];
		                    results.push(parseIntAuto(part));
		                }

		                return results;
		            })();
		        } else if ((match = string.match(ipv4Regexes.longValue))) {
		            value = parseIntAuto(match[1]);
		            if (value > 0xffffffff || value < 0) {
		                throw new Error('ipaddr: address outside defined range');
		            }

		            return ((function () {
		                const results = [];
		                let shift;

		                for (shift = 0; shift <= 24; shift += 8) {
		                    results.push((value >> shift) & 0xff);
		                }

		                return results;
		            })()).reverse();
		        } else if ((match = string.match(ipv4Regexes.twoOctet))) {
		            return (function () {
		                const ref = match.slice(1, 4);
		                const results = [];

		                value = parseIntAuto(ref[1]);
		                if (value > 0xffffff || value < 0) {
		                    throw new Error('ipaddr: address outside defined range');
		                }

		                results.push(parseIntAuto(ref[0]));
		                results.push((value >> 16) & 0xff);
		                results.push((value >>  8) & 0xff);
		                results.push( value        & 0xff);

		                return results;
		            })();
		        } else if ((match = string.match(ipv4Regexes.threeOctet))) {
		            return (function () {
		                const ref = match.slice(1, 5);
		                const results = [];

		                value = parseIntAuto(ref[2]);
		                if (value > 0xffff || value < 0) {
		                    throw new Error('ipaddr: address outside defined range');
		                }

		                results.push(parseIntAuto(ref[0]));
		                results.push(parseIntAuto(ref[1]));
		                results.push((value >> 8) & 0xff);
		                results.push( value       & 0xff);

		                return results;
		            })();
		        } else {
		            return null;
		        }
		    };

		    // A utility function to return subnet mask in IPv4 format given the prefix length
		    ipaddr.IPv4.subnetMaskFromPrefixLength = function (prefix) {
		        prefix = parseInt(prefix);
		        if (prefix < 0 || prefix > 32) {
		            throw new Error('ipaddr: invalid IPv4 prefix length');
		        }

		        const octets = [0, 0, 0, 0];
		        let j = 0;
		        const filledOctetCount = Math.floor(prefix / 8);

		        while (j < filledOctetCount) {
		            octets[j] = 255;
		            j++;
		        }

		        if (filledOctetCount < 4) {
		            octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - (prefix % 8);
		        }

		        return new this(octets);
		    };

		    // An IPv6 address (RFC2460)
		    ipaddr.IPv6 = (function () {
		        // Constructs an IPv6 address from an array of eight 16 - bit parts
		        // or sixteen 8 - bit parts in network order(MSB first).
		        // Throws an error if the input is invalid.
		        function IPv6 (parts, zoneId) {
		            let i, part;

		            if (parts.length === 16) {
		                this.parts = [];
		                for (i = 0; i <= 14; i += 2) {
		                    this.parts.push((parts[i] << 8) | parts[i + 1]);
		                }
		            } else if (parts.length === 8) {
		                this.parts = parts;
		            } else {
		                throw new Error('ipaddr: ipv6 part count should be 8 or 16');
		            }

		            for (i = 0; i < this.parts.length; i++) {
		                part = this.parts[i];
		                if (!((0 <= part && part <= 0xffff))) {
		                    throw new Error('ipaddr: ipv6 part should fit in 16 bits');
		                }
		            }

		            if (zoneId) {
		                this.zoneId = zoneId;
		            }
		        }

		        // Special IPv6 ranges
		        IPv6.prototype.SpecialRanges = {
		            // RFC4291, here and after
		            unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
		            linkLocal: [new IPv6([0xfe80, 0, 0, 0, 0, 0, 0, 0]), 10],
		            multicast: [new IPv6([0xff00, 0, 0, 0, 0, 0, 0, 0]), 8],
		            loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
		            uniqueLocal: [new IPv6([0xfc00, 0, 0, 0, 0, 0, 0, 0]), 7],
		            ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 0xffff, 0, 0]), 96],
		            // RFC6666
		            discard: [new IPv6([0x100, 0, 0, 0, 0, 0, 0, 0]), 64],
		            // RFC6145
		            rfc6145: [new IPv6([0, 0, 0, 0, 0xffff, 0, 0, 0]), 96],
		            // RFC6052
		            rfc6052: [new IPv6([0x64, 0xff9b, 0, 0, 0, 0, 0, 0]), 96],
		            // RFC3056
		            '6to4': [new IPv6([0x2002, 0, 0, 0, 0, 0, 0, 0]), 16],
		            // RFC6052, RFC6146
		            teredo: [new IPv6([0x2001, 0, 0, 0, 0, 0, 0, 0]), 32],
		            // RFC5180
		            benchmarking: [new IPv6([0x2001, 0x2, 0, 0, 0, 0, 0, 0]), 48],
		            // RFC7450
		            amt: [new IPv6([0x2001, 0x3, 0, 0, 0, 0, 0, 0]), 32],
		            as112v6: [
		                [new IPv6([0x2001, 0x4, 0x112, 0, 0, 0, 0, 0]), 48],
		                [new IPv6([0x2620, 0x4f, 0x8000, 0, 0, 0, 0, 0]), 48],
		            ],
		            deprecated: [new IPv6([0x2001, 0x10, 0, 0, 0, 0, 0, 0]), 28],
		            orchid2: [new IPv6([0x2001, 0x20, 0, 0, 0, 0, 0, 0]), 28],
		            droneRemoteIdProtocolEntityTags: [new IPv6([0x2001, 0x30, 0, 0, 0, 0, 0, 0]), 28],
		            reserved: [
		                // RFC3849
		                [new IPv6([0x2001, 0, 0, 0, 0, 0, 0, 0]), 23],
		                // RFC2928
		                [new IPv6([0x2001, 0xdb8, 0, 0, 0, 0, 0, 0]), 32],
		            ],
		        };

		        // Checks if this address is an IPv4-mapped IPv6 address.
		        IPv6.prototype.isIPv4MappedAddress = function () {
		            return this.range() === 'ipv4Mapped';
		        };

		        // The 'kind' method exists on both IPv4 and IPv6 classes.
		        IPv6.prototype.kind = function () {
		            return 'ipv6';
		        };

		        // Checks if this address matches other one within given CIDR range.
		        IPv6.prototype.match = function (other, cidrRange) {
		            let ref;

		            if (cidrRange === undefined) {
		                ref = other;
		                other = ref[0];
		                cidrRange = ref[1];
		            }

		            if (other.kind() !== 'ipv6') {
		                throw new Error('ipaddr: cannot match ipv6 address with non-ipv6 one');
		            }

		            return matchCIDR(this.parts, other.parts, 16, cidrRange);
		        };

		        // returns a number of leading ones in IPv6 address, making sure that
		        // the rest is a solid sequence of 0's (valid netmask)
		        // returns either the CIDR length or null if mask is not valid
		        IPv6.prototype.prefixLengthFromSubnetMask = function () {
		            let cidr = 0;
		            // non-zero encountered stop scanning for zeroes
		            let stop = false;
		            // number of zeroes in octet
		            const zerotable = {
		                0: 16,
		                32768: 15,
		                49152: 14,
		                57344: 13,
		                61440: 12,
		                63488: 11,
		                64512: 10,
		                65024: 9,
		                65280: 8,
		                65408: 7,
		                65472: 6,
		                65504: 5,
		                65520: 4,
		                65528: 3,
		                65532: 2,
		                65534: 1,
		                65535: 0
		            };
		            let part, zeros;

		            for (let i = 7; i >= 0; i -= 1) {
		                part = this.parts[i];
		                if (part in zerotable) {
		                    zeros = zerotable[part];
		                    if (stop && zeros !== 0) {
		                        return null;
		                    }

		                    if (zeros !== 16) {
		                        stop = true;
		                    }

		                    cidr += zeros;
		                } else {
		                    return null;
		                }
		            }

		            return 128 - cidr;
		        };


		        // Checks if the address corresponds to one of the special ranges.
		        IPv6.prototype.range = function () {
		            return ipaddr.subnetMatch(this, this.SpecialRanges);
		        };

		        // Returns an array of byte-sized values in network order (MSB first)
		        IPv6.prototype.toByteArray = function () {
		            let part;
		            const bytes = [];
		            const ref = this.parts;
		            for (let i = 0; i < ref.length; i++) {
		                part = ref[i];
		                bytes.push(part >> 8);
		                bytes.push(part & 0xff);
		            }

		            return bytes;
		        };

		        // Returns the address in expanded format with all zeroes included, like
		        // 2001:0db8:0008:0066:0000:0000:0000:0001
		        IPv6.prototype.toFixedLengthString = function () {
		            const addr = ((function () {
		                const results = [];
		                for (let i = 0; i < this.parts.length; i++) {
		                    results.push(padPart(this.parts[i].toString(16), 4));
		                }

		                return results;
		            }).call(this)).join(':');

		            let suffix = '';

		            if (this.zoneId) {
		                suffix = `%${this.zoneId}`;
		            }

		            return addr + suffix;
		        };

		        // Converts this address to IPv4 address if it is an IPv4-mapped IPv6 address.
		        // Throws an error otherwise.
		        IPv6.prototype.toIPv4Address = function () {
		            if (!this.isIPv4MappedAddress()) {
		                throw new Error('ipaddr: trying to convert a generic ipv6 address to ipv4');
		            }

		            const ref = this.parts.slice(-2);
		            const high = ref[0];
		            const low = ref[1];

		            return new ipaddr.IPv4([high >> 8, high & 0xff, low >> 8, low & 0xff]);
		        };

		        // Returns the address in expanded format with all zeroes included, like
		        // 2001:db8:8:66:0:0:0:1
		        //
		        // Deprecated: use toFixedLengthString() instead.
		        IPv6.prototype.toNormalizedString = function () {
		            const addr = ((function () {
		                const results = [];

		                for (let i = 0; i < this.parts.length; i++) {
		                    results.push(this.parts[i].toString(16));
		                }

		                return results;
		            }).call(this)).join(':');

		            let suffix = '';

		            if (this.zoneId) {
		                suffix = `%${this.zoneId}`;
		            }

		            return addr + suffix;
		        };

		        // Returns the address in compact, human-readable format like
		        // 2001:db8:8:66::1
		        // in line with RFC 5952 (see https://tools.ietf.org/html/rfc5952#section-4)
		        IPv6.prototype.toRFC5952String = function () {
		            const regex = /((^|:)(0(:|$)){2,})/g;
		            const string = this.toNormalizedString();
		            let bestMatchIndex = 0;
		            let bestMatchLength = -1;
		            let match;

		            while ((match = regex.exec(string))) {
		                if (match[0].length > bestMatchLength) {
		                    bestMatchIndex = match.index;
		                    bestMatchLength = match[0].length;
		                }
		            }

		            if (bestMatchLength < 0) {
		                return string;
		            }

		            return `${string.substring(0, bestMatchIndex)}::${string.substring(bestMatchIndex + bestMatchLength)}`;
		        };

		        // Returns the address in compact, human-readable format like
		        // 2001:db8:8:66::1
		        // Calls toRFC5952String under the hood.
		        IPv6.prototype.toString = function () {
		            return this.toRFC5952String();
		        };

		        return IPv6;

		    })();

		    // A utility function to return broadcast address given the IPv6 interface and prefix length in CIDR notation
		    ipaddr.IPv6.broadcastAddressFromCIDR = function (string) {
		        try {
		            const cidr = this.parseCIDR(string);
		            const ipInterfaceOctets = cidr[0].toByteArray();
		            const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
		            const octets = [];
		            let i = 0;
		            while (i < 16) {
		                // Broadcast address is bitwise OR between ip interface and inverted mask
		                octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
		                i++;
		            }

		            return new this(octets);
		        } catch (e) {
		            throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);
		        }
		    };

		    // Checks if a given string is formatted like IPv6 address.
		    ipaddr.IPv6.isIPv6 = function (string) {
		        return this.parser(string) !== null;
		    };

		    // Checks to see if string is a valid IPv6 Address
		    ipaddr.IPv6.isValid = function (string) {

		        // Since IPv6.isValid is always called first, this shortcut
		        // provides a substantial performance gain.
		        if (typeof string === 'string' && string.indexOf(':') === -1) {
		            return false;
		        }

		        try {
		            const addr = this.parser(string);
		            new this(addr.parts, addr.zoneId);
		            return true;
		        } catch (e) {
		            return false;
		        }
		    };

		    // Checks if a given string is a valid IPv6 address in CIDR notation.
		    ipaddr.IPv6.isValidCIDR = function (string) {

		        // See note in IPv6.isValid
		        if (typeof string === 'string' && string.indexOf(':') === -1) {
		            return false;
		        }

		        try {
		            this.parseCIDR(string);
		            return true;
		        } catch (e) {
		            return false;
		        }
		    };

		    // A utility function to return network address given the IPv6 interface and prefix length in CIDR notation
		    ipaddr.IPv6.networkAddressFromCIDR = function (string) {
		        let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;

		        try {
		            cidr = this.parseCIDR(string);
		            ipInterfaceOctets = cidr[0].toByteArray();
		            subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
		            octets = [];
		            i = 0;
		            while (i < 16) {
		                // Network address is bitwise AND between ip interface and mask
		                octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
		                i++;
		            }

		            return new this(octets);
		        } catch (e) {
		            throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);
		        }
		    };

		    // Tries to parse and validate a string with IPv6 address.
		    // Throws an error if it fails.
		    ipaddr.IPv6.parse = function (string) {
		        const addr = this.parser(string);

		        if (addr.parts === null) {
		            throw new Error('ipaddr: string is not formatted like an IPv6 Address');
		        }

		        return new this(addr.parts, addr.zoneId);
		    };

		    ipaddr.IPv6.parseCIDR = function (string) {
		        let maskLength, match, parsed;

		        if ((match = string.match(/^(.+)\/(\d+)$/))) {
		            maskLength = parseInt(match[2]);
		            if (maskLength >= 0 && maskLength <= 128) {
		                parsed = [this.parse(match[1]), maskLength];
		                Object.defineProperty(parsed, 'toString', {
		                    value: function () {
		                        return this.join('/');
		                    }
		                });
		                return parsed;
		            }
		        }

		        throw new Error('ipaddr: string is not formatted like an IPv6 CIDR range');
		    };

		    // Parse an IPv6 address.
		    ipaddr.IPv6.parser = function (string) {
		        let addr, i, match, octet, octets, zoneId;

		        if ((match = string.match(ipv6Regexes.deprecatedTransitional))) {
		            return this.parser(`::ffff:${match[1]}`);
		        }
		        if (ipv6Regexes.native.test(string)) {
		            return expandIPv6(string, 8);
		        }
		        if ((match = string.match(ipv6Regexes.transitional))) {
		            zoneId = match[6] || '';
		            addr = match[1];
		            if (!match[1].endsWith('::')) {
		                addr = addr.slice(0, -1);
		            }
		            addr = expandIPv6(addr + zoneId, 6);
		            if (addr.parts) {
		                octets = [
		                    parseInt(match[2]),
		                    parseInt(match[3]),
		                    parseInt(match[4]),
		                    parseInt(match[5])
		                ];
		                for (i = 0; i < octets.length; i++) {
		                    octet = octets[i];
		                    if (!((0 <= octet && octet <= 255))) {
		                        return null;
		                    }
		                }

		                addr.parts.push(octets[0] << 8 | octets[1]);
		                addr.parts.push(octets[2] << 8 | octets[3]);
		                return {
		                    parts: addr.parts,
		                    zoneId: addr.zoneId
		                };
		            }
		        }

		        return null;
		    };

		    // A utility function to return subnet mask in IPv6 format given the prefix length
		    ipaddr.IPv6.subnetMaskFromPrefixLength = function (prefix) {
		        prefix = parseInt(prefix);
		        if (prefix < 0 || prefix > 128) {
		            throw new Error('ipaddr: invalid IPv6 prefix length');
		        }

		        const octets = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
		        let j = 0;
		        const filledOctetCount = Math.floor(prefix / 8);

		        while (j < filledOctetCount) {
		            octets[j] = 255;
		            j++;
		        }

		        if (filledOctetCount < 16) {
		            octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - (prefix % 8);
		        }

		        return new this(octets);
		    };

		    // Try to parse an array in network order (MSB first) for IPv4 and IPv6
		    ipaddr.fromByteArray = function (bytes) {
		        const length = bytes.length;

		        if (length === 4) {
		            return new ipaddr.IPv4(bytes);
		        } else if (length === 16) {
		            return new ipaddr.IPv6(bytes);
		        } else {
		            throw new Error('ipaddr: the binary input is neither an IPv6 nor IPv4 address');
		        }
		    };

		    // Checks if the address is valid IP address
		    ipaddr.isValid = function (string) {
		        return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);
		    };

		    // Checks if the address is valid IP address in CIDR notation
		    ipaddr.isValidCIDR = function (string) {
		        return ipaddr.IPv6.isValidCIDR(string) || ipaddr.IPv4.isValidCIDR(string);
		    };


		    // Attempts to parse an IP Address, first through IPv6 then IPv4.
		    // Throws an error if it could not be parsed.
		    ipaddr.parse = function (string) {
		        if (ipaddr.IPv6.isValid(string)) {
		            return ipaddr.IPv6.parse(string);
		        } else if (ipaddr.IPv4.isValid(string)) {
		            return ipaddr.IPv4.parse(string);
		        } else {
		            throw new Error('ipaddr: the address has neither IPv6 nor IPv4 format');
		        }
		    };

		    // Attempt to parse CIDR notation, first through IPv6 then IPv4.
		    // Throws an error if it could not be parsed.
		    ipaddr.parseCIDR = function (string) {
		        try {
		            return ipaddr.IPv6.parseCIDR(string);
		        } catch (e) {
		            try {
		                return ipaddr.IPv4.parseCIDR(string);
		            } catch (e2) {
		                throw new Error('ipaddr: the address has neither IPv6 nor IPv4 CIDR format');
		            }
		        }
		    };

		    // Parse an address and return plain IPv4 address if it is an IPv4-mapped address
		    ipaddr.process = function (string) {
		        const addr = this.parse(string);

		        if (addr.kind() === 'ipv6' && addr.isIPv4MappedAddress()) {
		            return addr.toIPv4Address();
		        } else {
		            return addr;
		        }
		    };

		    // An utility function to ease named range matching. See examples below.
		    // rangeList can contain both IPv4 and IPv6 subnet entries and will not throw errors
		    // on matching IPv4 addresses to IPv6 ranges or vice versa.
		    ipaddr.subnetMatch = function (address, rangeList, defaultName) {
		        let i, rangeName, rangeSubnets, subnet;

		        if (defaultName === undefined || defaultName === null) {
		            defaultName = 'unicast';
		        }

		        for (rangeName in rangeList) {
		            if (Object.prototype.hasOwnProperty.call(rangeList, rangeName)) {
		                rangeSubnets = rangeList[rangeName];
		                // ECMA5 Array.isArray isn't available everywhere
		                if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
		                    rangeSubnets = [rangeSubnets];
		                }

		                for (i = 0; i < rangeSubnets.length; i++) {
		                    subnet = rangeSubnets[i];
		                    if (address.kind() === subnet[0].kind() && address.match.apply(address, subnet)) {
		                        return rangeName;
		                    }
		                }
		            }
		        }

		        return defaultName;
		    };

		    // Export for both the CommonJS and browser-like environment
		    if (module.exports) {
		        module.exports = ipaddr;

		    } else {
		        root.ipaddr = ipaddr;
		    }

		}(ipaddr)); 
	} (ipaddr$1));
	return ipaddr$1.exports;
}

/*!
 * proxy-addr
 * Copyright(c) 2021 Fastify collaborators
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */

var hasRequiredProxyAddr;

function requireProxyAddr () {
	if (hasRequiredProxyAddr) return proxyAddr.exports;
	hasRequiredProxyAddr = 1;

	/**
	 * Module exports.
	 * @public
	 */

	proxyAddr.exports = proxyaddr;
	proxyAddr.exports.default = proxyaddr;
	proxyAddr.exports.proxyaddr = proxyaddr;
	proxyAddr.exports.all = alladdrs;
	proxyAddr.exports.compile = compile;

	/**
	 * Module dependencies.
	 * @private
	 */

	const forwarded = requireForwarded();
	const ipaddr = requireIpaddr();

	/**
	 * Variables.
	 * @private
	 */

	const DIGIT_REGEXP = /^\d+$/u;
	const isip = ipaddr.isValid;
	const parseip = ipaddr.parse;

	/**
	 * Pre-defined IP ranges.
	 * @private
	 */

	const IP_RANGES = {
	  linklocal: ['169.254.0.0/16', 'fe80::/10'],
	  loopback: ['127.0.0.1/8', '::1/128'],
	  uniquelocal: ['10.0.0.0/8', '172.16.0.0/12', '192.168.0.0/16', 'fc00::/7']
	};

	/**
	 * Get all addresses in the request, optionally stopping
	 * at the first untrusted.
	 *
	 * @param {Object} request
	 * @param {Function|Array|String} [trust]
	 * @public
	 */

	function alladdrs (req, trust) {
	  // get addresses
	  const addrs = forwarded(req);

	  if (!trust) {
	    // Return all addresses
	    return addrs
	  }

	  if (typeof trust !== 'function') {
	    trust = compile(trust);
	  }

	  /* eslint-disable no-var */
	  for (var i = 0; i < addrs.length - 1; i++) {
	    if (trust(addrs[i], i)) continue

	    addrs.length = i + 1;
	  }

	  return addrs
	}

	/**
	 * Compile argument into trust function.
	 *
	 * @param {Array|String} val
	 * @private
	 */

	function compile (val) {
	  if (!val) {
	    throw new TypeError('argument is required')
	  }

	  let trust;

	  if (typeof val === 'string') {
	    trust = [val];
	  } else if (Array.isArray(val)) {
	    trust = val.slice();
	  } else {
	    throw new TypeError('unsupported trust argument')
	  }

	  /* eslint-disable no-var */
	  for (var i = 0; i < trust.length; i++) {
	    val = trust[i];

	    if (!Object.prototype.hasOwnProperty.call(IP_RANGES, val)) {
	      continue
	    }

	    // Splice in pre-defined range
	    val = IP_RANGES[val];
	    trust.splice.apply(trust, [i, 1].concat(val));
	    i += val.length - 1;
	  }

	  return compileTrust(compileRangeSubnets(trust))
	}

	/**
	 * Compile `arr` elements into range subnets.
	 *
	 * @param {Array} arr
	 * @private
	 */

	function compileRangeSubnets (arr) {
	  const rangeSubnets = new Array(arr.length);

	  /* eslint-disable no-var */
	  for (var i = 0; i < arr.length; i++) {
	    rangeSubnets[i] = parseipNotation(arr[i]);
	  }

	  return rangeSubnets
	}

	/**
	 * Compile range subnet array into trust function.
	 *
	 * @param {Array} rangeSubnets
	 * @private
	 */

	function compileTrust (rangeSubnets) {
	  // Return optimized function based on length
	  const len = rangeSubnets.length;
	  return len === 0
	    ? trustNone
	    : len === 1
	      ? trustSingle(rangeSubnets[0])
	      : trustMulti(rangeSubnets)
	}

	/**
	 * Parse IP notation string into range subnet.
	 *
	 * @param {String} note
	 * @private
	 */

	function parseipNotation (note) {
	  const pos = note.lastIndexOf('/');
	  const str = pos !== -1
	    ? note.substring(0, pos)
	    : note;

	  if (!isip(str)) {
	    throw new TypeError('invalid IP address: ' + str)
	  }

	  let ip = parseip(str);

	  if (pos === -1 && ip.kind() === 'ipv6' && ip.isIPv4MappedAddress()) {
	    // Store as IPv4
	    ip = ip.toIPv4Address();
	  }

	  const max = ip.kind() === 'ipv6'
	    ? 128
	    : 32;

	  let range = pos !== -1
	    ? note.substring(pos + 1, note.length)
	    : null;

	  if (range === null) {
	    range = max;
	  } else if (DIGIT_REGEXP.test(range)) {
	    range = parseInt(range, 10);
	  } else if (ip.kind() === 'ipv4' && isip(range)) {
	    range = parseNetmask(range);
	  } else {
	    range = null;
	  }

	  if (range <= 0 || range > max) {
	    throw new TypeError('invalid range on address: ' + note)
	  }

	  return [ip, range]
	}

	/**
	 * Parse netmask string into CIDR range.
	 *
	 * @param {String} netmask
	 * @private
	 */

	function parseNetmask (netmask) {
	  const ip = parseip(netmask);
	  const kind = ip.kind();

	  return kind === 'ipv4'
	    ? ip.prefixLengthFromSubnetMask()
	    : null
	}

	/**
	 * Determine address of proxied request.
	 *
	 * @param {Object} request
	 * @param {Function|Array|String} trust
	 * @public
	 */

	function proxyaddr (req, trust) {
	  if (!req) {
	    throw new TypeError('req argument is required')
	  }

	  if (!trust) {
	    throw new TypeError('trust argument is required')
	  }

	  const addrs = alladdrs(req, trust);
	  const addr = addrs[addrs.length - 1];

	  return addr
	}

	/**
	 * Static trust function to trust nothing.
	 *
	 * @private
	 */

	function trustNone () {
	  return false
	}

	/**
	 * Compile trust function for multiple subnets.
	 *
	 * @param {Array} subnets
	 * @private
	 */

	function trustMulti (subnets) {
	  return function trust (addr) {
	    if (!isip(addr)) return false

	    const ip = parseip(addr);
	    let ipconv;
	    const kind = ip.kind();

	    /* eslint-disable no-var */
	    for (var i = 0; i < subnets.length; i++) {
	      const subnet = subnets[i];
	      const subnetip = subnet[0];
	      const subnetkind = subnetip.kind();
	      const subnetrange = subnet[1];
	      let trusted = ip;

	      if (kind !== subnetkind) {
	        if (subnetkind === 'ipv4' && !ip.isIPv4MappedAddress()) {
	          // Incompatible IP addresses
	          continue
	        }

	        if (!ipconv) {
	          // Convert IP to match subnet IP kind
	          ipconv = subnetkind === 'ipv4'
	            ? ip.toIPv4Address()
	            : ip.toIPv4MappedAddress();
	        }

	        trusted = ipconv;
	      }

	      if (trusted.match(subnetip, subnetrange)) {
	        return true
	      }
	    }

	    return false
	  }
	}

	/**
	 * Compile trust function for single subnet.
	 *
	 * @param {Object} subnet
	 * @private
	 */

	function trustSingle (subnet) {
	  const subnetip = subnet[0];
	  const subnetkind = subnetip.kind();
	  const subnetisipv4 = subnetkind === 'ipv4';
	  const subnetrange = subnet[1];

	  return function trust (addr) {
	    if (!isip(addr)) return false

	    let ip = parseip(addr);
	    const kind = ip.kind();

	    if (kind !== subnetkind) {
	      if (subnetisipv4 && !ip.isIPv4MappedAddress()) {
	        // Incompatible IP addresses
	        return false
	      }

	      // Convert IP to match subnet IP kind
	      ip = subnetisipv4
	        ? ip.toIPv4Address()
	        : ip.toIPv4MappedAddress();
	    }

	    return ip.match(subnetip, subnetrange)
	  }
	}
	return proxyAddr.exports;
}

var hasRequiredRequest$1;

function requireRequest$1 () {
	if (hasRequiredRequest$1) return request$1.exports;
	hasRequiredRequest$1 = 1;

	const proxyAddr = requireProxyAddr();
	const {
	  kHasBeenDecorated,
	  kSchemaBody,
	  kSchemaHeaders,
	  kSchemaParams,
	  kSchemaQuerystring,
	  kSchemaController,
	  kOptions,
	  kRequestCacheValidateFns,
	  kRouteContext,
	  kRequestOriginalUrl
	} = requireSymbols$1();
	const { FST_ERR_REQ_INVALID_VALIDATION_INVOCATION, FST_ERR_DEC_UNDECLARED } = requireErrors$2();
	const decorators = requireDecorate();

	const HTTP_PART_SYMBOL_MAP = {
	  body: kSchemaBody,
	  headers: kSchemaHeaders,
	  params: kSchemaParams,
	  querystring: kSchemaQuerystring,
	  query: kSchemaQuerystring
	};

	function Request (id, params, req, query, log, context) {
	  this.id = id;
	  this[kRouteContext] = context;
	  this.params = params;
	  this.raw = req;
	  this.query = query;
	  this.log = log;
	  this.body = undefined;
	}
	Request.props = [];

	function getTrustProxyFn (tp) {
	  if (typeof tp === 'function') {
	    return tp
	  }
	  if (tp === true) {
	    // Support trusting everything
	    return null
	  }
	  if (typeof tp === 'number') {
	    // Support trusting hop count
	    return function (a, i) { return i < tp }
	  }
	  if (typeof tp === 'string') {
	    // Support comma-separated tps
	    const values = tp.split(',').map(it => it.trim());
	    return proxyAddr.compile(values)
	  }
	  return proxyAddr.compile(tp)
	}

	function buildRequest (R, trustProxy) {
	  if (trustProxy) {
	    return buildRequestWithTrustProxy(R, trustProxy)
	  }

	  return buildRegularRequest(R)
	}

	function buildRegularRequest (R) {
	  const props = R.props.slice();
	  function _Request (id, params, req, query, log, context) {
	    this.id = id;
	    this[kRouteContext] = context;
	    this.params = params;
	    this.raw = req;
	    this.query = query;
	    this.log = log;
	    this.body = undefined;

	    let prop;
	    for (let i = 0; i < props.length; i++) {
	      prop = props[i];
	      this[prop.key] = prop.value;
	    }
	  }
	  Object.setPrototypeOf(_Request.prototype, R.prototype);
	  Object.setPrototypeOf(_Request, R);
	  _Request.props = props;
	  _Request.parent = R;

	  return _Request
	}

	function getLastEntryInMultiHeaderValue (headerValue) {
	  // we use the last one if the header is set more than once
	  const lastIndex = headerValue.lastIndexOf(',');
	  return lastIndex === -1 ? headerValue.trim() : headerValue.slice(lastIndex + 1).trim()
	}

	function buildRequestWithTrustProxy (R, trustProxy) {
	  const _Request = buildRegularRequest(R);
	  const proxyFn = getTrustProxyFn(trustProxy);

	  // This is a more optimized version of decoration
	  _Request[kHasBeenDecorated] = true;

	  Object.defineProperties(_Request.prototype, {
	    ip: {
	      get () {
	        const addrs = proxyAddr.all(this.raw, proxyFn);
	        return addrs[addrs.length - 1]
	      }
	    },
	    ips: {
	      get () {
	        return proxyAddr.all(this.raw, proxyFn)
	      }
	    },
	    host: {
	      get () {
	        if (this.ip !== undefined && this.headers['x-forwarded-host']) {
	          return getLastEntryInMultiHeaderValue(this.headers['x-forwarded-host'])
	        }
	        /**
	         * The last fallback supports the following cases:
	         * 1. http.requireHostHeader === false
	         * 2. HTTP/1.0 without a Host Header
	         * 3. Headers schema that may remove the Host Header
	         */
	        return this.headers.host ?? this.headers[':authority'] ?? ''
	      }
	    },
	    protocol: {
	      get () {
	        if (this.headers['x-forwarded-proto']) {
	          return getLastEntryInMultiHeaderValue(this.headers['x-forwarded-proto'])
	        }
	        if (this.socket) {
	          return this.socket.encrypted ? 'https' : 'http'
	        }
	      }
	    }
	  });

	  return _Request
	}

	function assertsRequestDecoration (request, name) {
	  if (!decorators.hasKey(request, name) && !decorators.exist(request, name)) {
	    throw new FST_ERR_DEC_UNDECLARED(name, 'request')
	  }
	}

	Object.defineProperties(Request.prototype, {
	  server: {
	    get () {
	      return this[kRouteContext].server
	    }
	  },
	  url: {
	    get () {
	      return this.raw.url
	    }
	  },
	  originalUrl: {
	    get () {
	      /* istanbul ignore else */
	      if (!this[kRequestOriginalUrl]) {
	        this[kRequestOriginalUrl] = this.raw.originalUrl || this.raw.url;
	      }
	      return this[kRequestOriginalUrl]
	    }
	  },
	  method: {
	    get () {
	      return this.raw.method
	    }
	  },
	  routeOptions: {
	    get () {
	      const context = this[kRouteContext];
	      const routeLimit = context._parserOptions.limit;
	      const serverLimit = context.server.initialConfig.bodyLimit;
	      const version = context.server.hasConstraintStrategy('version') ? this.raw.headers['accept-version'] : undefined;
	      const options = {
	        method: context.config?.method,
	        url: context.config?.url,
	        bodyLimit: (routeLimit || serverLimit),
	        attachValidation: context.attachValidation,
	        logLevel: context.logLevel,
	        exposeHeadRoute: context.exposeHeadRoute,
	        prefixTrailingSlash: context.prefixTrailingSlash,
	        handler: context.handler,
	        config: context.config,
	        schema: context.schema,
	        version
	      };

	      return options
	    }
	  },
	  is404: {
	    get () {
	      return this[kRouteContext].config?.url === undefined
	    }
	  },
	  socket: {
	    get () {
	      return this.raw.socket
	    }
	  },
	  ip: {
	    get () {
	      if (this.socket) {
	        return this.socket.remoteAddress
	      }
	    }
	  },
	  host: {
	    get () {
	      /**
	       * The last fallback supports the following cases:
	       * 1. http.requireHostHeader === false
	       * 2. HTTP/1.0 without a Host Header
	       * 3. Headers schema that may remove the Host Header
	       */
	      return this.raw.headers.host ?? this.raw.headers[':authority'] ?? ''
	    }
	  },
	  hostname: {
	    get () {
	      return this.host.split(':', 1)[0]
	    }
	  },
	  port: {
	    get () {
	      // first try taking port from host
	      const portFromHost = parseInt(this.host.split(':').slice(-1)[0]);
	      if (!isNaN(portFromHost)) {
	        return portFromHost
	      }
	      // now fall back to port from host/:authority header
	      const host = (this.headers.host ?? this.headers[':authority'] ?? '');
	      const portFromHeader = parseInt(host.split(':').slice(-1)[0]);
	      if (!isNaN(portFromHeader)) {
	        return portFromHeader
	      }
	      // fall back to null
	      return null
	    }
	  },
	  protocol: {
	    get () {
	      if (this.socket) {
	        return this.socket.encrypted ? 'https' : 'http'
	      }
	    }
	  },
	  headers: {
	    get () {
	      if (this.additionalHeaders) {
	        return Object.assign({}, this.raw.headers, this.additionalHeaders)
	      }
	      return this.raw.headers
	    },
	    set (headers) {
	      this.additionalHeaders = headers;
	    }
	  },
	  getValidationFunction: {
	    value: function (httpPartOrSchema) {
	      if (typeof httpPartOrSchema === 'string') {
	        const symbol = HTTP_PART_SYMBOL_MAP[httpPartOrSchema];
	        return this[kRouteContext][symbol]
	      } else if (typeof httpPartOrSchema === 'object') {
	        return this[kRouteContext][kRequestCacheValidateFns]?.get(httpPartOrSchema)
	      }
	    }
	  },
	  compileValidationSchema: {
	    value: function (schema, httpPart = null) {
	      const { method, url } = this;

	      if (this[kRouteContext][kRequestCacheValidateFns]?.has(schema)) {
	        return this[kRouteContext][kRequestCacheValidateFns].get(schema)
	      }

	      const validatorCompiler = this[kRouteContext].validatorCompiler ||
	        this.server[kSchemaController].validatorCompiler ||
	        (
	          // We compile the schemas if no custom validatorCompiler is provided
	          // nor set
	          this.server[kSchemaController].setupValidator(this.server[kOptions]) ||
	          this.server[kSchemaController].validatorCompiler
	        );

	      const validateFn = validatorCompiler({
	        schema,
	        method,
	        url,
	        httpPart
	      });

	      // We create a WeakMap to compile the schema only once
	      // Its done lazily to avoid add overhead by creating the WeakMap
	      // if it is not used
	      // TODO: Explore a central cache for all the schemas shared across
	      // encapsulated contexts
	      if (this[kRouteContext][kRequestCacheValidateFns] == null) {
	        this[kRouteContext][kRequestCacheValidateFns] = new WeakMap();
	      }

	      this[kRouteContext][kRequestCacheValidateFns].set(schema, validateFn);

	      return validateFn
	    }
	  },
	  validateInput: {
	    value: function (input, schema, httpPart) {
	      httpPart = typeof schema === 'string' ? schema : httpPart;

	      const symbol = (httpPart != null && typeof httpPart === 'string') && HTTP_PART_SYMBOL_MAP[httpPart];
	      let validate;

	      if (symbol) {
	        // Validate using the HTTP Request Part schema
	        validate = this[kRouteContext][symbol];
	      }

	      // We cannot compile if the schema is missed
	      if (validate == null && (schema == null ||
	        typeof schema !== 'object' ||
	        Array.isArray(schema))
	      ) {
	        throw new FST_ERR_REQ_INVALID_VALIDATION_INVOCATION(httpPart)
	      }

	      if (validate == null) {
	        if (this[kRouteContext][kRequestCacheValidateFns]?.has(schema)) {
	          validate = this[kRouteContext][kRequestCacheValidateFns].get(schema);
	        } else {
	          // We proceed to compile if there's no validate function yet
	          validate = this.compileValidationSchema(schema, httpPart);
	        }
	      }

	      return validate(input)
	    }
	  },
	  getDecorator: {
	    value: function (name) {
	      assertsRequestDecoration(this, name);

	      const decorator = this[name];
	      if (typeof decorator === 'function') {
	        return decorator.bind(this)
	      }

	      return decorator
	    }
	  },
	  setDecorator: {
	    value: function (name, value) {
	      assertsRequestDecoration(this, name);

	      this[name] = value;
	    }
	  }
	});

	request$1.exports = Request;
	request$1.exports.buildRequest = buildRequest;
	return request$1.exports;
}

var context;
var hasRequiredContext;

function requireContext () {
	if (hasRequiredContext) return context;
	hasRequiredContext = 1;

	const {
	  kFourOhFourContext,
	  kReplySerializerDefault,
	  kSchemaErrorFormatter,
	  kErrorHandler,
	  kChildLoggerFactory,
	  kOptions,
	  kReply,
	  kRequest,
	  kBodyLimit,
	  kLogLevel,
	  kContentTypeParser,
	  kRouteByFastify,
	  kRequestCacheValidateFns,
	  kReplyCacheSerializeFns
	} = requireSymbols$1();

	// Object that holds the context of every request
	// Every route holds an instance of this object.
	function Context ({
	  schema,
	  handler,
	  config,
	  requestIdLogLabel,
	  childLoggerFactory,
	  errorHandler,
	  bodyLimit,
	  logLevel,
	  logSerializers,
	  attachValidation,
	  validatorCompiler,
	  serializerCompiler,
	  replySerializer,
	  schemaErrorFormatter,
	  exposeHeadRoute,
	  prefixTrailingSlash,
	  server,
	  isFastify
	}) {
	  this.schema = schema;
	  this.handler = handler;
	  this.Reply = server[kReply];
	  this.Request = server[kRequest];
	  this.contentTypeParser = server[kContentTypeParser];
	  this.onRequest = null;
	  this.onSend = null;
	  this.onError = null;
	  this.onTimeout = null;
	  this.preHandler = null;
	  this.onResponse = null;
	  this.preSerialization = null;
	  this.onRequestAbort = null;
	  this.config = config;
	  this.errorHandler = errorHandler || server[kErrorHandler];
	  this.requestIdLogLabel = requestIdLogLabel || server[kOptions].requestIdLogLabel;
	  this.childLoggerFactory = childLoggerFactory || server[kChildLoggerFactory];
	  this._middie = null;
	  this._parserOptions = {
	    limit: bodyLimit || server[kBodyLimit]
	  };
	  this.exposeHeadRoute = exposeHeadRoute;
	  this.prefixTrailingSlash = prefixTrailingSlash;
	  this.logLevel = logLevel || server[kLogLevel];
	  this.logSerializers = logSerializers;
	  this[kFourOhFourContext] = null;
	  this.attachValidation = attachValidation;
	  this[kReplySerializerDefault] = replySerializer;
	  this.schemaErrorFormatter =
	    schemaErrorFormatter ||
	    server[kSchemaErrorFormatter] ||
	    defaultSchemaErrorFormatter;
	  this[kRouteByFastify] = isFastify;

	  this[kRequestCacheValidateFns] = null;
	  this[kReplyCacheSerializeFns] = null;
	  this.validatorCompiler = validatorCompiler || null;
	  this.serializerCompiler = serializerCompiler || null;

	  this.server = server;
	}

	function defaultSchemaErrorFormatter (errors, dataVar) {
	  let text = '';
	  const separator = ', ';

	  for (let i = 0; i !== errors.length; ++i) {
	    const e = errors[i];
	    text += dataVar + (e.instancePath || '') + ' ' + e.message + separator;
	  }
	  return new Error(text.slice(0, -separator.length))
	}

	context = Context;
	return context;
}

var contentTypeParser = {exports: {}};

var toadCache = {};

/**
 * toad-cache
 *
 * @copyright 2024 Igor Savin <kibertoad@gmail.com>
 * @license MIT
 * @version 3.7.0
 */

var hasRequiredToadCache;

function requireToadCache () {
	if (hasRequiredToadCache) return toadCache;
	hasRequiredToadCache = 1;

	class FifoMap {
	  constructor(max = 1000, ttlInMsecs = 0) {
	    if (isNaN(max) || max < 0) {
	      throw new Error('Invalid max value')
	    }

	    if (isNaN(ttlInMsecs) || ttlInMsecs < 0) {
	      throw new Error('Invalid ttl value')
	    }

	    this.first = null;
	    this.items = new Map();
	    this.last = null;
	    this.max = max;
	    this.ttl = ttlInMsecs;
	  }

	  get size() {
	    return this.items.size
	  }

	  clear() {
	    this.items = new Map();
	    this.first = null;
	    this.last = null;
	  }

	  delete(key) {
	    if (this.items.has(key)) {
	      const deletedItem = this.items.get(key);

	      this.items.delete(key);

	      if (deletedItem.prev !== null) {
	        deletedItem.prev.next = deletedItem.next;
	      }

	      if (deletedItem.next !== null) {
	        deletedItem.next.prev = deletedItem.prev;
	      }

	      if (this.first === deletedItem) {
	        this.first = deletedItem.next;
	      }

	      if (this.last === deletedItem) {
	        this.last = deletedItem.prev;
	      }
	    }
	  }

	  deleteMany(keys) {
	    for (var i = 0; i < keys.length; i++) {
	      this.delete(keys[i]);
	    }
	  }

	  evict() {
	    if (this.size > 0) {
	      const item = this.first;

	      this.items.delete(item.key);

	      if (this.size === 0) {
	        this.first = null;
	        this.last = null;
	      } else {
	        this.first = item.next;
	        this.first.prev = null;
	      }
	    }
	  }

	  expiresAt(key) {
	    if (this.items.has(key)) {
	      return this.items.get(key).expiry
	    }
	  }

	  get(key) {
	    if (this.items.has(key)) {
	      const item = this.items.get(key);

	      if (this.ttl > 0 && item.expiry <= Date.now()) {
	        this.delete(key);
	        return
	      }

	      return item.value
	    }
	  }

	  getMany(keys) {
	    const result = [];

	    for (var i = 0; i < keys.length; i++) {
	      result.push(this.get(keys[i]));
	    }

	    return result
	  }

	  keys() {
	    return this.items.keys()
	  }

	  set(key, value) {
	    // Replace existing item
	    if (this.items.has(key)) {
	      const item = this.items.get(key);
	      item.value = value;

	      item.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;

	      return
	    }

	    // Add new item
	    if (this.max > 0 && this.size === this.max) {
	      this.evict();
	    }

	    const item = {
	      expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
	      key: key,
	      prev: this.last,
	      next: null,
	      value,
	    };
	    this.items.set(key, item);

	    if (this.size === 1) {
	      this.first = item;
	    } else {
	      this.last.next = item;
	    }

	    this.last = item;
	  }
	}

	class LruMap {
	  constructor(max = 1000, ttlInMsecs = 0) {
	    if (isNaN(max) || max < 0) {
	      throw new Error('Invalid max value')
	    }

	    if (isNaN(ttlInMsecs) || ttlInMsecs < 0) {
	      throw new Error('Invalid ttl value')
	    }

	    this.first = null;
	    this.items = new Map();
	    this.last = null;
	    this.max = max;
	    this.ttl = ttlInMsecs;
	  }

	  get size() {
	    return this.items.size
	  }

	  bumpLru(item) {
	    if (this.last === item) {
	      return // Item is already the last one, no need to bump
	    }

	    const last = this.last;
	    const next = item.next;
	    const prev = item.prev;

	    if (this.first === item) {
	      this.first = next;
	    }

	    item.next = null;
	    item.prev = last;
	    last.next = item;

	    if (prev !== null) {
	      prev.next = next;
	    }

	    if (next !== null) {
	      next.prev = prev;
	    }

	    this.last = item;
	  }

	  clear() {
	    this.items = new Map();
	    this.first = null;
	    this.last = null;
	  }

	  delete(key) {
	    if (this.items.has(key)) {
	      const item = this.items.get(key);

	      this.items.delete(key);

	      if (item.prev !== null) {
	        item.prev.next = item.next;
	      }

	      if (item.next !== null) {
	        item.next.prev = item.prev;
	      }

	      if (this.first === item) {
	        this.first = item.next;
	      }

	      if (this.last === item) {
	        this.last = item.prev;
	      }
	    }
	  }

	  deleteMany(keys) {
	    for (var i = 0; i < keys.length; i++) {
	      this.delete(keys[i]);
	    }
	  }

	  evict() {
	    if (this.size > 0) {
	      const item = this.first;

	      this.items.delete(item.key);

	      if (this.size === 0) {
	        this.first = null;
	        this.last = null;
	      } else {
	        this.first = item.next;
	        this.first.prev = null;
	      }
	    }
	  }

	  expiresAt(key) {
	    if (this.items.has(key)) {
	      return this.items.get(key).expiry
	    }
	  }

	  get(key) {
	    if (this.items.has(key)) {
	      const item = this.items.get(key);

	      // Item has already expired
	      if (this.ttl > 0 && item.expiry <= Date.now()) {
	        this.delete(key);
	        return
	      }

	      // Item is still fresh
	      this.bumpLru(item);
	      return item.value
	    }
	  }

	  getMany(keys) {
	    const result = [];

	    for (var i = 0; i < keys.length; i++) {
	      result.push(this.get(keys[i]));
	    }

	    return result
	  }

	  keys() {
	    return this.items.keys()
	  }

	  set(key, value) {
	    // Replace existing item
	    if (this.items.has(key)) {
	      const item = this.items.get(key);
	      item.value = value;

	      item.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;

	      if (this.last !== item) {
	        this.bumpLru(item);
	      }

	      return
	    }

	    // Add new item
	    if (this.max > 0 && this.size === this.max) {
	      this.evict();
	    }

	    const item = {
	      expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
	      key: key,
	      prev: this.last,
	      next: null,
	      value,
	    };
	    this.items.set(key, item);

	    if (this.size === 1) {
	      this.first = item;
	    } else {
	      this.last.next = item;
	    }

	    this.last = item;
	  }
	}

	class LruObject {
	  constructor(max = 1000, ttlInMsecs = 0) {
	    if (isNaN(max) || max < 0) {
	      throw new Error('Invalid max value')
	    }

	    if (isNaN(ttlInMsecs) || ttlInMsecs < 0) {
	      throw new Error('Invalid ttl value')
	    }

	    this.first = null;
	    this.items = Object.create(null);
	    this.last = null;
	    this.size = 0;
	    this.max = max;
	    this.ttl = ttlInMsecs;
	  }

	  bumpLru(item) {
	    if (this.last === item) {
	      return // Item is already the last one, no need to bump
	    }

	    const last = this.last;
	    const next = item.next;
	    const prev = item.prev;

	    if (this.first === item) {
	      this.first = next;
	    }

	    item.next = null;
	    item.prev = last;
	    last.next = item;

	    if (prev !== null) {
	      prev.next = next;
	    }

	    if (next !== null) {
	      next.prev = prev;
	    }

	    this.last = item;
	  }

	  clear() {
	    this.items = Object.create(null);
	    this.first = null;
	    this.last = null;
	    this.size = 0;
	  }

	  delete(key) {
	    if (Object.prototype.hasOwnProperty.call(this.items, key)) {
	      const item = this.items[key];

	      delete this.items[key];
	      this.size--;

	      if (item.prev !== null) {
	        item.prev.next = item.next;
	      }

	      if (item.next !== null) {
	        item.next.prev = item.prev;
	      }

	      if (this.first === item) {
	        this.first = item.next;
	      }

	      if (this.last === item) {
	        this.last = item.prev;
	      }
	    }
	  }

	  deleteMany(keys) {
	    for (var i = 0; i < keys.length; i++) {
	      this.delete(keys[i]);
	    }
	  }

	  evict() {
	    if (this.size > 0) {
	      const item = this.first;

	      delete this.items[item.key];

	      if (--this.size === 0) {
	        this.first = null;
	        this.last = null;
	      } else {
	        this.first = item.next;
	        this.first.prev = null;
	      }
	    }
	  }

	  expiresAt(key) {
	    if (Object.prototype.hasOwnProperty.call(this.items, key)) {
	      return this.items[key].expiry
	    }
	  }

	  get(key) {
	    if (Object.prototype.hasOwnProperty.call(this.items, key)) {
	      const item = this.items[key];

	      // Item has already expired
	      if (this.ttl > 0 && item.expiry <= Date.now()) {
	        this.delete(key);
	        return
	      }

	      // Item is still fresh
	      this.bumpLru(item);
	      return item.value
	    }
	  }

	  getMany(keys) {
	    const result = [];

	    for (var i = 0; i < keys.length; i++) {
	      result.push(this.get(keys[i]));
	    }

	    return result
	  }

	  keys() {
	    return Object.keys(this.items)
	  }

	  set(key, value) {
	    // Replace existing item
	    if (Object.prototype.hasOwnProperty.call(this.items, key)) {
	      const item = this.items[key];
	      item.value = value;

	      item.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;

	      if (this.last !== item) {
	        this.bumpLru(item);
	      }

	      return
	    }

	    // Add new item
	    if (this.max > 0 && this.size === this.max) {
	      this.evict();
	    }

	    const item = {
	      expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
	      key: key,
	      prev: this.last,
	      next: null,
	      value,
	    };
	    this.items[key] = item;

	    if (++this.size === 1) {
	      this.first = item;
	    } else {
	      this.last.next = item;
	    }

	    this.last = item;
	  }
	}

	class HitStatisticsRecord {
	  constructor() {
	    this.records = {};
	  }

	  initForCache(cacheId, currentTimeStamp) {
	    this.records[cacheId] = {
	      [currentTimeStamp]: {
	        cacheSize: 0,
	        hits: 0,
	        falsyHits: 0,
	        emptyHits: 0,
	        misses: 0,
	        expirations: 0,
	        evictions: 0,
	        invalidateOne: 0,
	        invalidateAll: 0,
	        sets: 0,
	      },
	    };
	  }

	  resetForCache(cacheId) {
	    for (let key of Object.keys(this.records[cacheId])) {
	      this.records[cacheId][key] = {
	        cacheSize: 0,
	        hits: 0,
	        falsyHits: 0,
	        emptyHits: 0,
	        misses: 0,
	        expirations: 0,
	        evictions: 0,
	        invalidateOne: 0,
	        invalidateAll: 0,
	        sets: 0,
	      };
	    }
	  }

	  getStatistics() {
	    return this.records
	  }
	}

	/**
	 *
	 * @param {Date} date
	 * @returns {string}
	 */
	function getTimestamp(date) {
	  return `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}-${date
	    .getDate()
	    .toString()
	    .padStart(2, '0')}`
	}

	class HitStatistics {
	  constructor(cacheId, statisticTtlInHours, globalStatisticsRecord) {
	    this.cacheId = cacheId;
	    this.statisticTtlInHours = statisticTtlInHours;

	    this.collectionStart = new Date();
	    this.currentTimeStamp = getTimestamp(this.collectionStart);

	    this.records = globalStatisticsRecord || new HitStatisticsRecord();
	    this.records.initForCache(this.cacheId, this.currentTimeStamp);
	  }

	  get currentRecord() {
	    // safety net
	    /* c8 ignore next 14 */
	    if (!this.records.records[this.cacheId][this.currentTimeStamp]) {
	      this.records.records[this.cacheId][this.currentTimeStamp] = {
	        cacheSize: 0,
	        hits: 0,
	        falsyHits: 0,
	        emptyHits: 0,
	        misses: 0,
	        expirations: 0,
	        evictions: 0,
	        sets: 0,
	        invalidateOne: 0,
	        invalidateAll: 0,
	      };
	    }

	    return this.records.records[this.cacheId][this.currentTimeStamp]
	  }

	  hoursPassed() {
	    return (Date.now() - this.collectionStart) / 1000 / 60 / 60
	  }

	  addHit() {
	    this.archiveIfNeeded();
	    this.currentRecord.hits++;
	  }
	  addFalsyHit() {
	    this.archiveIfNeeded();
	    this.currentRecord.falsyHits++;
	  }

	  addEmptyHit() {
	    this.archiveIfNeeded();
	    this.currentRecord.emptyHits++;
	  }

	  addMiss() {
	    this.archiveIfNeeded();
	    this.currentRecord.misses++;
	  }

	  addEviction() {
	    this.archiveIfNeeded();
	    this.currentRecord.evictions++;
	  }

	  setCacheSize(currentSize) {
	    this.archiveIfNeeded();
	    this.currentRecord.cacheSize = currentSize;
	  }

	  addExpiration() {
	    this.archiveIfNeeded();
	    this.currentRecord.expirations++;
	  }

	  addSet() {
	    this.archiveIfNeeded();
	    this.currentRecord.sets++;
	  }

	  addInvalidateOne() {
	    this.archiveIfNeeded();
	    this.currentRecord.invalidateOne++;
	  }

	  addInvalidateAll() {
	    this.archiveIfNeeded();
	    this.currentRecord.invalidateAll++;
	  }

	  getStatistics() {
	    return this.records.getStatistics()
	  }

	  archiveIfNeeded() {
	    if (this.hoursPassed() >= this.statisticTtlInHours) {
	      this.collectionStart = new Date();
	      this.currentTimeStamp = getTimestamp(this.collectionStart);
	      this.records.initForCache(this.cacheId, this.currentTimeStamp);
	    }
	  }
	}

	class LruObjectHitStatistics extends LruObject {
	  constructor(max, ttlInMsecs, cacheId, globalStatisticsRecord, statisticTtlInHours) {
	    super(max || 1000, ttlInMsecs || 0);

	    if (!cacheId) {
	      throw new Error('Cache id is mandatory')
	    }

	    this.hitStatistics = new HitStatistics(
	      cacheId,
	      statisticTtlInHours !== undefined ? statisticTtlInHours : 24,
	      globalStatisticsRecord,
	    );
	  }

	  getStatistics() {
	    return this.hitStatistics.getStatistics()
	  }

	  set(key, value) {
	    super.set(key, value);
	    this.hitStatistics.addSet();
	    this.hitStatistics.setCacheSize(this.size);
	  }

	  evict() {
	    super.evict();
	    this.hitStatistics.addEviction();
	    this.hitStatistics.setCacheSize(this.size);
	  }

	  delete(key, isExpiration = false) {
	    super.delete(key);

	    if (!isExpiration) {
	      this.hitStatistics.addInvalidateOne();
	    }
	    this.hitStatistics.setCacheSize(this.size);
	  }

	  clear() {
	    super.clear();

	    this.hitStatistics.addInvalidateAll();
	    this.hitStatistics.setCacheSize(this.size);
	  }

	  get(key) {
	    if (Object.prototype.hasOwnProperty.call(this.items, key)) {
	      const item = this.items[key];

	      // Item has already expired
	      if (this.ttl > 0 && item.expiry <= Date.now()) {
	        this.delete(key, true);
	        this.hitStatistics.addExpiration();
	        return
	      }

	      // Item is still fresh
	      this.bumpLru(item);
	      if (!item.value) {
	        this.hitStatistics.addFalsyHit();
	      }
	      if (item.value === undefined || item.value === null || item.value === '') {
	        this.hitStatistics.addEmptyHit();
	      }
	      this.hitStatistics.addHit();
	      return item.value
	    }
	    this.hitStatistics.addMiss();
	  }
	}

	class FifoObject {
	  constructor(max = 1000, ttlInMsecs = 0) {
	    if (isNaN(max) || max < 0) {
	      throw new Error('Invalid max value')
	    }

	    if (isNaN(ttlInMsecs) || ttlInMsecs < 0) {
	      throw new Error('Invalid ttl value')
	    }

	    this.first = null;
	    this.items = Object.create(null);
	    this.last = null;
	    this.size = 0;
	    this.max = max;
	    this.ttl = ttlInMsecs;
	  }

	  clear() {
	    this.items = Object.create(null);
	    this.first = null;
	    this.last = null;
	    this.size = 0;
	  }

	  delete(key) {
	    if (Object.prototype.hasOwnProperty.call(this.items, key)) {
	      const deletedItem = this.items[key];

	      delete this.items[key];
	      this.size--;

	      if (deletedItem.prev !== null) {
	        deletedItem.prev.next = deletedItem.next;
	      }

	      if (deletedItem.next !== null) {
	        deletedItem.next.prev = deletedItem.prev;
	      }

	      if (this.first === deletedItem) {
	        this.first = deletedItem.next;
	      }

	      if (this.last === deletedItem) {
	        this.last = deletedItem.prev;
	      }
	    }
	  }

	  deleteMany(keys) {
	    for (var i = 0; i < keys.length; i++) {
	      this.delete(keys[i]);
	    }
	  }

	  evict() {
	    if (this.size > 0) {
	      const item = this.first;

	      delete this.items[item.key];

	      if (--this.size === 0) {
	        this.first = null;
	        this.last = null;
	      } else {
	        this.first = item.next;
	        this.first.prev = null;
	      }
	    }
	  }

	  expiresAt(key) {
	    if (Object.prototype.hasOwnProperty.call(this.items, key)) {
	      return this.items[key].expiry
	    }
	  }

	  get(key) {
	    if (Object.prototype.hasOwnProperty.call(this.items, key)) {
	      const item = this.items[key];

	      if (this.ttl > 0 && item.expiry <= Date.now()) {
	        this.delete(key);
	        return
	      }

	      return item.value
	    }
	  }

	  getMany(keys) {
	    const result = [];

	    for (var i = 0; i < keys.length; i++) {
	      result.push(this.get(keys[i]));
	    }

	    return result
	  }

	  keys() {
	    return Object.keys(this.items)
	  }

	  set(key, value) {
	    // Replace existing item
	    if (Object.prototype.hasOwnProperty.call(this.items, key)) {
	      const item = this.items[key];
	      item.value = value;

	      item.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;

	      return
	    }

	    // Add new item
	    if (this.max > 0 && this.size === this.max) {
	      this.evict();
	    }

	    const item = {
	      expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
	      key: key,
	      prev: this.last,
	      next: null,
	      value,
	    };
	    this.items[key] = item;

	    if (++this.size === 1) {
	      this.first = item;
	    } else {
	      this.last.next = item;
	    }

	    this.last = item;
	  }
	}

	toadCache.Fifo = FifoObject;
	toadCache.FifoMap = FifoMap;
	toadCache.FifoObject = FifoObject;
	toadCache.HitStatisticsRecord = HitStatisticsRecord;
	toadCache.Lru = LruObject;
	toadCache.LruHitStatistics = LruObjectHitStatistics;
	toadCache.LruMap = LruMap;
	toadCache.LruObject = LruObject;
	toadCache.LruObjectHitStatistics = LruObjectHitStatistics;
	return toadCache;
}

var secureJsonParse = {exports: {}};

var hasRequiredSecureJsonParse;

function requireSecureJsonParse () {
	if (hasRequiredSecureJsonParse) return secureJsonParse.exports;
	hasRequiredSecureJsonParse = 1;

	const hasBuffer = typeof Buffer !== 'undefined';
	const suspectProtoRx = /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*:/;
	const suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;

	function _parse (text, reviver, options) {
	  // Normalize arguments
	  if (options == null) {
	    if (reviver !== null && typeof reviver === 'object') {
	      options = reviver;
	      reviver = undefined;
	    }
	  }

	  if (hasBuffer && Buffer.isBuffer(text)) {
	    text = text.toString();
	  }

	  // BOM checker
	  if (text && text.charCodeAt(0) === 0xFEFF) {
	    text = text.slice(1);
	  }

	  // Parse normally, allowing exceptions
	  const obj = JSON.parse(text, reviver);

	  // Ignore null and non-objects
	  if (obj === null || typeof obj !== 'object') {
	    return obj
	  }

	  const protoAction = (options && options.protoAction) || 'error';
	  const constructorAction = (options && options.constructorAction) || 'error';

	  // options: 'error' (default) / 'remove' / 'ignore'
	  if (protoAction === 'ignore' && constructorAction === 'ignore') {
	    return obj
	  }

	  if (protoAction !== 'ignore' && constructorAction !== 'ignore') {
	    if (suspectProtoRx.test(text) === false && suspectConstructorRx.test(text) === false) {
	      return obj
	    }
	  } else if (protoAction !== 'ignore' && constructorAction === 'ignore') {
	    if (suspectProtoRx.test(text) === false) {
	      return obj
	    }
	  } else {
	    if (suspectConstructorRx.test(text) === false) {
	      return obj
	    }
	  }

	  // Scan result for proto keys
	  return filter(obj, { protoAction, constructorAction, safe: options && options.safe })
	}

	function filter (obj, { protoAction = 'error', constructorAction = 'error', safe } = {}) {
	  let next = [obj];

	  while (next.length) {
	    const nodes = next;
	    next = [];

	    for (const node of nodes) {
	      if (protoAction !== 'ignore' && Object.prototype.hasOwnProperty.call(node, '__proto__')) { // Avoid calling node.hasOwnProperty directly
	        if (safe === true) {
	          return null
	        } else if (protoAction === 'error') {
	          throw new SyntaxError('Object contains forbidden prototype property')
	        }

	        delete node.__proto__; // eslint-disable-line no-proto
	      }

	      if (constructorAction !== 'ignore' &&
	          Object.prototype.hasOwnProperty.call(node, 'constructor') &&
	          Object.prototype.hasOwnProperty.call(node.constructor, 'prototype')) { // Avoid calling node.hasOwnProperty directly
	        if (safe === true) {
	          return null
	        } else if (constructorAction === 'error') {
	          throw new SyntaxError('Object contains forbidden prototype property')
	        }

	        delete node.constructor;
	      }

	      for (const key in node) {
	        const value = node[key];
	        if (value && typeof value === 'object') {
	          next.push(value);
	        }
	      }
	    }
	  }
	  return obj
	}

	function parse (text, reviver, options) {
	  const { stackTraceLimit } = Error;
	  Error.stackTraceLimit = 0;
	  try {
	    return _parse(text, reviver, options)
	  } finally {
	    Error.stackTraceLimit = stackTraceLimit;
	  }
	}

	function safeParse (text, reviver) {
	  const { stackTraceLimit } = Error;
	  Error.stackTraceLimit = 0;
	  try {
	    return _parse(text, reviver, { safe: true })
	  } catch {
	    return undefined
	  } finally {
	    Error.stackTraceLimit = stackTraceLimit;
	  }
	}

	secureJsonParse.exports = parse;
	secureJsonParse.exports.default = parse;
	secureJsonParse.exports.parse = parse;
	secureJsonParse.exports.safeParse = safeParse;
	secureJsonParse.exports.scan = filter;
	return secureJsonParse.exports;
}

var hasRequiredContentTypeParser;

function requireContentTypeParser () {
	if (hasRequiredContentTypeParser) return contentTypeParser.exports;
	hasRequiredContentTypeParser = 1;
	(function (module) {

		const { AsyncResource } = require$$0$8;
		const { FifoMap: Fifo } = requireToadCache();
		const { parse: secureJsonParse } = requireSecureJsonParse();
		const {
		  kDefaultJsonParse,
		  kContentTypeParser,
		  kBodyLimit,
		  kRequestPayloadStream,
		  kState,
		  kTestInternals,
		  kReplyIsError,
		  kRouteContext
		} = requireSymbols$1();

		const {
		  FST_ERR_CTP_INVALID_TYPE,
		  FST_ERR_CTP_EMPTY_TYPE,
		  FST_ERR_CTP_ALREADY_PRESENT,
		  FST_ERR_CTP_INVALID_HANDLER,
		  FST_ERR_CTP_INVALID_PARSE_TYPE,
		  FST_ERR_CTP_BODY_TOO_LARGE,
		  FST_ERR_CTP_INVALID_MEDIA_TYPE,
		  FST_ERR_CTP_INVALID_CONTENT_LENGTH,
		  FST_ERR_CTP_EMPTY_JSON_BODY,
		  FST_ERR_CTP_INSTANCE_ALREADY_STARTED
		} = requireErrors$2();
		const { FSTSEC001 } = requireWarnings();

		function ContentTypeParser (bodyLimit, onProtoPoisoning, onConstructorPoisoning) {
		  this[kDefaultJsonParse] = getDefaultJsonParser(onProtoPoisoning, onConstructorPoisoning);
		  // using a map instead of a plain object to avoid prototype hijack attacks
		  this.customParsers = new Map();
		  this.customParsers.set('application/json', new Parser(true, false, bodyLimit, this[kDefaultJsonParse]));
		  this.customParsers.set('text/plain', new Parser(true, false, bodyLimit, defaultPlainTextParser));
		  this.parserList = ['application/json', 'text/plain'];
		  this.parserRegExpList = [];
		  this.cache = new Fifo(100);
		}

		ContentTypeParser.prototype.add = function (contentType, opts, parserFn) {
		  const contentTypeIsString = typeof contentType === 'string';

		  if (contentTypeIsString) {
		    contentType = contentType.trim().toLowerCase();
		    if (contentType.length === 0) throw new FST_ERR_CTP_EMPTY_TYPE()
		  } else if (!(contentType instanceof RegExp)) {
		    throw new FST_ERR_CTP_INVALID_TYPE()
		  }

		  if (typeof parserFn !== 'function') {
		    throw new FST_ERR_CTP_INVALID_HANDLER()
		  }

		  if (this.existingParser(contentType)) {
		    throw new FST_ERR_CTP_ALREADY_PRESENT(contentType)
		  }

		  if (opts.parseAs !== undefined) {
		    if (opts.parseAs !== 'string' && opts.parseAs !== 'buffer') {
		      throw new FST_ERR_CTP_INVALID_PARSE_TYPE(opts.parseAs)
		    }
		  }

		  const parser = new Parser(
		    opts.parseAs === 'string',
		    opts.parseAs === 'buffer',
		    opts.bodyLimit,
		    parserFn
		  );

		  if (contentType === '*') {
		    this.customParsers.set('', parser);
		  } else {
		    if (contentTypeIsString) {
		      this.parserList.unshift(contentType);
		      this.customParsers.set(contentType, parser);
		    } else {
		      validateRegExp(contentType);
		      this.parserRegExpList.unshift(contentType);
		      this.customParsers.set(contentType.toString(), parser);
		    }
		  }
		};

		ContentTypeParser.prototype.hasParser = function (contentType) {
		  if (typeof contentType === 'string') {
		    contentType = contentType.trim().toLowerCase();
		  } else {
		    if (!(contentType instanceof RegExp)) throw new FST_ERR_CTP_INVALID_TYPE()
		    contentType = contentType.toString();
		  }

		  return this.customParsers.has(contentType)
		};

		ContentTypeParser.prototype.existingParser = function (contentType) {
		  if (contentType === 'application/json' && this.customParsers.has(contentType)) {
		    return this.customParsers.get(contentType).fn !== this[kDefaultJsonParse]
		  }
		  if (contentType === 'text/plain' && this.customParsers.has(contentType)) {
		    return this.customParsers.get(contentType).fn !== defaultPlainTextParser
		  }

		  return this.hasParser(contentType)
		};

		ContentTypeParser.prototype.getParser = function (contentType) {
		  let parser = this.customParsers.get(contentType);
		  if (parser !== undefined) return parser
		  parser = this.cache.get(contentType);
		  if (parser !== undefined) return parser

		  const caseInsensitiveContentType = contentType.toLowerCase();
		  for (let i = 0; i !== this.parserList.length; ++i) {
		    const parserListItem = this.parserList[i];
		    if (
		      caseInsensitiveContentType.slice(0, parserListItem.length) === parserListItem &&
		      (
		        caseInsensitiveContentType.length === parserListItem.length ||
		        caseInsensitiveContentType.charCodeAt(parserListItem.length) === 59 /* `;` */ ||
		        caseInsensitiveContentType.charCodeAt(parserListItem.length) === 32 /* ` ` */
		      )
		    ) {
		      parser = this.customParsers.get(parserListItem);
		      this.cache.set(contentType, parser);
		      return parser
		    }
		  }

		  for (let j = 0; j !== this.parserRegExpList.length; ++j) {
		    const parserRegExp = this.parserRegExpList[j];
		    if (parserRegExp.test(contentType)) {
		      parser = this.customParsers.get(parserRegExp.toString());
		      this.cache.set(contentType, parser);
		      return parser
		    }
		  }

		  return this.customParsers.get('')
		};

		ContentTypeParser.prototype.removeAll = function () {
		  this.customParsers = new Map();
		  this.parserRegExpList = [];
		  this.parserList = [];
		  this.cache = new Fifo(100);
		};

		ContentTypeParser.prototype.remove = function (contentType) {
		  let parsers;

		  if (typeof contentType === 'string') {
		    contentType = contentType.trim().toLowerCase();
		    parsers = this.parserList;
		  } else {
		    if (!(contentType instanceof RegExp)) throw new FST_ERR_CTP_INVALID_TYPE()
		    contentType = contentType.toString();
		    parsers = this.parserRegExpList;
		  }

		  const removed = this.customParsers.delete(contentType);
		  const idx = parsers.findIndex(ct => ct.toString() === contentType);

		  if (idx > -1) {
		    parsers.splice(idx, 1);
		  }

		  return removed || idx > -1
		};

		ContentTypeParser.prototype.run = function (contentType, handler, request, reply) {
		  const parser = this.getParser(contentType);

		  if (parser === undefined) {
		    if (request.is404) {
		      handler(request, reply);
		    } else {
		      reply.send(new FST_ERR_CTP_INVALID_MEDIA_TYPE(contentType || undefined));
		    }

		    // Early return to avoid allocating an AsyncResource if it's not needed
		    return
		  }

		  const resource = new AsyncResource('content-type-parser:run', request);

		  if (parser.asString === true || parser.asBuffer === true) {
		    rawBody(
		      request,
		      reply,
		      reply[kRouteContext]._parserOptions,
		      parser,
		      done
		    );
		  } else {
		    const result = parser.fn(request, request[kRequestPayloadStream], done);

		    if (result && typeof result.then === 'function') {
		      result.then(body => done(null, body), done);
		    }
		  }

		  function done (error, body) {
		    // We cannot use resource.bind() because it is broken in node v12 and v14
		    resource.runInAsyncScope(() => {
		      resource.emitDestroy();
		      if (error) {
		        reply[kReplyIsError] = true;
		        reply.send(error);
		      } else {
		        request.body = body;
		        handler(request, reply);
		      }
		    });
		  }
		};

		function rawBody (request, reply, options, parser, done) {
		  const asString = parser.asString;
		  const limit = options.limit === null ? parser.bodyLimit : options.limit;
		  const contentLength = Number(request.headers['content-length']);

		  if (contentLength > limit) {
		    // We must close the connection as the client is going
		    // to send this data anyway
		    reply.header('connection', 'close');
		    reply.send(new FST_ERR_CTP_BODY_TOO_LARGE());
		    return
		  }

		  let receivedLength = 0;
		  let body = asString === true ? '' : [];

		  const payload = request[kRequestPayloadStream] || request.raw;

		  if (asString === true) {
		    payload.setEncoding('utf8');
		  }

		  payload.on('data', onData);
		  payload.on('end', onEnd);
		  payload.on('error', onEnd);
		  payload.resume();

		  function onData (chunk) {
		    receivedLength += chunk.length;
		    const { receivedEncodedLength = 0 } = payload;
		    // The resulting body length must not exceed bodyLimit (see "zip bomb").
		    // The case when encoded length is larger than received length is rather theoretical,
		    // unless the stream returned by preParsing hook is broken and reports wrong value.
		    if (receivedLength > limit || receivedEncodedLength > limit) {
		      payload.removeListener('data', onData);
		      payload.removeListener('end', onEnd);
		      payload.removeListener('error', onEnd);
		      reply.send(new FST_ERR_CTP_BODY_TOO_LARGE());
		      return
		    }

		    if (asString === true) {
		      body += chunk;
		    } else {
		      body.push(chunk);
		    }
		  }

		  function onEnd (err) {
		    payload.removeListener('data', onData);
		    payload.removeListener('end', onEnd);
		    payload.removeListener('error', onEnd);

		    if (err !== undefined) {
		      if (!(typeof err.statusCode === 'number' && err.statusCode >= 400)) {
		        err.statusCode = 400;
		      }
		      reply[kReplyIsError] = true;
		      reply.code(err.statusCode).send(err);
		      return
		    }

		    if (asString === true) {
		      receivedLength = Buffer.byteLength(body);
		    }

		    if (!Number.isNaN(contentLength) && (payload.receivedEncodedLength || receivedLength) !== contentLength) {
		      reply.header('connection', 'close');
		      reply.send(new FST_ERR_CTP_INVALID_CONTENT_LENGTH());
		      return
		    }

		    if (asString === false) {
		      body = Buffer.concat(body);
		    }

		    const result = parser.fn(request, body, done);
		    if (result && typeof result.then === 'function') {
		      result.then(body => done(null, body), done);
		    }
		  }
		}

		function getDefaultJsonParser (onProtoPoisoning, onConstructorPoisoning) {
		  return defaultJsonParser

		  function defaultJsonParser (req, body, done) {
		    if (body.length === 0) {
		      done(new FST_ERR_CTP_EMPTY_JSON_BODY(), undefined);
		      return
		    }
		    try {
		      done(null, secureJsonParse(body, { protoAction: onProtoPoisoning, constructorAction: onConstructorPoisoning }));
		    } catch (err) {
		      err.statusCode = 400;
		      done(err, undefined);
		    }
		  }
		}

		function defaultPlainTextParser (req, body, done) {
		  done(null, body);
		}

		function Parser (asString, asBuffer, bodyLimit, fn) {
		  this.asString = asString;
		  this.asBuffer = asBuffer;
		  this.bodyLimit = bodyLimit;
		  this.fn = fn;
		}

		function buildContentTypeParser (c) {
		  const contentTypeParser = new ContentTypeParser();
		  contentTypeParser[kDefaultJsonParse] = c[kDefaultJsonParse];
		  contentTypeParser.customParsers = new Map(c.customParsers.entries());
		  contentTypeParser.parserList = c.parserList.slice();
		  contentTypeParser.parserRegExpList = c.parserRegExpList.slice();
		  return contentTypeParser
		}

		function addContentTypeParser (contentType, opts, parser) {
		  if (this[kState].started) {
		    throw new FST_ERR_CTP_INSTANCE_ALREADY_STARTED('addContentTypeParser')
		  }

		  if (typeof opts === 'function') {
		    parser = opts;
		    opts = {};
		  }

		  if (!opts) opts = {};
		  if (!opts.bodyLimit) opts.bodyLimit = this[kBodyLimit];

		  if (Array.isArray(contentType)) {
		    contentType.forEach((type) => this[kContentTypeParser].add(type, opts, parser));
		  } else {
		    this[kContentTypeParser].add(contentType, opts, parser);
		  }

		  return this
		}

		function hasContentTypeParser (contentType) {
		  return this[kContentTypeParser].hasParser(contentType)
		}

		function removeContentTypeParser (contentType) {
		  if (this[kState].started) {
		    throw new FST_ERR_CTP_INSTANCE_ALREADY_STARTED('removeContentTypeParser')
		  }

		  if (Array.isArray(contentType)) {
		    for (const type of contentType) {
		      this[kContentTypeParser].remove(type);
		    }
		  } else {
		    this[kContentTypeParser].remove(contentType);
		  }
		}

		function removeAllContentTypeParsers () {
		  if (this[kState].started) {
		    throw new FST_ERR_CTP_INSTANCE_ALREADY_STARTED('removeAllContentTypeParsers')
		  }

		  this[kContentTypeParser].removeAll();
		}

		function validateRegExp (regexp) {
		  // RegExp should either start with ^ or include ;?
		  // It can ensure the user is properly detect the essence
		  // MIME types.
		  if (regexp.source[0] !== '^' && regexp.source.includes(';?') === false) {
		    FSTSEC001(regexp.source);
		  }
		}

		module.exports = ContentTypeParser;
		module.exports.helpers = {
		  buildContentTypeParser,
		  addContentTypeParser,
		  hasContentTypeParser,
		  removeContentTypeParser,
		  removeAllContentTypeParsers
		};
		module.exports.defaultParsers = {
		  getDefaultJsonParser,
		  defaultTextParser: defaultPlainTextParser
		};
		module.exports[kTestInternals] = { rawBody }; 
	} (contentTypeParser));
	return contentTypeParser.exports;
}

var fastJsonStringifyCompiler = {exports: {}};

var standalone$3 = {};

var fastJsonStringify = {exports: {}};

var dist$5 = {};

var hasRequiredDist$4;

function requireDist$4 () {
	if (hasRequiredDist$4) return dist$5;
	hasRequiredDist$4 = 1;
	var has = Object.prototype.hasOwnProperty;

	function find(iter, tar, key) {
		for (key of iter.keys()) {
			if (dequal(key, tar)) return key;
		}
	}

	function dequal(foo, bar) {
		var ctor, len, tmp;
		if (foo === bar) return true;

		if (foo && bar && (ctor=foo.constructor) === bar.constructor) {
			if (ctor === Date) return foo.getTime() === bar.getTime();
			if (ctor === RegExp) return foo.toString() === bar.toString();

			if (ctor === Array) {
				if ((len=foo.length) === bar.length) {
					while (len-- && dequal(foo[len], bar[len]));
				}
				return len === -1;
			}

			if (ctor === Set) {
				if (foo.size !== bar.size) {
					return false;
				}
				for (len of foo) {
					tmp = len;
					if (tmp && typeof tmp === 'object') {
						tmp = find(bar, tmp);
						if (!tmp) return false;
					}
					if (!bar.has(tmp)) return false;
				}
				return true;
			}

			if (ctor === Map) {
				if (foo.size !== bar.size) {
					return false;
				}
				for (len of foo) {
					tmp = len[0];
					if (tmp && typeof tmp === 'object') {
						tmp = find(bar, tmp);
						if (!tmp) return false;
					}
					if (!dequal(len[1], bar.get(tmp))) {
						return false;
					}
				}
				return true;
			}

			if (ctor === ArrayBuffer) {
				foo = new Uint8Array(foo);
				bar = new Uint8Array(bar);
			} else if (ctor === DataView) {
				if ((len=foo.byteLength) === bar.byteLength) {
					while (len-- && foo.getInt8(len) === bar.getInt8(len));
				}
				return len === -1;
			}

			if (ArrayBuffer.isView(foo)) {
				if ((len=foo.byteLength) === bar.byteLength) {
					while (len-- && foo[len] === bar[len]);
				}
				return len === -1;
			}

			if (!ctor || typeof foo === 'object') {
				len = 0;
				for (ctor in foo) {
					if (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;
					if (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;
				}
				return Object.keys(bar).length === len;
			}
		}

		return foo !== foo && bar !== bar;
	}

	dist$5.dequal = dequal;
	return dist$5;
}

var jsonSchemaRefResolver;
var hasRequiredJsonSchemaRefResolver;

function requireJsonSchemaRefResolver () {
	if (hasRequiredJsonSchemaRefResolver) return jsonSchemaRefResolver;
	hasRequiredJsonSchemaRefResolver = 1;

	const { dequal: deepEqual } = requireDist$4();

	const jsonSchemaRefSymbol = Symbol.for('json-schema-ref');

	class RefResolver {
	  #schemas
	  #derefSchemas
	  #insertRefSymbol
	  #allowEqualDuplicates
	  #cloneSchemaWithoutRefs

	  constructor (opts = {}) {
	    this.#schemas = {};
	    this.#derefSchemas = {};
	    this.#insertRefSymbol = opts.insertRefSymbol ?? false;
	    this.#allowEqualDuplicates = opts.allowEqualDuplicates ?? true;
	    this.#cloneSchemaWithoutRefs = opts.cloneSchemaWithoutRefs ?? false;
	  }

	  addSchema (schema, rootSchemaId, isRootSchema = true) {
	    if (isRootSchema) {
	      if (schema.$id !== undefined && schema.$id.charAt(0) !== '#') {
	        // Schema has an $id that is not an anchor
	        rootSchemaId = schema.$id;
	      } else {
	        // Schema has no $id or $id is an anchor
	        this.#insertSchemaBySchemaId(schema, rootSchemaId);
	      }
	    }

	    const schemaId = schema.$id;
	    if (schemaId !== undefined && typeof schemaId === 'string') {
	      if (schemaId.charAt(0) === '#') {
	        this.#insertSchemaByAnchor(schema, rootSchemaId, schemaId);
	      } else {
	        this.#insertSchemaBySchemaId(schema, schemaId);
	        rootSchemaId = schemaId;
	      }
	    }

	    const ref = schema.$ref;
	    if (ref !== undefined && typeof ref === 'string') {
	      const { refSchemaId, refJsonPointer } = this.#parseSchemaRef(ref, rootSchemaId);
	      this.#schemas[rootSchemaId].refs.push({
	        schemaId: refSchemaId,
	        jsonPointer: refJsonPointer
	      });
	    }

	    for (const key in schema) {
	      if (typeof schema[key] === 'object' && schema[key] !== null) {
	        this.addSchema(schema[key], rootSchemaId, false);
	      }
	    }
	  }

	  getSchema (schemaId, jsonPointer = '#') {
	    const schema = this.#schemas[schemaId];
	    if (schema === undefined) {
	      throw new Error(
	        `Cannot resolve ref "${schemaId}${jsonPointer}". Schema with id "${schemaId}" is not found.`
	      )
	    }
	    if (schema.anchors[jsonPointer] !== undefined) {
	      return schema.anchors[jsonPointer]
	    }
	    return getDataByJSONPointer(schema.schema, jsonPointer)
	  }

	  hasSchema (schemaId) {
	    return this.#schemas[schemaId] !== undefined
	  }

	  getSchemaRefs (schemaId) {
	    const schema = this.#schemas[schemaId];
	    if (schema === undefined) {
	      throw new Error(`Schema with id "${schemaId}" is not found.`)
	    }
	    return schema.refs
	  }

	  getSchemaDependencies (schemaId, dependencies = {}) {
	    const schema = this.#schemas[schemaId];

	    for (const ref of schema.refs) {
	      const dependencySchemaId = ref.schemaId;
	      if (
	        dependencySchemaId === schemaId ||
	        dependencies[dependencySchemaId] !== undefined
	      ) continue

	      dependencies[dependencySchemaId] = this.getSchema(dependencySchemaId);
	      this.getSchemaDependencies(dependencySchemaId, dependencies);
	    }

	    return dependencies
	  }

	  derefSchema (schemaId) {
	    if (this.#derefSchemas[schemaId] !== undefined) return

	    const schema = this.#schemas[schemaId];
	    if (schema === undefined) {
	      throw new Error(`Schema with id "${schemaId}" is not found.`)
	    }

	    if (!this.#cloneSchemaWithoutRefs && schema.refs.length === 0) {
	      this.#derefSchemas[schemaId] = {
	        schema: schema.schema,
	        anchors: schema.anchors
	      };
	    }

	    const refs = [];
	    this.#addDerefSchema(schema.schema, schemaId, true, refs);

	    const dependencies = this.getSchemaDependencies(schemaId);
	    for (const schemaId in dependencies) {
	      const schema = dependencies[schemaId];
	      this.#addDerefSchema(schema, schemaId, true, refs);
	    }

	    for (const ref of refs) {
	      const {
	        refSchemaId,
	        refJsonPointer
	      } = this.#parseSchemaRef(ref.ref, ref.sourceSchemaId);

	      const targetSchema = this.getDerefSchema(refSchemaId, refJsonPointer);
	      if (targetSchema === null) {
	        throw new Error(
	          `Cannot resolve ref "${ref.ref}". Ref "${refJsonPointer}" is not found in schema "${refSchemaId}".`
	        )
	      }

	      ref.targetSchema = targetSchema;
	      ref.targetSchemaId = refSchemaId;
	    }

	    for (const ref of refs) {
	      this.#resolveRef(ref, refs);
	    }
	  }

	  getDerefSchema (schemaId, jsonPointer = '#') {
	    let derefSchema = this.#derefSchemas[schemaId];
	    if (derefSchema === undefined) {
	      this.derefSchema(schemaId);
	      derefSchema = this.#derefSchemas[schemaId];
	    }
	    if (derefSchema.anchors[jsonPointer] !== undefined) {
	      return derefSchema.anchors[jsonPointer]
	    }
	    return getDataByJSONPointer(derefSchema.schema, jsonPointer)
	  }

	  #parseSchemaRef (ref, schemaId) {
	    const sharpIndex = ref.indexOf('#');
	    if (sharpIndex === -1) {
	      return { refSchemaId: ref, refJsonPointer: '#' }
	    }
	    if (sharpIndex === 0) {
	      return { refSchemaId: schemaId, refJsonPointer: ref }
	    }
	    return {
	      refSchemaId: ref.slice(0, sharpIndex),
	      refJsonPointer: ref.slice(sharpIndex)
	    }
	  }

	  #addDerefSchema (schema, rootSchemaId, isRootSchema, refs = []) {
	    const derefSchema = Array.isArray(schema) ? [...schema] : { ...schema };

	    if (isRootSchema) {
	      if (schema.$id !== undefined && schema.$id.charAt(0) !== '#') {
	        // Schema has an $id that is not an anchor
	        rootSchemaId = schema.$id;
	      } else {
	        // Schema has no $id or $id is an anchor
	        this.#insertDerefSchemaBySchemaId(derefSchema, rootSchemaId);
	      }
	    }

	    const schemaId = derefSchema.$id;
	    if (schemaId !== undefined && typeof schemaId === 'string') {
	      if (schemaId.charAt(0) === '#') {
	        this.#insertDerefSchemaByAnchor(derefSchema, rootSchemaId, schemaId);
	      } else {
	        this.#insertDerefSchemaBySchemaId(derefSchema, schemaId);
	        rootSchemaId = schemaId;
	      }
	    }

	    if (derefSchema.$ref !== undefined) {
	      refs.push({
	        ref: derefSchema.$ref,
	        sourceSchemaId: rootSchemaId,
	        sourceSchema: derefSchema
	      });
	    }

	    for (const key in derefSchema) {
	      const value = derefSchema[key];
	      if (typeof value === 'object' && value !== null) {
	        derefSchema[key] = this.#addDerefSchema(value, rootSchemaId, false, refs);
	      }
	    }

	    return derefSchema
	  }

	  #resolveRef (ref, refs) {
	    const { sourceSchema, targetSchema } = ref;

	    if (!sourceSchema.$ref) return
	    if (this.#insertRefSymbol) {
	      sourceSchema[jsonSchemaRefSymbol] = sourceSchema.$ref;
	    }

	    delete sourceSchema.$ref;

	    if (targetSchema.$ref) {
	      const targetSchemaRef = refs.find(ref => ref.sourceSchema === targetSchema);
	      this.#resolveRef(targetSchemaRef, refs);
	    }
	    for (const key in targetSchema) {
	      if (key === '$id') continue
	      if (sourceSchema[key] !== undefined) {
	        if (deepEqual(sourceSchema[key], targetSchema[key])) continue
	        throw new Error(
	          `Cannot resolve ref "${ref.ref}". Property "${key}" already exists in schema "${ref.sourceSchemaId}".`
	        )
	      }
	      sourceSchema[key] = targetSchema[key];
	    }
	    ref.isResolved = true;
	  }

	  #insertSchemaBySchemaId (schema, schemaId) {
	    const foundSchema = this.#schemas[schemaId];
	    if (foundSchema !== undefined) {
	      if (this.#allowEqualDuplicates && deepEqual(schema, foundSchema.schema)) return
	      throw new Error(`There is already another schema with id "${schemaId}".`)
	    }
	    this.#schemas[schemaId] = { schema, anchors: {}, refs: [] };
	  }

	  #insertSchemaByAnchor (schema, schemaId, anchor) {
	    const { anchors } = this.#schemas[schemaId];
	    if (anchors[anchor] !== undefined) {
	      throw new Error(`There is already another anchor "${anchor}" in schema "${schemaId}".`)
	    }
	    anchors[anchor] = schema;
	  }

	  #insertDerefSchemaBySchemaId (schema, schemaId) {
	    const foundSchema = this.#derefSchemas[schemaId];
	    if (foundSchema !== undefined) return

	    this.#derefSchemas[schemaId] = { schema, anchors: {} };
	  }

	  #insertDerefSchemaByAnchor (schema, schemaId, anchor) {
	    const { anchors } = this.#derefSchemas[schemaId];
	    anchors[anchor] = schema;
	  }
	}

	function getDataByJSONPointer (data, jsonPointer) {
	  const parts = jsonPointer.split('/');
	  let current = data;
	  for (const part of parts) {
	    if (part === '' || part === '#') continue
	    if (typeof current !== 'object' || current === null) {
	      return null
	    }
	    current = current[part];
	  }
	  return current ?? null
	}

	jsonSchemaRefResolver = { RefResolver };
	return jsonSchemaRefResolver;
}

var ajv = {exports: {}};

var core$1 = {};

var validate = {};

var boolSchema = {};

var errors$1 = {};

var codegen = {};

var code$2 = {};

var hasRequiredCode$1;

function requireCode$1 () {
	if (hasRequiredCode$1) return code$2;
	hasRequiredCode$1 = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
		// eslint-disable-next-line @typescript-eslint/no-extraneous-class
		class _CodeOrName {
		}
		exports._CodeOrName = _CodeOrName;
		exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
		class Name extends _CodeOrName {
		    constructor(s) {
		        super();
		        if (!exports.IDENTIFIER.test(s))
		            throw new Error("CodeGen: name must be a valid identifier");
		        this.str = s;
		    }
		    toString() {
		        return this.str;
		    }
		    emptyStr() {
		        return false;
		    }
		    get names() {
		        return { [this.str]: 1 };
		    }
		}
		exports.Name = Name;
		class _Code extends _CodeOrName {
		    constructor(code) {
		        super();
		        this._items = typeof code === "string" ? [code] : code;
		    }
		    toString() {
		        return this.str;
		    }
		    emptyStr() {
		        if (this._items.length > 1)
		            return false;
		        const item = this._items[0];
		        return item === "" || item === '""';
		    }
		    get str() {
		        var _a;
		        return ((_a = this._str) !== null && _a !== void 0 ? _a : (this._str = this._items.reduce((s, c) => `${s}${c}`, "")));
		    }
		    get names() {
		        var _a;
		        return ((_a = this._names) !== null && _a !== void 0 ? _a : (this._names = this._items.reduce((names, c) => {
		            if (c instanceof Name)
		                names[c.str] = (names[c.str] || 0) + 1;
		            return names;
		        }, {})));
		    }
		}
		exports._Code = _Code;
		exports.nil = new _Code("");
		function _(strs, ...args) {
		    const code = [strs[0]];
		    let i = 0;
		    while (i < args.length) {
		        addCodeArg(code, args[i]);
		        code.push(strs[++i]);
		    }
		    return new _Code(code);
		}
		exports._ = _;
		const plus = new _Code("+");
		function str(strs, ...args) {
		    const expr = [safeStringify(strs[0])];
		    let i = 0;
		    while (i < args.length) {
		        expr.push(plus);
		        addCodeArg(expr, args[i]);
		        expr.push(plus, safeStringify(strs[++i]));
		    }
		    optimize(expr);
		    return new _Code(expr);
		}
		exports.str = str;
		function addCodeArg(code, arg) {
		    if (arg instanceof _Code)
		        code.push(...arg._items);
		    else if (arg instanceof Name)
		        code.push(arg);
		    else
		        code.push(interpolate(arg));
		}
		exports.addCodeArg = addCodeArg;
		function optimize(expr) {
		    let i = 1;
		    while (i < expr.length - 1) {
		        if (expr[i] === plus) {
		            const res = mergeExprItems(expr[i - 1], expr[i + 1]);
		            if (res !== undefined) {
		                expr.splice(i - 1, 3, res);
		                continue;
		            }
		            expr[i++] = "+";
		        }
		        i++;
		    }
		}
		function mergeExprItems(a, b) {
		    if (b === '""')
		        return a;
		    if (a === '""')
		        return b;
		    if (typeof a == "string") {
		        if (b instanceof Name || a[a.length - 1] !== '"')
		            return;
		        if (typeof b != "string")
		            return `${a.slice(0, -1)}${b}"`;
		        if (b[0] === '"')
		            return a.slice(0, -1) + b.slice(1);
		        return;
		    }
		    if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
		        return `"${a}${b.slice(1)}`;
		    return;
		}
		function strConcat(c1, c2) {
		    return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str `${c1}${c2}`;
		}
		exports.strConcat = strConcat;
		// TODO do not allow arrays here
		function interpolate(x) {
		    return typeof x == "number" || typeof x == "boolean" || x === null
		        ? x
		        : safeStringify(Array.isArray(x) ? x.join(",") : x);
		}
		function stringify(x) {
		    return new _Code(safeStringify(x));
		}
		exports.stringify = stringify;
		function safeStringify(x) {
		    return JSON.stringify(x)
		        .replace(/\u2028/g, "\\u2028")
		        .replace(/\u2029/g, "\\u2029");
		}
		exports.safeStringify = safeStringify;
		function getProperty(key) {
		    return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _ `[${key}]`;
		}
		exports.getProperty = getProperty;
		//Does best effort to format the name properly
		function getEsmExportName(key) {
		    if (typeof key == "string" && exports.IDENTIFIER.test(key)) {
		        return new _Code(`${key}`);
		    }
		    throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
		}
		exports.getEsmExportName = getEsmExportName;
		function regexpCode(rx) {
		    return new _Code(rx.toString());
		}
		exports.regexpCode = regexpCode;
		
	} (code$2));
	return code$2;
}

var scope = {};

var hasRequiredScope;

function requireScope () {
	if (hasRequiredScope) return scope;
	hasRequiredScope = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
		const code_1 = requireCode$1();
		class ValueError extends Error {
		    constructor(name) {
		        super(`CodeGen: "code" for ${name} not defined`);
		        this.value = name.value;
		    }
		}
		var UsedValueState;
		(function (UsedValueState) {
		    UsedValueState[UsedValueState["Started"] = 0] = "Started";
		    UsedValueState[UsedValueState["Completed"] = 1] = "Completed";
		})(UsedValueState || (exports.UsedValueState = UsedValueState = {}));
		exports.varKinds = {
		    const: new code_1.Name("const"),
		    let: new code_1.Name("let"),
		    var: new code_1.Name("var"),
		};
		class Scope {
		    constructor({ prefixes, parent } = {}) {
		        this._names = {};
		        this._prefixes = prefixes;
		        this._parent = parent;
		    }
		    toName(nameOrPrefix) {
		        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
		    }
		    name(prefix) {
		        return new code_1.Name(this._newName(prefix));
		    }
		    _newName(prefix) {
		        const ng = this._names[prefix] || this._nameGroup(prefix);
		        return `${prefix}${ng.index++}`;
		    }
		    _nameGroup(prefix) {
		        var _a, _b;
		        if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || (this._prefixes && !this._prefixes.has(prefix))) {
		            throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
		        }
		        return (this._names[prefix] = { prefix, index: 0 });
		    }
		}
		exports.Scope = Scope;
		class ValueScopeName extends code_1.Name {
		    constructor(prefix, nameStr) {
		        super(nameStr);
		        this.prefix = prefix;
		    }
		    setValue(value, { property, itemIndex }) {
		        this.value = value;
		        this.scopePath = (0, code_1._) `.${new code_1.Name(property)}[${itemIndex}]`;
		    }
		}
		exports.ValueScopeName = ValueScopeName;
		const line = (0, code_1._) `\n`;
		class ValueScope extends Scope {
		    constructor(opts) {
		        super(opts);
		        this._values = {};
		        this._scope = opts.scope;
		        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
		    }
		    get() {
		        return this._scope;
		    }
		    name(prefix) {
		        return new ValueScopeName(prefix, this._newName(prefix));
		    }
		    value(nameOrPrefix, value) {
		        var _a;
		        if (value.ref === undefined)
		            throw new Error("CodeGen: ref must be passed in value");
		        const name = this.toName(nameOrPrefix);
		        const { prefix } = name;
		        const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
		        let vs = this._values[prefix];
		        if (vs) {
		            const _name = vs.get(valueKey);
		            if (_name)
		                return _name;
		        }
		        else {
		            vs = this._values[prefix] = new Map();
		        }
		        vs.set(valueKey, name);
		        const s = this._scope[prefix] || (this._scope[prefix] = []);
		        const itemIndex = s.length;
		        s[itemIndex] = value.ref;
		        name.setValue(value, { property: prefix, itemIndex });
		        return name;
		    }
		    getValue(prefix, keyOrRef) {
		        const vs = this._values[prefix];
		        if (!vs)
		            return;
		        return vs.get(keyOrRef);
		    }
		    scopeRefs(scopeName, values = this._values) {
		        return this._reduceValues(values, (name) => {
		            if (name.scopePath === undefined)
		                throw new Error(`CodeGen: name "${name}" has no value`);
		            return (0, code_1._) `${scopeName}${name.scopePath}`;
		        });
		    }
		    scopeCode(values = this._values, usedValues, getCode) {
		        return this._reduceValues(values, (name) => {
		            if (name.value === undefined)
		                throw new Error(`CodeGen: name "${name}" has no value`);
		            return name.value.code;
		        }, usedValues, getCode);
		    }
		    _reduceValues(values, valueCode, usedValues = {}, getCode) {
		        let code = code_1.nil;
		        for (const prefix in values) {
		            const vs = values[prefix];
		            if (!vs)
		                continue;
		            const nameSet = (usedValues[prefix] = usedValues[prefix] || new Map());
		            vs.forEach((name) => {
		                if (nameSet.has(name))
		                    return;
		                nameSet.set(name, UsedValueState.Started);
		                let c = valueCode(name);
		                if (c) {
		                    const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
		                    code = (0, code_1._) `${code}${def} ${name} = ${c};${this.opts._n}`;
		                }
		                else if ((c = getCode === null || getCode === void 0 ? void 0 : getCode(name))) {
		                    code = (0, code_1._) `${code}${c}${this.opts._n}`;
		                }
		                else {
		                    throw new ValueError(name);
		                }
		                nameSet.set(name, UsedValueState.Completed);
		            });
		        }
		        return code;
		    }
		}
		exports.ValueScope = ValueScope;
		
	} (scope));
	return scope;
}

var hasRequiredCodegen;

function requireCodegen () {
	if (hasRequiredCodegen) return codegen;
	hasRequiredCodegen = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
		const code_1 = requireCode$1();
		const scope_1 = requireScope();
		var code_2 = requireCode$1();
		Object.defineProperty(exports, "_", { enumerable: true, get: function () { return code_2._; } });
		Object.defineProperty(exports, "str", { enumerable: true, get: function () { return code_2.str; } });
		Object.defineProperty(exports, "strConcat", { enumerable: true, get: function () { return code_2.strConcat; } });
		Object.defineProperty(exports, "nil", { enumerable: true, get: function () { return code_2.nil; } });
		Object.defineProperty(exports, "getProperty", { enumerable: true, get: function () { return code_2.getProperty; } });
		Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return code_2.stringify; } });
		Object.defineProperty(exports, "regexpCode", { enumerable: true, get: function () { return code_2.regexpCode; } });
		Object.defineProperty(exports, "Name", { enumerable: true, get: function () { return code_2.Name; } });
		var scope_2 = requireScope();
		Object.defineProperty(exports, "Scope", { enumerable: true, get: function () { return scope_2.Scope; } });
		Object.defineProperty(exports, "ValueScope", { enumerable: true, get: function () { return scope_2.ValueScope; } });
		Object.defineProperty(exports, "ValueScopeName", { enumerable: true, get: function () { return scope_2.ValueScopeName; } });
		Object.defineProperty(exports, "varKinds", { enumerable: true, get: function () { return scope_2.varKinds; } });
		exports.operators = {
		    GT: new code_1._Code(">"),
		    GTE: new code_1._Code(">="),
		    LT: new code_1._Code("<"),
		    LTE: new code_1._Code("<="),
		    EQ: new code_1._Code("==="),
		    NEQ: new code_1._Code("!=="),
		    NOT: new code_1._Code("!"),
		    OR: new code_1._Code("||"),
		    AND: new code_1._Code("&&"),
		    ADD: new code_1._Code("+"),
		};
		class Node {
		    optimizeNodes() {
		        return this;
		    }
		    optimizeNames(_names, _constants) {
		        return this;
		    }
		}
		class Def extends Node {
		    constructor(varKind, name, rhs) {
		        super();
		        this.varKind = varKind;
		        this.name = name;
		        this.rhs = rhs;
		    }
		    render({ es5, _n }) {
		        const varKind = es5 ? scope_1.varKinds.var : this.varKind;
		        const rhs = this.rhs === undefined ? "" : ` = ${this.rhs}`;
		        return `${varKind} ${this.name}${rhs};` + _n;
		    }
		    optimizeNames(names, constants) {
		        if (!names[this.name.str])
		            return;
		        if (this.rhs)
		            this.rhs = optimizeExpr(this.rhs, names, constants);
		        return this;
		    }
		    get names() {
		        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
		    }
		}
		class Assign extends Node {
		    constructor(lhs, rhs, sideEffects) {
		        super();
		        this.lhs = lhs;
		        this.rhs = rhs;
		        this.sideEffects = sideEffects;
		    }
		    render({ _n }) {
		        return `${this.lhs} = ${this.rhs};` + _n;
		    }
		    optimizeNames(names, constants) {
		        if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)
		            return;
		        this.rhs = optimizeExpr(this.rhs, names, constants);
		        return this;
		    }
		    get names() {
		        const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
		        return addExprNames(names, this.rhs);
		    }
		}
		class AssignOp extends Assign {
		    constructor(lhs, op, rhs, sideEffects) {
		        super(lhs, rhs, sideEffects);
		        this.op = op;
		    }
		    render({ _n }) {
		        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
		    }
		}
		class Label extends Node {
		    constructor(label) {
		        super();
		        this.label = label;
		        this.names = {};
		    }
		    render({ _n }) {
		        return `${this.label}:` + _n;
		    }
		}
		class Break extends Node {
		    constructor(label) {
		        super();
		        this.label = label;
		        this.names = {};
		    }
		    render({ _n }) {
		        const label = this.label ? ` ${this.label}` : "";
		        return `break${label};` + _n;
		    }
		}
		class Throw extends Node {
		    constructor(error) {
		        super();
		        this.error = error;
		    }
		    render({ _n }) {
		        return `throw ${this.error};` + _n;
		    }
		    get names() {
		        return this.error.names;
		    }
		}
		class AnyCode extends Node {
		    constructor(code) {
		        super();
		        this.code = code;
		    }
		    render({ _n }) {
		        return `${this.code};` + _n;
		    }
		    optimizeNodes() {
		        return `${this.code}` ? this : undefined;
		    }
		    optimizeNames(names, constants) {
		        this.code = optimizeExpr(this.code, names, constants);
		        return this;
		    }
		    get names() {
		        return this.code instanceof code_1._CodeOrName ? this.code.names : {};
		    }
		}
		class ParentNode extends Node {
		    constructor(nodes = []) {
		        super();
		        this.nodes = nodes;
		    }
		    render(opts) {
		        return this.nodes.reduce((code, n) => code + n.render(opts), "");
		    }
		    optimizeNodes() {
		        const { nodes } = this;
		        let i = nodes.length;
		        while (i--) {
		            const n = nodes[i].optimizeNodes();
		            if (Array.isArray(n))
		                nodes.splice(i, 1, ...n);
		            else if (n)
		                nodes[i] = n;
		            else
		                nodes.splice(i, 1);
		        }
		        return nodes.length > 0 ? this : undefined;
		    }
		    optimizeNames(names, constants) {
		        const { nodes } = this;
		        let i = nodes.length;
		        while (i--) {
		            // iterating backwards improves 1-pass optimization
		            const n = nodes[i];
		            if (n.optimizeNames(names, constants))
		                continue;
		            subtractNames(names, n.names);
		            nodes.splice(i, 1);
		        }
		        return nodes.length > 0 ? this : undefined;
		    }
		    get names() {
		        return this.nodes.reduce((names, n) => addNames(names, n.names), {});
		    }
		}
		class BlockNode extends ParentNode {
		    render(opts) {
		        return "{" + opts._n + super.render(opts) + "}" + opts._n;
		    }
		}
		class Root extends ParentNode {
		}
		class Else extends BlockNode {
		}
		Else.kind = "else";
		class If extends BlockNode {
		    constructor(condition, nodes) {
		        super(nodes);
		        this.condition = condition;
		    }
		    render(opts) {
		        let code = `if(${this.condition})` + super.render(opts);
		        if (this.else)
		            code += "else " + this.else.render(opts);
		        return code;
		    }
		    optimizeNodes() {
		        super.optimizeNodes();
		        const cond = this.condition;
		        if (cond === true)
		            return this.nodes; // else is ignored here
		        let e = this.else;
		        if (e) {
		            const ns = e.optimizeNodes();
		            e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
		        }
		        if (e) {
		            if (cond === false)
		                return e instanceof If ? e : e.nodes;
		            if (this.nodes.length)
		                return this;
		            return new If(not(cond), e instanceof If ? [e] : e.nodes);
		        }
		        if (cond === false || !this.nodes.length)
		            return undefined;
		        return this;
		    }
		    optimizeNames(names, constants) {
		        var _a;
		        this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
		        if (!(super.optimizeNames(names, constants) || this.else))
		            return;
		        this.condition = optimizeExpr(this.condition, names, constants);
		        return this;
		    }
		    get names() {
		        const names = super.names;
		        addExprNames(names, this.condition);
		        if (this.else)
		            addNames(names, this.else.names);
		        return names;
		    }
		}
		If.kind = "if";
		class For extends BlockNode {
		}
		For.kind = "for";
		class ForLoop extends For {
		    constructor(iteration) {
		        super();
		        this.iteration = iteration;
		    }
		    render(opts) {
		        return `for(${this.iteration})` + super.render(opts);
		    }
		    optimizeNames(names, constants) {
		        if (!super.optimizeNames(names, constants))
		            return;
		        this.iteration = optimizeExpr(this.iteration, names, constants);
		        return this;
		    }
		    get names() {
		        return addNames(super.names, this.iteration.names);
		    }
		}
		class ForRange extends For {
		    constructor(varKind, name, from, to) {
		        super();
		        this.varKind = varKind;
		        this.name = name;
		        this.from = from;
		        this.to = to;
		    }
		    render(opts) {
		        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
		        const { name, from, to } = this;
		        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
		    }
		    get names() {
		        const names = addExprNames(super.names, this.from);
		        return addExprNames(names, this.to);
		    }
		}
		class ForIter extends For {
		    constructor(loop, varKind, name, iterable) {
		        super();
		        this.loop = loop;
		        this.varKind = varKind;
		        this.name = name;
		        this.iterable = iterable;
		    }
		    render(opts) {
		        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
		    }
		    optimizeNames(names, constants) {
		        if (!super.optimizeNames(names, constants))
		            return;
		        this.iterable = optimizeExpr(this.iterable, names, constants);
		        return this;
		    }
		    get names() {
		        return addNames(super.names, this.iterable.names);
		    }
		}
		class Func extends BlockNode {
		    constructor(name, args, async) {
		        super();
		        this.name = name;
		        this.args = args;
		        this.async = async;
		    }
		    render(opts) {
		        const _async = this.async ? "async " : "";
		        return `${_async}function ${this.name}(${this.args})` + super.render(opts);
		    }
		}
		Func.kind = "func";
		class Return extends ParentNode {
		    render(opts) {
		        return "return " + super.render(opts);
		    }
		}
		Return.kind = "return";
		class Try extends BlockNode {
		    render(opts) {
		        let code = "try" + super.render(opts);
		        if (this.catch)
		            code += this.catch.render(opts);
		        if (this.finally)
		            code += this.finally.render(opts);
		        return code;
		    }
		    optimizeNodes() {
		        var _a, _b;
		        super.optimizeNodes();
		        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
		        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
		        return this;
		    }
		    optimizeNames(names, constants) {
		        var _a, _b;
		        super.optimizeNames(names, constants);
		        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
		        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);
		        return this;
		    }
		    get names() {
		        const names = super.names;
		        if (this.catch)
		            addNames(names, this.catch.names);
		        if (this.finally)
		            addNames(names, this.finally.names);
		        return names;
		    }
		}
		class Catch extends BlockNode {
		    constructor(error) {
		        super();
		        this.error = error;
		    }
		    render(opts) {
		        return `catch(${this.error})` + super.render(opts);
		    }
		}
		Catch.kind = "catch";
		class Finally extends BlockNode {
		    render(opts) {
		        return "finally" + super.render(opts);
		    }
		}
		Finally.kind = "finally";
		class CodeGen {
		    constructor(extScope, opts = {}) {
		        this._values = {};
		        this._blockStarts = [];
		        this._constants = {};
		        this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
		        this._extScope = extScope;
		        this._scope = new scope_1.Scope({ parent: extScope });
		        this._nodes = [new Root()];
		    }
		    toString() {
		        return this._root.render(this.opts);
		    }
		    // returns unique name in the internal scope
		    name(prefix) {
		        return this._scope.name(prefix);
		    }
		    // reserves unique name in the external scope
		    scopeName(prefix) {
		        return this._extScope.name(prefix);
		    }
		    // reserves unique name in the external scope and assigns value to it
		    scopeValue(prefixOrName, value) {
		        const name = this._extScope.value(prefixOrName, value);
		        const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set());
		        vs.add(name);
		        return name;
		    }
		    getScopeValue(prefix, keyOrRef) {
		        return this._extScope.getValue(prefix, keyOrRef);
		    }
		    // return code that assigns values in the external scope to the names that are used internally
		    // (same names that were returned by gen.scopeName or gen.scopeValue)
		    scopeRefs(scopeName) {
		        return this._extScope.scopeRefs(scopeName, this._values);
		    }
		    scopeCode() {
		        return this._extScope.scopeCode(this._values);
		    }
		    _def(varKind, nameOrPrefix, rhs, constant) {
		        const name = this._scope.toName(nameOrPrefix);
		        if (rhs !== undefined && constant)
		            this._constants[name.str] = rhs;
		        this._leafNode(new Def(varKind, name, rhs));
		        return name;
		    }
		    // `const` declaration (`var` in es5 mode)
		    const(nameOrPrefix, rhs, _constant) {
		        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
		    }
		    // `let` declaration with optional assignment (`var` in es5 mode)
		    let(nameOrPrefix, rhs, _constant) {
		        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
		    }
		    // `var` declaration with optional assignment
		    var(nameOrPrefix, rhs, _constant) {
		        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
		    }
		    // assignment code
		    assign(lhs, rhs, sideEffects) {
		        return this._leafNode(new Assign(lhs, rhs, sideEffects));
		    }
		    // `+=` code
		    add(lhs, rhs) {
		        return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
		    }
		    // appends passed SafeExpr to code or executes Block
		    code(c) {
		        if (typeof c == "function")
		            c();
		        else if (c !== code_1.nil)
		            this._leafNode(new AnyCode(c));
		        return this;
		    }
		    // returns code for object literal for the passed argument list of key-value pairs
		    object(...keyValues) {
		        const code = ["{"];
		        for (const [key, value] of keyValues) {
		            if (code.length > 1)
		                code.push(",");
		            code.push(key);
		            if (key !== value || this.opts.es5) {
		                code.push(":");
		                (0, code_1.addCodeArg)(code, value);
		            }
		        }
		        code.push("}");
		        return new code_1._Code(code);
		    }
		    // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
		    if(condition, thenBody, elseBody) {
		        this._blockNode(new If(condition));
		        if (thenBody && elseBody) {
		            this.code(thenBody).else().code(elseBody).endIf();
		        }
		        else if (thenBody) {
		            this.code(thenBody).endIf();
		        }
		        else if (elseBody) {
		            throw new Error('CodeGen: "else" body without "then" body');
		        }
		        return this;
		    }
		    // `else if` clause - invalid without `if` or after `else` clauses
		    elseIf(condition) {
		        return this._elseNode(new If(condition));
		    }
		    // `else` clause - only valid after `if` or `else if` clauses
		    else() {
		        return this._elseNode(new Else());
		    }
		    // end `if` statement (needed if gen.if was used only with condition)
		    endIf() {
		        return this._endBlockNode(If, Else);
		    }
		    _for(node, forBody) {
		        this._blockNode(node);
		        if (forBody)
		            this.code(forBody).endFor();
		        return this;
		    }
		    // a generic `for` clause (or statement if `forBody` is passed)
		    for(iteration, forBody) {
		        return this._for(new ForLoop(iteration), forBody);
		    }
		    // `for` statement for a range of values
		    forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
		        const name = this._scope.toName(nameOrPrefix);
		        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
		    }
		    // `for-of` statement (in es5 mode replace with a normal for loop)
		    forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
		        const name = this._scope.toName(nameOrPrefix);
		        if (this.opts.es5) {
		            const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
		            return this.forRange("_i", 0, (0, code_1._) `${arr}.length`, (i) => {
		                this.var(name, (0, code_1._) `${arr}[${i}]`);
		                forBody(name);
		            });
		        }
		        return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
		    }
		    // `for-in` statement.
		    // With option `ownProperties` replaced with a `for-of` loop for object keys
		    forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
		        if (this.opts.ownProperties) {
		            return this.forOf(nameOrPrefix, (0, code_1._) `Object.keys(${obj})`, forBody);
		        }
		        const name = this._scope.toName(nameOrPrefix);
		        return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
		    }
		    // end `for` loop
		    endFor() {
		        return this._endBlockNode(For);
		    }
		    // `label` statement
		    label(label) {
		        return this._leafNode(new Label(label));
		    }
		    // `break` statement
		    break(label) {
		        return this._leafNode(new Break(label));
		    }
		    // `return` statement
		    return(value) {
		        const node = new Return();
		        this._blockNode(node);
		        this.code(value);
		        if (node.nodes.length !== 1)
		            throw new Error('CodeGen: "return" should have one node');
		        return this._endBlockNode(Return);
		    }
		    // `try` statement
		    try(tryBody, catchCode, finallyCode) {
		        if (!catchCode && !finallyCode)
		            throw new Error('CodeGen: "try" without "catch" and "finally"');
		        const node = new Try();
		        this._blockNode(node);
		        this.code(tryBody);
		        if (catchCode) {
		            const error = this.name("e");
		            this._currNode = node.catch = new Catch(error);
		            catchCode(error);
		        }
		        if (finallyCode) {
		            this._currNode = node.finally = new Finally();
		            this.code(finallyCode);
		        }
		        return this._endBlockNode(Catch, Finally);
		    }
		    // `throw` statement
		    throw(error) {
		        return this._leafNode(new Throw(error));
		    }
		    // start self-balancing block
		    block(body, nodeCount) {
		        this._blockStarts.push(this._nodes.length);
		        if (body)
		            this.code(body).endBlock(nodeCount);
		        return this;
		    }
		    // end the current self-balancing block
		    endBlock(nodeCount) {
		        const len = this._blockStarts.pop();
		        if (len === undefined)
		            throw new Error("CodeGen: not in self-balancing block");
		        const toClose = this._nodes.length - len;
		        if (toClose < 0 || (nodeCount !== undefined && toClose !== nodeCount)) {
		            throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
		        }
		        this._nodes.length = len;
		        return this;
		    }
		    // `function` heading (or definition if funcBody is passed)
		    func(name, args = code_1.nil, async, funcBody) {
		        this._blockNode(new Func(name, args, async));
		        if (funcBody)
		            this.code(funcBody).endFunc();
		        return this;
		    }
		    // end function definition
		    endFunc() {
		        return this._endBlockNode(Func);
		    }
		    optimize(n = 1) {
		        while (n-- > 0) {
		            this._root.optimizeNodes();
		            this._root.optimizeNames(this._root.names, this._constants);
		        }
		    }
		    _leafNode(node) {
		        this._currNode.nodes.push(node);
		        return this;
		    }
		    _blockNode(node) {
		        this._currNode.nodes.push(node);
		        this._nodes.push(node);
		    }
		    _endBlockNode(N1, N2) {
		        const n = this._currNode;
		        if (n instanceof N1 || (N2 && n instanceof N2)) {
		            this._nodes.pop();
		            return this;
		        }
		        throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
		    }
		    _elseNode(node) {
		        const n = this._currNode;
		        if (!(n instanceof If)) {
		            throw new Error('CodeGen: "else" without "if"');
		        }
		        this._currNode = n.else = node;
		        return this;
		    }
		    get _root() {
		        return this._nodes[0];
		    }
		    get _currNode() {
		        const ns = this._nodes;
		        return ns[ns.length - 1];
		    }
		    set _currNode(node) {
		        const ns = this._nodes;
		        ns[ns.length - 1] = node;
		    }
		}
		exports.CodeGen = CodeGen;
		function addNames(names, from) {
		    for (const n in from)
		        names[n] = (names[n] || 0) + (from[n] || 0);
		    return names;
		}
		function addExprNames(names, from) {
		    return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
		}
		function optimizeExpr(expr, names, constants) {
		    if (expr instanceof code_1.Name)
		        return replaceName(expr);
		    if (!canOptimize(expr))
		        return expr;
		    return new code_1._Code(expr._items.reduce((items, c) => {
		        if (c instanceof code_1.Name)
		            c = replaceName(c);
		        if (c instanceof code_1._Code)
		            items.push(...c._items);
		        else
		            items.push(c);
		        return items;
		    }, []));
		    function replaceName(n) {
		        const c = constants[n.str];
		        if (c === undefined || names[n.str] !== 1)
		            return n;
		        delete names[n.str];
		        return c;
		    }
		    function canOptimize(e) {
		        return (e instanceof code_1._Code &&
		            e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== undefined));
		    }
		}
		function subtractNames(names, from) {
		    for (const n in from)
		        names[n] = (names[n] || 0) - (from[n] || 0);
		}
		function not(x) {
		    return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._) `!${par(x)}`;
		}
		exports.not = not;
		const andCode = mappend(exports.operators.AND);
		// boolean AND (&&) expression with the passed arguments
		function and(...args) {
		    return args.reduce(andCode);
		}
		exports.and = and;
		const orCode = mappend(exports.operators.OR);
		// boolean OR (||) expression with the passed arguments
		function or(...args) {
		    return args.reduce(orCode);
		}
		exports.or = or;
		function mappend(op) {
		    return (x, y) => (x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._) `${par(x)} ${op} ${par(y)}`);
		}
		function par(x) {
		    return x instanceof code_1.Name ? x : (0, code_1._) `(${x})`;
		}
		
	} (codegen));
	return codegen;
}

var util$1 = {};

var hasRequiredUtil$1;

function requireUtil$1 () {
	if (hasRequiredUtil$1) return util$1;
	hasRequiredUtil$1 = 1;
	Object.defineProperty(util$1, "__esModule", { value: true });
	util$1.checkStrictMode = util$1.getErrorPath = util$1.Type = util$1.useFunc = util$1.setEvaluated = util$1.evaluatedPropsToName = util$1.mergeEvaluated = util$1.eachItem = util$1.unescapeJsonPointer = util$1.escapeJsonPointer = util$1.escapeFragment = util$1.unescapeFragment = util$1.schemaRefOrVal = util$1.schemaHasRulesButRef = util$1.schemaHasRules = util$1.checkUnknownRules = util$1.alwaysValidSchema = util$1.toHash = void 0;
	const codegen_1 = requireCodegen();
	const code_1 = requireCode$1();
	// TODO refactor to use Set
	function toHash(arr) {
	    const hash = {};
	    for (const item of arr)
	        hash[item] = true;
	    return hash;
	}
	util$1.toHash = toHash;
	function alwaysValidSchema(it, schema) {
	    if (typeof schema == "boolean")
	        return schema;
	    if (Object.keys(schema).length === 0)
	        return true;
	    checkUnknownRules(it, schema);
	    return !schemaHasRules(schema, it.self.RULES.all);
	}
	util$1.alwaysValidSchema = alwaysValidSchema;
	function checkUnknownRules(it, schema = it.schema) {
	    const { opts, self } = it;
	    if (!opts.strictSchema)
	        return;
	    if (typeof schema === "boolean")
	        return;
	    const rules = self.RULES.keywords;
	    for (const key in schema) {
	        if (!rules[key])
	            checkStrictMode(it, `unknown keyword: "${key}"`);
	    }
	}
	util$1.checkUnknownRules = checkUnknownRules;
	function schemaHasRules(schema, rules) {
	    if (typeof schema == "boolean")
	        return !schema;
	    for (const key in schema)
	        if (rules[key])
	            return true;
	    return false;
	}
	util$1.schemaHasRules = schemaHasRules;
	function schemaHasRulesButRef(schema, RULES) {
	    if (typeof schema == "boolean")
	        return !schema;
	    for (const key in schema)
	        if (key !== "$ref" && RULES.all[key])
	            return true;
	    return false;
	}
	util$1.schemaHasRulesButRef = schemaHasRulesButRef;
	function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
	    if (!$data) {
	        if (typeof schema == "number" || typeof schema == "boolean")
	            return schema;
	        if (typeof schema == "string")
	            return (0, codegen_1._) `${schema}`;
	    }
	    return (0, codegen_1._) `${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;
	}
	util$1.schemaRefOrVal = schemaRefOrVal;
	function unescapeFragment(str) {
	    return unescapeJsonPointer(decodeURIComponent(str));
	}
	util$1.unescapeFragment = unescapeFragment;
	function escapeFragment(str) {
	    return encodeURIComponent(escapeJsonPointer(str));
	}
	util$1.escapeFragment = escapeFragment;
	function escapeJsonPointer(str) {
	    if (typeof str == "number")
	        return `${str}`;
	    return str.replace(/~/g, "~0").replace(/\//g, "~1");
	}
	util$1.escapeJsonPointer = escapeJsonPointer;
	function unescapeJsonPointer(str) {
	    return str.replace(/~1/g, "/").replace(/~0/g, "~");
	}
	util$1.unescapeJsonPointer = unescapeJsonPointer;
	function eachItem(xs, f) {
	    if (Array.isArray(xs)) {
	        for (const x of xs)
	            f(x);
	    }
	    else {
	        f(xs);
	    }
	}
	util$1.eachItem = eachItem;
	function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName, }) {
	    return (gen, from, to, toName) => {
	        const res = to === undefined
	            ? from
	            : to instanceof codegen_1.Name
	                ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to)
	                : from instanceof codegen_1.Name
	                    ? (mergeToName(gen, to, from), from)
	                    : mergeValues(from, to);
	        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
	    };
	}
	util$1.mergeEvaluated = {
	    props: makeMergeEvaluated({
	        mergeNames: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true && ${from} !== undefined`, () => {
	            gen.if((0, codegen_1._) `${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._) `${to} || {}`).code((0, codegen_1._) `Object.assign(${to}, ${from})`));
	        }),
	        mergeToName: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true`, () => {
	            if (from === true) {
	                gen.assign(to, true);
	            }
	            else {
	                gen.assign(to, (0, codegen_1._) `${to} || {}`);
	                setEvaluated(gen, to, from);
	            }
	        }),
	        mergeValues: (from, to) => (from === true ? true : { ...from, ...to }),
	        resultToName: evaluatedPropsToName,
	    }),
	    items: makeMergeEvaluated({
	        mergeNames: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._) `${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
	        mergeToName: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._) `${to} > ${from} ? ${to} : ${from}`)),
	        mergeValues: (from, to) => (from === true ? true : Math.max(from, to)),
	        resultToName: (gen, items) => gen.var("items", items),
	    }),
	};
	function evaluatedPropsToName(gen, ps) {
	    if (ps === true)
	        return gen.var("props", true);
	    const props = gen.var("props", (0, codegen_1._) `{}`);
	    if (ps !== undefined)
	        setEvaluated(gen, props, ps);
	    return props;
	}
	util$1.evaluatedPropsToName = evaluatedPropsToName;
	function setEvaluated(gen, props, ps) {
	    Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._) `${props}${(0, codegen_1.getProperty)(p)}`, true));
	}
	util$1.setEvaluated = setEvaluated;
	const snippets = {};
	function useFunc(gen, f) {
	    return gen.scopeValue("func", {
	        ref: f,
	        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code)),
	    });
	}
	util$1.useFunc = useFunc;
	var Type;
	(function (Type) {
	    Type[Type["Num"] = 0] = "Num";
	    Type[Type["Str"] = 1] = "Str";
	})(Type || (util$1.Type = Type = {}));
	function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
	    // let path
	    if (dataProp instanceof codegen_1.Name) {
	        const isNumber = dataPropType === Type.Num;
	        return jsPropertySyntax
	            ? isNumber
	                ? (0, codegen_1._) `"[" + ${dataProp} + "]"`
	                : (0, codegen_1._) `"['" + ${dataProp} + "']"`
	            : isNumber
	                ? (0, codegen_1._) `"/" + ${dataProp}`
	                : (0, codegen_1._) `"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`; // TODO maybe use global escapePointer
	    }
	    return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
	}
	util$1.getErrorPath = getErrorPath;
	function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
	    if (!mode)
	        return;
	    msg = `strict mode: ${msg}`;
	    if (mode === true)
	        throw new Error(msg);
	    it.self.logger.warn(msg);
	}
	util$1.checkStrictMode = checkStrictMode;
	
	return util$1;
}

var names = {};

var hasRequiredNames;

function requireNames () {
	if (hasRequiredNames) return names;
	hasRequiredNames = 1;
	Object.defineProperty(names, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const names$1 = {
	    // validation function arguments
	    data: new codegen_1.Name("data"), // data passed to validation function
	    // args passed from referencing schema
	    valCxt: new codegen_1.Name("valCxt"), // validation/data context - should not be used directly, it is destructured to the names below
	    instancePath: new codegen_1.Name("instancePath"),
	    parentData: new codegen_1.Name("parentData"),
	    parentDataProperty: new codegen_1.Name("parentDataProperty"),
	    rootData: new codegen_1.Name("rootData"), // root data - same as the data passed to the first/top validation function
	    dynamicAnchors: new codegen_1.Name("dynamicAnchors"), // used to support recursiveRef and dynamicRef
	    // function scoped variables
	    vErrors: new codegen_1.Name("vErrors"), // null or array of validation errors
	    errors: new codegen_1.Name("errors"), // counter of validation errors
	    this: new codegen_1.Name("this"),
	    // "globals"
	    self: new codegen_1.Name("self"),
	    scope: new codegen_1.Name("scope"),
	    // JTD serialize/parse name for JSON string and position
	    json: new codegen_1.Name("json"),
	    jsonPos: new codegen_1.Name("jsonPos"),
	    jsonLen: new codegen_1.Name("jsonLen"),
	    jsonPart: new codegen_1.Name("jsonPart"),
	};
	names.default = names$1;
	
	return names;
}

var hasRequiredErrors$1;

function requireErrors$1 () {
	if (hasRequiredErrors$1) return errors$1;
	hasRequiredErrors$1 = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;
		const codegen_1 = requireCodegen();
		const util_1 = requireUtil$1();
		const names_1 = requireNames();
		exports.keywordError = {
		    message: ({ keyword }) => (0, codegen_1.str) `must pass "${keyword}" keyword validation`,
		};
		exports.keyword$DataError = {
		    message: ({ keyword, schemaType }) => schemaType
		        ? (0, codegen_1.str) `"${keyword}" keyword must be ${schemaType} ($data)`
		        : (0, codegen_1.str) `"${keyword}" keyword is invalid ($data)`,
		};
		function reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {
		    const { it } = cxt;
		    const { gen, compositeRule, allErrors } = it;
		    const errObj = errorObjectCode(cxt, error, errorPaths);
		    if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : (compositeRule || allErrors)) {
		        addError(gen, errObj);
		    }
		    else {
		        returnErrors(it, (0, codegen_1._) `[${errObj}]`);
		    }
		}
		exports.reportError = reportError;
		function reportExtraError(cxt, error = exports.keywordError, errorPaths) {
		    const { it } = cxt;
		    const { gen, compositeRule, allErrors } = it;
		    const errObj = errorObjectCode(cxt, error, errorPaths);
		    addError(gen, errObj);
		    if (!(compositeRule || allErrors)) {
		        returnErrors(it, names_1.default.vErrors);
		    }
		}
		exports.reportExtraError = reportExtraError;
		function resetErrorsCount(gen, errsCount) {
		    gen.assign(names_1.default.errors, errsCount);
		    gen.if((0, codegen_1._) `${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._) `${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
		}
		exports.resetErrorsCount = resetErrorsCount;
		function extendErrors({ gen, keyword, schemaValue, data, errsCount, it, }) {
		    /* istanbul ignore if */
		    if (errsCount === undefined)
		        throw new Error("ajv implementation error");
		    const err = gen.name("err");
		    gen.forRange("i", errsCount, names_1.default.errors, (i) => {
		        gen.const(err, (0, codegen_1._) `${names_1.default.vErrors}[${i}]`);
		        gen.if((0, codegen_1._) `${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._) `${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));
		        gen.assign((0, codegen_1._) `${err}.schemaPath`, (0, codegen_1.str) `${it.errSchemaPath}/${keyword}`);
		        if (it.opts.verbose) {
		            gen.assign((0, codegen_1._) `${err}.schema`, schemaValue);
		            gen.assign((0, codegen_1._) `${err}.data`, data);
		        }
		    });
		}
		exports.extendErrors = extendErrors;
		function addError(gen, errObj) {
		    const err = gen.const("err", errObj);
		    gen.if((0, codegen_1._) `${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._) `[${err}]`), (0, codegen_1._) `${names_1.default.vErrors}.push(${err})`);
		    gen.code((0, codegen_1._) `${names_1.default.errors}++`);
		}
		function returnErrors(it, errs) {
		    const { gen, validateName, schemaEnv } = it;
		    if (schemaEnv.$async) {
		        gen.throw((0, codegen_1._) `new ${it.ValidationError}(${errs})`);
		    }
		    else {
		        gen.assign((0, codegen_1._) `${validateName}.errors`, errs);
		        gen.return(false);
		    }
		}
		const E = {
		    keyword: new codegen_1.Name("keyword"),
		    schemaPath: new codegen_1.Name("schemaPath"), // also used in JTD errors
		    params: new codegen_1.Name("params"),
		    propertyName: new codegen_1.Name("propertyName"),
		    message: new codegen_1.Name("message"),
		    schema: new codegen_1.Name("schema"),
		    parentSchema: new codegen_1.Name("parentSchema"),
		};
		function errorObjectCode(cxt, error, errorPaths) {
		    const { createErrors } = cxt.it;
		    if (createErrors === false)
		        return (0, codegen_1._) `{}`;
		    return errorObject(cxt, error, errorPaths);
		}
		function errorObject(cxt, error, errorPaths = {}) {
		    const { gen, it } = cxt;
		    const keyValues = [
		        errorInstancePath(it, errorPaths),
		        errorSchemaPath(cxt, errorPaths),
		    ];
		    extraErrorProps(cxt, error, keyValues);
		    return gen.object(...keyValues);
		}
		function errorInstancePath({ errorPath }, { instancePath }) {
		    const instPath = instancePath
		        ? (0, codegen_1.str) `${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}`
		        : errorPath;
		    return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
		}
		function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
		    let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str) `${errSchemaPath}/${keyword}`;
		    if (schemaPath) {
		        schPath = (0, codegen_1.str) `${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
		    }
		    return [E.schemaPath, schPath];
		}
		function extraErrorProps(cxt, { params, message }, keyValues) {
		    const { keyword, data, schemaValue, it } = cxt;
		    const { opts, propertyName, topSchemaRef, schemaPath } = it;
		    keyValues.push([E.keyword, keyword], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._) `{}`]);
		    if (opts.messages) {
		        keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
		    }
		    if (opts.verbose) {
		        keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._) `${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
		    }
		    if (propertyName)
		        keyValues.push([E.propertyName, propertyName]);
		}
		
	} (errors$1));
	return errors$1;
}

var hasRequiredBoolSchema;

function requireBoolSchema () {
	if (hasRequiredBoolSchema) return boolSchema;
	hasRequiredBoolSchema = 1;
	Object.defineProperty(boolSchema, "__esModule", { value: true });
	boolSchema.boolOrEmptySchema = boolSchema.topBoolOrEmptySchema = void 0;
	const errors_1 = requireErrors$1();
	const codegen_1 = requireCodegen();
	const names_1 = requireNames();
	const boolError = {
	    message: "boolean schema is false",
	};
	function topBoolOrEmptySchema(it) {
	    const { gen, schema, validateName } = it;
	    if (schema === false) {
	        falseSchemaError(it, false);
	    }
	    else if (typeof schema == "object" && schema.$async === true) {
	        gen.return(names_1.default.data);
	    }
	    else {
	        gen.assign((0, codegen_1._) `${validateName}.errors`, null);
	        gen.return(true);
	    }
	}
	boolSchema.topBoolOrEmptySchema = topBoolOrEmptySchema;
	function boolOrEmptySchema(it, valid) {
	    const { gen, schema } = it;
	    if (schema === false) {
	        gen.var(valid, false); // TODO var
	        falseSchemaError(it);
	    }
	    else {
	        gen.var(valid, true); // TODO var
	    }
	}
	boolSchema.boolOrEmptySchema = boolOrEmptySchema;
	function falseSchemaError(it, overrideAllErrors) {
	    const { gen, data } = it;
	    // TODO maybe some other interface should be used for non-keyword validation errors...
	    const cxt = {
	        gen,
	        keyword: "false schema",
	        data,
	        schema: false,
	        schemaCode: false,
	        schemaValue: false,
	        params: {},
	        it,
	    };
	    (0, errors_1.reportError)(cxt, boolError, undefined, overrideAllErrors);
	}
	
	return boolSchema;
}

var dataType = {};

var rules = {};

var hasRequiredRules;

function requireRules () {
	if (hasRequiredRules) return rules;
	hasRequiredRules = 1;
	Object.defineProperty(rules, "__esModule", { value: true });
	rules.getRules = rules.isJSONType = void 0;
	const _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
	const jsonTypes = new Set(_jsonTypes);
	function isJSONType(x) {
	    return typeof x == "string" && jsonTypes.has(x);
	}
	rules.isJSONType = isJSONType;
	function getRules() {
	    const groups = {
	        number: { type: "number", rules: [] },
	        string: { type: "string", rules: [] },
	        array: { type: "array", rules: [] },
	        object: { type: "object", rules: [] },
	    };
	    return {
	        types: { ...groups, integer: true, boolean: true, null: true },
	        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
	        post: { rules: [] },
	        all: {},
	        keywords: {},
	    };
	}
	rules.getRules = getRules;
	
	return rules;
}

var applicability = {};

var hasRequiredApplicability;

function requireApplicability () {
	if (hasRequiredApplicability) return applicability;
	hasRequiredApplicability = 1;
	Object.defineProperty(applicability, "__esModule", { value: true });
	applicability.shouldUseRule = applicability.shouldUseGroup = applicability.schemaHasRulesForType = void 0;
	function schemaHasRulesForType({ schema, self }, type) {
	    const group = self.RULES.types[type];
	    return group && group !== true && shouldUseGroup(schema, group);
	}
	applicability.schemaHasRulesForType = schemaHasRulesForType;
	function shouldUseGroup(schema, group) {
	    return group.rules.some((rule) => shouldUseRule(schema, rule));
	}
	applicability.shouldUseGroup = shouldUseGroup;
	function shouldUseRule(schema, rule) {
	    var _a;
	    return (schema[rule.keyword] !== undefined ||
	        ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== undefined)));
	}
	applicability.shouldUseRule = shouldUseRule;
	
	return applicability;
}

var hasRequiredDataType;

function requireDataType () {
	if (hasRequiredDataType) return dataType;
	hasRequiredDataType = 1;
	Object.defineProperty(dataType, "__esModule", { value: true });
	dataType.reportTypeError = dataType.checkDataTypes = dataType.checkDataType = dataType.coerceAndCheckDataType = dataType.getJSONTypes = dataType.getSchemaTypes = dataType.DataType = void 0;
	const rules_1 = requireRules();
	const applicability_1 = requireApplicability();
	const errors_1 = requireErrors$1();
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil$1();
	var DataType;
	(function (DataType) {
	    DataType[DataType["Correct"] = 0] = "Correct";
	    DataType[DataType["Wrong"] = 1] = "Wrong";
	})(DataType || (dataType.DataType = DataType = {}));
	function getSchemaTypes(schema) {
	    const types = getJSONTypes(schema.type);
	    const hasNull = types.includes("null");
	    if (hasNull) {
	        if (schema.nullable === false)
	            throw new Error("type: null contradicts nullable: false");
	    }
	    else {
	        if (!types.length && schema.nullable !== undefined) {
	            throw new Error('"nullable" cannot be used without "type"');
	        }
	        if (schema.nullable === true)
	            types.push("null");
	    }
	    return types;
	}
	dataType.getSchemaTypes = getSchemaTypes;
	// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents
	function getJSONTypes(ts) {
	    const types = Array.isArray(ts) ? ts : ts ? [ts] : [];
	    if (types.every(rules_1.isJSONType))
	        return types;
	    throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
	}
	dataType.getJSONTypes = getJSONTypes;
	function coerceAndCheckDataType(it, types) {
	    const { gen, data, opts } = it;
	    const coerceTo = coerceToTypes(types, opts.coerceTypes);
	    const checkTypes = types.length > 0 &&
	        !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));
	    if (checkTypes) {
	        const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
	        gen.if(wrongType, () => {
	            if (coerceTo.length)
	                coerceData(it, types, coerceTo);
	            else
	                reportTypeError(it);
	        });
	    }
	    return checkTypes;
	}
	dataType.coerceAndCheckDataType = coerceAndCheckDataType;
	const COERCIBLE = new Set(["string", "number", "integer", "boolean", "null"]);
	function coerceToTypes(types, coerceTypes) {
	    return coerceTypes
	        ? types.filter((t) => COERCIBLE.has(t) || (coerceTypes === "array" && t === "array"))
	        : [];
	}
	function coerceData(it, types, coerceTo) {
	    const { gen, data, opts } = it;
	    const dataType = gen.let("dataType", (0, codegen_1._) `typeof ${data}`);
	    const coerced = gen.let("coerced", (0, codegen_1._) `undefined`);
	    if (opts.coerceTypes === "array") {
	        gen.if((0, codegen_1._) `${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen
	            .assign(data, (0, codegen_1._) `${data}[0]`)
	            .assign(dataType, (0, codegen_1._) `typeof ${data}`)
	            .if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));
	    }
	    gen.if((0, codegen_1._) `${coerced} !== undefined`);
	    for (const t of coerceTo) {
	        if (COERCIBLE.has(t) || (t === "array" && opts.coerceTypes === "array")) {
	            coerceSpecificType(t);
	        }
	    }
	    gen.else();
	    reportTypeError(it);
	    gen.endIf();
	    gen.if((0, codegen_1._) `${coerced} !== undefined`, () => {
	        gen.assign(data, coerced);
	        assignParentData(it, coerced);
	    });
	    function coerceSpecificType(t) {
	        switch (t) {
	            case "string":
	                gen
	                    .elseIf((0, codegen_1._) `${dataType} == "number" || ${dataType} == "boolean"`)
	                    .assign(coerced, (0, codegen_1._) `"" + ${data}`)
	                    .elseIf((0, codegen_1._) `${data} === null`)
	                    .assign(coerced, (0, codegen_1._) `""`);
	                return;
	            case "number":
	                gen
	                    .elseIf((0, codegen_1._) `${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`)
	                    .assign(coerced, (0, codegen_1._) `+${data}`);
	                return;
	            case "integer":
	                gen
	                    .elseIf((0, codegen_1._) `${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`)
	                    .assign(coerced, (0, codegen_1._) `+${data}`);
	                return;
	            case "boolean":
	                gen
	                    .elseIf((0, codegen_1._) `${data} === "false" || ${data} === 0 || ${data} === null`)
	                    .assign(coerced, false)
	                    .elseIf((0, codegen_1._) `${data} === "true" || ${data} === 1`)
	                    .assign(coerced, true);
	                return;
	            case "null":
	                gen.elseIf((0, codegen_1._) `${data} === "" || ${data} === 0 || ${data} === false`);
	                gen.assign(coerced, null);
	                return;
	            case "array":
	                gen
	                    .elseIf((0, codegen_1._) `${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`)
	                    .assign(coerced, (0, codegen_1._) `[${data}]`);
	        }
	    }
	}
	function assignParentData({ gen, parentData, parentDataProperty }, expr) {
	    // TODO use gen.property
	    gen.if((0, codegen_1._) `${parentData} !== undefined`, () => gen.assign((0, codegen_1._) `${parentData}[${parentDataProperty}]`, expr));
	}
	function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
	    const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
	    let cond;
	    switch (dataType) {
	        case "null":
	            return (0, codegen_1._) `${data} ${EQ} null`;
	        case "array":
	            cond = (0, codegen_1._) `Array.isArray(${data})`;
	            break;
	        case "object":
	            cond = (0, codegen_1._) `${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
	            break;
	        case "integer":
	            cond = numCond((0, codegen_1._) `!(${data} % 1) && !isNaN(${data})`);
	            break;
	        case "number":
	            cond = numCond();
	            break;
	        default:
	            return (0, codegen_1._) `typeof ${data} ${EQ} ${dataType}`;
	    }
	    return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
	    function numCond(_cond = codegen_1.nil) {
	        return (0, codegen_1.and)((0, codegen_1._) `typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._) `isFinite(${data})` : codegen_1.nil);
	    }
	}
	dataType.checkDataType = checkDataType;
	function checkDataTypes(dataTypes, data, strictNums, correct) {
	    if (dataTypes.length === 1) {
	        return checkDataType(dataTypes[0], data, strictNums, correct);
	    }
	    let cond;
	    const types = (0, util_1.toHash)(dataTypes);
	    if (types.array && types.object) {
	        const notObj = (0, codegen_1._) `typeof ${data} != "object"`;
	        cond = types.null ? notObj : (0, codegen_1._) `!${data} || ${notObj}`;
	        delete types.null;
	        delete types.array;
	        delete types.object;
	    }
	    else {
	        cond = codegen_1.nil;
	    }
	    if (types.number)
	        delete types.integer;
	    for (const t in types)
	        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));
	    return cond;
	}
	dataType.checkDataTypes = checkDataTypes;
	const typeError = {
	    message: ({ schema }) => `must be ${schema}`,
	    params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._) `{type: ${schema}}` : (0, codegen_1._) `{type: ${schemaValue}}`,
	};
	function reportTypeError(it) {
	    const cxt = getTypeErrorContext(it);
	    (0, errors_1.reportError)(cxt, typeError);
	}
	dataType.reportTypeError = reportTypeError;
	function getTypeErrorContext(it) {
	    const { gen, data, schema } = it;
	    const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
	    return {
	        gen,
	        keyword: "type",
	        data,
	        schema: schema.type,
	        schemaCode,
	        schemaValue: schemaCode,
	        parentSchema: schema,
	        params: {},
	        it,
	    };
	}
	
	return dataType;
}

var defaults = {};

var hasRequiredDefaults;

function requireDefaults () {
	if (hasRequiredDefaults) return defaults;
	hasRequiredDefaults = 1;
	Object.defineProperty(defaults, "__esModule", { value: true });
	defaults.assignDefaults = void 0;
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil$1();
	function assignDefaults(it, ty) {
	    const { properties, items } = it.schema;
	    if (ty === "object" && properties) {
	        for (const key in properties) {
	            assignDefault(it, key, properties[key].default);
	        }
	    }
	    else if (ty === "array" && Array.isArray(items)) {
	        items.forEach((sch, i) => assignDefault(it, i, sch.default));
	    }
	}
	defaults.assignDefaults = assignDefaults;
	function assignDefault(it, prop, defaultValue) {
	    const { gen, compositeRule, data, opts } = it;
	    if (defaultValue === undefined)
	        return;
	    const childData = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(prop)}`;
	    if (compositeRule) {
	        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
	        return;
	    }
	    let condition = (0, codegen_1._) `${childData} === undefined`;
	    if (opts.useDefaults === "empty") {
	        condition = (0, codegen_1._) `${condition} || ${childData} === null || ${childData} === ""`;
	    }
	    // `${childData} === undefined` +
	    // (opts.useDefaults === "empty" ? ` || ${childData} === null || ${childData} === ""` : "")
	    gen.if(condition, (0, codegen_1._) `${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
	}
	
	return defaults;
}

var keyword = {};

var code$1 = {};

var hasRequiredCode;

function requireCode () {
	if (hasRequiredCode) return code$1;
	hasRequiredCode = 1;
	Object.defineProperty(code$1, "__esModule", { value: true });
	code$1.validateUnion = code$1.validateArray = code$1.usePattern = code$1.callValidateCode = code$1.schemaProperties = code$1.allSchemaProperties = code$1.noPropertyInData = code$1.propertyInData = code$1.isOwnProperty = code$1.hasPropFunc = code$1.reportMissingProp = code$1.checkMissingProp = code$1.checkReportMissingProp = void 0;
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil$1();
	const names_1 = requireNames();
	const util_2 = requireUtil$1();
	function checkReportMissingProp(cxt, prop) {
	    const { gen, data, it } = cxt;
	    gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
	        cxt.setParams({ missingProperty: (0, codegen_1._) `${prop}` }, true);
	        cxt.error();
	    });
	}
	code$1.checkReportMissingProp = checkReportMissingProp;
	function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
	    return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._) `${missing} = ${prop}`)));
	}
	code$1.checkMissingProp = checkMissingProp;
	function reportMissingProp(cxt, missing) {
	    cxt.setParams({ missingProperty: missing }, true);
	    cxt.error();
	}
	code$1.reportMissingProp = reportMissingProp;
	function hasPropFunc(gen) {
	    return gen.scopeValue("func", {
	        // eslint-disable-next-line @typescript-eslint/unbound-method
	        ref: Object.prototype.hasOwnProperty,
	        code: (0, codegen_1._) `Object.prototype.hasOwnProperty`,
	    });
	}
	code$1.hasPropFunc = hasPropFunc;
	function isOwnProperty(gen, data, property) {
	    return (0, codegen_1._) `${hasPropFunc(gen)}.call(${data}, ${property})`;
	}
	code$1.isOwnProperty = isOwnProperty;
	function propertyInData(gen, data, property, ownProperties) {
	    const cond = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
	    return ownProperties ? (0, codegen_1._) `${cond} && ${isOwnProperty(gen, data, property)}` : cond;
	}
	code$1.propertyInData = propertyInData;
	function noPropertyInData(gen, data, property, ownProperties) {
	    const cond = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(property)} === undefined`;
	    return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
	}
	code$1.noPropertyInData = noPropertyInData;
	function allSchemaProperties(schemaMap) {
	    return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
	}
	code$1.allSchemaProperties = allSchemaProperties;
	function schemaProperties(it, schemaMap) {
	    return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));
	}
	code$1.schemaProperties = schemaProperties;
	function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
	    const dataAndSchema = passSchema ? (0, codegen_1._) `${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
	    const valCxt = [
	        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
	        [names_1.default.parentData, it.parentData],
	        [names_1.default.parentDataProperty, it.parentDataProperty],
	        [names_1.default.rootData, names_1.default.rootData],
	    ];
	    if (it.opts.dynamicRef)
	        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
	    const args = (0, codegen_1._) `${dataAndSchema}, ${gen.object(...valCxt)}`;
	    return context !== codegen_1.nil ? (0, codegen_1._) `${func}.call(${context}, ${args})` : (0, codegen_1._) `${func}(${args})`;
	}
	code$1.callValidateCode = callValidateCode;
	const newRegExp = (0, codegen_1._) `new RegExp`;
	function usePattern({ gen, it: { opts } }, pattern) {
	    const u = opts.unicodeRegExp ? "u" : "";
	    const { regExp } = opts.code;
	    const rx = regExp(pattern, u);
	    return gen.scopeValue("pattern", {
	        key: rx.toString(),
	        ref: rx,
	        code: (0, codegen_1._) `${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`,
	    });
	}
	code$1.usePattern = usePattern;
	function validateArray(cxt) {
	    const { gen, data, keyword, it } = cxt;
	    const valid = gen.name("valid");
	    if (it.allErrors) {
	        const validArr = gen.let("valid", true);
	        validateItems(() => gen.assign(validArr, false));
	        return validArr;
	    }
	    gen.var(valid, true);
	    validateItems(() => gen.break());
	    return valid;
	    function validateItems(notValid) {
	        const len = gen.const("len", (0, codegen_1._) `${data}.length`);
	        gen.forRange("i", 0, len, (i) => {
	            cxt.subschema({
	                keyword,
	                dataProp: i,
	                dataPropType: util_1.Type.Num,
	            }, valid);
	            gen.if((0, codegen_1.not)(valid), notValid);
	        });
	    }
	}
	code$1.validateArray = validateArray;
	function validateUnion(cxt) {
	    const { gen, schema, keyword, it } = cxt;
	    /* istanbul ignore if */
	    if (!Array.isArray(schema))
	        throw new Error("ajv implementation error");
	    const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));
	    if (alwaysValid && !it.opts.unevaluated)
	        return;
	    const valid = gen.let("valid", false);
	    const schValid = gen.name("_valid");
	    gen.block(() => schema.forEach((_sch, i) => {
	        const schCxt = cxt.subschema({
	            keyword,
	            schemaProp: i,
	            compositeRule: true,
	        }, schValid);
	        gen.assign(valid, (0, codegen_1._) `${valid} || ${schValid}`);
	        const merged = cxt.mergeValidEvaluated(schCxt, schValid);
	        // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)
	        // or if all properties and items were evaluated (it.props === true && it.items === true)
	        if (!merged)
	            gen.if((0, codegen_1.not)(valid));
	    }));
	    cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
	}
	code$1.validateUnion = validateUnion;
	
	return code$1;
}

var hasRequiredKeyword;

function requireKeyword () {
	if (hasRequiredKeyword) return keyword;
	hasRequiredKeyword = 1;
	Object.defineProperty(keyword, "__esModule", { value: true });
	keyword.validateKeywordUsage = keyword.validSchemaType = keyword.funcKeywordCode = keyword.macroKeywordCode = void 0;
	const codegen_1 = requireCodegen();
	const names_1 = requireNames();
	const code_1 = requireCode();
	const errors_1 = requireErrors$1();
	function macroKeywordCode(cxt, def) {
	    const { gen, keyword, schema, parentSchema, it } = cxt;
	    const macroSchema = def.macro.call(it.self, schema, parentSchema, it);
	    const schemaRef = useKeyword(gen, keyword, macroSchema);
	    if (it.opts.validateSchema !== false)
	        it.self.validateSchema(macroSchema, true);
	    const valid = gen.name("valid");
	    cxt.subschema({
	        schema: macroSchema,
	        schemaPath: codegen_1.nil,
	        errSchemaPath: `${it.errSchemaPath}/${keyword}`,
	        topSchemaRef: schemaRef,
	        compositeRule: true,
	    }, valid);
	    cxt.pass(valid, () => cxt.error(true));
	}
	keyword.macroKeywordCode = macroKeywordCode;
	function funcKeywordCode(cxt, def) {
	    var _a;
	    const { gen, keyword, schema, parentSchema, $data, it } = cxt;
	    checkAsyncKeyword(it, def);
	    const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;
	    const validateRef = useKeyword(gen, keyword, validate);
	    const valid = gen.let("valid");
	    cxt.block$data(valid, validateKeyword);
	    cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);
	    function validateKeyword() {
	        if (def.errors === false) {
	            assignValid();
	            if (def.modifying)
	                modifyData(cxt);
	            reportErrs(() => cxt.error());
	        }
	        else {
	            const ruleErrs = def.async ? validateAsync() : validateSync();
	            if (def.modifying)
	                modifyData(cxt);
	            reportErrs(() => addErrs(cxt, ruleErrs));
	        }
	    }
	    function validateAsync() {
	        const ruleErrs = gen.let("ruleErrs", null);
	        gen.try(() => assignValid((0, codegen_1._) `await `), (e) => gen.assign(valid, false).if((0, codegen_1._) `${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._) `${e}.errors`), () => gen.throw(e)));
	        return ruleErrs;
	    }
	    function validateSync() {
	        const validateErrs = (0, codegen_1._) `${validateRef}.errors`;
	        gen.assign(validateErrs, null);
	        assignValid(codegen_1.nil);
	        return validateErrs;
	    }
	    function assignValid(_await = def.async ? (0, codegen_1._) `await ` : codegen_1.nil) {
	        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
	        const passSchema = !(("compile" in def && !$data) || def.schema === false);
	        gen.assign(valid, (0, codegen_1._) `${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
	    }
	    function reportErrs(errors) {
	        var _a;
	        gen.if((0, codegen_1.not)((_a = def.valid) !== null && _a !== void 0 ? _a : valid), errors);
	    }
	}
	keyword.funcKeywordCode = funcKeywordCode;
	function modifyData(cxt) {
	    const { gen, data, it } = cxt;
	    gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._) `${it.parentData}[${it.parentDataProperty}]`));
	}
	function addErrs(cxt, errs) {
	    const { gen } = cxt;
	    gen.if((0, codegen_1._) `Array.isArray(${errs})`, () => {
	        gen
	            .assign(names_1.default.vErrors, (0, codegen_1._) `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`)
	            .assign(names_1.default.errors, (0, codegen_1._) `${names_1.default.vErrors}.length`);
	        (0, errors_1.extendErrors)(cxt);
	    }, () => cxt.error());
	}
	function checkAsyncKeyword({ schemaEnv }, def) {
	    if (def.async && !schemaEnv.$async)
	        throw new Error("async keyword in sync schema");
	}
	function useKeyword(gen, keyword, result) {
	    if (result === undefined)
	        throw new Error(`keyword "${keyword}" failed to compile`);
	    return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
	}
	function validSchemaType(schema, schemaType, allowUndefined = false) {
	    // TODO add tests
	    return (!schemaType.length ||
	        schemaType.some((st) => st === "array"
	            ? Array.isArray(schema)
	            : st === "object"
	                ? schema && typeof schema == "object" && !Array.isArray(schema)
	                : typeof schema == st || (allowUndefined && typeof schema == "undefined")));
	}
	keyword.validSchemaType = validSchemaType;
	function validateKeywordUsage({ schema, opts, self, errSchemaPath }, def, keyword) {
	    /* istanbul ignore if */
	    if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
	        throw new Error("ajv implementation error");
	    }
	    const deps = def.dependencies;
	    if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
	        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
	    }
	    if (def.validateSchema) {
	        const valid = def.validateSchema(schema[keyword]);
	        if (!valid) {
	            const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` +
	                self.errorsText(def.validateSchema.errors);
	            if (opts.validateSchema === "log")
	                self.logger.error(msg);
	            else
	                throw new Error(msg);
	        }
	    }
	}
	keyword.validateKeywordUsage = validateKeywordUsage;
	
	return keyword;
}

var subschema = {};

var hasRequiredSubschema;

function requireSubschema () {
	if (hasRequiredSubschema) return subschema;
	hasRequiredSubschema = 1;
	Object.defineProperty(subschema, "__esModule", { value: true });
	subschema.extendSubschemaMode = subschema.extendSubschemaData = subschema.getSubschema = void 0;
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil$1();
	function getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
	    if (keyword !== undefined && schema !== undefined) {
	        throw new Error('both "keyword" and "schema" passed, only one allowed');
	    }
	    if (keyword !== undefined) {
	        const sch = it.schema[keyword];
	        return schemaProp === undefined
	            ? {
	                schema: sch,
	                schemaPath: (0, codegen_1._) `${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,
	                errSchemaPath: `${it.errSchemaPath}/${keyword}`,
	            }
	            : {
	                schema: sch[schemaProp],
	                schemaPath: (0, codegen_1._) `${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,
	                errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`,
	            };
	    }
	    if (schema !== undefined) {
	        if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {
	            throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
	        }
	        return {
	            schema,
	            schemaPath,
	            topSchemaRef,
	            errSchemaPath,
	        };
	    }
	    throw new Error('either "keyword" or "schema" must be passed');
	}
	subschema.getSubschema = getSubschema;
	function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
	    if (data !== undefined && dataProp !== undefined) {
	        throw new Error('both "data" and "dataProp" passed, only one allowed');
	    }
	    const { gen } = it;
	    if (dataProp !== undefined) {
	        const { errorPath, dataPathArr, opts } = it;
	        const nextData = gen.let("data", (0, codegen_1._) `${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
	        dataContextProps(nextData);
	        subschema.errorPath = (0, codegen_1.str) `${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
	        subschema.parentDataProperty = (0, codegen_1._) `${dataProp}`;
	        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
	    }
	    if (data !== undefined) {
	        const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true); // replaceable if used once?
	        dataContextProps(nextData);
	        if (propertyName !== undefined)
	            subschema.propertyName = propertyName;
	        // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr
	    }
	    if (dataTypes)
	        subschema.dataTypes = dataTypes;
	    function dataContextProps(_nextData) {
	        subschema.data = _nextData;
	        subschema.dataLevel = it.dataLevel + 1;
	        subschema.dataTypes = [];
	        it.definedProperties = new Set();
	        subschema.parentData = it.data;
	        subschema.dataNames = [...it.dataNames, _nextData];
	    }
	}
	subschema.extendSubschemaData = extendSubschemaData;
	function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
	    if (compositeRule !== undefined)
	        subschema.compositeRule = compositeRule;
	    if (createErrors !== undefined)
	        subschema.createErrors = createErrors;
	    if (allErrors !== undefined)
	        subschema.allErrors = allErrors;
	    subschema.jtdDiscriminator = jtdDiscriminator; // not inherited
	    subschema.jtdMetadata = jtdMetadata; // not inherited
	}
	subschema.extendSubschemaMode = extendSubschemaMode;
	
	return subschema;
}

var resolve = {};

var fastDeepEqual;
var hasRequiredFastDeepEqual;

function requireFastDeepEqual () {
	if (hasRequiredFastDeepEqual) return fastDeepEqual;
	hasRequiredFastDeepEqual = 1;

	// do not edit .js files directly - edit src/index.jst



	fastDeepEqual = function equal(a, b) {
	  if (a === b) return true;

	  if (a && b && typeof a == 'object' && typeof b == 'object') {
	    if (a.constructor !== b.constructor) return false;

	    var length, i, keys;
	    if (Array.isArray(a)) {
	      length = a.length;
	      if (length != b.length) return false;
	      for (i = length; i-- !== 0;)
	        if (!equal(a[i], b[i])) return false;
	      return true;
	    }



	    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
	    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
	    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

	    keys = Object.keys(a);
	    length = keys.length;
	    if (length !== Object.keys(b).length) return false;

	    for (i = length; i-- !== 0;)
	      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

	    for (i = length; i-- !== 0;) {
	      var key = keys[i];

	      if (!equal(a[key], b[key])) return false;
	    }

	    return true;
	  }

	  // true if both NaN, false otherwise
	  return a!==a && b!==b;
	};
	return fastDeepEqual;
}

var jsonSchemaTraverse = {exports: {}};

var hasRequiredJsonSchemaTraverse;

function requireJsonSchemaTraverse () {
	if (hasRequiredJsonSchemaTraverse) return jsonSchemaTraverse.exports;
	hasRequiredJsonSchemaTraverse = 1;

	var traverse = jsonSchemaTraverse.exports = function (schema, opts, cb) {
	  // Legacy support for v0.3.1 and earlier.
	  if (typeof opts == 'function') {
	    cb = opts;
	    opts = {};
	  }

	  cb = opts.cb || cb;
	  var pre = (typeof cb == 'function') ? cb : cb.pre || function() {};
	  var post = cb.post || function() {};

	  _traverse(opts, pre, post, schema, '', schema);
	};


	traverse.keywords = {
	  additionalItems: true,
	  items: true,
	  contains: true,
	  additionalProperties: true,
	  propertyNames: true,
	  not: true,
	  if: true,
	  then: true,
	  else: true
	};

	traverse.arrayKeywords = {
	  items: true,
	  allOf: true,
	  anyOf: true,
	  oneOf: true
	};

	traverse.propsKeywords = {
	  $defs: true,
	  definitions: true,
	  properties: true,
	  patternProperties: true,
	  dependencies: true
	};

	traverse.skipKeywords = {
	  default: true,
	  enum: true,
	  const: true,
	  required: true,
	  maximum: true,
	  minimum: true,
	  exclusiveMaximum: true,
	  exclusiveMinimum: true,
	  multipleOf: true,
	  maxLength: true,
	  minLength: true,
	  pattern: true,
	  format: true,
	  maxItems: true,
	  minItems: true,
	  uniqueItems: true,
	  maxProperties: true,
	  minProperties: true
	};


	function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
	  if (schema && typeof schema == 'object' && !Array.isArray(schema)) {
	    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
	    for (var key in schema) {
	      var sch = schema[key];
	      if (Array.isArray(sch)) {
	        if (key in traverse.arrayKeywords) {
	          for (var i=0; i<sch.length; i++)
	            _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);
	        }
	      } else if (key in traverse.propsKeywords) {
	        if (sch && typeof sch == 'object') {
	          for (var prop in sch)
	            _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
	        }
	      } else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {
	        _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);
	      }
	    }
	    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
	  }
	}


	function escapeJsonPtr(str) {
	  return str.replace(/~/g, '~0').replace(/\//g, '~1');
	}
	return jsonSchemaTraverse.exports;
}

var hasRequiredResolve;

function requireResolve () {
	if (hasRequiredResolve) return resolve;
	hasRequiredResolve = 1;
	Object.defineProperty(resolve, "__esModule", { value: true });
	resolve.getSchemaRefs = resolve.resolveUrl = resolve.normalizeId = resolve._getFullPath = resolve.getFullPath = resolve.inlineRef = void 0;
	const util_1 = requireUtil$1();
	const equal = requireFastDeepEqual();
	const traverse = requireJsonSchemaTraverse();
	// TODO refactor to use keyword definitions
	const SIMPLE_INLINED = new Set([
	    "type",
	    "format",
	    "pattern",
	    "maxLength",
	    "minLength",
	    "maxProperties",
	    "minProperties",
	    "maxItems",
	    "minItems",
	    "maximum",
	    "minimum",
	    "uniqueItems",
	    "multipleOf",
	    "required",
	    "enum",
	    "const",
	]);
	function inlineRef(schema, limit = true) {
	    if (typeof schema == "boolean")
	        return true;
	    if (limit === true)
	        return !hasRef(schema);
	    if (!limit)
	        return false;
	    return countKeys(schema) <= limit;
	}
	resolve.inlineRef = inlineRef;
	const REF_KEYWORDS = new Set([
	    "$ref",
	    "$recursiveRef",
	    "$recursiveAnchor",
	    "$dynamicRef",
	    "$dynamicAnchor",
	]);
	function hasRef(schema) {
	    for (const key in schema) {
	        if (REF_KEYWORDS.has(key))
	            return true;
	        const sch = schema[key];
	        if (Array.isArray(sch) && sch.some(hasRef))
	            return true;
	        if (typeof sch == "object" && hasRef(sch))
	            return true;
	    }
	    return false;
	}
	function countKeys(schema) {
	    let count = 0;
	    for (const key in schema) {
	        if (key === "$ref")
	            return Infinity;
	        count++;
	        if (SIMPLE_INLINED.has(key))
	            continue;
	        if (typeof schema[key] == "object") {
	            (0, util_1.eachItem)(schema[key], (sch) => (count += countKeys(sch)));
	        }
	        if (count === Infinity)
	            return Infinity;
	    }
	    return count;
	}
	function getFullPath(resolver, id = "", normalize) {
	    if (normalize !== false)
	        id = normalizeId(id);
	    const p = resolver.parse(id);
	    return _getFullPath(resolver, p);
	}
	resolve.getFullPath = getFullPath;
	function _getFullPath(resolver, p) {
	    const serialized = resolver.serialize(p);
	    return serialized.split("#")[0] + "#";
	}
	resolve._getFullPath = _getFullPath;
	const TRAILING_SLASH_HASH = /#\/?$/;
	function normalizeId(id) {
	    return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
	}
	resolve.normalizeId = normalizeId;
	function resolveUrl(resolver, baseId, id) {
	    id = normalizeId(id);
	    return resolver.resolve(baseId, id);
	}
	resolve.resolveUrl = resolveUrl;
	const ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
	function getSchemaRefs(schema, baseId) {
	    if (typeof schema == "boolean")
	        return {};
	    const { schemaId, uriResolver } = this.opts;
	    const schId = normalizeId(schema[schemaId] || baseId);
	    const baseIds = { "": schId };
	    const pathPrefix = getFullPath(uriResolver, schId, false);
	    const localRefs = {};
	    const schemaRefs = new Set();
	    traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
	        if (parentJsonPtr === undefined)
	            return;
	        const fullPath = pathPrefix + jsonPtr;
	        let innerBaseId = baseIds[parentJsonPtr];
	        if (typeof sch[schemaId] == "string")
	            innerBaseId = addRef.call(this, sch[schemaId]);
	        addAnchor.call(this, sch.$anchor);
	        addAnchor.call(this, sch.$dynamicAnchor);
	        baseIds[jsonPtr] = innerBaseId;
	        function addRef(ref) {
	            // eslint-disable-next-line @typescript-eslint/unbound-method
	            const _resolve = this.opts.uriResolver.resolve;
	            ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref);
	            if (schemaRefs.has(ref))
	                throw ambiguos(ref);
	            schemaRefs.add(ref);
	            let schOrRef = this.refs[ref];
	            if (typeof schOrRef == "string")
	                schOrRef = this.refs[schOrRef];
	            if (typeof schOrRef == "object") {
	                checkAmbiguosRef(sch, schOrRef.schema, ref);
	            }
	            else if (ref !== normalizeId(fullPath)) {
	                if (ref[0] === "#") {
	                    checkAmbiguosRef(sch, localRefs[ref], ref);
	                    localRefs[ref] = sch;
	                }
	                else {
	                    this.refs[ref] = fullPath;
	                }
	            }
	            return ref;
	        }
	        function addAnchor(anchor) {
	            if (typeof anchor == "string") {
	                if (!ANCHOR.test(anchor))
	                    throw new Error(`invalid anchor "${anchor}"`);
	                addRef.call(this, `#${anchor}`);
	            }
	        }
	    });
	    return localRefs;
	    function checkAmbiguosRef(sch1, sch2, ref) {
	        if (sch2 !== undefined && !equal(sch1, sch2))
	            throw ambiguos(ref);
	    }
	    function ambiguos(ref) {
	        return new Error(`reference "${ref}" resolves to more than one schema`);
	    }
	}
	resolve.getSchemaRefs = getSchemaRefs;
	
	return resolve;
}

var hasRequiredValidate;

function requireValidate () {
	if (hasRequiredValidate) return validate;
	hasRequiredValidate = 1;
	Object.defineProperty(validate, "__esModule", { value: true });
	validate.getData = validate.KeywordCxt = validate.validateFunctionCode = void 0;
	const boolSchema_1 = requireBoolSchema();
	const dataType_1 = requireDataType();
	const applicability_1 = requireApplicability();
	const dataType_2 = requireDataType();
	const defaults_1 = requireDefaults();
	const keyword_1 = requireKeyword();
	const subschema_1 = requireSubschema();
	const codegen_1 = requireCodegen();
	const names_1 = requireNames();
	const resolve_1 = requireResolve();
	const util_1 = requireUtil$1();
	const errors_1 = requireErrors$1();
	// schema compilation - generates validation function, subschemaCode (below) is used for subschemas
	function validateFunctionCode(it) {
	    if (isSchemaObj(it)) {
	        checkKeywords(it);
	        if (schemaCxtHasRules(it)) {
	            topSchemaObjCode(it);
	            return;
	        }
	    }
	    validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
	}
	validate.validateFunctionCode = validateFunctionCode;
	function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
	    if (opts.code.es5) {
	        gen.func(validateName, (0, codegen_1._) `${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
	            gen.code((0, codegen_1._) `"use strict"; ${funcSourceUrl(schema, opts)}`);
	            destructureValCxtES5(gen, opts);
	            gen.code(body);
	        });
	    }
	    else {
	        gen.func(validateName, (0, codegen_1._) `${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
	    }
	}
	function destructureValCxt(opts) {
	    return (0, codegen_1._) `{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._) `, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
	}
	function destructureValCxtES5(gen, opts) {
	    gen.if(names_1.default.valCxt, () => {
	        gen.var(names_1.default.instancePath, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.instancePath}`);
	        gen.var(names_1.default.parentData, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.parentData}`);
	        gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
	        gen.var(names_1.default.rootData, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.rootData}`);
	        if (opts.dynamicRef)
	            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
	    }, () => {
	        gen.var(names_1.default.instancePath, (0, codegen_1._) `""`);
	        gen.var(names_1.default.parentData, (0, codegen_1._) `undefined`);
	        gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `undefined`);
	        gen.var(names_1.default.rootData, names_1.default.data);
	        if (opts.dynamicRef)
	            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `{}`);
	    });
	}
	function topSchemaObjCode(it) {
	    const { schema, opts, gen } = it;
	    validateFunction(it, () => {
	        if (opts.$comment && schema.$comment)
	            commentKeyword(it);
	        checkNoDefault(it);
	        gen.let(names_1.default.vErrors, null);
	        gen.let(names_1.default.errors, 0);
	        if (opts.unevaluated)
	            resetEvaluated(it);
	        typeAndKeywords(it);
	        returnResults(it);
	    });
	    return;
	}
	function resetEvaluated(it) {
	    // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated
	    const { gen, validateName } = it;
	    it.evaluated = gen.const("evaluated", (0, codegen_1._) `${validateName}.evaluated`);
	    gen.if((0, codegen_1._) `${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._) `${it.evaluated}.props`, (0, codegen_1._) `undefined`));
	    gen.if((0, codegen_1._) `${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._) `${it.evaluated}.items`, (0, codegen_1._) `undefined`));
	}
	function funcSourceUrl(schema, opts) {
	    const schId = typeof schema == "object" && schema[opts.schemaId];
	    return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._) `/*# sourceURL=${schId} */` : codegen_1.nil;
	}
	// schema compilation - this function is used recursively to generate code for sub-schemas
	function subschemaCode(it, valid) {
	    if (isSchemaObj(it)) {
	        checkKeywords(it);
	        if (schemaCxtHasRules(it)) {
	            subSchemaObjCode(it, valid);
	            return;
	        }
	    }
	    (0, boolSchema_1.boolOrEmptySchema)(it, valid);
	}
	function schemaCxtHasRules({ schema, self }) {
	    if (typeof schema == "boolean")
	        return !schema;
	    for (const key in schema)
	        if (self.RULES.all[key])
	            return true;
	    return false;
	}
	function isSchemaObj(it) {
	    return typeof it.schema != "boolean";
	}
	function subSchemaObjCode(it, valid) {
	    const { schema, gen, opts } = it;
	    if (opts.$comment && schema.$comment)
	        commentKeyword(it);
	    updateContext(it);
	    checkAsyncSchema(it);
	    const errsCount = gen.const("_errs", names_1.default.errors);
	    typeAndKeywords(it, errsCount);
	    // TODO var
	    gen.var(valid, (0, codegen_1._) `${errsCount} === ${names_1.default.errors}`);
	}
	function checkKeywords(it) {
	    (0, util_1.checkUnknownRules)(it);
	    checkRefsAndKeywords(it);
	}
	function typeAndKeywords(it, errsCount) {
	    if (it.opts.jtd)
	        return schemaKeywords(it, [], false, errsCount);
	    const types = (0, dataType_1.getSchemaTypes)(it.schema);
	    const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);
	    schemaKeywords(it, types, !checkedTypes, errsCount);
	}
	function checkRefsAndKeywords(it) {
	    const { schema, errSchemaPath, opts, self } = it;
	    if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES)) {
	        self.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
	    }
	}
	function checkNoDefault(it) {
	    const { schema, opts } = it;
	    if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {
	        (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
	    }
	}
	function updateContext(it) {
	    const schId = it.schema[it.opts.schemaId];
	    if (schId)
	        it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
	}
	function checkAsyncSchema(it) {
	    if (it.schema.$async && !it.schemaEnv.$async)
	        throw new Error("async schema in sync schema");
	}
	function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
	    const msg = schema.$comment;
	    if (opts.$comment === true) {
	        gen.code((0, codegen_1._) `${names_1.default.self}.logger.log(${msg})`);
	    }
	    else if (typeof opts.$comment == "function") {
	        const schemaPath = (0, codegen_1.str) `${errSchemaPath}/$comment`;
	        const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
	        gen.code((0, codegen_1._) `${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
	    }
	}
	function returnResults(it) {
	    const { gen, schemaEnv, validateName, ValidationError, opts } = it;
	    if (schemaEnv.$async) {
	        // TODO assign unevaluated
	        gen.if((0, codegen_1._) `${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._) `new ${ValidationError}(${names_1.default.vErrors})`));
	    }
	    else {
	        gen.assign((0, codegen_1._) `${validateName}.errors`, names_1.default.vErrors);
	        if (opts.unevaluated)
	            assignEvaluated(it);
	        gen.return((0, codegen_1._) `${names_1.default.errors} === 0`);
	    }
	}
	function assignEvaluated({ gen, evaluated, props, items }) {
	    if (props instanceof codegen_1.Name)
	        gen.assign((0, codegen_1._) `${evaluated}.props`, props);
	    if (items instanceof codegen_1.Name)
	        gen.assign((0, codegen_1._) `${evaluated}.items`, items);
	}
	function schemaKeywords(it, types, typeErrors, errsCount) {
	    const { gen, schema, data, allErrors, opts, self } = it;
	    const { RULES } = self;
	    if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
	        gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition)); // TODO typecast
	        return;
	    }
	    if (!opts.jtd)
	        checkStrictTypes(it, types);
	    gen.block(() => {
	        for (const group of RULES.rules)
	            groupKeywords(group);
	        groupKeywords(RULES.post);
	    });
	    function groupKeywords(group) {
	        if (!(0, applicability_1.shouldUseGroup)(schema, group))
	            return;
	        if (group.type) {
	            gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
	            iterateKeywords(it, group);
	            if (types.length === 1 && types[0] === group.type && typeErrors) {
	                gen.else();
	                (0, dataType_2.reportTypeError)(it);
	            }
	            gen.endIf();
	        }
	        else {
	            iterateKeywords(it, group);
	        }
	        // TODO make it "ok" call?
	        if (!allErrors)
	            gen.if((0, codegen_1._) `${names_1.default.errors} === ${errsCount || 0}`);
	    }
	}
	function iterateKeywords(it, group) {
	    const { gen, schema, opts: { useDefaults }, } = it;
	    if (useDefaults)
	        (0, defaults_1.assignDefaults)(it, group.type);
	    gen.block(() => {
	        for (const rule of group.rules) {
	            if ((0, applicability_1.shouldUseRule)(schema, rule)) {
	                keywordCode(it, rule.keyword, rule.definition, group.type);
	            }
	        }
	    });
	}
	function checkStrictTypes(it, types) {
	    if (it.schemaEnv.meta || !it.opts.strictTypes)
	        return;
	    checkContextTypes(it, types);
	    if (!it.opts.allowUnionTypes)
	        checkMultipleTypes(it, types);
	    checkKeywordTypes(it, it.dataTypes);
	}
	function checkContextTypes(it, types) {
	    if (!types.length)
	        return;
	    if (!it.dataTypes.length) {
	        it.dataTypes = types;
	        return;
	    }
	    types.forEach((t) => {
	        if (!includesType(it.dataTypes, t)) {
	            strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);
	        }
	    });
	    narrowSchemaTypes(it, types);
	}
	function checkMultipleTypes(it, ts) {
	    if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
	        strictTypesError(it, "use allowUnionTypes to allow union type keyword");
	    }
	}
	function checkKeywordTypes(it, ts) {
	    const rules = it.self.RULES.all;
	    for (const keyword in rules) {
	        const rule = rules[keyword];
	        if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
	            const { type } = rule.definition;
	            if (type.length && !type.some((t) => hasApplicableType(ts, t))) {
	                strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`);
	            }
	        }
	    }
	}
	function hasApplicableType(schTs, kwdT) {
	    return schTs.includes(kwdT) || (kwdT === "number" && schTs.includes("integer"));
	}
	function includesType(ts, t) {
	    return ts.includes(t) || (t === "integer" && ts.includes("number"));
	}
	function narrowSchemaTypes(it, withTypes) {
	    const ts = [];
	    for (const t of it.dataTypes) {
	        if (includesType(withTypes, t))
	            ts.push(t);
	        else if (withTypes.includes("integer") && t === "number")
	            ts.push("integer");
	    }
	    it.dataTypes = ts;
	}
	function strictTypesError(it, msg) {
	    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
	    msg += ` at "${schemaPath}" (strictTypes)`;
	    (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
	}
	class KeywordCxt {
	    constructor(it, def, keyword) {
	        (0, keyword_1.validateKeywordUsage)(it, def, keyword);
	        this.gen = it.gen;
	        this.allErrors = it.allErrors;
	        this.keyword = keyword;
	        this.data = it.data;
	        this.schema = it.schema[keyword];
	        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;
	        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);
	        this.schemaType = def.schemaType;
	        this.parentSchema = it.schema;
	        this.params = {};
	        this.it = it;
	        this.def = def;
	        if (this.$data) {
	            this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
	        }
	        else {
	            this.schemaCode = this.schemaValue;
	            if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
	                throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
	            }
	        }
	        if ("code" in def ? def.trackErrors : def.errors !== false) {
	            this.errsCount = it.gen.const("_errs", names_1.default.errors);
	        }
	    }
	    result(condition, successAction, failAction) {
	        this.failResult((0, codegen_1.not)(condition), successAction, failAction);
	    }
	    failResult(condition, successAction, failAction) {
	        this.gen.if(condition);
	        if (failAction)
	            failAction();
	        else
	            this.error();
	        if (successAction) {
	            this.gen.else();
	            successAction();
	            if (this.allErrors)
	                this.gen.endIf();
	        }
	        else {
	            if (this.allErrors)
	                this.gen.endIf();
	            else
	                this.gen.else();
	        }
	    }
	    pass(condition, failAction) {
	        this.failResult((0, codegen_1.not)(condition), undefined, failAction);
	    }
	    fail(condition) {
	        if (condition === undefined) {
	            this.error();
	            if (!this.allErrors)
	                this.gen.if(false); // this branch will be removed by gen.optimize
	            return;
	        }
	        this.gen.if(condition);
	        this.error();
	        if (this.allErrors)
	            this.gen.endIf();
	        else
	            this.gen.else();
	    }
	    fail$data(condition) {
	        if (!this.$data)
	            return this.fail(condition);
	        const { schemaCode } = this;
	        this.fail((0, codegen_1._) `${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
	    }
	    error(append, errorParams, errorPaths) {
	        if (errorParams) {
	            this.setParams(errorParams);
	            this._error(append, errorPaths);
	            this.setParams({});
	            return;
	        }
	        this._error(append, errorPaths);
	    }
	    _error(append, errorPaths) {
	        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
	    }
	    $dataError() {
	        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
	    }
	    reset() {
	        if (this.errsCount === undefined)
	            throw new Error('add "trackErrors" to keyword definition');
	        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
	    }
	    ok(cond) {
	        if (!this.allErrors)
	            this.gen.if(cond);
	    }
	    setParams(obj, assign) {
	        if (assign)
	            Object.assign(this.params, obj);
	        else
	            this.params = obj;
	    }
	    block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
	        this.gen.block(() => {
	            this.check$data(valid, $dataValid);
	            codeBlock();
	        });
	    }
	    check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
	        if (!this.$data)
	            return;
	        const { gen, schemaCode, schemaType, def } = this;
	        gen.if((0, codegen_1.or)((0, codegen_1._) `${schemaCode} === undefined`, $dataValid));
	        if (valid !== codegen_1.nil)
	            gen.assign(valid, true);
	        if (schemaType.length || def.validateSchema) {
	            gen.elseIf(this.invalid$data());
	            this.$dataError();
	            if (valid !== codegen_1.nil)
	                gen.assign(valid, false);
	        }
	        gen.else();
	    }
	    invalid$data() {
	        const { gen, schemaCode, schemaType, def, it } = this;
	        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
	        function wrong$DataType() {
	            if (schemaType.length) {
	                /* istanbul ignore if */
	                if (!(schemaCode instanceof codegen_1.Name))
	                    throw new Error("ajv implementation error");
	                const st = Array.isArray(schemaType) ? schemaType : [schemaType];
	                return (0, codegen_1._) `${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
	            }
	            return codegen_1.nil;
	        }
	        function invalid$DataSchema() {
	            if (def.validateSchema) {
	                const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema }); // TODO value.code for standalone
	                return (0, codegen_1._) `!${validateSchemaRef}(${schemaCode})`;
	            }
	            return codegen_1.nil;
	        }
	    }
	    subschema(appl, valid) {
	        const subschema = (0, subschema_1.getSubschema)(this.it, appl);
	        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
	        (0, subschema_1.extendSubschemaMode)(subschema, appl);
	        const nextContext = { ...this.it, ...subschema, items: undefined, props: undefined };
	        subschemaCode(nextContext, valid);
	        return nextContext;
	    }
	    mergeEvaluated(schemaCxt, toName) {
	        const { it, gen } = this;
	        if (!it.opts.unevaluated)
	            return;
	        if (it.props !== true && schemaCxt.props !== undefined) {
	            it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
	        }
	        if (it.items !== true && schemaCxt.items !== undefined) {
	            it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
	        }
	    }
	    mergeValidEvaluated(schemaCxt, valid) {
	        const { it, gen } = this;
	        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
	            gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
	            return true;
	        }
	    }
	}
	validate.KeywordCxt = KeywordCxt;
	function keywordCode(it, keyword, def, ruleType) {
	    const cxt = new KeywordCxt(it, def, keyword);
	    if ("code" in def) {
	        def.code(cxt, ruleType);
	    }
	    else if (cxt.$data && def.validate) {
	        (0, keyword_1.funcKeywordCode)(cxt, def);
	    }
	    else if ("macro" in def) {
	        (0, keyword_1.macroKeywordCode)(cxt, def);
	    }
	    else if (def.compile || def.validate) {
	        (0, keyword_1.funcKeywordCode)(cxt, def);
	    }
	}
	const JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
	const RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
	function getData($data, { dataLevel, dataNames, dataPathArr }) {
	    let jsonPointer;
	    let data;
	    if ($data === "")
	        return names_1.default.rootData;
	    if ($data[0] === "/") {
	        if (!JSON_POINTER.test($data))
	            throw new Error(`Invalid JSON-pointer: ${$data}`);
	        jsonPointer = $data;
	        data = names_1.default.rootData;
	    }
	    else {
	        const matches = RELATIVE_JSON_POINTER.exec($data);
	        if (!matches)
	            throw new Error(`Invalid JSON-pointer: ${$data}`);
	        const up = +matches[1];
	        jsonPointer = matches[2];
	        if (jsonPointer === "#") {
	            if (up >= dataLevel)
	                throw new Error(errorMsg("property/index", up));
	            return dataPathArr[dataLevel - up];
	        }
	        if (up > dataLevel)
	            throw new Error(errorMsg("data", up));
	        data = dataNames[dataLevel - up];
	        if (!jsonPointer)
	            return data;
	    }
	    let expr = data;
	    const segments = jsonPointer.split("/");
	    for (const segment of segments) {
	        if (segment) {
	            data = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
	            expr = (0, codegen_1._) `${expr} && ${data}`;
	        }
	    }
	    return expr;
	    function errorMsg(pointerType, up) {
	        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
	    }
	}
	validate.getData = getData;
	
	return validate;
}

var validation_error = {};

var hasRequiredValidation_error;

function requireValidation_error () {
	if (hasRequiredValidation_error) return validation_error;
	hasRequiredValidation_error = 1;
	Object.defineProperty(validation_error, "__esModule", { value: true });
	class ValidationError extends Error {
	    constructor(errors) {
	        super("validation failed");
	        this.errors = errors;
	        this.ajv = this.validation = true;
	    }
	}
	validation_error.default = ValidationError;
	
	return validation_error;
}

var ref_error = {};

var hasRequiredRef_error;

function requireRef_error () {
	if (hasRequiredRef_error) return ref_error;
	hasRequiredRef_error = 1;
	Object.defineProperty(ref_error, "__esModule", { value: true });
	const resolve_1 = requireResolve();
	class MissingRefError extends Error {
	    constructor(resolver, baseId, ref, msg) {
	        super(msg || `can't resolve reference ${ref} from id ${baseId}`);
	        this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);
	        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
	    }
	}
	ref_error.default = MissingRefError;
	
	return ref_error;
}

var compile = {};

var hasRequiredCompile;

function requireCompile () {
	if (hasRequiredCompile) return compile;
	hasRequiredCompile = 1;
	Object.defineProperty(compile, "__esModule", { value: true });
	compile.resolveSchema = compile.getCompilingSchema = compile.resolveRef = compile.compileSchema = compile.SchemaEnv = void 0;
	const codegen_1 = requireCodegen();
	const validation_error_1 = requireValidation_error();
	const names_1 = requireNames();
	const resolve_1 = requireResolve();
	const util_1 = requireUtil$1();
	const validate_1 = requireValidate();
	class SchemaEnv {
	    constructor(env) {
	        var _a;
	        this.refs = {};
	        this.dynamicAnchors = {};
	        let schema;
	        if (typeof env.schema == "object")
	            schema = env.schema;
	        this.schema = env.schema;
	        this.schemaId = env.schemaId;
	        this.root = env.root || this;
	        this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || "$id"]);
	        this.schemaPath = env.schemaPath;
	        this.localRefs = env.localRefs;
	        this.meta = env.meta;
	        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
	        this.refs = {};
	    }
	}
	compile.SchemaEnv = SchemaEnv;
	// let codeSize = 0
	// let nodeCount = 0
	// Compiles schema in SchemaEnv
	function compileSchema(sch) {
	    // TODO refactor - remove compilations
	    const _sch = getCompilingSchema.call(this, sch);
	    if (_sch)
	        return _sch;
	    const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId); // TODO if getFullPath removed 1 tests fails
	    const { es5, lines } = this.opts.code;
	    const { ownProperties } = this.opts;
	    const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
	    let _ValidationError;
	    if (sch.$async) {
	        _ValidationError = gen.scopeValue("Error", {
	            ref: validation_error_1.default,
	            code: (0, codegen_1._) `require("ajv/dist/runtime/validation_error").default`,
	        });
	    }
	    const validateName = gen.scopeName("validate");
	    sch.validateName = validateName;
	    const schemaCxt = {
	        gen,
	        allErrors: this.opts.allErrors,
	        data: names_1.default.data,
	        parentData: names_1.default.parentData,
	        parentDataProperty: names_1.default.parentDataProperty,
	        dataNames: [names_1.default.data],
	        dataPathArr: [codegen_1.nil], // TODO can its length be used as dataLevel if nil is removed?
	        dataLevel: 0,
	        dataTypes: [],
	        definedProperties: new Set(),
	        topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true
	            ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) }
	            : { ref: sch.schema }),
	        validateName,
	        ValidationError: _ValidationError,
	        schema: sch.schema,
	        schemaEnv: sch,
	        rootId,
	        baseId: sch.baseId || rootId,
	        schemaPath: codegen_1.nil,
	        errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
	        errorPath: (0, codegen_1._) `""`,
	        opts: this.opts,
	        self: this,
	    };
	    let sourceCode;
	    try {
	        this._compilations.add(sch);
	        (0, validate_1.validateFunctionCode)(schemaCxt);
	        gen.optimize(this.opts.code.optimize);
	        // gen.optimize(1)
	        const validateCode = gen.toString();
	        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
	        // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))
	        if (this.opts.code.process)
	            sourceCode = this.opts.code.process(sourceCode, sch);
	        // console.log("\n\n\n *** \n", sourceCode)
	        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
	        const validate = makeValidate(this, this.scope.get());
	        this.scope.value(validateName, { ref: validate });
	        validate.errors = null;
	        validate.schema = sch.schema;
	        validate.schemaEnv = sch;
	        if (sch.$async)
	            validate.$async = true;
	        if (this.opts.code.source === true) {
	            validate.source = { validateName, validateCode, scopeValues: gen._values };
	        }
	        if (this.opts.unevaluated) {
	            const { props, items } = schemaCxt;
	            validate.evaluated = {
	                props: props instanceof codegen_1.Name ? undefined : props,
	                items: items instanceof codegen_1.Name ? undefined : items,
	                dynamicProps: props instanceof codegen_1.Name,
	                dynamicItems: items instanceof codegen_1.Name,
	            };
	            if (validate.source)
	                validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);
	        }
	        sch.validate = validate;
	        return sch;
	    }
	    catch (e) {
	        delete sch.validate;
	        delete sch.validateName;
	        if (sourceCode)
	            this.logger.error("Error compiling schema, function code:", sourceCode);
	        // console.log("\n\n\n *** \n", sourceCode, this.opts)
	        throw e;
	    }
	    finally {
	        this._compilations.delete(sch);
	    }
	}
	compile.compileSchema = compileSchema;
	function resolveRef(root, baseId, ref) {
	    var _a;
	    ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
	    const schOrFunc = root.refs[ref];
	    if (schOrFunc)
	        return schOrFunc;
	    let _sch = resolve.call(this, root, ref);
	    if (_sch === undefined) {
	        const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref]; // TODO maybe localRefs should hold SchemaEnv
	        const { schemaId } = this.opts;
	        if (schema)
	            _sch = new SchemaEnv({ schema, schemaId, root, baseId });
	    }
	    if (_sch === undefined)
	        return;
	    return (root.refs[ref] = inlineOrCompile.call(this, _sch));
	}
	compile.resolveRef = resolveRef;
	function inlineOrCompile(sch) {
	    if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
	        return sch.schema;
	    return sch.validate ? sch : compileSchema.call(this, sch);
	}
	// Index of schema compilation in the currently compiled list
	function getCompilingSchema(schEnv) {
	    for (const sch of this._compilations) {
	        if (sameSchemaEnv(sch, schEnv))
	            return sch;
	    }
	}
	compile.getCompilingSchema = getCompilingSchema;
	function sameSchemaEnv(s1, s2) {
	    return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
	}
	// resolve and compile the references ($ref)
	// TODO returns AnySchemaObject (if the schema can be inlined) or validation function
	function resolve(root, // information about the root schema for the current schema
	ref // reference to resolve
	) {
	    let sch;
	    while (typeof (sch = this.refs[ref]) == "string")
	        ref = sch;
	    return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
	}
	// Resolve schema, its root and baseId
	function resolveSchema(root, // root object with properties schema, refs TODO below SchemaEnv is assigned to it
	ref // reference to resolve
	) {
	    const p = this.opts.uriResolver.parse(ref);
	    const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);
	    let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, undefined);
	    // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests
	    if (Object.keys(root.schema).length > 0 && refPath === baseId) {
	        return getJsonPointer.call(this, p, root);
	    }
	    const id = (0, resolve_1.normalizeId)(refPath);
	    const schOrRef = this.refs[id] || this.schemas[id];
	    if (typeof schOrRef == "string") {
	        const sch = resolveSchema.call(this, root, schOrRef);
	        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
	            return;
	        return getJsonPointer.call(this, p, sch);
	    }
	    if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
	        return;
	    if (!schOrRef.validate)
	        compileSchema.call(this, schOrRef);
	    if (id === (0, resolve_1.normalizeId)(ref)) {
	        const { schema } = schOrRef;
	        const { schemaId } = this.opts;
	        const schId = schema[schemaId];
	        if (schId)
	            baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
	        return new SchemaEnv({ schema, schemaId, root, baseId });
	    }
	    return getJsonPointer.call(this, p, schOrRef);
	}
	compile.resolveSchema = resolveSchema;
	const PREVENT_SCOPE_CHANGE = new Set([
	    "properties",
	    "patternProperties",
	    "enum",
	    "dependencies",
	    "definitions",
	]);
	function getJsonPointer(parsedRef, { baseId, schema, root }) {
	    var _a;
	    if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
	        return;
	    for (const part of parsedRef.fragment.slice(1).split("/")) {
	        if (typeof schema === "boolean")
	            return;
	        const partSchema = schema[(0, util_1.unescapeFragment)(part)];
	        if (partSchema === undefined)
	            return;
	        schema = partSchema;
	        // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?
	        const schId = typeof schema === "object" && schema[this.opts.schemaId];
	        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
	            baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
	        }
	    }
	    let env;
	    if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
	        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
	        env = resolveSchema.call(this, root, $ref);
	    }
	    // even though resolution failed we need to return SchemaEnv to throw exception
	    // so that compileAsync loads missing schema.
	    const { schemaId } = this.opts;
	    env = env || new SchemaEnv({ schema, schemaId, root, baseId });
	    if (env.schema !== env.root.schema)
	        return env;
	    return undefined;
	}
	
	return compile;
}

var $id$1 = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#";
var description = "Meta-schema for $data reference (JSON AnySchema extension proposal)";
var type$2 = "object";
var required$1 = [
	"$data"
];
var properties$3 = {
	$data: {
		type: "string",
		anyOf: [
			{
				format: "relative-json-pointer"
			},
			{
				format: "json-pointer"
			}
		]
	}
};
var additionalProperties$1 = false;
var require$$9 = {
	$id: $id$1,
	description: description,
	type: type$2,
	required: required$1,
	properties: properties$3,
	additionalProperties: additionalProperties$1
};

var uri = {};

var fastUri = {exports: {}};

var scopedChars;
var hasRequiredScopedChars;

function requireScopedChars () {
	if (hasRequiredScopedChars) return scopedChars;
	hasRequiredScopedChars = 1;

	const HEX = {
	  0: 0,
	  1: 1,
	  2: 2,
	  3: 3,
	  4: 4,
	  5: 5,
	  6: 6,
	  7: 7,
	  8: 8,
	  9: 9,
	  a: 10,
	  A: 10,
	  b: 11,
	  B: 11,
	  c: 12,
	  C: 12,
	  d: 13,
	  D: 13,
	  e: 14,
	  E: 14,
	  f: 15,
	  F: 15
	};

	scopedChars = {
	  HEX
	};
	return scopedChars;
}

var utils$2;
var hasRequiredUtils$2;

function requireUtils$2 () {
	if (hasRequiredUtils$2) return utils$2;
	hasRequiredUtils$2 = 1;

	const { HEX } = requireScopedChars();

	const IPV4_REG = /^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u;

	function normalizeIPv4 (host) {
	  if (findToken(host, '.') < 3) { return { host, isIPV4: false } }
	  const matches = host.match(IPV4_REG) || [];
	  const [address] = matches;
	  if (address) {
	    return { host: stripLeadingZeros(address, '.'), isIPV4: true }
	  } else {
	    return { host, isIPV4: false }
	  }
	}

	/**
	 * @param {string[]} input
	 * @param {boolean} [keepZero=false]
	 * @returns {string|undefined}
	 */
	function stringArrayToHexStripped (input, keepZero = false) {
	  let acc = '';
	  let strip = true;
	  for (const c of input) {
	    if (HEX[c] === undefined) return undefined
	    if (c !== '0' && strip === true) strip = false;
	    if (!strip) acc += c;
	  }
	  if (keepZero && acc.length === 0) acc = '0';
	  return acc
	}

	function getIPV6 (input) {
	  let tokenCount = 0;
	  const output = { error: false, address: '', zone: '' };
	  const address = [];
	  const buffer = [];
	  let isZone = false;
	  let endipv6Encountered = false;
	  let endIpv6 = false;

	  function consume () {
	    if (buffer.length) {
	      if (isZone === false) {
	        const hex = stringArrayToHexStripped(buffer);
	        if (hex !== undefined) {
	          address.push(hex);
	        } else {
	          output.error = true;
	          return false
	        }
	      }
	      buffer.length = 0;
	    }
	    return true
	  }

	  for (let i = 0; i < input.length; i++) {
	    const cursor = input[i];
	    if (cursor === '[' || cursor === ']') { continue }
	    if (cursor === ':') {
	      if (endipv6Encountered === true) {
	        endIpv6 = true;
	      }
	      if (!consume()) { break }
	      tokenCount++;
	      address.push(':');
	      if (tokenCount > 7) {
	        // not valid
	        output.error = true;
	        break
	      }
	      if (i - 1 >= 0 && input[i - 1] === ':') {
	        endipv6Encountered = true;
	      }
	      continue
	    } else if (cursor === '%') {
	      if (!consume()) { break }
	      // switch to zone detection
	      isZone = true;
	    } else {
	      buffer.push(cursor);
	      continue
	    }
	  }
	  if (buffer.length) {
	    if (isZone) {
	      output.zone = buffer.join('');
	    } else if (endIpv6) {
	      address.push(buffer.join(''));
	    } else {
	      address.push(stringArrayToHexStripped(buffer));
	    }
	  }
	  output.address = address.join('');
	  return output
	}

	function normalizeIPv6 (host) {
	  if (findToken(host, ':') < 2) { return { host, isIPV6: false } }
	  const ipv6 = getIPV6(host);

	  if (!ipv6.error) {
	    let newHost = ipv6.address;
	    let escapedHost = ipv6.address;
	    if (ipv6.zone) {
	      newHost += '%' + ipv6.zone;
	      escapedHost += '%25' + ipv6.zone;
	    }
	    return { host: newHost, escapedHost, isIPV6: true }
	  } else {
	    return { host, isIPV6: false }
	  }
	}

	function stripLeadingZeros (str, token) {
	  let out = '';
	  let skip = true;
	  const l = str.length;
	  for (let i = 0; i < l; i++) {
	    const c = str[i];
	    if (c === '0' && skip) {
	      if ((i + 1 <= l && str[i + 1] === token) || i + 1 === l) {
	        out += c;
	        skip = false;
	      }
	    } else {
	      if (c === token) {
	        skip = true;
	      } else {
	        skip = false;
	      }
	      out += c;
	    }
	  }
	  return out
	}

	function findToken (str, token) {
	  let ind = 0;
	  for (let i = 0; i < str.length; i++) {
	    if (str[i] === token) ind++;
	  }
	  return ind
	}

	const RDS1 = /^\.\.?\//u;
	const RDS2 = /^\/\.(?:\/|$)/u;
	const RDS3 = /^\/\.\.(?:\/|$)/u;
	const RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/u;

	function removeDotSegments (input) {
	  const output = [];

	  while (input.length) {
	    if (input.match(RDS1)) {
	      input = input.replace(RDS1, '');
	    } else if (input.match(RDS2)) {
	      input = input.replace(RDS2, '/');
	    } else if (input.match(RDS3)) {
	      input = input.replace(RDS3, '/');
	      output.pop();
	    } else if (input === '.' || input === '..') {
	      input = '';
	    } else {
	      const im = input.match(RDS5);
	      if (im) {
	        const s = im[0];
	        input = input.slice(s.length);
	        output.push(s);
	      } else {
	        throw new Error('Unexpected dot segment condition')
	      }
	    }
	  }
	  return output.join('')
	}

	function normalizeComponentEncoding (components, esc) {
	  const func = esc !== true ? escape : unescape;
	  if (components.scheme !== undefined) {
	    components.scheme = func(components.scheme);
	  }
	  if (components.userinfo !== undefined) {
	    components.userinfo = func(components.userinfo);
	  }
	  if (components.host !== undefined) {
	    components.host = func(components.host);
	  }
	  if (components.path !== undefined) {
	    components.path = func(components.path);
	  }
	  if (components.query !== undefined) {
	    components.query = func(components.query);
	  }
	  if (components.fragment !== undefined) {
	    components.fragment = func(components.fragment);
	  }
	  return components
	}

	function recomposeAuthority (components) {
	  const uriTokens = [];

	  if (components.userinfo !== undefined) {
	    uriTokens.push(components.userinfo);
	    uriTokens.push('@');
	  }

	  if (components.host !== undefined) {
	    let host = unescape(components.host);
	    const ipV4res = normalizeIPv4(host);

	    if (ipV4res.isIPV4) {
	      host = ipV4res.host;
	    } else {
	      const ipV6res = normalizeIPv6(ipV4res.host);
	      if (ipV6res.isIPV6 === true) {
	        host = `[${ipV6res.escapedHost}]`;
	      } else {
	        host = components.host;
	      }
	    }
	    uriTokens.push(host);
	  }

	  if (typeof components.port === 'number' || typeof components.port === 'string') {
	    uriTokens.push(':');
	    uriTokens.push(String(components.port));
	  }

	  return uriTokens.length ? uriTokens.join('') : undefined
	}
	utils$2 = {
	  recomposeAuthority,
	  normalizeComponentEncoding,
	  removeDotSegments,
	  normalizeIPv4,
	  normalizeIPv6,
	  stringArrayToHexStripped
	};
	return utils$2;
}

var schemes;
var hasRequiredSchemes;

function requireSchemes () {
	if (hasRequiredSchemes) return schemes;
	hasRequiredSchemes = 1;

	const UUID_REG = /^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu;
	const URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;

	function isSecure (wsComponents) {
	  return typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === 'wss'
	}

	function httpParse (components) {
	  if (!components.host) {
	    components.error = components.error || 'HTTP URIs must have a host.';
	  }

	  return components
	}

	function httpSerialize (components) {
	  const secure = String(components.scheme).toLowerCase() === 'https';

	  // normalize the default port
	  if (components.port === (secure ? 443 : 80) || components.port === '') {
	    components.port = undefined;
	  }

	  // normalize the empty path
	  if (!components.path) {
	    components.path = '/';
	  }

	  // NOTE: We do not parse query strings for HTTP URIs
	  // as WWW Form Url Encoded query strings are part of the HTML4+ spec,
	  // and not the HTTP spec.

	  return components
	}

	function wsParse (wsComponents) {
	// indicate if the secure flag is set
	  wsComponents.secure = isSecure(wsComponents);

	  // construct resouce name
	  wsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '');
	  wsComponents.path = undefined;
	  wsComponents.query = undefined;

	  return wsComponents
	}

	function wsSerialize (wsComponents) {
	// normalize the default port
	  if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === '') {
	    wsComponents.port = undefined;
	  }

	  // ensure scheme matches secure flag
	  if (typeof wsComponents.secure === 'boolean') {
	    wsComponents.scheme = (wsComponents.secure ? 'wss' : 'ws');
	    wsComponents.secure = undefined;
	  }

	  // reconstruct path from resource name
	  if (wsComponents.resourceName) {
	    const [path, query] = wsComponents.resourceName.split('?');
	    wsComponents.path = (path && path !== '/' ? path : undefined);
	    wsComponents.query = query;
	    wsComponents.resourceName = undefined;
	  }

	  // forbid fragment component
	  wsComponents.fragment = undefined;

	  return wsComponents
	}

	function urnParse (urnComponents, options) {
	  if (!urnComponents.path) {
	    urnComponents.error = 'URN can not be parsed';
	    return urnComponents
	  }
	  const matches = urnComponents.path.match(URN_REG);
	  if (matches) {
	    const scheme = options.scheme || urnComponents.scheme || 'urn';
	    urnComponents.nid = matches[1].toLowerCase();
	    urnComponents.nss = matches[2];
	    const urnScheme = `${scheme}:${options.nid || urnComponents.nid}`;
	    const schemeHandler = SCHEMES[urnScheme];
	    urnComponents.path = undefined;

	    if (schemeHandler) {
	      urnComponents = schemeHandler.parse(urnComponents, options);
	    }
	  } else {
	    urnComponents.error = urnComponents.error || 'URN can not be parsed.';
	  }

	  return urnComponents
	}

	function urnSerialize (urnComponents, options) {
	  const scheme = options.scheme || urnComponents.scheme || 'urn';
	  const nid = urnComponents.nid.toLowerCase();
	  const urnScheme = `${scheme}:${options.nid || nid}`;
	  const schemeHandler = SCHEMES[urnScheme];

	  if (schemeHandler) {
	    urnComponents = schemeHandler.serialize(urnComponents, options);
	  }

	  const uriComponents = urnComponents;
	  const nss = urnComponents.nss;
	  uriComponents.path = `${nid || options.nid}:${nss}`;

	  options.skipEscape = true;
	  return uriComponents
	}

	function urnuuidParse (urnComponents, options) {
	  const uuidComponents = urnComponents;
	  uuidComponents.uuid = uuidComponents.nss;
	  uuidComponents.nss = undefined;

	  if (!options.tolerant && (!uuidComponents.uuid || !UUID_REG.test(uuidComponents.uuid))) {
	    uuidComponents.error = uuidComponents.error || 'UUID is not valid.';
	  }

	  return uuidComponents
	}

	function urnuuidSerialize (uuidComponents) {
	  const urnComponents = uuidComponents;
	  // normalize UUID
	  urnComponents.nss = (uuidComponents.uuid || '').toLowerCase();
	  return urnComponents
	}

	const http = {
	  scheme: 'http',
	  domainHost: true,
	  parse: httpParse,
	  serialize: httpSerialize
	};

	const https = {
	  scheme: 'https',
	  domainHost: http.domainHost,
	  parse: httpParse,
	  serialize: httpSerialize
	};

	const ws = {
	  scheme: 'ws',
	  domainHost: true,
	  parse: wsParse,
	  serialize: wsSerialize
	};

	const wss = {
	  scheme: 'wss',
	  domainHost: ws.domainHost,
	  parse: ws.parse,
	  serialize: ws.serialize
	};

	const urn = {
	  scheme: 'urn',
	  parse: urnParse,
	  serialize: urnSerialize,
	  skipNormalize: true
	};

	const urnuuid = {
	  scheme: 'urn:uuid',
	  parse: urnuuidParse,
	  serialize: urnuuidSerialize,
	  skipNormalize: true
	};

	const SCHEMES = {
	  http,
	  https,
	  ws,
	  wss,
	  urn,
	  'urn:uuid': urnuuid
	};

	schemes = SCHEMES;
	return schemes;
}

var hasRequiredFastUri;

function requireFastUri () {
	if (hasRequiredFastUri) return fastUri.exports;
	hasRequiredFastUri = 1;

	const { normalizeIPv6, normalizeIPv4, removeDotSegments, recomposeAuthority, normalizeComponentEncoding } = requireUtils$2();
	const SCHEMES = requireSchemes();

	function normalize (uri, options) {
	  if (typeof uri === 'string') {
	    uri = serialize(parse(uri, options), options);
	  } else if (typeof uri === 'object') {
	    uri = parse(serialize(uri, options), options);
	  }
	  return uri
	}

	function resolve (baseURI, relativeURI, options) {
	  const schemelessOptions = Object.assign({ scheme: 'null' }, options);
	  const resolved = resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true);
	  return serialize(resolved, { ...schemelessOptions, skipEscape: true })
	}

	function resolveComponents (base, relative, options, skipNormalization) {
	  const target = {};
	  if (!skipNormalization) {
	    base = parse(serialize(base, options), options); // normalize base components
	    relative = parse(serialize(relative, options), options); // normalize relative components
	  }
	  options = options || {};

	  if (!options.tolerant && relative.scheme) {
	    target.scheme = relative.scheme;
	    // target.authority = relative.authority;
	    target.userinfo = relative.userinfo;
	    target.host = relative.host;
	    target.port = relative.port;
	    target.path = removeDotSegments(relative.path || '');
	    target.query = relative.query;
	  } else {
	    if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {
	      // target.authority = relative.authority;
	      target.userinfo = relative.userinfo;
	      target.host = relative.host;
	      target.port = relative.port;
	      target.path = removeDotSegments(relative.path || '');
	      target.query = relative.query;
	    } else {
	      if (!relative.path) {
	        target.path = base.path;
	        if (relative.query !== undefined) {
	          target.query = relative.query;
	        } else {
	          target.query = base.query;
	        }
	      } else {
	        if (relative.path.charAt(0) === '/') {
	          target.path = removeDotSegments(relative.path);
	        } else {
	          if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {
	            target.path = '/' + relative.path;
	          } else if (!base.path) {
	            target.path = relative.path;
	          } else {
	            target.path = base.path.slice(0, base.path.lastIndexOf('/') + 1) + relative.path;
	          }
	          target.path = removeDotSegments(target.path);
	        }
	        target.query = relative.query;
	      }
	      // target.authority = base.authority;
	      target.userinfo = base.userinfo;
	      target.host = base.host;
	      target.port = base.port;
	    }
	    target.scheme = base.scheme;
	  }

	  target.fragment = relative.fragment;

	  return target
	}

	function equal (uriA, uriB, options) {
	  if (typeof uriA === 'string') {
	    uriA = unescape(uriA);
	    uriA = serialize(normalizeComponentEncoding(parse(uriA, options), true), { ...options, skipEscape: true });
	  } else if (typeof uriA === 'object') {
	    uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true });
	  }

	  if (typeof uriB === 'string') {
	    uriB = unescape(uriB);
	    uriB = serialize(normalizeComponentEncoding(parse(uriB, options), true), { ...options, skipEscape: true });
	  } else if (typeof uriB === 'object') {
	    uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true });
	  }

	  return uriA.toLowerCase() === uriB.toLowerCase()
	}

	function serialize (cmpts, opts) {
	  const components = {
	    host: cmpts.host,
	    scheme: cmpts.scheme,
	    userinfo: cmpts.userinfo,
	    port: cmpts.port,
	    path: cmpts.path,
	    query: cmpts.query,
	    nid: cmpts.nid,
	    nss: cmpts.nss,
	    uuid: cmpts.uuid,
	    fragment: cmpts.fragment,
	    reference: cmpts.reference,
	    resourceName: cmpts.resourceName,
	    secure: cmpts.secure,
	    error: ''
	  };
	  const options = Object.assign({}, opts);
	  const uriTokens = [];

	  // find scheme handler
	  const schemeHandler = SCHEMES[(options.scheme || components.scheme || '').toLowerCase()];

	  // perform scheme specific serialization
	  if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);

	  if (components.path !== undefined) {
	    if (!options.skipEscape) {
	      components.path = escape(components.path);

	      if (components.scheme !== undefined) {
	        components.path = components.path.split('%3A').join(':');
	      }
	    } else {
	      components.path = unescape(components.path);
	    }
	  }

	  if (options.reference !== 'suffix' && components.scheme) {
	    uriTokens.push(components.scheme, ':');
	  }

	  const authority = recomposeAuthority(components);
	  if (authority !== undefined) {
	    if (options.reference !== 'suffix') {
	      uriTokens.push('//');
	    }

	    uriTokens.push(authority);

	    if (components.path && components.path.charAt(0) !== '/') {
	      uriTokens.push('/');
	    }
	  }
	  if (components.path !== undefined) {
	    let s = components.path;

	    if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
	      s = removeDotSegments(s);
	    }

	    if (authority === undefined) {
	      s = s.replace(/^\/\//u, '/%2F'); // don't allow the path to start with "//"
	    }

	    uriTokens.push(s);
	  }

	  if (components.query !== undefined) {
	    uriTokens.push('?', components.query);
	  }

	  if (components.fragment !== undefined) {
	    uriTokens.push('#', components.fragment);
	  }
	  return uriTokens.join('')
	}

	const hexLookUp = Array.from({ length: 127 }, (_v, k) => /[^!"$&'()*+,\-.;=_`a-z{}~]/u.test(String.fromCharCode(k)));

	function nonSimpleDomain (value) {
	  let code = 0;
	  for (let i = 0, len = value.length; i < len; ++i) {
	    code = value.charCodeAt(i);
	    if (code > 126 || hexLookUp[code]) {
	      return true
	    }
	  }
	  return false
	}

	const URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;

	function parse (uri, opts) {
	  const options = Object.assign({}, opts);
	  const parsed = {
	    scheme: undefined,
	    userinfo: undefined,
	    host: '',
	    port: undefined,
	    path: '',
	    query: undefined,
	    fragment: undefined
	  };
	  const gotEncoding = uri.indexOf('%') !== -1;
	  let isIP = false;
	  if (options.reference === 'suffix') uri = (options.scheme ? options.scheme + ':' : '') + '//' + uri;

	  const matches = uri.match(URI_PARSE);

	  if (matches) {
	    // store each component
	    parsed.scheme = matches[1];
	    parsed.userinfo = matches[3];
	    parsed.host = matches[4];
	    parsed.port = parseInt(matches[5], 10);
	    parsed.path = matches[6] || '';
	    parsed.query = matches[7];
	    parsed.fragment = matches[8];

	    // fix port number
	    if (isNaN(parsed.port)) {
	      parsed.port = matches[5];
	    }
	    if (parsed.host) {
	      const ipv4result = normalizeIPv4(parsed.host);
	      if (ipv4result.isIPV4 === false) {
	        const ipv6result = normalizeIPv6(ipv4result.host);
	        parsed.host = ipv6result.host.toLowerCase();
	        isIP = ipv6result.isIPV6;
	      } else {
	        parsed.host = ipv4result.host;
	        isIP = true;
	      }
	    }
	    if (parsed.scheme === undefined && parsed.userinfo === undefined && parsed.host === undefined && parsed.port === undefined && parsed.query === undefined && !parsed.path) {
	      parsed.reference = 'same-document';
	    } else if (parsed.scheme === undefined) {
	      parsed.reference = 'relative';
	    } else if (parsed.fragment === undefined) {
	      parsed.reference = 'absolute';
	    } else {
	      parsed.reference = 'uri';
	    }

	    // check for reference errors
	    if (options.reference && options.reference !== 'suffix' && options.reference !== parsed.reference) {
	      parsed.error = parsed.error || 'URI is not a ' + options.reference + ' reference.';
	    }

	    // find scheme handler
	    const schemeHandler = SCHEMES[(options.scheme || parsed.scheme || '').toLowerCase()];

	    // check if scheme can't handle IRIs
	    if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
	      // if host component is a domain name
	      if (parsed.host && (options.domainHost || (schemeHandler && schemeHandler.domainHost)) && isIP === false && nonSimpleDomain(parsed.host)) {
	        // convert Unicode IDN -> ASCII IDN
	        try {
	          parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
	        } catch (e) {
	          parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e;
	        }
	      }
	      // convert IRI -> URI
	    }

	    if (!schemeHandler || (schemeHandler && !schemeHandler.skipNormalize)) {
	      if (gotEncoding && parsed.scheme !== undefined) {
	        parsed.scheme = unescape(parsed.scheme);
	      }
	      if (gotEncoding && parsed.host !== undefined) {
	        parsed.host = unescape(parsed.host);
	      }
	      if (parsed.path) {
	        parsed.path = escape(unescape(parsed.path));
	      }
	      if (parsed.fragment) {
	        parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment));
	      }
	    }

	    // perform scheme specific parsing
	    if (schemeHandler && schemeHandler.parse) {
	      schemeHandler.parse(parsed, options);
	    }
	  } else {
	    parsed.error = parsed.error || 'URI can not be parsed.';
	  }
	  return parsed
	}

	const fastUri$1 = {
	  SCHEMES,
	  normalize,
	  resolve,
	  resolveComponents,
	  equal,
	  serialize,
	  parse
	};

	fastUri.exports = fastUri$1;
	fastUri.exports.default = fastUri$1;
	fastUri.exports.fastUri = fastUri$1;
	return fastUri.exports;
}

var hasRequiredUri;

function requireUri () {
	if (hasRequiredUri) return uri;
	hasRequiredUri = 1;
	Object.defineProperty(uri, "__esModule", { value: true });
	const uri$1 = requireFastUri();
	uri$1.code = 'require("ajv/dist/runtime/uri").default';
	uri.default = uri$1;
	
	return uri;
}

var hasRequiredCore$1;

function requireCore$1 () {
	if (hasRequiredCore$1) return core$1;
	hasRequiredCore$1 = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
		var validate_1 = requireValidate();
		Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function () { return validate_1.KeywordCxt; } });
		var codegen_1 = requireCodegen();
		Object.defineProperty(exports, "_", { enumerable: true, get: function () { return codegen_1._; } });
		Object.defineProperty(exports, "str", { enumerable: true, get: function () { return codegen_1.str; } });
		Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return codegen_1.stringify; } });
		Object.defineProperty(exports, "nil", { enumerable: true, get: function () { return codegen_1.nil; } });
		Object.defineProperty(exports, "Name", { enumerable: true, get: function () { return codegen_1.Name; } });
		Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function () { return codegen_1.CodeGen; } });
		const validation_error_1 = requireValidation_error();
		const ref_error_1 = requireRef_error();
		const rules_1 = requireRules();
		const compile_1 = requireCompile();
		const codegen_2 = requireCodegen();
		const resolve_1 = requireResolve();
		const dataType_1 = requireDataType();
		const util_1 = requireUtil$1();
		const $dataRefSchema = require$$9;
		const uri_1 = requireUri();
		const defaultRegExp = (str, flags) => new RegExp(str, flags);
		defaultRegExp.code = "new RegExp";
		const META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
		const EXT_SCOPE_NAMES = new Set([
		    "validate",
		    "serialize",
		    "parse",
		    "wrapper",
		    "root",
		    "schema",
		    "keyword",
		    "pattern",
		    "formats",
		    "validate$data",
		    "func",
		    "obj",
		    "Error",
		]);
		const removedOptions = {
		    errorDataPath: "",
		    format: "`validateFormats: false` can be used instead.",
		    nullable: '"nullable" keyword is supported by default.',
		    jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
		    extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
		    missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
		    processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
		    sourceCode: "Use option `code: {source: true}`",
		    strictDefaults: "It is default now, see option `strict`.",
		    strictKeywords: "It is default now, see option `strict`.",
		    uniqueItems: '"uniqueItems" keyword is always validated.',
		    unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
		    cache: "Map is used as cache, schema object as key.",
		    serialize: "Map is used as cache, schema object as key.",
		    ajvErrors: "It is default now.",
		};
		const deprecatedOptions = {
		    ignoreKeywordsWithRef: "",
		    jsPropertySyntax: "",
		    unicode: '"minLength"/"maxLength" account for unicode characters by default.',
		};
		const MAX_EXPRESSION = 200;
		// eslint-disable-next-line complexity
		function requiredOptions(o) {
		    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
		    const s = o.strict;
		    const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;
		    const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0;
		    const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
		    const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
		    return {
		        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
		        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
		        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
		        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
		        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
		        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
		        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
		        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
		        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
		        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
		        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
		        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
		        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
		        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
		        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
		        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
		        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
		        uriResolver: uriResolver,
		    };
		}
		class Ajv {
		    constructor(opts = {}) {
		        this.schemas = {};
		        this.refs = {};
		        this.formats = {};
		        this._compilations = new Set();
		        this._loading = {};
		        this._cache = new Map();
		        opts = this.opts = { ...opts, ...requiredOptions(opts) };
		        const { es5, lines } = this.opts.code;
		        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
		        this.logger = getLogger(opts.logger);
		        const formatOpt = opts.validateFormats;
		        opts.validateFormats = false;
		        this.RULES = (0, rules_1.getRules)();
		        checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
		        checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
		        this._metaOpts = getMetaSchemaOptions.call(this);
		        if (opts.formats)
		            addInitialFormats.call(this);
		        this._addVocabularies();
		        this._addDefaultMetaSchema();
		        if (opts.keywords)
		            addInitialKeywords.call(this, opts.keywords);
		        if (typeof opts.meta == "object")
		            this.addMetaSchema(opts.meta);
		        addInitialSchemas.call(this);
		        opts.validateFormats = formatOpt;
		    }
		    _addVocabularies() {
		        this.addKeyword("$async");
		    }
		    _addDefaultMetaSchema() {
		        const { $data, meta, schemaId } = this.opts;
		        let _dataRefSchema = $dataRefSchema;
		        if (schemaId === "id") {
		            _dataRefSchema = { ...$dataRefSchema };
		            _dataRefSchema.id = _dataRefSchema.$id;
		            delete _dataRefSchema.$id;
		        }
		        if (meta && $data)
		            this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
		    }
		    defaultMeta() {
		        const { meta, schemaId } = this.opts;
		        return (this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : undefined);
		    }
		    validate(schemaKeyRef, // key, ref or schema object
		    // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents
		    data // to be validated
		    ) {
		        let v;
		        if (typeof schemaKeyRef == "string") {
		            v = this.getSchema(schemaKeyRef);
		            if (!v)
		                throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
		        }
		        else {
		            v = this.compile(schemaKeyRef);
		        }
		        const valid = v(data);
		        if (!("$async" in v))
		            this.errors = v.errors;
		        return valid;
		    }
		    compile(schema, _meta) {
		        const sch = this._addSchema(schema, _meta);
		        return (sch.validate || this._compileSchemaEnv(sch));
		    }
		    compileAsync(schema, meta) {
		        if (typeof this.opts.loadSchema != "function") {
		            throw new Error("options.loadSchema should be a function");
		        }
		        const { loadSchema } = this.opts;
		        return runCompileAsync.call(this, schema, meta);
		        async function runCompileAsync(_schema, _meta) {
		            await loadMetaSchema.call(this, _schema.$schema);
		            const sch = this._addSchema(_schema, _meta);
		            return sch.validate || _compileAsync.call(this, sch);
		        }
		        async function loadMetaSchema($ref) {
		            if ($ref && !this.getSchema($ref)) {
		                await runCompileAsync.call(this, { $ref }, true);
		            }
		        }
		        async function _compileAsync(sch) {
		            try {
		                return this._compileSchemaEnv(sch);
		            }
		            catch (e) {
		                if (!(e instanceof ref_error_1.default))
		                    throw e;
		                checkLoaded.call(this, e);
		                await loadMissingSchema.call(this, e.missingSchema);
		                return _compileAsync.call(this, sch);
		            }
		        }
		        function checkLoaded({ missingSchema: ref, missingRef }) {
		            if (this.refs[ref]) {
		                throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
		            }
		        }
		        async function loadMissingSchema(ref) {
		            const _schema = await _loadSchema.call(this, ref);
		            if (!this.refs[ref])
		                await loadMetaSchema.call(this, _schema.$schema);
		            if (!this.refs[ref])
		                this.addSchema(_schema, ref, meta);
		        }
		        async function _loadSchema(ref) {
		            const p = this._loading[ref];
		            if (p)
		                return p;
		            try {
		                return await (this._loading[ref] = loadSchema(ref));
		            }
		            finally {
		                delete this._loading[ref];
		            }
		        }
		    }
		    // Adds schema to the instance
		    addSchema(schema, // If array is passed, `key` will be ignored
		    key, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.
		    _meta, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.
		    _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.
		    ) {
		        if (Array.isArray(schema)) {
		            for (const sch of schema)
		                this.addSchema(sch, undefined, _meta, _validateSchema);
		            return this;
		        }
		        let id;
		        if (typeof schema === "object") {
		            const { schemaId } = this.opts;
		            id = schema[schemaId];
		            if (id !== undefined && typeof id != "string") {
		                throw new Error(`schema ${schemaId} must be string`);
		            }
		        }
		        key = (0, resolve_1.normalizeId)(key || id);
		        this._checkUnique(key);
		        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
		        return this;
		    }
		    // Add schema that will be used to validate other schemas
		    // options in META_IGNORE_OPTIONS are alway set to false
		    addMetaSchema(schema, key, // schema key
		    _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema
		    ) {
		        this.addSchema(schema, key, true, _validateSchema);
		        return this;
		    }
		    //  Validate schema against its meta-schema
		    validateSchema(schema, throwOrLogError) {
		        if (typeof schema == "boolean")
		            return true;
		        let $schema;
		        $schema = schema.$schema;
		        if ($schema !== undefined && typeof $schema != "string") {
		            throw new Error("$schema must be a string");
		        }
		        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
		        if (!$schema) {
		            this.logger.warn("meta-schema not available");
		            this.errors = null;
		            return true;
		        }
		        const valid = this.validate($schema, schema);
		        if (!valid && throwOrLogError) {
		            const message = "schema is invalid: " + this.errorsText();
		            if (this.opts.validateSchema === "log")
		                this.logger.error(message);
		            else
		                throw new Error(message);
		        }
		        return valid;
		    }
		    // Get compiled schema by `key` or `ref`.
		    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
		    getSchema(keyRef) {
		        let sch;
		        while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
		            keyRef = sch;
		        if (sch === undefined) {
		            const { schemaId } = this.opts;
		            const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
		            sch = compile_1.resolveSchema.call(this, root, keyRef);
		            if (!sch)
		                return;
		            this.refs[keyRef] = sch;
		        }
		        return (sch.validate || this._compileSchemaEnv(sch));
		    }
		    // Remove cached schema(s).
		    // If no parameter is passed all schemas but meta-schemas are removed.
		    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
		    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
		    removeSchema(schemaKeyRef) {
		        if (schemaKeyRef instanceof RegExp) {
		            this._removeAllSchemas(this.schemas, schemaKeyRef);
		            this._removeAllSchemas(this.refs, schemaKeyRef);
		            return this;
		        }
		        switch (typeof schemaKeyRef) {
		            case "undefined":
		                this._removeAllSchemas(this.schemas);
		                this._removeAllSchemas(this.refs);
		                this._cache.clear();
		                return this;
		            case "string": {
		                const sch = getSchEnv.call(this, schemaKeyRef);
		                if (typeof sch == "object")
		                    this._cache.delete(sch.schema);
		                delete this.schemas[schemaKeyRef];
		                delete this.refs[schemaKeyRef];
		                return this;
		            }
		            case "object": {
		                const cacheKey = schemaKeyRef;
		                this._cache.delete(cacheKey);
		                let id = schemaKeyRef[this.opts.schemaId];
		                if (id) {
		                    id = (0, resolve_1.normalizeId)(id);
		                    delete this.schemas[id];
		                    delete this.refs[id];
		                }
		                return this;
		            }
		            default:
		                throw new Error("ajv.removeSchema: invalid parameter");
		        }
		    }
		    // add "vocabulary" - a collection of keywords
		    addVocabulary(definitions) {
		        for (const def of definitions)
		            this.addKeyword(def);
		        return this;
		    }
		    addKeyword(kwdOrDef, def // deprecated
		    ) {
		        let keyword;
		        if (typeof kwdOrDef == "string") {
		            keyword = kwdOrDef;
		            if (typeof def == "object") {
		                this.logger.warn("these parameters are deprecated, see docs for addKeyword");
		                def.keyword = keyword;
		            }
		        }
		        else if (typeof kwdOrDef == "object" && def === undefined) {
		            def = kwdOrDef;
		            keyword = def.keyword;
		            if (Array.isArray(keyword) && !keyword.length) {
		                throw new Error("addKeywords: keyword must be string or non-empty array");
		            }
		        }
		        else {
		            throw new Error("invalid addKeywords parameters");
		        }
		        checkKeyword.call(this, keyword, def);
		        if (!def) {
		            (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));
		            return this;
		        }
		        keywordMetaschema.call(this, def);
		        const definition = {
		            ...def,
		            type: (0, dataType_1.getJSONTypes)(def.type),
		            schemaType: (0, dataType_1.getJSONTypes)(def.schemaType),
		        };
		        (0, util_1.eachItem)(keyword, definition.type.length === 0
		            ? (k) => addRule.call(this, k, definition)
		            : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));
		        return this;
		    }
		    getKeyword(keyword) {
		        const rule = this.RULES.all[keyword];
		        return typeof rule == "object" ? rule.definition : !!rule;
		    }
		    // Remove keyword
		    removeKeyword(keyword) {
		        // TODO return type should be Ajv
		        const { RULES } = this;
		        delete RULES.keywords[keyword];
		        delete RULES.all[keyword];
		        for (const group of RULES.rules) {
		            const i = group.rules.findIndex((rule) => rule.keyword === keyword);
		            if (i >= 0)
		                group.rules.splice(i, 1);
		        }
		        return this;
		    }
		    // Add format
		    addFormat(name, format) {
		        if (typeof format == "string")
		            format = new RegExp(format);
		        this.formats[name] = format;
		        return this;
		    }
		    errorsText(errors = this.errors, // optional array of validation errors
		    { separator = ", ", dataVar = "data" } = {} // optional options with properties `separator` and `dataVar`
		    ) {
		        if (!errors || errors.length === 0)
		            return "No errors";
		        return errors
		            .map((e) => `${dataVar}${e.instancePath} ${e.message}`)
		            .reduce((text, msg) => text + separator + msg);
		    }
		    $dataMetaSchema(metaSchema, keywordsJsonPointers) {
		        const rules = this.RULES.all;
		        metaSchema = JSON.parse(JSON.stringify(metaSchema));
		        for (const jsonPointer of keywordsJsonPointers) {
		            const segments = jsonPointer.split("/").slice(1); // first segment is an empty string
		            let keywords = metaSchema;
		            for (const seg of segments)
		                keywords = keywords[seg];
		            for (const key in rules) {
		                const rule = rules[key];
		                if (typeof rule != "object")
		                    continue;
		                const { $data } = rule.definition;
		                const schema = keywords[key];
		                if ($data && schema)
		                    keywords[key] = schemaOrData(schema);
		            }
		        }
		        return metaSchema;
		    }
		    _removeAllSchemas(schemas, regex) {
		        for (const keyRef in schemas) {
		            const sch = schemas[keyRef];
		            if (!regex || regex.test(keyRef)) {
		                if (typeof sch == "string") {
		                    delete schemas[keyRef];
		                }
		                else if (sch && !sch.meta) {
		                    this._cache.delete(sch.schema);
		                    delete schemas[keyRef];
		                }
		            }
		        }
		    }
		    _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
		        let id;
		        const { schemaId } = this.opts;
		        if (typeof schema == "object") {
		            id = schema[schemaId];
		        }
		        else {
		            if (this.opts.jtd)
		                throw new Error("schema must be object");
		            else if (typeof schema != "boolean")
		                throw new Error("schema must be object or boolean");
		        }
		        let sch = this._cache.get(schema);
		        if (sch !== undefined)
		            return sch;
		        baseId = (0, resolve_1.normalizeId)(id || baseId);
		        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
		        sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
		        this._cache.set(sch.schema, sch);
		        if (addSchema && !baseId.startsWith("#")) {
		            // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)
		            if (baseId)
		                this._checkUnique(baseId);
		            this.refs[baseId] = sch;
		        }
		        if (validateSchema)
		            this.validateSchema(schema, true);
		        return sch;
		    }
		    _checkUnique(id) {
		        if (this.schemas[id] || this.refs[id]) {
		            throw new Error(`schema with key or id "${id}" already exists`);
		        }
		    }
		    _compileSchemaEnv(sch) {
		        if (sch.meta)
		            this._compileMetaSchema(sch);
		        else
		            compile_1.compileSchema.call(this, sch);
		        /* istanbul ignore if */
		        if (!sch.validate)
		            throw new Error("ajv implementation error");
		        return sch.validate;
		    }
		    _compileMetaSchema(sch) {
		        const currentOpts = this.opts;
		        this.opts = this._metaOpts;
		        try {
		            compile_1.compileSchema.call(this, sch);
		        }
		        finally {
		            this.opts = currentOpts;
		        }
		    }
		}
		Ajv.ValidationError = validation_error_1.default;
		Ajv.MissingRefError = ref_error_1.default;
		exports.default = Ajv;
		function checkOptions(checkOpts, options, msg, log = "error") {
		    for (const key in checkOpts) {
		        const opt = key;
		        if (opt in options)
		            this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
		    }
		}
		function getSchEnv(keyRef) {
		    keyRef = (0, resolve_1.normalizeId)(keyRef); // TODO tests fail without this line
		    return this.schemas[keyRef] || this.refs[keyRef];
		}
		function addInitialSchemas() {
		    const optsSchemas = this.opts.schemas;
		    if (!optsSchemas)
		        return;
		    if (Array.isArray(optsSchemas))
		        this.addSchema(optsSchemas);
		    else
		        for (const key in optsSchemas)
		            this.addSchema(optsSchemas[key], key);
		}
		function addInitialFormats() {
		    for (const name in this.opts.formats) {
		        const format = this.opts.formats[name];
		        if (format)
		            this.addFormat(name, format);
		    }
		}
		function addInitialKeywords(defs) {
		    if (Array.isArray(defs)) {
		        this.addVocabulary(defs);
		        return;
		    }
		    this.logger.warn("keywords option as map is deprecated, pass array");
		    for (const keyword in defs) {
		        const def = defs[keyword];
		        if (!def.keyword)
		            def.keyword = keyword;
		        this.addKeyword(def);
		    }
		}
		function getMetaSchemaOptions() {
		    const metaOpts = { ...this.opts };
		    for (const opt of META_IGNORE_OPTIONS)
		        delete metaOpts[opt];
		    return metaOpts;
		}
		const noLogs = { log() { }, warn() { }, error() { } };
		function getLogger(logger) {
		    if (logger === false)
		        return noLogs;
		    if (logger === undefined)
		        return console;
		    if (logger.log && logger.warn && logger.error)
		        return logger;
		    throw new Error("logger must implement log, warn and error methods");
		}
		const KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
		function checkKeyword(keyword, def) {
		    const { RULES } = this;
		    (0, util_1.eachItem)(keyword, (kwd) => {
		        if (RULES.keywords[kwd])
		            throw new Error(`Keyword ${kwd} is already defined`);
		        if (!KEYWORD_NAME.test(kwd))
		            throw new Error(`Keyword ${kwd} has invalid name`);
		    });
		    if (!def)
		        return;
		    if (def.$data && !("code" in def || "validate" in def)) {
		        throw new Error('$data keyword must have "code" or "validate" function');
		    }
		}
		function addRule(keyword, definition, dataType) {
		    var _a;
		    const post = definition === null || definition === void 0 ? void 0 : definition.post;
		    if (dataType && post)
		        throw new Error('keyword with "post" flag cannot have "type"');
		    const { RULES } = this;
		    let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);
		    if (!ruleGroup) {
		        ruleGroup = { type: dataType, rules: [] };
		        RULES.rules.push(ruleGroup);
		    }
		    RULES.keywords[keyword] = true;
		    if (!definition)
		        return;
		    const rule = {
		        keyword,
		        definition: {
		            ...definition,
		            type: (0, dataType_1.getJSONTypes)(definition.type),
		            schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType),
		        },
		    };
		    if (definition.before)
		        addBeforeRule.call(this, ruleGroup, rule, definition.before);
		    else
		        ruleGroup.rules.push(rule);
		    RULES.all[keyword] = rule;
		    (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));
		}
		function addBeforeRule(ruleGroup, rule, before) {
		    const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
		    if (i >= 0) {
		        ruleGroup.rules.splice(i, 0, rule);
		    }
		    else {
		        ruleGroup.rules.push(rule);
		        this.logger.warn(`rule ${before} is not defined`);
		    }
		}
		function keywordMetaschema(def) {
		    let { metaSchema } = def;
		    if (metaSchema === undefined)
		        return;
		    if (def.$data && this.opts.$data)
		        metaSchema = schemaOrData(metaSchema);
		    def.validateSchema = this.compile(metaSchema, true);
		}
		const $dataRef = {
		    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
		};
		function schemaOrData(schema) {
		    return { anyOf: [schema, $dataRef] };
		}
		
	} (core$1));
	return core$1;
}

var draft7 = {};

var core = {};

var id = {};

var hasRequiredId;

function requireId () {
	if (hasRequiredId) return id;
	hasRequiredId = 1;
	Object.defineProperty(id, "__esModule", { value: true });
	const def = {
	    keyword: "id",
	    code() {
	        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
	    },
	};
	id.default = def;
	
	return id;
}

var ref$1 = {};

var hasRequiredRef$1;

function requireRef$1 () {
	if (hasRequiredRef$1) return ref$1;
	hasRequiredRef$1 = 1;
	Object.defineProperty(ref$1, "__esModule", { value: true });
	ref$1.callRef = ref$1.getValidate = void 0;
	const ref_error_1 = requireRef_error();
	const code_1 = requireCode();
	const codegen_1 = requireCodegen();
	const names_1 = requireNames();
	const compile_1 = requireCompile();
	const util_1 = requireUtil$1();
	const def = {
	    keyword: "$ref",
	    schemaType: "string",
	    code(cxt) {
	        const { gen, schema: $ref, it } = cxt;
	        const { baseId, schemaEnv: env, validateName, opts, self } = it;
	        const { root } = env;
	        if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
	            return callRootRef();
	        const schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);
	        if (schOrEnv === undefined)
	            throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
	        if (schOrEnv instanceof compile_1.SchemaEnv)
	            return callValidate(schOrEnv);
	        return inlineRefSchema(schOrEnv);
	        function callRootRef() {
	            if (env === root)
	                return callRef(cxt, validateName, env, env.$async);
	            const rootName = gen.scopeValue("root", { ref: root });
	            return callRef(cxt, (0, codegen_1._) `${rootName}.validate`, root, root.$async);
	        }
	        function callValidate(sch) {
	            const v = getValidate(cxt, sch);
	            callRef(cxt, v, sch, sch.$async);
	        }
	        function inlineRefSchema(sch) {
	            const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });
	            const valid = gen.name("valid");
	            const schCxt = cxt.subschema({
	                schema: sch,
	                dataTypes: [],
	                schemaPath: codegen_1.nil,
	                topSchemaRef: schName,
	                errSchemaPath: $ref,
	            }, valid);
	            cxt.mergeEvaluated(schCxt);
	            cxt.ok(valid);
	        }
	    },
	};
	function getValidate(cxt, sch) {
	    const { gen } = cxt;
	    return sch.validate
	        ? gen.scopeValue("validate", { ref: sch.validate })
	        : (0, codegen_1._) `${gen.scopeValue("wrapper", { ref: sch })}.validate`;
	}
	ref$1.getValidate = getValidate;
	function callRef(cxt, v, sch, $async) {
	    const { gen, it } = cxt;
	    const { allErrors, schemaEnv: env, opts } = it;
	    const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
	    if ($async)
	        callAsyncRef();
	    else
	        callSyncRef();
	    function callAsyncRef() {
	        if (!env.$async)
	            throw new Error("async schema referenced by sync schema");
	        const valid = gen.let("valid");
	        gen.try(() => {
	            gen.code((0, codegen_1._) `await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);
	            addEvaluatedFrom(v); // TODO will not work with async, it has to be returned with the result
	            if (!allErrors)
	                gen.assign(valid, true);
	        }, (e) => {
	            gen.if((0, codegen_1._) `!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
	            addErrorsFrom(e);
	            if (!allErrors)
	                gen.assign(valid, false);
	        });
	        cxt.ok(valid);
	    }
	    function callSyncRef() {
	        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
	    }
	    function addErrorsFrom(source) {
	        const errs = (0, codegen_1._) `${source}.errors`;
	        gen.assign(names_1.default.vErrors, (0, codegen_1._) `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`); // TODO tagged
	        gen.assign(names_1.default.errors, (0, codegen_1._) `${names_1.default.vErrors}.length`);
	    }
	    function addEvaluatedFrom(source) {
	        var _a;
	        if (!it.opts.unevaluated)
	            return;
	        const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
	        // TODO refactor
	        if (it.props !== true) {
	            if (schEvaluated && !schEvaluated.dynamicProps) {
	                if (schEvaluated.props !== undefined) {
	                    it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);
	                }
	            }
	            else {
	                const props = gen.var("props", (0, codegen_1._) `${source}.evaluated.props`);
	                it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
	            }
	        }
	        if (it.items !== true) {
	            if (schEvaluated && !schEvaluated.dynamicItems) {
	                if (schEvaluated.items !== undefined) {
	                    it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);
	                }
	            }
	            else {
	                const items = gen.var("items", (0, codegen_1._) `${source}.evaluated.items`);
	                it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);
	            }
	        }
	    }
	}
	ref$1.callRef = callRef;
	ref$1.default = def;
	
	return ref$1;
}

var hasRequiredCore;

function requireCore () {
	if (hasRequiredCore) return core;
	hasRequiredCore = 1;
	Object.defineProperty(core, "__esModule", { value: true });
	const id_1 = requireId();
	const ref_1 = requireRef$1();
	const core$1 = [
	    "$schema",
	    "$id",
	    "$defs",
	    "$vocabulary",
	    { keyword: "$comment" },
	    "definitions",
	    id_1.default,
	    ref_1.default,
	];
	core.default = core$1;
	
	return core;
}

var validation = {};

var limitNumber = {};

var hasRequiredLimitNumber;

function requireLimitNumber () {
	if (hasRequiredLimitNumber) return limitNumber;
	hasRequiredLimitNumber = 1;
	Object.defineProperty(limitNumber, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const ops = codegen_1.operators;
	const KWDs = {
	    maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
	    minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
	    exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
	    exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE },
	};
	const error = {
	    message: ({ keyword, schemaCode }) => (0, codegen_1.str) `must be ${KWDs[keyword].okStr} ${schemaCode}`,
	    params: ({ keyword, schemaCode }) => (0, codegen_1._) `{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`,
	};
	const def = {
	    keyword: Object.keys(KWDs),
	    type: "number",
	    schemaType: "number",
	    $data: true,
	    error,
	    code(cxt) {
	        const { keyword, data, schemaCode } = cxt;
	        cxt.fail$data((0, codegen_1._) `${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
	    },
	};
	limitNumber.default = def;
	
	return limitNumber;
}

var multipleOf = {};

var hasRequiredMultipleOf;

function requireMultipleOf () {
	if (hasRequiredMultipleOf) return multipleOf;
	hasRequiredMultipleOf = 1;
	Object.defineProperty(multipleOf, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const error = {
	    message: ({ schemaCode }) => (0, codegen_1.str) `must be multiple of ${schemaCode}`,
	    params: ({ schemaCode }) => (0, codegen_1._) `{multipleOf: ${schemaCode}}`,
	};
	const def = {
	    keyword: "multipleOf",
	    type: "number",
	    schemaType: "number",
	    $data: true,
	    error,
	    code(cxt) {
	        const { gen, data, schemaCode, it } = cxt;
	        // const bdt = bad$DataType(schemaCode, <string>def.schemaType, $data)
	        const prec = it.opts.multipleOfPrecision;
	        const res = gen.let("res");
	        const invalid = prec
	            ? (0, codegen_1._) `Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}`
	            : (0, codegen_1._) `${res} !== parseInt(${res})`;
	        cxt.fail$data((0, codegen_1._) `(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
	    },
	};
	multipleOf.default = def;
	
	return multipleOf;
}

var limitLength = {};

var ucs2length = {};

var hasRequiredUcs2length;

function requireUcs2length () {
	if (hasRequiredUcs2length) return ucs2length;
	hasRequiredUcs2length = 1;
	Object.defineProperty(ucs2length, "__esModule", { value: true });
	// https://mathiasbynens.be/notes/javascript-encoding
	// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode
	function ucs2length$1(str) {
	    const len = str.length;
	    let length = 0;
	    let pos = 0;
	    let value;
	    while (pos < len) {
	        length++;
	        value = str.charCodeAt(pos++);
	        if (value >= 0xd800 && value <= 0xdbff && pos < len) {
	            // high surrogate, and there is a next character
	            value = str.charCodeAt(pos);
	            if ((value & 0xfc00) === 0xdc00)
	                pos++; // low surrogate
	        }
	    }
	    return length;
	}
	ucs2length.default = ucs2length$1;
	ucs2length$1.code = 'require("ajv/dist/runtime/ucs2length").default';
	
	return ucs2length;
}

var hasRequiredLimitLength;

function requireLimitLength () {
	if (hasRequiredLimitLength) return limitLength;
	hasRequiredLimitLength = 1;
	Object.defineProperty(limitLength, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil$1();
	const ucs2length_1 = requireUcs2length();
	const error = {
	    message({ keyword, schemaCode }) {
	        const comp = keyword === "maxLength" ? "more" : "fewer";
	        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} characters`;
	    },
	    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,
	};
	const def = {
	    keyword: ["maxLength", "minLength"],
	    type: "string",
	    schemaType: "number",
	    $data: true,
	    error,
	    code(cxt) {
	        const { keyword, data, schemaCode, it } = cxt;
	        const op = keyword === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
	        const len = it.opts.unicode === false ? (0, codegen_1._) `${data}.length` : (0, codegen_1._) `${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
	        cxt.fail$data((0, codegen_1._) `${len} ${op} ${schemaCode}`);
	    },
	};
	limitLength.default = def;
	
	return limitLength;
}

var pattern$1 = {};

var hasRequiredPattern$1;

function requirePattern$1 () {
	if (hasRequiredPattern$1) return pattern$1;
	hasRequiredPattern$1 = 1;
	Object.defineProperty(pattern$1, "__esModule", { value: true });
	const code_1 = requireCode();
	const codegen_1 = requireCodegen();
	const error = {
	    message: ({ schemaCode }) => (0, codegen_1.str) `must match pattern "${schemaCode}"`,
	    params: ({ schemaCode }) => (0, codegen_1._) `{pattern: ${schemaCode}}`,
	};
	const def = {
	    keyword: "pattern",
	    type: "string",
	    schemaType: "string",
	    $data: true,
	    error,
	    code(cxt) {
	        const { data, $data, schema, schemaCode, it } = cxt;
	        // TODO regexp should be wrapped in try/catchs
	        const u = it.opts.unicodeRegExp ? "u" : "";
	        const regExp = $data ? (0, codegen_1._) `(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);
	        cxt.fail$data((0, codegen_1._) `!${regExp}.test(${data})`);
	    },
	};
	pattern$1.default = def;
	
	return pattern$1;
}

var limitProperties = {};

var hasRequiredLimitProperties;

function requireLimitProperties () {
	if (hasRequiredLimitProperties) return limitProperties;
	hasRequiredLimitProperties = 1;
	Object.defineProperty(limitProperties, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const error = {
	    message({ keyword, schemaCode }) {
	        const comp = keyword === "maxProperties" ? "more" : "fewer";
	        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} properties`;
	    },
	    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,
	};
	const def = {
	    keyword: ["maxProperties", "minProperties"],
	    type: "object",
	    schemaType: "number",
	    $data: true,
	    error,
	    code(cxt) {
	        const { keyword, data, schemaCode } = cxt;
	        const op = keyword === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
	        cxt.fail$data((0, codegen_1._) `Object.keys(${data}).length ${op} ${schemaCode}`);
	    },
	};
	limitProperties.default = def;
	
	return limitProperties;
}

var required = {};

var hasRequiredRequired;

function requireRequired () {
	if (hasRequiredRequired) return required;
	hasRequiredRequired = 1;
	Object.defineProperty(required, "__esModule", { value: true });
	const code_1 = requireCode();
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil$1();
	const error = {
	    message: ({ params: { missingProperty } }) => (0, codegen_1.str) `must have required property '${missingProperty}'`,
	    params: ({ params: { missingProperty } }) => (0, codegen_1._) `{missingProperty: ${missingProperty}}`,
	};
	const def = {
	    keyword: "required",
	    type: "object",
	    schemaType: "array",
	    $data: true,
	    error,
	    code(cxt) {
	        const { gen, schema, schemaCode, data, $data, it } = cxt;
	        const { opts } = it;
	        if (!$data && schema.length === 0)
	            return;
	        const useLoop = schema.length >= opts.loopRequired;
	        if (it.allErrors)
	            allErrorsMode();
	        else
	            exitOnErrorMode();
	        if (opts.strictRequired) {
	            const props = cxt.parentSchema.properties;
	            const { definedProperties } = cxt.it;
	            for (const requiredKey of schema) {
	                if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === undefined && !definedProperties.has(requiredKey)) {
	                    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
	                    const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
	                    (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
	                }
	            }
	        }
	        function allErrorsMode() {
	            if (useLoop || $data) {
	                cxt.block$data(codegen_1.nil, loopAllRequired);
	            }
	            else {
	                for (const prop of schema) {
	                    (0, code_1.checkReportMissingProp)(cxt, prop);
	                }
	            }
	        }
	        function exitOnErrorMode() {
	            const missing = gen.let("missing");
	            if (useLoop || $data) {
	                const valid = gen.let("valid", true);
	                cxt.block$data(valid, () => loopUntilMissing(missing, valid));
	                cxt.ok(valid);
	            }
	            else {
	                gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));
	                (0, code_1.reportMissingProp)(cxt, missing);
	                gen.else();
	            }
	        }
	        function loopAllRequired() {
	            gen.forOf("prop", schemaCode, (prop) => {
	                cxt.setParams({ missingProperty: prop });
	                gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
	            });
	        }
	        function loopUntilMissing(missing, valid) {
	            cxt.setParams({ missingProperty: missing });
	            gen.forOf(missing, schemaCode, () => {
	                gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));
	                gen.if((0, codegen_1.not)(valid), () => {
	                    cxt.error();
	                    gen.break();
	                });
	            }, codegen_1.nil);
	        }
	    },
	};
	required.default = def;
	
	return required;
}

var limitItems = {};

var hasRequiredLimitItems;

function requireLimitItems () {
	if (hasRequiredLimitItems) return limitItems;
	hasRequiredLimitItems = 1;
	Object.defineProperty(limitItems, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const error = {
	    message({ keyword, schemaCode }) {
	        const comp = keyword === "maxItems" ? "more" : "fewer";
	        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} items`;
	    },
	    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,
	};
	const def = {
	    keyword: ["maxItems", "minItems"],
	    type: "array",
	    schemaType: "number",
	    $data: true,
	    error,
	    code(cxt) {
	        const { keyword, data, schemaCode } = cxt;
	        const op = keyword === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
	        cxt.fail$data((0, codegen_1._) `${data}.length ${op} ${schemaCode}`);
	    },
	};
	limitItems.default = def;
	
	return limitItems;
}

var uniqueItems = {};

var equal = {};

var hasRequiredEqual;

function requireEqual () {
	if (hasRequiredEqual) return equal;
	hasRequiredEqual = 1;
	Object.defineProperty(equal, "__esModule", { value: true });
	// https://github.com/ajv-validator/ajv/issues/889
	const equal$1 = requireFastDeepEqual();
	equal$1.code = 'require("ajv/dist/runtime/equal").default';
	equal.default = equal$1;
	
	return equal;
}

var hasRequiredUniqueItems;

function requireUniqueItems () {
	if (hasRequiredUniqueItems) return uniqueItems;
	hasRequiredUniqueItems = 1;
	Object.defineProperty(uniqueItems, "__esModule", { value: true });
	const dataType_1 = requireDataType();
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil$1();
	const equal_1 = requireEqual();
	const error = {
	    message: ({ params: { i, j } }) => (0, codegen_1.str) `must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
	    params: ({ params: { i, j } }) => (0, codegen_1._) `{i: ${i}, j: ${j}}`,
	};
	const def = {
	    keyword: "uniqueItems",
	    type: "array",
	    schemaType: "boolean",
	    $data: true,
	    error,
	    code(cxt) {
	        const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
	        if (!$data && !schema)
	            return;
	        const valid = gen.let("valid");
	        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
	        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._) `${schemaCode} === false`);
	        cxt.ok(valid);
	        function validateUniqueItems() {
	            const i = gen.let("i", (0, codegen_1._) `${data}.length`);
	            const j = gen.let("j");
	            cxt.setParams({ i, j });
	            gen.assign(valid, true);
	            gen.if((0, codegen_1._) `${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
	        }
	        function canOptimize() {
	            return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
	        }
	        function loopN(i, j) {
	            const item = gen.name("item");
	            const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
	            const indices = gen.const("indices", (0, codegen_1._) `{}`);
	            gen.for((0, codegen_1._) `;${i}--;`, () => {
	                gen.let(item, (0, codegen_1._) `${data}[${i}]`);
	                gen.if(wrongType, (0, codegen_1._) `continue`);
	                if (itemTypes.length > 1)
	                    gen.if((0, codegen_1._) `typeof ${item} == "string"`, (0, codegen_1._) `${item} += "_"`);
	                gen
	                    .if((0, codegen_1._) `typeof ${indices}[${item}] == "number"`, () => {
	                    gen.assign(j, (0, codegen_1._) `${indices}[${item}]`);
	                    cxt.error();
	                    gen.assign(valid, false).break();
	                })
	                    .code((0, codegen_1._) `${indices}[${item}] = ${i}`);
	            });
	        }
	        function loopN2(i, j) {
	            const eql = (0, util_1.useFunc)(gen, equal_1.default);
	            const outer = gen.name("outer");
	            gen.label(outer).for((0, codegen_1._) `;${i}--;`, () => gen.for((0, codegen_1._) `${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._) `${eql}(${data}[${i}], ${data}[${j}])`, () => {
	                cxt.error();
	                gen.assign(valid, false).break(outer);
	            })));
	        }
	    },
	};
	uniqueItems.default = def;
	
	return uniqueItems;
}

var _const = {};

var hasRequired_const;

function require_const () {
	if (hasRequired_const) return _const;
	hasRequired_const = 1;
	Object.defineProperty(_const, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil$1();
	const equal_1 = requireEqual();
	const error = {
	    message: "must be equal to constant",
	    params: ({ schemaCode }) => (0, codegen_1._) `{allowedValue: ${schemaCode}}`,
	};
	const def = {
	    keyword: "const",
	    $data: true,
	    error,
	    code(cxt) {
	        const { gen, data, $data, schemaCode, schema } = cxt;
	        if ($data || (schema && typeof schema == "object")) {
	            cxt.fail$data((0, codegen_1._) `!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);
	        }
	        else {
	            cxt.fail((0, codegen_1._) `${schema} !== ${data}`);
	        }
	    },
	};
	_const.default = def;
	
	return _const;
}

var _enum$1 = {};

var hasRequired_enum$1;

function require_enum$1 () {
	if (hasRequired_enum$1) return _enum$1;
	hasRequired_enum$1 = 1;
	Object.defineProperty(_enum$1, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil$1();
	const equal_1 = requireEqual();
	const error = {
	    message: "must be equal to one of the allowed values",
	    params: ({ schemaCode }) => (0, codegen_1._) `{allowedValues: ${schemaCode}}`,
	};
	const def = {
	    keyword: "enum",
	    schemaType: "array",
	    $data: true,
	    error,
	    code(cxt) {
	        const { gen, data, $data, schema, schemaCode, it } = cxt;
	        if (!$data && schema.length === 0)
	            throw new Error("enum must have non-empty array");
	        const useLoop = schema.length >= it.opts.loopEnum;
	        let eql;
	        const getEql = () => (eql !== null && eql !== void 0 ? eql : (eql = (0, util_1.useFunc)(gen, equal_1.default)));
	        let valid;
	        if (useLoop || $data) {
	            valid = gen.let("valid");
	            cxt.block$data(valid, loopEnum);
	        }
	        else {
	            /* istanbul ignore if */
	            if (!Array.isArray(schema))
	                throw new Error("ajv implementation error");
	            const vSchema = gen.const("vSchema", schemaCode);
	            valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
	        }
	        cxt.pass(valid);
	        function loopEnum() {
	            gen.assign(valid, false);
	            gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1._) `${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));
	        }
	        function equalCode(vSchema, i) {
	            const sch = schema[i];
	            return typeof sch === "object" && sch !== null
	                ? (0, codegen_1._) `${getEql()}(${data}, ${vSchema}[${i}])`
	                : (0, codegen_1._) `${data} === ${sch}`;
	        }
	    },
	};
	_enum$1.default = def;
	
	return _enum$1;
}

var hasRequiredValidation;

function requireValidation () {
	if (hasRequiredValidation) return validation;
	hasRequiredValidation = 1;
	Object.defineProperty(validation, "__esModule", { value: true });
	const limitNumber_1 = requireLimitNumber();
	const multipleOf_1 = requireMultipleOf();
	const limitLength_1 = requireLimitLength();
	const pattern_1 = requirePattern$1();
	const limitProperties_1 = requireLimitProperties();
	const required_1 = requireRequired();
	const limitItems_1 = requireLimitItems();
	const uniqueItems_1 = requireUniqueItems();
	const const_1 = require_const();
	const enum_1 = require_enum$1();
	const validation$1 = [
	    // number
	    limitNumber_1.default,
	    multipleOf_1.default,
	    // string
	    limitLength_1.default,
	    pattern_1.default,
	    // object
	    limitProperties_1.default,
	    required_1.default,
	    // array
	    limitItems_1.default,
	    uniqueItems_1.default,
	    // any
	    { keyword: "type", schemaType: ["string", "array"] },
	    { keyword: "nullable", schemaType: "boolean" },
	    const_1.default,
	    enum_1.default,
	];
	validation.default = validation$1;
	
	return validation;
}

var applicator = {};

var additionalItems = {};

var hasRequiredAdditionalItems;

function requireAdditionalItems () {
	if (hasRequiredAdditionalItems) return additionalItems;
	hasRequiredAdditionalItems = 1;
	Object.defineProperty(additionalItems, "__esModule", { value: true });
	additionalItems.validateAdditionalItems = void 0;
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil$1();
	const error = {
	    message: ({ params: { len } }) => (0, codegen_1.str) `must NOT have more than ${len} items`,
	    params: ({ params: { len } }) => (0, codegen_1._) `{limit: ${len}}`,
	};
	const def = {
	    keyword: "additionalItems",
	    type: "array",
	    schemaType: ["boolean", "object"],
	    before: "uniqueItems",
	    error,
	    code(cxt) {
	        const { parentSchema, it } = cxt;
	        const { items } = parentSchema;
	        if (!Array.isArray(items)) {
	            (0, util_1.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
	            return;
	        }
	        validateAdditionalItems(cxt, items);
	    },
	};
	function validateAdditionalItems(cxt, items) {
	    const { gen, schema, data, keyword, it } = cxt;
	    it.items = true;
	    const len = gen.const("len", (0, codegen_1._) `${data}.length`);
	    if (schema === false) {
	        cxt.setParams({ len: items.length });
	        cxt.pass((0, codegen_1._) `${len} <= ${items.length}`);
	    }
	    else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
	        const valid = gen.var("valid", (0, codegen_1._) `${len} <= ${items.length}`); // TODO var
	        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));
	        cxt.ok(valid);
	    }
	    function validateItems(valid) {
	        gen.forRange("i", items.length, len, (i) => {
	            cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);
	            if (!it.allErrors)
	                gen.if((0, codegen_1.not)(valid), () => gen.break());
	        });
	    }
	}
	additionalItems.validateAdditionalItems = validateAdditionalItems;
	additionalItems.default = def;
	
	return additionalItems;
}

var prefixItems = {};

var items = {};

var hasRequiredItems;

function requireItems () {
	if (hasRequiredItems) return items;
	hasRequiredItems = 1;
	Object.defineProperty(items, "__esModule", { value: true });
	items.validateTuple = void 0;
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil$1();
	const code_1 = requireCode();
	const def = {
	    keyword: "items",
	    type: "array",
	    schemaType: ["object", "array", "boolean"],
	    before: "uniqueItems",
	    code(cxt) {
	        const { schema, it } = cxt;
	        if (Array.isArray(schema))
	            return validateTuple(cxt, "additionalItems", schema);
	        it.items = true;
	        if ((0, util_1.alwaysValidSchema)(it, schema))
	            return;
	        cxt.ok((0, code_1.validateArray)(cxt));
	    },
	};
	function validateTuple(cxt, extraItems, schArr = cxt.schema) {
	    const { gen, parentSchema, data, keyword, it } = cxt;
	    checkStrictTuple(parentSchema);
	    if (it.opts.unevaluated && schArr.length && it.items !== true) {
	        it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);
	    }
	    const valid = gen.name("valid");
	    const len = gen.const("len", (0, codegen_1._) `${data}.length`);
	    schArr.forEach((sch, i) => {
	        if ((0, util_1.alwaysValidSchema)(it, sch))
	            return;
	        gen.if((0, codegen_1._) `${len} > ${i}`, () => cxt.subschema({
	            keyword,
	            schemaProp: i,
	            dataProp: i,
	        }, valid));
	        cxt.ok(valid);
	    });
	    function checkStrictTuple(sch) {
	        const { opts, errSchemaPath } = it;
	        const l = schArr.length;
	        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
	        if (opts.strictTuples && !fullTuple) {
	            const msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
	            (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);
	        }
	    }
	}
	items.validateTuple = validateTuple;
	items.default = def;
	
	return items;
}

var hasRequiredPrefixItems;

function requirePrefixItems () {
	if (hasRequiredPrefixItems) return prefixItems;
	hasRequiredPrefixItems = 1;
	Object.defineProperty(prefixItems, "__esModule", { value: true });
	const items_1 = requireItems();
	const def = {
	    keyword: "prefixItems",
	    type: "array",
	    schemaType: ["array"],
	    before: "uniqueItems",
	    code: (cxt) => (0, items_1.validateTuple)(cxt, "items"),
	};
	prefixItems.default = def;
	
	return prefixItems;
}

var items2020 = {};

var hasRequiredItems2020;

function requireItems2020 () {
	if (hasRequiredItems2020) return items2020;
	hasRequiredItems2020 = 1;
	Object.defineProperty(items2020, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil$1();
	const code_1 = requireCode();
	const additionalItems_1 = requireAdditionalItems();
	const error = {
	    message: ({ params: { len } }) => (0, codegen_1.str) `must NOT have more than ${len} items`,
	    params: ({ params: { len } }) => (0, codegen_1._) `{limit: ${len}}`,
	};
	const def = {
	    keyword: "items",
	    type: "array",
	    schemaType: ["object", "boolean"],
	    before: "uniqueItems",
	    error,
	    code(cxt) {
	        const { schema, parentSchema, it } = cxt;
	        const { prefixItems } = parentSchema;
	        it.items = true;
	        if ((0, util_1.alwaysValidSchema)(it, schema))
	            return;
	        if (prefixItems)
	            (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);
	        else
	            cxt.ok((0, code_1.validateArray)(cxt));
	    },
	};
	items2020.default = def;
	
	return items2020;
}

var contains = {};

var hasRequiredContains;

function requireContains () {
	if (hasRequiredContains) return contains;
	hasRequiredContains = 1;
	Object.defineProperty(contains, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil$1();
	const error = {
	    message: ({ params: { min, max } }) => max === undefined
	        ? (0, codegen_1.str) `must contain at least ${min} valid item(s)`
	        : (0, codegen_1.str) `must contain at least ${min} and no more than ${max} valid item(s)`,
	    params: ({ params: { min, max } }) => max === undefined ? (0, codegen_1._) `{minContains: ${min}}` : (0, codegen_1._) `{minContains: ${min}, maxContains: ${max}}`,
	};
	const def = {
	    keyword: "contains",
	    type: "array",
	    schemaType: ["object", "boolean"],
	    before: "uniqueItems",
	    trackErrors: true,
	    error,
	    code(cxt) {
	        const { gen, schema, parentSchema, data, it } = cxt;
	        let min;
	        let max;
	        const { minContains, maxContains } = parentSchema;
	        if (it.opts.next) {
	            min = minContains === undefined ? 1 : minContains;
	            max = maxContains;
	        }
	        else {
	            min = 1;
	        }
	        const len = gen.const("len", (0, codegen_1._) `${data}.length`);
	        cxt.setParams({ min, max });
	        if (max === undefined && min === 0) {
	            (0, util_1.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
	            return;
	        }
	        if (max !== undefined && min > max) {
	            (0, util_1.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
	            cxt.fail();
	            return;
	        }
	        if ((0, util_1.alwaysValidSchema)(it, schema)) {
	            let cond = (0, codegen_1._) `${len} >= ${min}`;
	            if (max !== undefined)
	                cond = (0, codegen_1._) `${cond} && ${len} <= ${max}`;
	            cxt.pass(cond);
	            return;
	        }
	        it.items = true;
	        const valid = gen.name("valid");
	        if (max === undefined && min === 1) {
	            validateItems(valid, () => gen.if(valid, () => gen.break()));
	        }
	        else if (min === 0) {
	            gen.let(valid, true);
	            if (max !== undefined)
	                gen.if((0, codegen_1._) `${data}.length > 0`, validateItemsWithCount);
	        }
	        else {
	            gen.let(valid, false);
	            validateItemsWithCount();
	        }
	        cxt.result(valid, () => cxt.reset());
	        function validateItemsWithCount() {
	            const schValid = gen.name("_valid");
	            const count = gen.let("count", 0);
	            validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
	        }
	        function validateItems(_valid, block) {
	            gen.forRange("i", 0, len, (i) => {
	                cxt.subschema({
	                    keyword: "contains",
	                    dataProp: i,
	                    dataPropType: util_1.Type.Num,
	                    compositeRule: true,
	                }, _valid);
	                block();
	            });
	        }
	        function checkLimits(count) {
	            gen.code((0, codegen_1._) `${count}++`);
	            if (max === undefined) {
	                gen.if((0, codegen_1._) `${count} >= ${min}`, () => gen.assign(valid, true).break());
	            }
	            else {
	                gen.if((0, codegen_1._) `${count} > ${max}`, () => gen.assign(valid, false).break());
	                if (min === 1)
	                    gen.assign(valid, true);
	                else
	                    gen.if((0, codegen_1._) `${count} >= ${min}`, () => gen.assign(valid, true));
	            }
	        }
	    },
	};
	contains.default = def;
	
	return contains;
}

var dependencies = {};

var hasRequiredDependencies;

function requireDependencies () {
	if (hasRequiredDependencies) return dependencies;
	hasRequiredDependencies = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;
		const codegen_1 = requireCodegen();
		const util_1 = requireUtil$1();
		const code_1 = requireCode();
		exports.error = {
		    message: ({ params: { property, depsCount, deps } }) => {
		        const property_ies = depsCount === 1 ? "property" : "properties";
		        return (0, codegen_1.str) `must have ${property_ies} ${deps} when property ${property} is present`;
		    },
		    params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._) `{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`, // TODO change to reference
		};
		const def = {
		    keyword: "dependencies",
		    type: "object",
		    schemaType: "object",
		    error: exports.error,
		    code(cxt) {
		        const [propDeps, schDeps] = splitDependencies(cxt);
		        validatePropertyDeps(cxt, propDeps);
		        validateSchemaDeps(cxt, schDeps);
		    },
		};
		function splitDependencies({ schema }) {
		    const propertyDeps = {};
		    const schemaDeps = {};
		    for (const key in schema) {
		        if (key === "__proto__")
		            continue;
		        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
		        deps[key] = schema[key];
		    }
		    return [propertyDeps, schemaDeps];
		}
		function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
		    const { gen, data, it } = cxt;
		    if (Object.keys(propertyDeps).length === 0)
		        return;
		    const missing = gen.let("missing");
		    for (const prop in propertyDeps) {
		        const deps = propertyDeps[prop];
		        if (deps.length === 0)
		            continue;
		        const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);
		        cxt.setParams({
		            property: prop,
		            depsCount: deps.length,
		            deps: deps.join(", "),
		        });
		        if (it.allErrors) {
		            gen.if(hasProperty, () => {
		                for (const depProp of deps) {
		                    (0, code_1.checkReportMissingProp)(cxt, depProp);
		                }
		            });
		        }
		        else {
		            gen.if((0, codegen_1._) `${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
		            (0, code_1.reportMissingProp)(cxt, missing);
		            gen.else();
		        }
		    }
		}
		exports.validatePropertyDeps = validatePropertyDeps;
		function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
		    const { gen, data, keyword, it } = cxt;
		    const valid = gen.name("valid");
		    for (const prop in schemaDeps) {
		        if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))
		            continue;
		        gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties), () => {
		            const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
		            cxt.mergeValidEvaluated(schCxt, valid);
		        }, () => gen.var(valid, true) // TODO var
		        );
		        cxt.ok(valid);
		    }
		}
		exports.validateSchemaDeps = validateSchemaDeps;
		exports.default = def;
		
	} (dependencies));
	return dependencies;
}

var propertyNames = {};

var hasRequiredPropertyNames;

function requirePropertyNames () {
	if (hasRequiredPropertyNames) return propertyNames;
	hasRequiredPropertyNames = 1;
	Object.defineProperty(propertyNames, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil$1();
	const error = {
	    message: "property name must be valid",
	    params: ({ params }) => (0, codegen_1._) `{propertyName: ${params.propertyName}}`,
	};
	const def = {
	    keyword: "propertyNames",
	    type: "object",
	    schemaType: ["object", "boolean"],
	    error,
	    code(cxt) {
	        const { gen, schema, data, it } = cxt;
	        if ((0, util_1.alwaysValidSchema)(it, schema))
	            return;
	        const valid = gen.name("valid");
	        gen.forIn("key", data, (key) => {
	            cxt.setParams({ propertyName: key });
	            cxt.subschema({
	                keyword: "propertyNames",
	                data: key,
	                dataTypes: ["string"],
	                propertyName: key,
	                compositeRule: true,
	            }, valid);
	            gen.if((0, codegen_1.not)(valid), () => {
	                cxt.error(true);
	                if (!it.allErrors)
	                    gen.break();
	            });
	        });
	        cxt.ok(valid);
	    },
	};
	propertyNames.default = def;
	
	return propertyNames;
}

var additionalProperties = {};

var hasRequiredAdditionalProperties;

function requireAdditionalProperties () {
	if (hasRequiredAdditionalProperties) return additionalProperties;
	hasRequiredAdditionalProperties = 1;
	Object.defineProperty(additionalProperties, "__esModule", { value: true });
	const code_1 = requireCode();
	const codegen_1 = requireCodegen();
	const names_1 = requireNames();
	const util_1 = requireUtil$1();
	const error = {
	    message: "must NOT have additional properties",
	    params: ({ params }) => (0, codegen_1._) `{additionalProperty: ${params.additionalProperty}}`,
	};
	const def = {
	    keyword: "additionalProperties",
	    type: ["object"],
	    schemaType: ["boolean", "object"],
	    allowUndefined: true,
	    trackErrors: true,
	    error,
	    code(cxt) {
	        const { gen, schema, parentSchema, data, errsCount, it } = cxt;
	        /* istanbul ignore if */
	        if (!errsCount)
	            throw new Error("ajv implementation error");
	        const { allErrors, opts } = it;
	        it.props = true;
	        if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it, schema))
	            return;
	        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
	        const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
	        checkAdditionalProperties();
	        cxt.ok((0, codegen_1._) `${errsCount} === ${names_1.default.errors}`);
	        function checkAdditionalProperties() {
	            gen.forIn("key", data, (key) => {
	                if (!props.length && !patProps.length)
	                    additionalPropertyCode(key);
	                else
	                    gen.if(isAdditional(key), () => additionalPropertyCode(key));
	            });
	        }
	        function isAdditional(key) {
	            let definedProp;
	            if (props.length > 8) {
	                // TODO maybe an option instead of hard-coded 8?
	                const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");
	                definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
	            }
	            else if (props.length) {
	                definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._) `${key} === ${p}`));
	            }
	            else {
	                definedProp = codegen_1.nil;
	            }
	            if (patProps.length) {
	                definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._) `${(0, code_1.usePattern)(cxt, p)}.test(${key})`));
	            }
	            return (0, codegen_1.not)(definedProp);
	        }
	        function deleteAdditional(key) {
	            gen.code((0, codegen_1._) `delete ${data}[${key}]`);
	        }
	        function additionalPropertyCode(key) {
	            if (opts.removeAdditional === "all" || (opts.removeAdditional && schema === false)) {
	                deleteAdditional(key);
	                return;
	            }
	            if (schema === false) {
	                cxt.setParams({ additionalProperty: key });
	                cxt.error();
	                if (!allErrors)
	                    gen.break();
	                return;
	            }
	            if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
	                const valid = gen.name("valid");
	                if (opts.removeAdditional === "failing") {
	                    applyAdditionalSchema(key, valid, false);
	                    gen.if((0, codegen_1.not)(valid), () => {
	                        cxt.reset();
	                        deleteAdditional(key);
	                    });
	                }
	                else {
	                    applyAdditionalSchema(key, valid);
	                    if (!allErrors)
	                        gen.if((0, codegen_1.not)(valid), () => gen.break());
	                }
	            }
	        }
	        function applyAdditionalSchema(key, valid, errors) {
	            const subschema = {
	                keyword: "additionalProperties",
	                dataProp: key,
	                dataPropType: util_1.Type.Str,
	            };
	            if (errors === false) {
	                Object.assign(subschema, {
	                    compositeRule: true,
	                    createErrors: false,
	                    allErrors: false,
	                });
	            }
	            cxt.subschema(subschema, valid);
	        }
	    },
	};
	additionalProperties.default = def;
	
	return additionalProperties;
}

var properties$2 = {};

var hasRequiredProperties$1;

function requireProperties$1 () {
	if (hasRequiredProperties$1) return properties$2;
	hasRequiredProperties$1 = 1;
	Object.defineProperty(properties$2, "__esModule", { value: true });
	const validate_1 = requireValidate();
	const code_1 = requireCode();
	const util_1 = requireUtil$1();
	const additionalProperties_1 = requireAdditionalProperties();
	const def = {
	    keyword: "properties",
	    type: "object",
	    schemaType: "object",
	    code(cxt) {
	        const { gen, schema, parentSchema, data, it } = cxt;
	        if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === undefined) {
	            additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, "additionalProperties"));
	        }
	        const allProps = (0, code_1.allSchemaProperties)(schema);
	        for (const prop of allProps) {
	            it.definedProperties.add(prop);
	        }
	        if (it.opts.unevaluated && allProps.length && it.props !== true) {
	            it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);
	        }
	        const properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));
	        if (properties.length === 0)
	            return;
	        const valid = gen.name("valid");
	        for (const prop of properties) {
	            if (hasDefault(prop)) {
	                applyPropertySchema(prop);
	            }
	            else {
	                gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));
	                applyPropertySchema(prop);
	                if (!it.allErrors)
	                    gen.else().var(valid, true);
	                gen.endIf();
	            }
	            cxt.it.definedProperties.add(prop);
	            cxt.ok(valid);
	        }
	        function hasDefault(prop) {
	            return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== undefined;
	        }
	        function applyPropertySchema(prop) {
	            cxt.subschema({
	                keyword: "properties",
	                schemaProp: prop,
	                dataProp: prop,
	            }, valid);
	        }
	    },
	};
	properties$2.default = def;
	
	return properties$2;
}

var patternProperties = {};

var hasRequiredPatternProperties;

function requirePatternProperties () {
	if (hasRequiredPatternProperties) return patternProperties;
	hasRequiredPatternProperties = 1;
	Object.defineProperty(patternProperties, "__esModule", { value: true });
	const code_1 = requireCode();
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil$1();
	const util_2 = requireUtil$1();
	const def = {
	    keyword: "patternProperties",
	    type: "object",
	    schemaType: "object",
	    code(cxt) {
	        const { gen, schema, data, parentSchema, it } = cxt;
	        const { opts } = it;
	        const patterns = (0, code_1.allSchemaProperties)(schema);
	        const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));
	        if (patterns.length === 0 ||
	            (alwaysValidPatterns.length === patterns.length &&
	                (!it.opts.unevaluated || it.props === true))) {
	            return;
	        }
	        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
	        const valid = gen.name("valid");
	        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {
	            it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
	        }
	        const { props } = it;
	        validatePatternProperties();
	        function validatePatternProperties() {
	            for (const pat of patterns) {
	                if (checkProperties)
	                    checkMatchingProperties(pat);
	                if (it.allErrors) {
	                    validateProperties(pat);
	                }
	                else {
	                    gen.var(valid, true); // TODO var
	                    validateProperties(pat);
	                    gen.if(valid);
	                }
	            }
	        }
	        function checkMatchingProperties(pat) {
	            for (const prop in checkProperties) {
	                if (new RegExp(pat).test(prop)) {
	                    (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
	                }
	            }
	        }
	        function validateProperties(pat) {
	            gen.forIn("key", data, (key) => {
	                gen.if((0, codegen_1._) `${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
	                    const alwaysValid = alwaysValidPatterns.includes(pat);
	                    if (!alwaysValid) {
	                        cxt.subschema({
	                            keyword: "patternProperties",
	                            schemaProp: pat,
	                            dataProp: key,
	                            dataPropType: util_2.Type.Str,
	                        }, valid);
	                    }
	                    if (it.opts.unevaluated && props !== true) {
	                        gen.assign((0, codegen_1._) `${props}[${key}]`, true);
	                    }
	                    else if (!alwaysValid && !it.allErrors) {
	                        // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)
	                        // or if all properties were evaluated (props === true)
	                        gen.if((0, codegen_1.not)(valid), () => gen.break());
	                    }
	                });
	            });
	        }
	    },
	};
	patternProperties.default = def;
	
	return patternProperties;
}

var not = {};

var hasRequiredNot;

function requireNot () {
	if (hasRequiredNot) return not;
	hasRequiredNot = 1;
	Object.defineProperty(not, "__esModule", { value: true });
	const util_1 = requireUtil$1();
	const def = {
	    keyword: "not",
	    schemaType: ["object", "boolean"],
	    trackErrors: true,
	    code(cxt) {
	        const { gen, schema, it } = cxt;
	        if ((0, util_1.alwaysValidSchema)(it, schema)) {
	            cxt.fail();
	            return;
	        }
	        const valid = gen.name("valid");
	        cxt.subschema({
	            keyword: "not",
	            compositeRule: true,
	            createErrors: false,
	            allErrors: false,
	        }, valid);
	        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
	    },
	    error: { message: "must NOT be valid" },
	};
	not.default = def;
	
	return not;
}

var anyOf = {};

var hasRequiredAnyOf;

function requireAnyOf () {
	if (hasRequiredAnyOf) return anyOf;
	hasRequiredAnyOf = 1;
	Object.defineProperty(anyOf, "__esModule", { value: true });
	const code_1 = requireCode();
	const def = {
	    keyword: "anyOf",
	    schemaType: "array",
	    trackErrors: true,
	    code: code_1.validateUnion,
	    error: { message: "must match a schema in anyOf" },
	};
	anyOf.default = def;
	
	return anyOf;
}

var oneOf = {};

var hasRequiredOneOf;

function requireOneOf () {
	if (hasRequiredOneOf) return oneOf;
	hasRequiredOneOf = 1;
	Object.defineProperty(oneOf, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil$1();
	const error = {
	    message: "must match exactly one schema in oneOf",
	    params: ({ params }) => (0, codegen_1._) `{passingSchemas: ${params.passing}}`,
	};
	const def = {
	    keyword: "oneOf",
	    schemaType: "array",
	    trackErrors: true,
	    error,
	    code(cxt) {
	        const { gen, schema, parentSchema, it } = cxt;
	        /* istanbul ignore if */
	        if (!Array.isArray(schema))
	            throw new Error("ajv implementation error");
	        if (it.opts.discriminator && parentSchema.discriminator)
	            return;
	        const schArr = schema;
	        const valid = gen.let("valid", false);
	        const passing = gen.let("passing", null);
	        const schValid = gen.name("_valid");
	        cxt.setParams({ passing });
	        // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas
	        gen.block(validateOneOf);
	        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
	        function validateOneOf() {
	            schArr.forEach((sch, i) => {
	                let schCxt;
	                if ((0, util_1.alwaysValidSchema)(it, sch)) {
	                    gen.var(schValid, true);
	                }
	                else {
	                    schCxt = cxt.subschema({
	                        keyword: "oneOf",
	                        schemaProp: i,
	                        compositeRule: true,
	                    }, schValid);
	                }
	                if (i > 0) {
	                    gen
	                        .if((0, codegen_1._) `${schValid} && ${valid}`)
	                        .assign(valid, false)
	                        .assign(passing, (0, codegen_1._) `[${passing}, ${i}]`)
	                        .else();
	                }
	                gen.if(schValid, () => {
	                    gen.assign(valid, true);
	                    gen.assign(passing, i);
	                    if (schCxt)
	                        cxt.mergeEvaluated(schCxt, codegen_1.Name);
	                });
	            });
	        }
	    },
	};
	oneOf.default = def;
	
	return oneOf;
}

var allOf = {};

var hasRequiredAllOf;

function requireAllOf () {
	if (hasRequiredAllOf) return allOf;
	hasRequiredAllOf = 1;
	Object.defineProperty(allOf, "__esModule", { value: true });
	const util_1 = requireUtil$1();
	const def = {
	    keyword: "allOf",
	    schemaType: "array",
	    code(cxt) {
	        const { gen, schema, it } = cxt;
	        /* istanbul ignore if */
	        if (!Array.isArray(schema))
	            throw new Error("ajv implementation error");
	        const valid = gen.name("valid");
	        schema.forEach((sch, i) => {
	            if ((0, util_1.alwaysValidSchema)(it, sch))
	                return;
	            const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
	            cxt.ok(valid);
	            cxt.mergeEvaluated(schCxt);
	        });
	    },
	};
	allOf.default = def;
	
	return allOf;
}

var _if = {};

var hasRequired_if;

function require_if () {
	if (hasRequired_if) return _if;
	hasRequired_if = 1;
	Object.defineProperty(_if, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil$1();
	const error = {
	    message: ({ params }) => (0, codegen_1.str) `must match "${params.ifClause}" schema`,
	    params: ({ params }) => (0, codegen_1._) `{failingKeyword: ${params.ifClause}}`,
	};
	const def = {
	    keyword: "if",
	    schemaType: ["object", "boolean"],
	    trackErrors: true,
	    error,
	    code(cxt) {
	        const { gen, parentSchema, it } = cxt;
	        if (parentSchema.then === undefined && parentSchema.else === undefined) {
	            (0, util_1.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
	        }
	        const hasThen = hasSchema(it, "then");
	        const hasElse = hasSchema(it, "else");
	        if (!hasThen && !hasElse)
	            return;
	        const valid = gen.let("valid", true);
	        const schValid = gen.name("_valid");
	        validateIf();
	        cxt.reset();
	        if (hasThen && hasElse) {
	            const ifClause = gen.let("ifClause");
	            cxt.setParams({ ifClause });
	            gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
	        }
	        else if (hasThen) {
	            gen.if(schValid, validateClause("then"));
	        }
	        else {
	            gen.if((0, codegen_1.not)(schValid), validateClause("else"));
	        }
	        cxt.pass(valid, () => cxt.error(true));
	        function validateIf() {
	            const schCxt = cxt.subschema({
	                keyword: "if",
	                compositeRule: true,
	                createErrors: false,
	                allErrors: false,
	            }, schValid);
	            cxt.mergeEvaluated(schCxt);
	        }
	        function validateClause(keyword, ifClause) {
	            return () => {
	                const schCxt = cxt.subschema({ keyword }, schValid);
	                gen.assign(valid, schValid);
	                cxt.mergeValidEvaluated(schCxt, valid);
	                if (ifClause)
	                    gen.assign(ifClause, (0, codegen_1._) `${keyword}`);
	                else
	                    cxt.setParams({ ifClause: keyword });
	            };
	        }
	    },
	};
	function hasSchema(it, keyword) {
	    const schema = it.schema[keyword];
	    return schema !== undefined && !(0, util_1.alwaysValidSchema)(it, schema);
	}
	_if.default = def;
	
	return _if;
}

var thenElse = {};

var hasRequiredThenElse;

function requireThenElse () {
	if (hasRequiredThenElse) return thenElse;
	hasRequiredThenElse = 1;
	Object.defineProperty(thenElse, "__esModule", { value: true });
	const util_1 = requireUtil$1();
	const def = {
	    keyword: ["then", "else"],
	    schemaType: ["object", "boolean"],
	    code({ keyword, parentSchema, it }) {
	        if (parentSchema.if === undefined)
	            (0, util_1.checkStrictMode)(it, `"${keyword}" without "if" is ignored`);
	    },
	};
	thenElse.default = def;
	
	return thenElse;
}

var hasRequiredApplicator;

function requireApplicator () {
	if (hasRequiredApplicator) return applicator;
	hasRequiredApplicator = 1;
	Object.defineProperty(applicator, "__esModule", { value: true });
	const additionalItems_1 = requireAdditionalItems();
	const prefixItems_1 = requirePrefixItems();
	const items_1 = requireItems();
	const items2020_1 = requireItems2020();
	const contains_1 = requireContains();
	const dependencies_1 = requireDependencies();
	const propertyNames_1 = requirePropertyNames();
	const additionalProperties_1 = requireAdditionalProperties();
	const properties_1 = requireProperties$1();
	const patternProperties_1 = requirePatternProperties();
	const not_1 = requireNot();
	const anyOf_1 = requireAnyOf();
	const oneOf_1 = requireOneOf();
	const allOf_1 = requireAllOf();
	const if_1 = require_if();
	const thenElse_1 = requireThenElse();
	function getApplicator(draft2020 = false) {
	    const applicator = [
	        // any
	        not_1.default,
	        anyOf_1.default,
	        oneOf_1.default,
	        allOf_1.default,
	        if_1.default,
	        thenElse_1.default,
	        // object
	        propertyNames_1.default,
	        additionalProperties_1.default,
	        dependencies_1.default,
	        properties_1.default,
	        patternProperties_1.default,
	    ];
	    // array
	    if (draft2020)
	        applicator.push(prefixItems_1.default, items2020_1.default);
	    else
	        applicator.push(additionalItems_1.default, items_1.default);
	    applicator.push(contains_1.default);
	    return applicator;
	}
	applicator.default = getApplicator;
	
	return applicator;
}

var format$1 = {};

var format = {};

var hasRequiredFormat$1;

function requireFormat$1 () {
	if (hasRequiredFormat$1) return format;
	hasRequiredFormat$1 = 1;
	Object.defineProperty(format, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const error = {
	    message: ({ schemaCode }) => (0, codegen_1.str) `must match format "${schemaCode}"`,
	    params: ({ schemaCode }) => (0, codegen_1._) `{format: ${schemaCode}}`,
	};
	const def = {
	    keyword: "format",
	    type: ["number", "string"],
	    schemaType: "string",
	    $data: true,
	    error,
	    code(cxt, ruleType) {
	        const { gen, data, $data, schema, schemaCode, it } = cxt;
	        const { opts, errSchemaPath, schemaEnv, self } = it;
	        if (!opts.validateFormats)
	            return;
	        if ($data)
	            validate$DataFormat();
	        else
	            validateFormat();
	        function validate$DataFormat() {
	            const fmts = gen.scopeValue("formats", {
	                ref: self.formats,
	                code: opts.code.formats,
	            });
	            const fDef = gen.const("fDef", (0, codegen_1._) `${fmts}[${schemaCode}]`);
	            const fType = gen.let("fType");
	            const format = gen.let("format");
	            // TODO simplify
	            gen.if((0, codegen_1._) `typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._) `${fDef}.type || "string"`).assign(format, (0, codegen_1._) `${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._) `"string"`).assign(format, fDef));
	            cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
	            function unknownFmt() {
	                if (opts.strictSchema === false)
	                    return codegen_1.nil;
	                return (0, codegen_1._) `${schemaCode} && !${format}`;
	            }
	            function invalidFmt() {
	                const callFormat = schemaEnv.$async
	                    ? (0, codegen_1._) `(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))`
	                    : (0, codegen_1._) `${format}(${data})`;
	                const validData = (0, codegen_1._) `(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`;
	                return (0, codegen_1._) `${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;
	            }
	        }
	        function validateFormat() {
	            const formatDef = self.formats[schema];
	            if (!formatDef) {
	                unknownFormat();
	                return;
	            }
	            if (formatDef === true)
	                return;
	            const [fmtType, format, fmtRef] = getFormat(formatDef);
	            if (fmtType === ruleType)
	                cxt.pass(validCondition());
	            function unknownFormat() {
	                if (opts.strictSchema === false) {
	                    self.logger.warn(unknownMsg());
	                    return;
	                }
	                throw new Error(unknownMsg());
	                function unknownMsg() {
	                    return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
	                }
	            }
	            function getFormat(fmtDef) {
	                const code = fmtDef instanceof RegExp
	                    ? (0, codegen_1.regexpCode)(fmtDef)
	                    : opts.code.formats
	                        ? (0, codegen_1._) `${opts.code.formats}${(0, codegen_1.getProperty)(schema)}`
	                        : undefined;
	                const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code });
	                if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
	                    return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._) `${fmt}.validate`];
	                }
	                return ["string", fmtDef, fmt];
	            }
	            function validCondition() {
	                if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
	                    if (!schemaEnv.$async)
	                        throw new Error("async format in sync schema");
	                    return (0, codegen_1._) `await ${fmtRef}(${data})`;
	                }
	                return typeof format == "function" ? (0, codegen_1._) `${fmtRef}(${data})` : (0, codegen_1._) `${fmtRef}.test(${data})`;
	            }
	        }
	    },
	};
	format.default = def;
	
	return format;
}

var hasRequiredFormat;

function requireFormat () {
	if (hasRequiredFormat) return format$1;
	hasRequiredFormat = 1;
	Object.defineProperty(format$1, "__esModule", { value: true });
	const format_1 = requireFormat$1();
	const format = [format_1.default];
	format$1.default = format;
	
	return format$1;
}

var metadata$2 = {};

var hasRequiredMetadata$2;

function requireMetadata$2 () {
	if (hasRequiredMetadata$2) return metadata$2;
	hasRequiredMetadata$2 = 1;
	Object.defineProperty(metadata$2, "__esModule", { value: true });
	metadata$2.contentVocabulary = metadata$2.metadataVocabulary = void 0;
	metadata$2.metadataVocabulary = [
	    "title",
	    "description",
	    "default",
	    "deprecated",
	    "readOnly",
	    "writeOnly",
	    "examples",
	];
	metadata$2.contentVocabulary = [
	    "contentMediaType",
	    "contentEncoding",
	    "contentSchema",
	];
	
	return metadata$2;
}

var hasRequiredDraft7;

function requireDraft7 () {
	if (hasRequiredDraft7) return draft7;
	hasRequiredDraft7 = 1;
	Object.defineProperty(draft7, "__esModule", { value: true });
	const core_1 = requireCore();
	const validation_1 = requireValidation();
	const applicator_1 = requireApplicator();
	const format_1 = requireFormat();
	const metadata_1 = requireMetadata$2();
	const draft7Vocabularies = [
	    core_1.default,
	    validation_1.default,
	    (0, applicator_1.default)(),
	    format_1.default,
	    metadata_1.metadataVocabulary,
	    metadata_1.contentVocabulary,
	];
	draft7.default = draft7Vocabularies;
	
	return draft7;
}

var discriminator$1 = {};

var types$3 = {};

var hasRequiredTypes$3;

function requireTypes$3 () {
	if (hasRequiredTypes$3) return types$3;
	hasRequiredTypes$3 = 1;
	Object.defineProperty(types$3, "__esModule", { value: true });
	types$3.DiscrError = void 0;
	var DiscrError;
	(function (DiscrError) {
	    DiscrError["Tag"] = "tag";
	    DiscrError["Mapping"] = "mapping";
	})(DiscrError || (types$3.DiscrError = DiscrError = {}));
	
	return types$3;
}

var hasRequiredDiscriminator$1;

function requireDiscriminator$1 () {
	if (hasRequiredDiscriminator$1) return discriminator$1;
	hasRequiredDiscriminator$1 = 1;
	Object.defineProperty(discriminator$1, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const types_1 = requireTypes$3();
	const compile_1 = requireCompile();
	const ref_error_1 = requireRef_error();
	const util_1 = requireUtil$1();
	const error = {
	    message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag
	        ? `tag "${tagName}" must be string`
	        : `value of tag "${tagName}" must be in oneOf`,
	    params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._) `{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`,
	};
	const def = {
	    keyword: "discriminator",
	    type: "object",
	    schemaType: "object",
	    error,
	    code(cxt) {
	        const { gen, data, schema, parentSchema, it } = cxt;
	        const { oneOf } = parentSchema;
	        if (!it.opts.discriminator) {
	            throw new Error("discriminator: requires discriminator option");
	        }
	        const tagName = schema.propertyName;
	        if (typeof tagName != "string")
	            throw new Error("discriminator: requires propertyName");
	        if (schema.mapping)
	            throw new Error("discriminator: mapping is not supported");
	        if (!oneOf)
	            throw new Error("discriminator: requires oneOf keyword");
	        const valid = gen.let("valid", false);
	        const tag = gen.const("tag", (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(tagName)}`);
	        gen.if((0, codegen_1._) `typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
	        cxt.ok(valid);
	        function validateMapping() {
	            const mapping = getMapping();
	            gen.if(false);
	            for (const tagValue in mapping) {
	                gen.elseIf((0, codegen_1._) `${tag} === ${tagValue}`);
	                gen.assign(valid, applyTagSchema(mapping[tagValue]));
	            }
	            gen.else();
	            cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
	            gen.endIf();
	        }
	        function applyTagSchema(schemaProp) {
	            const _valid = gen.name("valid");
	            const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
	            cxt.mergeEvaluated(schCxt, codegen_1.Name);
	            return _valid;
	        }
	        function getMapping() {
	            var _a;
	            const oneOfMapping = {};
	            const topRequired = hasRequired(parentSchema);
	            let tagRequired = true;
	            for (let i = 0; i < oneOf.length; i++) {
	                let sch = oneOf[i];
	                if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
	                    const ref = sch.$ref;
	                    sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref);
	                    if (sch instanceof compile_1.SchemaEnv)
	                        sch = sch.schema;
	                    if (sch === undefined)
	                        throw new ref_error_1.default(it.opts.uriResolver, it.baseId, ref);
	                }
	                const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
	                if (typeof propSch != "object") {
	                    throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
	                }
	                tagRequired = tagRequired && (topRequired || hasRequired(sch));
	                addMappings(propSch, i);
	            }
	            if (!tagRequired)
	                throw new Error(`discriminator: "${tagName}" must be required`);
	            return oneOfMapping;
	            function hasRequired({ required }) {
	                return Array.isArray(required) && required.includes(tagName);
	            }
	            function addMappings(sch, i) {
	                if (sch.const) {
	                    addMapping(sch.const, i);
	                }
	                else if (sch.enum) {
	                    for (const tagValue of sch.enum) {
	                        addMapping(tagValue, i);
	                    }
	                }
	                else {
	                    throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
	                }
	            }
	            function addMapping(tagValue, i) {
	                if (typeof tagValue != "string" || tagValue in oneOfMapping) {
	                    throw new Error(`discriminator: "${tagName}" values must be unique strings`);
	                }
	                oneOfMapping[tagValue] = i;
	            }
	        }
	    },
	};
	discriminator$1.default = def;
	
	return discriminator$1;
}

var $schema = "http://json-schema.org/draft-07/schema#";
var $id = "http://json-schema.org/draft-07/schema#";
var title = "Core schema meta-schema";
var definitions = {
	schemaArray: {
		type: "array",
		minItems: 1,
		items: {
			$ref: "#"
		}
	},
	nonNegativeInteger: {
		type: "integer",
		minimum: 0
	},
	nonNegativeIntegerDefault0: {
		allOf: [
			{
				$ref: "#/definitions/nonNegativeInteger"
			},
			{
				"default": 0
			}
		]
	},
	simpleTypes: {
		"enum": [
			"array",
			"boolean",
			"integer",
			"null",
			"number",
			"object",
			"string"
		]
	},
	stringArray: {
		type: "array",
		items: {
			type: "string"
		},
		uniqueItems: true,
		"default": [
		]
	}
};
var type$1 = [
	"object",
	"boolean"
];
var properties$1 = {
	$id: {
		type: "string",
		format: "uri-reference"
	},
	$schema: {
		type: "string",
		format: "uri"
	},
	$ref: {
		type: "string",
		format: "uri-reference"
	},
	$comment: {
		type: "string"
	},
	title: {
		type: "string"
	},
	description: {
		type: "string"
	},
	"default": true,
	readOnly: {
		type: "boolean",
		"default": false
	},
	examples: {
		type: "array",
		items: true
	},
	multipleOf: {
		type: "number",
		exclusiveMinimum: 0
	},
	maximum: {
		type: "number"
	},
	exclusiveMaximum: {
		type: "number"
	},
	minimum: {
		type: "number"
	},
	exclusiveMinimum: {
		type: "number"
	},
	maxLength: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minLength: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	pattern: {
		type: "string",
		format: "regex"
	},
	additionalItems: {
		$ref: "#"
	},
	items: {
		anyOf: [
			{
				$ref: "#"
			},
			{
				$ref: "#/definitions/schemaArray"
			}
		],
		"default": true
	},
	maxItems: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minItems: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	uniqueItems: {
		type: "boolean",
		"default": false
	},
	contains: {
		$ref: "#"
	},
	maxProperties: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minProperties: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	required: {
		$ref: "#/definitions/stringArray"
	},
	additionalProperties: {
		$ref: "#"
	},
	definitions: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		"default": {
		}
	},
	properties: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		"default": {
		}
	},
	patternProperties: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		propertyNames: {
			format: "regex"
		},
		"default": {
		}
	},
	dependencies: {
		type: "object",
		additionalProperties: {
			anyOf: [
				{
					$ref: "#"
				},
				{
					$ref: "#/definitions/stringArray"
				}
			]
		}
	},
	propertyNames: {
		$ref: "#"
	},
	"const": true,
	"enum": {
		type: "array",
		items: true,
		minItems: 1,
		uniqueItems: true
	},
	type: {
		anyOf: [
			{
				$ref: "#/definitions/simpleTypes"
			},
			{
				type: "array",
				items: {
					$ref: "#/definitions/simpleTypes"
				},
				minItems: 1,
				uniqueItems: true
			}
		]
	},
	format: {
		type: "string"
	},
	contentMediaType: {
		type: "string"
	},
	contentEncoding: {
		type: "string"
	},
	"if": {
		$ref: "#"
	},
	then: {
		$ref: "#"
	},
	"else": {
		$ref: "#"
	},
	allOf: {
		$ref: "#/definitions/schemaArray"
	},
	anyOf: {
		$ref: "#/definitions/schemaArray"
	},
	oneOf: {
		$ref: "#/definitions/schemaArray"
	},
	not: {
		$ref: "#"
	}
};
var require$$3$1 = {
	$schema: $schema,
	$id: $id,
	title: title,
	definitions: definitions,
	type: type$1,
	properties: properties$1,
	"default": true
};

var hasRequiredAjv;

function requireAjv () {
	if (hasRequiredAjv) return ajv.exports;
	hasRequiredAjv = 1;
	(function (module, exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = exports.Ajv = void 0;
		const core_1 = requireCore$1();
		const draft7_1 = requireDraft7();
		const discriminator_1 = requireDiscriminator$1();
		const draft7MetaSchema = require$$3$1;
		const META_SUPPORT_DATA = ["/properties"];
		const META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
		class Ajv extends core_1.default {
		    _addVocabularies() {
		        super._addVocabularies();
		        draft7_1.default.forEach((v) => this.addVocabulary(v));
		        if (this.opts.discriminator)
		            this.addKeyword(discriminator_1.default);
		    }
		    _addDefaultMetaSchema() {
		        super._addDefaultMetaSchema();
		        if (!this.opts.meta)
		            return;
		        const metaSchema = this.opts.$data
		            ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA)
		            : draft7MetaSchema;
		        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
		        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
		    }
		    defaultMeta() {
		        return (this.opts.defaultMeta =
		            super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined));
		    }
		}
		exports.Ajv = Ajv;
		module.exports = exports = Ajv;
		module.exports.Ajv = Ajv;
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.default = Ajv;
		var validate_1 = requireValidate();
		Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function () { return validate_1.KeywordCxt; } });
		var codegen_1 = requireCodegen();
		Object.defineProperty(exports, "_", { enumerable: true, get: function () { return codegen_1._; } });
		Object.defineProperty(exports, "str", { enumerable: true, get: function () { return codegen_1.str; } });
		Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return codegen_1.stringify; } });
		Object.defineProperty(exports, "nil", { enumerable: true, get: function () { return codegen_1.nil; } });
		Object.defineProperty(exports, "Name", { enumerable: true, get: function () { return codegen_1.Name; } });
		Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function () { return codegen_1.CodeGen; } });
		var validation_error_1 = requireValidation_error();
		Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function () { return validation_error_1.default; } });
		var ref_error_1 = requireRef_error();
		Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: function () { return ref_error_1.default; } });
		
	} (ajv, ajv.exports));
	return ajv.exports;
}

var dist$4 = {exports: {}};

var formats = {};

var hasRequiredFormats;

function requireFormats () {
	if (hasRequiredFormats) return formats;
	hasRequiredFormats = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.formatNames = exports.fastFormats = exports.fullFormats = void 0;
		function fmtDef(validate, compare) {
		    return { validate, compare };
		}
		exports.fullFormats = {
		    // date: http://tools.ietf.org/html/rfc3339#section-5.6
		    date: fmtDef(date, compareDate),
		    // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
		    time: fmtDef(getTime(true), compareTime),
		    "date-time": fmtDef(getDateTime(true), compareDateTime),
		    "iso-time": fmtDef(getTime(), compareIsoTime),
		    "iso-date-time": fmtDef(getDateTime(), compareIsoDateTime),
		    // duration: https://tools.ietf.org/html/rfc3339#appendix-A
		    duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
		    uri,
		    "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
		    // uri-template: https://tools.ietf.org/html/rfc6570
		    "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
		    // For the source: https://gist.github.com/dperini/729294
		    // For test cases: https://mathiasbynens.be/demo/url-regex
		    url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
		    email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
		    hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
		    // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
		    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/,
		    ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
		    regex,
		    // uuid: http://tools.ietf.org/html/rfc4122
		    uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
		    // JSON-pointer: https://tools.ietf.org/html/rfc6901
		    // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
		    "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
		    "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
		    // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
		    "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
		    // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
		    // byte: https://github.com/miguelmota/is-base64
		    byte,
		    // signed 32 bit integer
		    int32: { type: "number", validate: validateInt32 },
		    // signed 64 bit integer
		    int64: { type: "number", validate: validateInt64 },
		    // C-type float
		    float: { type: "number", validate: validateNumber },
		    // C-type double
		    double: { type: "number", validate: validateNumber },
		    // hint to the UI to hide input strings
		    password: true,
		    // unchecked string payload
		    binary: true,
		};
		exports.fastFormats = {
		    ...exports.fullFormats,
		    date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
		    time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareTime),
		    "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
		    "iso-time": fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoTime),
		    "iso-date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoDateTime),
		    // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
		    uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
		    "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
		    // email (sources from jsen validator):
		    // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
		    // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
		    email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
		};
		exports.formatNames = Object.keys(exports.fullFormats);
		function isLeapYear(year) {
		    // https://tools.ietf.org/html/rfc3339#appendix-C
		    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
		}
		const DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
		const DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
		function date(str) {
		    // full-date from http://tools.ietf.org/html/rfc3339#section-5.6
		    const matches = DATE.exec(str);
		    if (!matches)
		        return false;
		    const year = +matches[1];
		    const month = +matches[2];
		    const day = +matches[3];
		    return (month >= 1 &&
		        month <= 12 &&
		        day >= 1 &&
		        day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]));
		}
		function compareDate(d1, d2) {
		    if (!(d1 && d2))
		        return undefined;
		    if (d1 > d2)
		        return 1;
		    if (d1 < d2)
		        return -1;
		    return 0;
		}
		const TIME = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
		function getTime(strictTimeZone) {
		    return function time(str) {
		        const matches = TIME.exec(str);
		        if (!matches)
		            return false;
		        const hr = +matches[1];
		        const min = +matches[2];
		        const sec = +matches[3];
		        const tz = matches[4];
		        const tzSign = matches[5] === "-" ? -1 : 1;
		        const tzH = +(matches[6] || 0);
		        const tzM = +(matches[7] || 0);
		        if (tzH > 23 || tzM > 59 || (strictTimeZone && !tz))
		            return false;
		        if (hr <= 23 && min <= 59 && sec < 60)
		            return true;
		        // leap second
		        const utcMin = min - tzM * tzSign;
		        const utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0);
		        return (utcHr === 23 || utcHr === -1) && (utcMin === 59 || utcMin === -1) && sec < 61;
		    };
		}
		function compareTime(s1, s2) {
		    if (!(s1 && s2))
		        return undefined;
		    const t1 = new Date("2020-01-01T" + s1).valueOf();
		    const t2 = new Date("2020-01-01T" + s2).valueOf();
		    if (!(t1 && t2))
		        return undefined;
		    return t1 - t2;
		}
		function compareIsoTime(t1, t2) {
		    if (!(t1 && t2))
		        return undefined;
		    const a1 = TIME.exec(t1);
		    const a2 = TIME.exec(t2);
		    if (!(a1 && a2))
		        return undefined;
		    t1 = a1[1] + a1[2] + a1[3];
		    t2 = a2[1] + a2[2] + a2[3];
		    if (t1 > t2)
		        return 1;
		    if (t1 < t2)
		        return -1;
		    return 0;
		}
		const DATE_TIME_SEPARATOR = /t|\s/i;
		function getDateTime(strictTimeZone) {
		    const time = getTime(strictTimeZone);
		    return function date_time(str) {
		        // http://tools.ietf.org/html/rfc3339#section-5.6
		        const dateTime = str.split(DATE_TIME_SEPARATOR);
		        return dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1]);
		    };
		}
		function compareDateTime(dt1, dt2) {
		    if (!(dt1 && dt2))
		        return undefined;
		    const d1 = new Date(dt1).valueOf();
		    const d2 = new Date(dt2).valueOf();
		    if (!(d1 && d2))
		        return undefined;
		    return d1 - d2;
		}
		function compareIsoDateTime(dt1, dt2) {
		    if (!(dt1 && dt2))
		        return undefined;
		    const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);
		    const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR);
		    const res = compareDate(d1, d2);
		    if (res === undefined)
		        return undefined;
		    return res || compareTime(t1, t2);
		}
		const NOT_URI_FRAGMENT = /\/|:/;
		const URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
		function uri(str) {
		    // http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required "."
		    return NOT_URI_FRAGMENT.test(str) && URI.test(str);
		}
		const BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
		function byte(str) {
		    BYTE.lastIndex = 0;
		    return BYTE.test(str);
		}
		const MIN_INT32 = -2147483648;
		const MAX_INT32 = 2 ** 31 - 1;
		function validateInt32(value) {
		    return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
		}
		function validateInt64(value) {
		    // JSON and javascript max Int is 2**53, so any int that passes isInteger is valid for Int64
		    return Number.isInteger(value);
		}
		function validateNumber() {
		    return true;
		}
		const Z_ANCHOR = /[^\\]\\Z/;
		function regex(str) {
		    if (Z_ANCHOR.test(str))
		        return false;
		    try {
		        new RegExp(str);
		        return true;
		    }
		    catch (e) {
		        return false;
		    }
		}
		
	} (formats));
	return formats;
}

var limit = {};

var hasRequiredLimit;

function requireLimit () {
	if (hasRequiredLimit) return limit;
	hasRequiredLimit = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.formatLimitDefinition = void 0;
		const ajv_1 = requireAjv();
		const codegen_1 = requireCodegen();
		const ops = codegen_1.operators;
		const KWDs = {
		    formatMaximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
		    formatMinimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
		    formatExclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
		    formatExclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE },
		};
		const error = {
		    message: ({ keyword, schemaCode }) => (0, codegen_1.str) `should be ${KWDs[keyword].okStr} ${schemaCode}`,
		    params: ({ keyword, schemaCode }) => (0, codegen_1._) `{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`,
		};
		exports.formatLimitDefinition = {
		    keyword: Object.keys(KWDs),
		    type: "string",
		    schemaType: "string",
		    $data: true,
		    error,
		    code(cxt) {
		        const { gen, data, schemaCode, keyword, it } = cxt;
		        const { opts, self } = it;
		        if (!opts.validateFormats)
		            return;
		        const fCxt = new ajv_1.KeywordCxt(it, self.RULES.all.format.definition, "format");
		        if (fCxt.$data)
		            validate$DataFormat();
		        else
		            validateFormat();
		        function validate$DataFormat() {
		            const fmts = gen.scopeValue("formats", {
		                ref: self.formats,
		                code: opts.code.formats,
		            });
		            const fmt = gen.const("fmt", (0, codegen_1._) `${fmts}[${fCxt.schemaCode}]`);
		            cxt.fail$data((0, codegen_1.or)((0, codegen_1._) `typeof ${fmt} != "object"`, (0, codegen_1._) `${fmt} instanceof RegExp`, (0, codegen_1._) `typeof ${fmt}.compare != "function"`, compareCode(fmt)));
		        }
		        function validateFormat() {
		            const format = fCxt.schema;
		            const fmtDef = self.formats[format];
		            if (!fmtDef || fmtDef === true)
		                return;
		            if (typeof fmtDef != "object" ||
		                fmtDef instanceof RegExp ||
		                typeof fmtDef.compare != "function") {
		                throw new Error(`"${keyword}": format "${format}" does not define "compare" function`);
		            }
		            const fmt = gen.scopeValue("formats", {
		                key: format,
		                ref: fmtDef,
		                code: opts.code.formats ? (0, codegen_1._) `${opts.code.formats}${(0, codegen_1.getProperty)(format)}` : undefined,
		            });
		            cxt.fail$data(compareCode(fmt));
		        }
		        function compareCode(fmt) {
		            return (0, codegen_1._) `${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword].fail} 0`;
		        }
		    },
		    dependencies: ["format"],
		};
		const formatLimitPlugin = (ajv) => {
		    ajv.addKeyword(exports.formatLimitDefinition);
		    return ajv;
		};
		exports.default = formatLimitPlugin;
		
	} (limit));
	return limit;
}

var hasRequiredDist$3;

function requireDist$3 () {
	if (hasRequiredDist$3) return dist$4.exports;
	hasRequiredDist$3 = 1;
	(function (module, exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		const formats_1 = requireFormats();
		const limit_1 = requireLimit();
		const codegen_1 = requireCodegen();
		const fullName = new codegen_1.Name("fullFormats");
		const fastName = new codegen_1.Name("fastFormats");
		const formatsPlugin = (ajv, opts = { keywords: true }) => {
		    if (Array.isArray(opts)) {
		        addFormats(ajv, opts, formats_1.fullFormats, fullName);
		        return ajv;
		    }
		    const [formats, exportName] = opts.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];
		    const list = opts.formats || formats_1.formatNames;
		    addFormats(ajv, list, formats, exportName);
		    if (opts.keywords)
		        (0, limit_1.default)(ajv);
		    return ajv;
		};
		formatsPlugin.get = (name, mode = "full") => {
		    const formats = mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats;
		    const f = formats[name];
		    if (!f)
		        throw new Error(`Unknown format "${name}"`);
		    return f;
		};
		function addFormats(ajv, list, fs, exportName) {
		    var _a;
		    var _b;
		    (_a = (_b = ajv.opts.code).formats) !== null && _a !== void 0 ? _a : (_b.formats = (0, codegen_1._) `require("ajv-formats/dist/formats").${exportName}`);
		    for (const f of list)
		        ajv.addFormat(f, fs[f]);
		}
		module.exports = exports = formatsPlugin;
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.default = formatsPlugin;
		
	} (dist$4, dist$4.exports));
	return dist$4.exports;
}

var validator;
var hasRequiredValidator;

function requireValidator () {
	if (hasRequiredValidator) return validator;
	hasRequiredValidator = 1;

	const Ajv = requireAjv();
	const fastUri = requireFastUri();
	const ajvFormats = requireDist$3();
	const clone = requireRfdc()({ proto: true });

	class Validator {
	  constructor (ajvOptions) {
	    this.ajv = new Ajv({
	      ...ajvOptions,
	      strictSchema: false,
	      validateSchema: false,
	      allowUnionTypes: true,
	      uriResolver: fastUri
	    });

	    ajvFormats(this.ajv);

	    this.ajv.addKeyword({
	      keyword: 'fjs_type',
	      type: 'object',
	      errors: false,
	      validate: (_type, date) => {
	        return date instanceof Date
	      }
	    });

	    this._ajvSchemas = {};
	    this._ajvOptions = ajvOptions || {};
	  }

	  addSchema (schema, schemaName) {
	    let schemaKey = schema.$id || schemaName;
	    if (schema.$id !== undefined && schema.$id[0] === '#') {
	      schemaKey = schemaName + schema.$id; // relative URI
	    }

	    if (
	      this.ajv.refs[schemaKey] === undefined &&
	      this.ajv.schemas[schemaKey] === undefined
	    ) {
	      const ajvSchema = clone(schema);
	      this.convertSchemaToAjvFormat(ajvSchema);
	      this.ajv.addSchema(ajvSchema, schemaKey);
	      this._ajvSchemas[schemaKey] = schema;
	    }
	  }

	  validate (schemaRef, data) {
	    return this.ajv.validate(schemaRef, data)
	  }

	  // Ajv does not support js date format. In order to properly validate objects containing a date,
	  // it needs to replace all occurrences of the string date format with a custom keyword fjs_type.
	  // (see https://github.com/fastify/fast-json-stringify/pull/441)
	  convertSchemaToAjvFormat (schema) {
	    if (schema === null) return

	    if (schema.type === 'string') {
	      schema.fjs_type = 'string';
	      schema.type = ['string', 'object'];
	    } else if (
	      Array.isArray(schema.type) &&
	      schema.type.includes('string') &&
	      !schema.type.includes('object')
	    ) {
	      schema.fjs_type = 'string';
	      schema.type.push('object');
	    }
	    for (const property in schema) {
	      if (typeof schema[property] === 'object') {
	        this.convertSchemaToAjvFormat(schema[property]);
	      }
	    }
	  }

	  getState () {
	    return {
	      ajvOptions: this._ajvOptions,
	      ajvSchemas: this._ajvSchemas
	    }
	  }

	  static restoreFromState (state) {
	    const validator = new Validator(state.ajvOptions);
	    for (const [id, ajvSchema] of Object.entries(state.ajvSchemas)) {
	      validator.ajv.addSchema(ajvSchema, id);
	    }
	    return validator
	  }
	}

	validator = Validator;
	return validator;
}

var location;
var hasRequiredLocation;

function requireLocation () {
	if (hasRequiredLocation) return location;
	hasRequiredLocation = 1;

	class Location {
	  constructor (schema, schemaId, jsonPointer = '#') {
	    this.schema = schema;
	    this.schemaId = schemaId;
	    this.jsonPointer = jsonPointer;
	  }

	  getPropertyLocation (propertyName) {
	    const propertyLocation = new Location(
	      this.schema[propertyName],
	      this.schemaId,
	      this.jsonPointer + '/' + propertyName
	    );
	    return propertyLocation
	  }

	  getSchemaRef () {
	    return this.schemaId + this.jsonPointer
	  }
	}

	location = Location;
	return location;
}

var schemaValidator = {exports: {}};

/* CODE GENERATED BY 'build-schema-validator.js' DO NOT EDIT! */

var hasRequiredSchemaValidator;

function requireSchemaValidator () {
	if (hasRequiredSchemaValidator) return schemaValidator.exports;
	hasRequiredSchemaValidator = 1;
	schemaValidator.exports = validate10;
	schemaValidator.exports.default = validate10;
	const schema11 = {"type":["object","boolean"]};
	const schema20 = {"enum":["array","boolean","integer","null","number","object","string"]};
	const formats0 = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
	const formats2 = requireFormats().fullFormats.uri;
	const formats6 = requireFormats().fullFormats.regex;

	function validate11(data, {instancePath="", parentData, parentDataProperty, rootData=data}={}){
	let vErrors = null;
	let errors = 0;
	if(!(((typeof data == "number") && (!(data % 1) && !isNaN(data))) && (isFinite(data)))){
	validate11.errors = [{instancePath,schemaPath:"#/definitions/nonNegativeInteger/type",keyword:"type",params:{type: "integer"},message:"must be integer"}];
	return false;
	}
	{
	if((typeof data == "number") && (isFinite(data))){
	if(data < 0 || isNaN(data)){
	validate11.errors = [{instancePath,schemaPath:"#/definitions/nonNegativeInteger/minimum",keyword:"minimum",params:{comparison: ">=", limit: 0},message:"must be >= 0"}];
	return false;
	}
	}
	}
	validate11.errors = vErrors;
	return errors === 0;
	}
	const root1 = {validate: validate10};

	function validate13(data, {instancePath="", parentData, parentDataProperty, rootData=data}={}){
	let vErrors = null;
	let errors = 0;
	if(errors === 0){
	if(Array.isArray(data)){
	if(data.length < 1){
	validate13.errors = [{instancePath,schemaPath:"#/minItems",keyword:"minItems",params:{limit: 1},message:"must NOT have fewer than 1 items"}];
	return false;
	}
	else {
	var valid0 = true;
	const len0 = data.length;
	for(let i0=0; i0<len0; i0++){
	const _errs1 = errors;
	if(!(root1.validate(data[i0], {instancePath:instancePath+"/" + i0,parentData:data,parentDataProperty:i0,rootData}))){
	vErrors = vErrors === null ? root1.validate.errors : vErrors.concat(root1.validate.errors);
	errors = vErrors.length;
	}
	var valid0 = _errs1 === errors;
	if(!valid0){
	break;
	}
	}
	}
	}
	else {
	validate13.errors = [{instancePath,schemaPath:"#/type",keyword:"type",params:{type: "array"},message:"must be array"}];
	return false;
	}
	}
	validate13.errors = vErrors;
	return errors === 0;
	}

	const func0 = requireEqual().default;

	function validate10(data, {instancePath="", parentData, parentDataProperty, rootData=data}={}){
	let vErrors = null;
	let errors = 0;
	if((!(data && typeof data == "object" && !Array.isArray(data))) && (typeof data !== "boolean")){
	validate10.errors = [{instancePath,schemaPath:"#/type",keyword:"type",params:{type: schema11.type},message:"must be object,boolean"}];
	return false;
	}
	if(errors === 0){
	if(data && typeof data == "object" && !Array.isArray(data)){
	if(data.$id !== undefined){
	let data0 = data.$id;
	const _errs1 = errors;
	if(errors === _errs1){
	if(errors === _errs1){
	if(typeof data0 === "string"){
	if(!(formats0.test(data0))){
	validate10.errors = [{instancePath:instancePath+"/$id",schemaPath:"#/properties/%24id/format",keyword:"format",params:{format: "uri-reference"},message:"must match format \""+"uri-reference"+"\""}];
	return false;
	}
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/$id",schemaPath:"#/properties/%24id/type",keyword:"type",params:{type: "string"},message:"must be string"}];
	return false;
	}
	}
	}
	var valid0 = _errs1 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.$schema !== undefined){
	let data1 = data.$schema;
	const _errs3 = errors;
	if(errors === _errs3){
	if(errors === _errs3){
	if(typeof data1 === "string"){
	if(!(formats2(data1))){
	validate10.errors = [{instancePath:instancePath+"/$schema",schemaPath:"#/properties/%24schema/format",keyword:"format",params:{format: "uri"},message:"must match format \""+"uri"+"\""}];
	return false;
	}
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/$schema",schemaPath:"#/properties/%24schema/type",keyword:"type",params:{type: "string"},message:"must be string"}];
	return false;
	}
	}
	}
	var valid0 = _errs3 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.$ref !== undefined){
	let data2 = data.$ref;
	const _errs5 = errors;
	if(errors === _errs5){
	if(errors === _errs5){
	if(typeof data2 === "string"){
	if(!(formats0.test(data2))){
	validate10.errors = [{instancePath:instancePath+"/$ref",schemaPath:"#/properties/%24ref/format",keyword:"format",params:{format: "uri-reference"},message:"must match format \""+"uri-reference"+"\""}];
	return false;
	}
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/$ref",schemaPath:"#/properties/%24ref/type",keyword:"type",params:{type: "string"},message:"must be string"}];
	return false;
	}
	}
	}
	var valid0 = _errs5 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.$comment !== undefined){
	const _errs7 = errors;
	if(typeof data.$comment !== "string"){
	validate10.errors = [{instancePath:instancePath+"/$comment",schemaPath:"#/properties/%24comment/type",keyword:"type",params:{type: "string"},message:"must be string"}];
	return false;
	}
	var valid0 = _errs7 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.title !== undefined){
	const _errs9 = errors;
	if(typeof data.title !== "string"){
	validate10.errors = [{instancePath:instancePath+"/title",schemaPath:"#/properties/title/type",keyword:"type",params:{type: "string"},message:"must be string"}];
	return false;
	}
	var valid0 = _errs9 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.description !== undefined){
	const _errs11 = errors;
	if(typeof data.description !== "string"){
	validate10.errors = [{instancePath:instancePath+"/description",schemaPath:"#/properties/description/type",keyword:"type",params:{type: "string"},message:"must be string"}];
	return false;
	}
	var valid0 = _errs11 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.readOnly !== undefined){
	const _errs13 = errors;
	if(typeof data.readOnly !== "boolean"){
	validate10.errors = [{instancePath:instancePath+"/readOnly",schemaPath:"#/properties/readOnly/type",keyword:"type",params:{type: "boolean"},message:"must be boolean"}];
	return false;
	}
	var valid0 = _errs13 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.examples !== undefined){
	const _errs15 = errors;
	if(errors === _errs15){
	if(!(Array.isArray(data.examples))){
	validate10.errors = [{instancePath:instancePath+"/examples",schemaPath:"#/properties/examples/type",keyword:"type",params:{type: "array"},message:"must be array"}];
	return false;
	}
	}
	var valid0 = _errs15 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.multipleOf !== undefined){
	let data8 = data.multipleOf;
	const _errs17 = errors;
	if(errors === _errs17){
	if((typeof data8 == "number") && (isFinite(data8))){
	if(data8 <= 0 || isNaN(data8)){
	validate10.errors = [{instancePath:instancePath+"/multipleOf",schemaPath:"#/properties/multipleOf/exclusiveMinimum",keyword:"exclusiveMinimum",params:{comparison: ">", limit: 0},message:"must be > 0"}];
	return false;
	}
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/multipleOf",schemaPath:"#/properties/multipleOf/type",keyword:"type",params:{type: "number"},message:"must be number"}];
	return false;
	}
	}
	var valid0 = _errs17 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.maximum !== undefined){
	let data9 = data.maximum;
	const _errs19 = errors;
	if(!((typeof data9 == "number") && (isFinite(data9)))){
	validate10.errors = [{instancePath:instancePath+"/maximum",schemaPath:"#/properties/maximum/type",keyword:"type",params:{type: "number"},message:"must be number"}];
	return false;
	}
	var valid0 = _errs19 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.exclusiveMaximum !== undefined){
	let data10 = data.exclusiveMaximum;
	const _errs21 = errors;
	if(!((typeof data10 == "number") && (isFinite(data10)))){
	validate10.errors = [{instancePath:instancePath+"/exclusiveMaximum",schemaPath:"#/properties/exclusiveMaximum/type",keyword:"type",params:{type: "number"},message:"must be number"}];
	return false;
	}
	var valid0 = _errs21 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.minimum !== undefined){
	let data11 = data.minimum;
	const _errs23 = errors;
	if(!((typeof data11 == "number") && (isFinite(data11)))){
	validate10.errors = [{instancePath:instancePath+"/minimum",schemaPath:"#/properties/minimum/type",keyword:"type",params:{type: "number"},message:"must be number"}];
	return false;
	}
	var valid0 = _errs23 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.exclusiveMinimum !== undefined){
	let data12 = data.exclusiveMinimum;
	const _errs25 = errors;
	if(!((typeof data12 == "number") && (isFinite(data12)))){
	validate10.errors = [{instancePath:instancePath+"/exclusiveMinimum",schemaPath:"#/properties/exclusiveMinimum/type",keyword:"type",params:{type: "number"},message:"must be number"}];
	return false;
	}
	var valid0 = _errs25 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.maxLength !== undefined){
	let data13 = data.maxLength;
	const _errs27 = errors;
	const _errs28 = errors;
	if(!(((typeof data13 == "number") && (!(data13 % 1) && !isNaN(data13))) && (isFinite(data13)))){
	validate10.errors = [{instancePath:instancePath+"/maxLength",schemaPath:"#/definitions/nonNegativeInteger/type",keyword:"type",params:{type: "integer"},message:"must be integer"}];
	return false;
	}
	if(errors === _errs28){
	if((typeof data13 == "number") && (isFinite(data13))){
	if(data13 < 0 || isNaN(data13)){
	validate10.errors = [{instancePath:instancePath+"/maxLength",schemaPath:"#/definitions/nonNegativeInteger/minimum",keyword:"minimum",params:{comparison: ">=", limit: 0},message:"must be >= 0"}];
	return false;
	}
	}
	}
	var valid0 = _errs27 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.minLength !== undefined){
	const _errs30 = errors;
	if(!(validate11(data.minLength, {instancePath:instancePath+"/minLength",parentData:data,parentDataProperty:"minLength",rootData}))){
	vErrors = vErrors === null ? validate11.errors : vErrors.concat(validate11.errors);
	errors = vErrors.length;
	}
	var valid0 = _errs30 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.pattern !== undefined){
	let data15 = data.pattern;
	const _errs31 = errors;
	if(errors === _errs31){
	if(errors === _errs31){
	if(typeof data15 === "string"){
	if(!(formats6(data15))){
	validate10.errors = [{instancePath:instancePath+"/pattern",schemaPath:"#/properties/pattern/format",keyword:"format",params:{format: "regex"},message:"must match format \""+"regex"+"\""}];
	return false;
	}
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/pattern",schemaPath:"#/properties/pattern/type",keyword:"type",params:{type: "string"},message:"must be string"}];
	return false;
	}
	}
	}
	var valid0 = _errs31 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.additionalItems !== undefined){
	const _errs33 = errors;
	if(!(validate10(data.additionalItems, {instancePath:instancePath+"/additionalItems",parentData:data,parentDataProperty:"additionalItems",rootData}))){
	vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
	errors = vErrors.length;
	}
	var valid0 = _errs33 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.items !== undefined){
	let data17 = data.items;
	const _errs34 = errors;
	const _errs35 = errors;
	let valid2 = false;
	const _errs36 = errors;
	if(!(validate10(data17, {instancePath:instancePath+"/items",parentData:data,parentDataProperty:"items",rootData}))){
	vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
	errors = vErrors.length;
	}
	var _valid0 = _errs36 === errors;
	valid2 = valid2 || _valid0;
	if(!valid2){
	const _errs37 = errors;
	if(!(validate13(data17, {instancePath:instancePath+"/items",parentData:data,parentDataProperty:"items",rootData}))){
	vErrors = vErrors === null ? validate13.errors : vErrors.concat(validate13.errors);
	errors = vErrors.length;
	}
	var _valid0 = _errs37 === errors;
	valid2 = valid2 || _valid0;
	}
	if(!valid2){
	const err0 = {instancePath:instancePath+"/items",schemaPath:"#/properties/items/anyOf",keyword:"anyOf",params:{},message:"must match a schema in anyOf"};
	if(vErrors === null){
	vErrors = [err0];
	}
	else {
	vErrors.push(err0);
	}
	errors++;
	validate10.errors = vErrors;
	return false;
	}
	else {
	errors = _errs35;
	if(vErrors !== null){
	if(_errs35){
	vErrors.length = _errs35;
	}
	else {
	vErrors = null;
	}
	}
	}
	var valid0 = _errs34 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.maxItems !== undefined){
	let data18 = data.maxItems;
	const _errs38 = errors;
	const _errs39 = errors;
	if(!(((typeof data18 == "number") && (!(data18 % 1) && !isNaN(data18))) && (isFinite(data18)))){
	validate10.errors = [{instancePath:instancePath+"/maxItems",schemaPath:"#/definitions/nonNegativeInteger/type",keyword:"type",params:{type: "integer"},message:"must be integer"}];
	return false;
	}
	if(errors === _errs39){
	if((typeof data18 == "number") && (isFinite(data18))){
	if(data18 < 0 || isNaN(data18)){
	validate10.errors = [{instancePath:instancePath+"/maxItems",schemaPath:"#/definitions/nonNegativeInteger/minimum",keyword:"minimum",params:{comparison: ">=", limit: 0},message:"must be >= 0"}];
	return false;
	}
	}
	}
	var valid0 = _errs38 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.minItems !== undefined){
	const _errs41 = errors;
	if(!(validate11(data.minItems, {instancePath:instancePath+"/minItems",parentData:data,parentDataProperty:"minItems",rootData}))){
	vErrors = vErrors === null ? validate11.errors : vErrors.concat(validate11.errors);
	errors = vErrors.length;
	}
	var valid0 = _errs41 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.uniqueItems !== undefined){
	const _errs42 = errors;
	if(typeof data.uniqueItems !== "boolean"){
	validate10.errors = [{instancePath:instancePath+"/uniqueItems",schemaPath:"#/properties/uniqueItems/type",keyword:"type",params:{type: "boolean"},message:"must be boolean"}];
	return false;
	}
	var valid0 = _errs42 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.contains !== undefined){
	const _errs44 = errors;
	if(!(validate10(data.contains, {instancePath:instancePath+"/contains",parentData:data,parentDataProperty:"contains",rootData}))){
	vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
	errors = vErrors.length;
	}
	var valid0 = _errs44 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.maxProperties !== undefined){
	let data22 = data.maxProperties;
	const _errs45 = errors;
	const _errs46 = errors;
	if(!(((typeof data22 == "number") && (!(data22 % 1) && !isNaN(data22))) && (isFinite(data22)))){
	validate10.errors = [{instancePath:instancePath+"/maxProperties",schemaPath:"#/definitions/nonNegativeInteger/type",keyword:"type",params:{type: "integer"},message:"must be integer"}];
	return false;
	}
	if(errors === _errs46){
	if((typeof data22 == "number") && (isFinite(data22))){
	if(data22 < 0 || isNaN(data22)){
	validate10.errors = [{instancePath:instancePath+"/maxProperties",schemaPath:"#/definitions/nonNegativeInteger/minimum",keyword:"minimum",params:{comparison: ">=", limit: 0},message:"must be >= 0"}];
	return false;
	}
	}
	}
	var valid0 = _errs45 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.minProperties !== undefined){
	const _errs48 = errors;
	if(!(validate11(data.minProperties, {instancePath:instancePath+"/minProperties",parentData:data,parentDataProperty:"minProperties",rootData}))){
	vErrors = vErrors === null ? validate11.errors : vErrors.concat(validate11.errors);
	errors = vErrors.length;
	}
	var valid0 = _errs48 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.required !== undefined){
	let data24 = data.required;
	const _errs49 = errors;
	const _errs50 = errors;
	if(errors === _errs50){
	if(Array.isArray(data24)){
	var valid6 = true;
	const len0 = data24.length;
	for(let i0=0; i0<len0; i0++){
	const _errs52 = errors;
	if(typeof data24[i0] !== "string"){
	validate10.errors = [{instancePath:instancePath+"/required/" + i0,schemaPath:"#/definitions/stringArray/items/type",keyword:"type",params:{type: "string"},message:"must be string"}];
	return false;
	}
	var valid6 = _errs52 === errors;
	if(!valid6){
	break;
	}
	}
	if(valid6){
	let i1 = data24.length;
	let j0;
	if(i1 > 1){
	const indices0 = {};
	for(;i1--;){
	let item0 = data24[i1];
	if(typeof item0 !== "string"){
	continue;
	}
	if(typeof indices0[item0] == "number"){
	j0 = indices0[item0];
	validate10.errors = [{instancePath:instancePath+"/required",schemaPath:"#/definitions/stringArray/uniqueItems",keyword:"uniqueItems",params:{i: i1, j: j0},message:"must NOT have duplicate items (items ## "+j0+" and "+i1+" are identical)"}];
	return false;
	}
	indices0[item0] = i1;
	}
	}
	}
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/required",schemaPath:"#/definitions/stringArray/type",keyword:"type",params:{type: "array"},message:"must be array"}];
	return false;
	}
	}
	var valid0 = _errs49 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.additionalProperties !== undefined){
	const _errs54 = errors;
	if(!(validate10(data.additionalProperties, {instancePath:instancePath+"/additionalProperties",parentData:data,parentDataProperty:"additionalProperties",rootData}))){
	vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
	errors = vErrors.length;
	}
	var valid0 = _errs54 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.definitions !== undefined){
	let data27 = data.definitions;
	const _errs55 = errors;
	if(errors === _errs55){
	if(data27 && typeof data27 == "object" && !Array.isArray(data27)){
	for(const key0 in data27){
	const _errs58 = errors;
	if(!(validate10(data27[key0], {instancePath:instancePath+"/definitions/" + key0.replace(/~/g, "~0").replace(/\//g, "~1"),parentData:data27,parentDataProperty:key0,rootData}))){
	vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
	errors = vErrors.length;
	}
	var valid8 = _errs58 === errors;
	if(!valid8){
	break;
	}
	}
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/definitions",schemaPath:"#/properties/definitions/type",keyword:"type",params:{type: "object"},message:"must be object"}];
	return false;
	}
	}
	var valid0 = _errs55 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.properties !== undefined){
	let data29 = data.properties;
	const _errs59 = errors;
	if(errors === _errs59){
	if(data29 && typeof data29 == "object" && !Array.isArray(data29)){
	for(const key1 in data29){
	const _errs62 = errors;
	if(!(validate10(data29[key1], {instancePath:instancePath+"/properties/" + key1.replace(/~/g, "~0").replace(/\//g, "~1"),parentData:data29,parentDataProperty:key1,rootData}))){
	vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
	errors = vErrors.length;
	}
	var valid9 = _errs62 === errors;
	if(!valid9){
	break;
	}
	}
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/properties",schemaPath:"#/properties/properties/type",keyword:"type",params:{type: "object"},message:"must be object"}];
	return false;
	}
	}
	var valid0 = _errs59 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.patternProperties !== undefined){
	let data31 = data.patternProperties;
	const _errs63 = errors;
	if(errors === _errs63){
	if(data31 && typeof data31 == "object" && !Array.isArray(data31)){
	for(const key2 in data31){
	const _errs65 = errors;
	if(errors === _errs65){
	if(typeof key2 === "string"){
	if(!(formats6(key2))){
	const err1 = {instancePath:instancePath+"/patternProperties",schemaPath:"#/properties/patternProperties/propertyNames/format",keyword:"format",params:{format: "regex"},message:"must match format \""+"regex"+"\"",propertyName:key2};
	if(vErrors === null){
	vErrors = [err1];
	}
	else {
	vErrors.push(err1);
	}
	errors++;
	}
	}
	}
	var valid10 = _errs65 === errors;
	if(!valid10){
	const err2 = {instancePath:instancePath+"/patternProperties",schemaPath:"#/properties/patternProperties/propertyNames",keyword:"propertyNames",params:{propertyName: key2},message:"property name must be valid"};
	if(vErrors === null){
	vErrors = [err2];
	}
	else {
	vErrors.push(err2);
	}
	errors++;
	validate10.errors = vErrors;
	return false;
	}
	}
	if(valid10){
	for(const key3 in data31){
	const _errs67 = errors;
	if(!(validate10(data31[key3], {instancePath:instancePath+"/patternProperties/" + key3.replace(/~/g, "~0").replace(/\//g, "~1"),parentData:data31,parentDataProperty:key3,rootData}))){
	vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
	errors = vErrors.length;
	}
	var valid11 = _errs67 === errors;
	if(!valid11){
	break;
	}
	}
	}
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/patternProperties",schemaPath:"#/properties/patternProperties/type",keyword:"type",params:{type: "object"},message:"must be object"}];
	return false;
	}
	}
	var valid0 = _errs63 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.dependencies !== undefined){
	let data33 = data.dependencies;
	const _errs68 = errors;
	if(errors === _errs68){
	if(data33 && typeof data33 == "object" && !Array.isArray(data33)){
	for(const key4 in data33){
	let data34 = data33[key4];
	const _errs71 = errors;
	const _errs72 = errors;
	let valid13 = false;
	const _errs73 = errors;
	if(!(validate10(data34, {instancePath:instancePath+"/dependencies/" + key4.replace(/~/g, "~0").replace(/\//g, "~1"),parentData:data33,parentDataProperty:key4,rootData}))){
	vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
	errors = vErrors.length;
	}
	var _valid1 = _errs73 === errors;
	valid13 = valid13 || _valid1;
	if(!valid13){
	const _errs74 = errors;
	const _errs75 = errors;
	if(errors === _errs75){
	if(Array.isArray(data34)){
	var valid15 = true;
	const len1 = data34.length;
	for(let i2=0; i2<len1; i2++){
	const _errs77 = errors;
	if(typeof data34[i2] !== "string"){
	const err3 = {instancePath:instancePath+"/dependencies/" + key4.replace(/~/g, "~0").replace(/\//g, "~1")+"/" + i2,schemaPath:"#/definitions/stringArray/items/type",keyword:"type",params:{type: "string"},message:"must be string"};
	if(vErrors === null){
	vErrors = [err3];
	}
	else {
	vErrors.push(err3);
	}
	errors++;
	}
	var valid15 = _errs77 === errors;
	if(!valid15){
	break;
	}
	}
	if(valid15){
	let i3 = data34.length;
	let j1;
	if(i3 > 1){
	const indices1 = {};
	for(;i3--;){
	let item1 = data34[i3];
	if(typeof item1 !== "string"){
	continue;
	}
	if(typeof indices1[item1] == "number"){
	j1 = indices1[item1];
	const err4 = {instancePath:instancePath+"/dependencies/" + key4.replace(/~/g, "~0").replace(/\//g, "~1"),schemaPath:"#/definitions/stringArray/uniqueItems",keyword:"uniqueItems",params:{i: i3, j: j1},message:"must NOT have duplicate items (items ## "+j1+" and "+i3+" are identical)"};
	if(vErrors === null){
	vErrors = [err4];
	}
	else {
	vErrors.push(err4);
	}
	errors++;
	break;
	}
	indices1[item1] = i3;
	}
	}
	}
	}
	else {
	const err5 = {instancePath:instancePath+"/dependencies/" + key4.replace(/~/g, "~0").replace(/\//g, "~1"),schemaPath:"#/definitions/stringArray/type",keyword:"type",params:{type: "array"},message:"must be array"};
	if(vErrors === null){
	vErrors = [err5];
	}
	else {
	vErrors.push(err5);
	}
	errors++;
	}
	}
	var _valid1 = _errs74 === errors;
	valid13 = valid13 || _valid1;
	}
	if(!valid13){
	const err6 = {instancePath:instancePath+"/dependencies/" + key4.replace(/~/g, "~0").replace(/\//g, "~1"),schemaPath:"#/properties/dependencies/additionalProperties/anyOf",keyword:"anyOf",params:{},message:"must match a schema in anyOf"};
	if(vErrors === null){
	vErrors = [err6];
	}
	else {
	vErrors.push(err6);
	}
	errors++;
	validate10.errors = vErrors;
	return false;
	}
	else {
	errors = _errs72;
	if(vErrors !== null){
	if(_errs72){
	vErrors.length = _errs72;
	}
	else {
	vErrors = null;
	}
	}
	}
	var valid12 = _errs71 === errors;
	if(!valid12){
	break;
	}
	}
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/dependencies",schemaPath:"#/properties/dependencies/type",keyword:"type",params:{type: "object"},message:"must be object"}];
	return false;
	}
	}
	var valid0 = _errs68 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.propertyNames !== undefined){
	const _errs79 = errors;
	if(!(validate10(data.propertyNames, {instancePath:instancePath+"/propertyNames",parentData:data,parentDataProperty:"propertyNames",rootData}))){
	vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
	errors = vErrors.length;
	}
	var valid0 = _errs79 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.enum !== undefined){
	let data37 = data.enum;
	const _errs80 = errors;
	if(errors === _errs80){
	if(Array.isArray(data37)){
	if(data37.length < 1){
	validate10.errors = [{instancePath:instancePath+"/enum",schemaPath:"#/properties/enum/minItems",keyword:"minItems",params:{limit: 1},message:"must NOT have fewer than 1 items"}];
	return false;
	}
	else {
	let i4 = data37.length;
	let j2;
	if(i4 > 1){
	for(;i4--;){
	for(j2 = i4; j2--;){
	if(func0(data37[i4], data37[j2])){
	validate10.errors = [{instancePath:instancePath+"/enum",schemaPath:"#/properties/enum/uniqueItems",keyword:"uniqueItems",params:{i: i4, j: j2},message:"must NOT have duplicate items (items ## "+j2+" and "+i4+" are identical)"}];
	return false;
	}
	}
	}
	}
	}
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/enum",schemaPath:"#/properties/enum/type",keyword:"type",params:{type: "array"},message:"must be array"}];
	return false;
	}
	}
	var valid0 = _errs80 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.type !== undefined){
	let data38 = data.type;
	const _errs82 = errors;
	const _errs83 = errors;
	let valid18 = false;
	const _errs84 = errors;
	if(!(((((((data38 === "array") || (data38 === "boolean")) || (data38 === "integer")) || (data38 === "null")) || (data38 === "number")) || (data38 === "object")) || (data38 === "string"))){
	const err7 = {instancePath:instancePath+"/type",schemaPath:"#/definitions/simpleTypes/enum",keyword:"enum",params:{allowedValues: schema20.enum},message:"must be equal to one of the allowed values"};
	if(vErrors === null){
	vErrors = [err7];
	}
	else {
	vErrors.push(err7);
	}
	errors++;
	}
	var _valid2 = _errs84 === errors;
	valid18 = valid18 || _valid2;
	if(!valid18){
	const _errs86 = errors;
	if(errors === _errs86){
	if(Array.isArray(data38)){
	if(data38.length < 1){
	const err8 = {instancePath:instancePath+"/type",schemaPath:"#/properties/type/anyOf/1/minItems",keyword:"minItems",params:{limit: 1},message:"must NOT have fewer than 1 items"};
	if(vErrors === null){
	vErrors = [err8];
	}
	else {
	vErrors.push(err8);
	}
	errors++;
	}
	else {
	var valid20 = true;
	const len2 = data38.length;
	for(let i5=0; i5<len2; i5++){
	let data39 = data38[i5];
	const _errs88 = errors;
	if(!(((((((data39 === "array") || (data39 === "boolean")) || (data39 === "integer")) || (data39 === "null")) || (data39 === "number")) || (data39 === "object")) || (data39 === "string"))){
	const err9 = {instancePath:instancePath+"/type/" + i5,schemaPath:"#/definitions/simpleTypes/enum",keyword:"enum",params:{allowedValues: schema20.enum},message:"must be equal to one of the allowed values"};
	if(vErrors === null){
	vErrors = [err9];
	}
	else {
	vErrors.push(err9);
	}
	errors++;
	}
	var valid20 = _errs88 === errors;
	if(!valid20){
	break;
	}
	}
	if(valid20){
	let i6 = data38.length;
	let j3;
	if(i6 > 1){
	outer1:
	for(;i6--;){
	for(j3 = i6; j3--;){
	if(func0(data38[i6], data38[j3])){
	const err10 = {instancePath:instancePath+"/type",schemaPath:"#/properties/type/anyOf/1/uniqueItems",keyword:"uniqueItems",params:{i: i6, j: j3},message:"must NOT have duplicate items (items ## "+j3+" and "+i6+" are identical)"};
	if(vErrors === null){
	vErrors = [err10];
	}
	else {
	vErrors.push(err10);
	}
	errors++;
	break outer1;
	}
	}
	}
	}
	}
	}
	}
	else {
	const err11 = {instancePath:instancePath+"/type",schemaPath:"#/properties/type/anyOf/1/type",keyword:"type",params:{type: "array"},message:"must be array"};
	if(vErrors === null){
	vErrors = [err11];
	}
	else {
	vErrors.push(err11);
	}
	errors++;
	}
	}
	var _valid2 = _errs86 === errors;
	valid18 = valid18 || _valid2;
	}
	if(!valid18){
	const err12 = {instancePath:instancePath+"/type",schemaPath:"#/properties/type/anyOf",keyword:"anyOf",params:{},message:"must match a schema in anyOf"};
	if(vErrors === null){
	vErrors = [err12];
	}
	else {
	vErrors.push(err12);
	}
	errors++;
	validate10.errors = vErrors;
	return false;
	}
	else {
	errors = _errs83;
	if(vErrors !== null){
	if(_errs83){
	vErrors.length = _errs83;
	}
	else {
	vErrors = null;
	}
	}
	}
	var valid0 = _errs82 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.format !== undefined){
	const _errs90 = errors;
	if(typeof data.format !== "string"){
	validate10.errors = [{instancePath:instancePath+"/format",schemaPath:"#/properties/format/type",keyword:"type",params:{type: "string"},message:"must be string"}];
	return false;
	}
	var valid0 = _errs90 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.contentMediaType !== undefined){
	const _errs92 = errors;
	if(typeof data.contentMediaType !== "string"){
	validate10.errors = [{instancePath:instancePath+"/contentMediaType",schemaPath:"#/properties/contentMediaType/type",keyword:"type",params:{type: "string"},message:"must be string"}];
	return false;
	}
	var valid0 = _errs92 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.contentEncoding !== undefined){
	const _errs94 = errors;
	if(typeof data.contentEncoding !== "string"){
	validate10.errors = [{instancePath:instancePath+"/contentEncoding",schemaPath:"#/properties/contentEncoding/type",keyword:"type",params:{type: "string"},message:"must be string"}];
	return false;
	}
	var valid0 = _errs94 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.if !== undefined){
	const _errs96 = errors;
	if(!(validate10(data.if, {instancePath:instancePath+"/if",parentData:data,parentDataProperty:"if",rootData}))){
	vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
	errors = vErrors.length;
	}
	var valid0 = _errs96 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.then !== undefined){
	const _errs97 = errors;
	if(!(validate10(data.then, {instancePath:instancePath+"/then",parentData:data,parentDataProperty:"then",rootData}))){
	vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
	errors = vErrors.length;
	}
	var valid0 = _errs97 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.else !== undefined){
	const _errs98 = errors;
	if(!(validate10(data.else, {instancePath:instancePath+"/else",parentData:data,parentDataProperty:"else",rootData}))){
	vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
	errors = vErrors.length;
	}
	var valid0 = _errs98 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.allOf !== undefined){
	const _errs99 = errors;
	if(!(validate13(data.allOf, {instancePath:instancePath+"/allOf",parentData:data,parentDataProperty:"allOf",rootData}))){
	vErrors = vErrors === null ? validate13.errors : vErrors.concat(validate13.errors);
	errors = vErrors.length;
	}
	var valid0 = _errs99 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.anyOf !== undefined){
	const _errs100 = errors;
	if(!(validate13(data.anyOf, {instancePath:instancePath+"/anyOf",parentData:data,parentDataProperty:"anyOf",rootData}))){
	vErrors = vErrors === null ? validate13.errors : vErrors.concat(validate13.errors);
	errors = vErrors.length;
	}
	var valid0 = _errs100 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.oneOf !== undefined){
	const _errs101 = errors;
	if(!(validate13(data.oneOf, {instancePath:instancePath+"/oneOf",parentData:data,parentDataProperty:"oneOf",rootData}))){
	vErrors = vErrors === null ? validate13.errors : vErrors.concat(validate13.errors);
	errors = vErrors.length;
	}
	var valid0 = _errs101 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.not !== undefined){
	const _errs102 = errors;
	if(!(validate10(data.not, {instancePath:instancePath+"/not",parentData:data,parentDataProperty:"not",rootData}))){
	vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
	errors = vErrors.length;
	}
	var valid0 = _errs102 === errors;
	}
	else {
	var valid0 = true;
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	validate10.errors = vErrors;
	return errors === 0;
	}
	return schemaValidator.exports;
}

var errors;
var hasRequiredErrors;

function requireErrors () {
	if (hasRequiredErrors) return errors;
	hasRequiredErrors = 1;

	class MergeError extends Error {
	  constructor (keyword, schemas) {
	    super();
	    this.name = 'JsonSchemaMergeError';
	    this.code = 'JSON_SCHEMA_MERGE_ERROR';
	    this.message = `Failed to merge "${keyword}" keyword schemas.`;
	    this.schemas = schemas;
	  }
	}

	class ResolverNotFoundError extends Error {
	  constructor (keyword, schemas) {
	    super();
	    this.name = 'JsonSchemaMergeError';
	    this.code = 'JSON_SCHEMA_MERGE_ERROR';
	    this.message = `Resolver for "${keyword}" keyword not found.`;
	    this.schemas = schemas;
	  }
	}

	class InvalidOnConflictOptionError extends Error {
	  constructor (onConflict) {
	    super();
	    this.name = 'JsonSchemaMergeError';
	    this.code = 'JSON_SCHEMA_MERGE_ERROR';
	    this.message = `Invalid "onConflict" option: "${onConflict}".`;
	  }
	}

	errors = {
	  MergeError,
	  ResolverNotFoundError,
	  InvalidOnConflictOptionError
	};
	return errors;
}

var resolvers;
var hasRequiredResolvers;

function requireResolvers () {
	if (hasRequiredResolvers) return resolvers;
	hasRequiredResolvers = 1;

	const { dequal: deepEqual } = requireDist$4();
	const { MergeError } = requireErrors();

	function _arraysIntersection (arrays) {
	  let intersection = arrays[0];
	  for (let i = 1; i < arrays.length; i++) {
	    intersection = intersection.filter(
	      value => arrays[i].includes(value)
	    );
	  }
	  return intersection
	}

	function arraysIntersection (keyword, values, mergedSchema) {
	  const intersection = _arraysIntersection(values);
	  if (intersection.length === 0) {
	    throw new MergeError(keyword, values)
	  }
	  mergedSchema[keyword] = intersection;
	}

	function hybridArraysIntersection (keyword, values, mergedSchema) {
	  for (let i = 0; i < values.length; i++) {
	    if (!Array.isArray(values[i])) {
	      values[i] = [values[i]];
	    }
	  }

	  const intersection = _arraysIntersection(values);
	  if (intersection.length === 0) {
	    throw new MergeError(keyword, values)
	  }

	  if (intersection.length === 1) {
	    mergedSchema[keyword] = intersection[0];
	  } else {
	    mergedSchema[keyword] = intersection;
	  }
	}

	function arraysUnion (keyword, values, mergedSchema) {
	  const union = [];

	  for (const array of values) {
	    for (const value of array) {
	      if (!union.includes(value)) {
	        union.push(value);
	      }
	    }
	  }

	  mergedSchema[keyword] = union;
	}

	function minNumber (keyword, values, mergedSchema) {
	  mergedSchema[keyword] = Math.min(...values);
	}

	function maxNumber (keyword, values, mergedSchema) {
	  mergedSchema[keyword] = Math.max(...values);
	}

	function commonMultiple (keyword, values, mergedSchema) {
	  const gcd = (a, b) => (!b ? a : gcd(b, a % b));
	  const lcm = (a, b) => (a * b) / gcd(a, b);

	  let scale = 1;
	  for (const value of values) {
	    while (value * scale % 1 !== 0) {
	      scale *= 10;
	    }
	  }

	  let multiple = values[0] * scale;
	  for (const value of values) {
	    multiple = lcm(multiple, value * scale);
	  }

	  mergedSchema[keyword] = multiple / scale;
	}

	function allEqual (keyword, values, mergedSchema) {
	  const firstValue = values[0];
	  for (let i = 1; i < values.length; i++) {
	    if (!deepEqual(values[i], firstValue)) {
	      throw new MergeError(keyword, values)
	    }
	  }
	  mergedSchema[keyword] = firstValue;
	}

	function skip () {}

	function booleanAnd (keyword, values, mergedSchema) {
	  for (const value of values) {
	    if (value === false) {
	      mergedSchema[keyword] = false;
	      return
	    }
	  }
	  mergedSchema[keyword] = true;
	}

	function booleanOr (keyword, values, mergedSchema) {
	  for (const value of values) {
	    if (value === true) {
	      mergedSchema[keyword] = true;
	      return
	    }
	  }
	  mergedSchema[keyword] = false;
	}

	resolvers = {
	  arraysIntersection,
	  hybridArraysIntersection,
	  arraysUnion,
	  minNumber,
	  maxNumber,
	  commonMultiple,
	  allEqual,
	  booleanAnd,
	  booleanOr,
	  skip
	};
	return resolvers;
}

var mergeJsonSchemas;
var hasRequiredMergeJsonSchemas;

function requireMergeJsonSchemas () {
	if (hasRequiredMergeJsonSchemas) return mergeJsonSchemas;
	hasRequiredMergeJsonSchemas = 1;

	const { dequal: deepEqual } = requireDist$4();
	const resolvers = requireResolvers();
	const errors = requireErrors();

	const keywordsResolvers = {
	  $id: resolvers.skip,
	  type: resolvers.hybridArraysIntersection,
	  enum: resolvers.arraysIntersection,
	  minLength: resolvers.maxNumber,
	  maxLength: resolvers.minNumber,
	  minimum: resolvers.maxNumber,
	  maximum: resolvers.minNumber,
	  multipleOf: resolvers.commonMultiple,
	  exclusiveMinimum: resolvers.maxNumber,
	  exclusiveMaximum: resolvers.minNumber,
	  minItems: resolvers.maxNumber,
	  maxItems: resolvers.minNumber,
	  maxProperties: resolvers.minNumber,
	  minProperties: resolvers.maxNumber,
	  const: resolvers.allEqual,
	  default: resolvers.allEqual,
	  format: resolvers.allEqual,
	  required: resolvers.arraysUnion,
	  properties: mergeProperties,
	  patternProperties: mergeObjects,
	  additionalProperties: mergeSchemasResolver,
	  items: mergeItems,
	  additionalItems: mergeAdditionalItems,
	  definitions: mergeObjects,
	  $defs: mergeObjects,
	  nullable: resolvers.booleanAnd,
	  oneOf: mergeOneOf,
	  anyOf: mergeOneOf,
	  allOf: resolvers.arraysUnion,
	  not: mergeSchemasResolver,
	  if: mergeIfThenElseSchemas,
	  then: resolvers.skip,
	  else: resolvers.skip,
	  dependencies: mergeDependencies,
	  dependentRequired: mergeDependencies,
	  dependentSchemas: mergeObjects,
	  propertyNames: mergeSchemasResolver,
	  uniqueItems: resolvers.booleanOr,
	  contains: mergeSchemasResolver
	};

	function mergeSchemasResolver (keyword, values, mergedSchema, _schemas, options) {
	  mergedSchema[keyword] = _mergeSchemas(values, options);
	}

	function cartesianProduct (arrays) {
	  let result = [[]];

	  for (const array of arrays) {
	    const temp = [];
	    for (const x of result) {
	      for (const y of array) {
	        temp.push([...x, y]);
	      }
	    }
	    result = temp;
	  }

	  return result
	}

	function mergeOneOf (keyword, values, mergedSchema, _schemas, options) {
	  if (values.length === 1) {
	    mergedSchema[keyword] = values[0];
	    return
	  }

	  const product = cartesianProduct(values);
	  const mergedOneOf = [];
	  for (const combination of product) {
	    try {
	      const mergedSchema = _mergeSchemas(combination, options);
	      if (mergedSchema !== undefined) {
	        mergedOneOf.push(mergedSchema);
	      }
	    } catch (error) {
	      // If this combination is not valid, we can ignore it.
	      if (error instanceof errors.MergeError) continue
	      throw error
	    }
	  }
	  mergedSchema[keyword] = mergedOneOf;
	}

	function getSchemaForItem (schema, index) {
	  const { items, additionalItems } = schema;

	  if (Array.isArray(items)) {
	    if (index < items.length) {
	      return items[index]
	    }
	    return additionalItems
	  }

	  if (items !== undefined) {
	    return items
	  }

	  return additionalItems
	}

	function mergeItems (keyword, values, mergedSchema, schemas, options) {
	  let maxArrayItemsLength = 0;
	  for (const itemsSchema of values) {
	    if (Array.isArray(itemsSchema)) {
	      maxArrayItemsLength = Math.max(maxArrayItemsLength, itemsSchema.length);
	    }
	  }

	  if (maxArrayItemsLength === 0) {
	    mergedSchema[keyword] = _mergeSchemas(values, options);
	    return
	  }

	  const mergedItemsSchemas = [];
	  for (let i = 0; i < maxArrayItemsLength; i++) {
	    const indexItemSchemas = [];
	    for (const schema of schemas) {
	      const itemSchema = getSchemaForItem(schema, i);
	      if (itemSchema !== undefined) {
	        indexItemSchemas.push(itemSchema);
	      }
	    }
	    mergedItemsSchemas[i] = _mergeSchemas(indexItemSchemas, options);
	  }
	  mergedSchema[keyword] = mergedItemsSchemas;
	}

	function mergeAdditionalItems (keyword, values, mergedSchema, schemas, options) {
	  let hasArrayItems = false;
	  for (const schema of schemas) {
	    if (Array.isArray(schema.items)) {
	      hasArrayItems = true;
	      break
	    }
	  }

	  if (!hasArrayItems) {
	    mergedSchema[keyword] = _mergeSchemas(values, options);
	    return
	  }

	  const mergedAdditionalItemsSchemas = [];
	  for (const schema of schemas) {
	    let additionalItemsSchema = schema.additionalItems;
	    if (
	      additionalItemsSchema === undefined &&
	      !Array.isArray(schema.items)
	    ) {
	      additionalItemsSchema = schema.items;
	    }
	    if (additionalItemsSchema !== undefined) {
	      mergedAdditionalItemsSchemas.push(additionalItemsSchema);
	    }
	  }

	  mergedSchema[keyword] = _mergeSchemas(mergedAdditionalItemsSchemas, options);
	}

	function getSchemaForProperty (schema, propertyName) {
	  const { properties, patternProperties, additionalProperties } = schema;

	  if (properties?.[propertyName] !== undefined) {
	    return properties[propertyName]
	  }

	  for (const pattern of Object.keys(patternProperties ?? {})) {
	    const regexp = new RegExp(pattern);
	    if (regexp.test(propertyName)) {
	      return patternProperties[pattern]
	    }
	  }

	  return additionalProperties
	}

	function mergeProperties (keyword, _values, mergedSchema, schemas, options) {
	  const foundProperties = {};
	  for (const currentSchema of schemas) {
	    const properties = currentSchema.properties ?? {};
	    for (const propertyName of Object.keys(properties)) {
	      if (foundProperties[propertyName] !== undefined) continue

	      const propertySchema = properties[propertyName];
	      foundProperties[propertyName] = [propertySchema];

	      for (const anotherSchema of schemas) {
	        if (currentSchema === anotherSchema) continue

	        const propertySchema = getSchemaForProperty(anotherSchema, propertyName);
	        if (propertySchema !== undefined) {
	          foundProperties[propertyName].push(propertySchema);
	        }
	      }
	    }
	  }

	  const mergedProperties = {};
	  for (const property of Object.keys(foundProperties)) {
	    const propertySchemas = foundProperties[property];
	    mergedProperties[property] = _mergeSchemas(propertySchemas, options);
	  }
	  mergedSchema[keyword] = mergedProperties;
	}

	function mergeObjects (keyword, values, mergedSchema, _schemas, options) {
	  const objectsProperties = {};

	  for (const properties of values) {
	    for (const propertyName of Object.keys(properties)) {
	      if (objectsProperties[propertyName] === undefined) {
	        objectsProperties[propertyName] = [];
	      }
	      objectsProperties[propertyName].push(properties[propertyName]);
	    }
	  }

	  const mergedProperties = {};
	  for (const propertyName of Object.keys(objectsProperties)) {
	    const propertySchemas = objectsProperties[propertyName];
	    const mergedPropertySchema = _mergeSchemas(propertySchemas, options);
	    mergedProperties[propertyName] = mergedPropertySchema;
	  }

	  mergedSchema[keyword] = mergedProperties;
	}

	function mergeIfThenElseSchemas (_keyword, _values, mergedSchema, schemas, options) {
	  for (let i = 0; i < schemas.length; i++) {
	    const subSchema = {
	      if: schemas[i].if,
	      then: schemas[i].then,
	      else: schemas[i].else
	    };

	    if (subSchema.if === undefined) continue

	    if (mergedSchema.if === undefined) {
	      mergedSchema.if = subSchema.if;
	      if (subSchema.then !== undefined) {
	        mergedSchema.then = subSchema.then;
	      }
	      if (subSchema.else !== undefined) {
	        mergedSchema.else = subSchema.else;
	      }
	      continue
	    }

	    if (mergedSchema.then !== undefined) {
	      mergedSchema.then = _mergeSchemas([mergedSchema.then, subSchema], options);
	    }
	    if (mergedSchema.else !== undefined) {
	      mergedSchema.else = _mergeSchemas([mergedSchema.else, subSchema], options);
	    }
	  }
	}

	function mergeDependencies (keyword, values, mergedSchema) {
	  const mergedDependencies = {};
	  for (const dependencies of values) {
	    for (const propertyName of Object.keys(dependencies)) {
	      if (mergedDependencies[propertyName] === undefined) {
	        mergedDependencies[propertyName] = [];
	      }
	      const mergedPropertyDependencies = mergedDependencies[propertyName];
	      for (const propertyDependency of dependencies[propertyName]) {
	        if (!mergedPropertyDependencies.includes(propertyDependency)) {
	          mergedPropertyDependencies.push(propertyDependency);
	        }
	      }
	    }
	  }
	  mergedSchema[keyword] = mergedDependencies;
	}

	function _mergeSchemas (schemas, options) {
	  if (schemas.length === 0) return {}
	  if (schemas.length === 1) return schemas[0]

	  const mergedSchema = {};
	  const keywords = {};

	  let allSchemasAreTrue = true;

	  for (const schema of schemas) {
	    if (schema === false) return false
	    if (schema === true) continue
	    allSchemasAreTrue = false;

	    for (const keyword of Object.keys(schema)) {
	      if (keywords[keyword] === undefined) {
	        keywords[keyword] = [];
	      }
	      keywords[keyword].push(schema[keyword]);
	    }
	  }

	  if (allSchemasAreTrue) return true

	  for (const keyword of Object.keys(keywords)) {
	    const keywordValues = keywords[keyword];
	    const resolver = options.resolvers[keyword] ?? options.defaultResolver;
	    resolver(keyword, keywordValues, mergedSchema, schemas, options);
	  }

	  return mergedSchema
	}

	function defaultResolver (keyword, values, mergedSchema, _schemas, options) {
	  const onConflict = options.onConflict ?? 'throw';

	  if (values.length === 1 || onConflict === 'first') {
	    mergedSchema[keyword] = values[0];
	    return
	  }

	  let allValuesEqual = true;
	  for (let i = 1; i < values.length; i++) {
	    if (!deepEqual(values[i], values[0])) {
	      allValuesEqual = false;
	      break
	    }
	  }

	  if (allValuesEqual) {
	    mergedSchema[keyword] = values[0];
	    return
	  }

	  if (onConflict === 'throw') {
	    throw new errors.ResolverNotFoundError(keyword, values)
	  }
	  if (onConflict === 'skip') {
	    return
	  }
	  throw new errors.InvalidOnConflictOptionError(onConflict)
	}

	function mergeSchemas (schemas, options = {}) {
	  if (options.defaultResolver === undefined) {
	    options.defaultResolver = defaultResolver;
	  }

	  options.resolvers = { ...keywordsResolvers, ...options.resolvers };

	  const mergedSchema = _mergeSchemas(schemas, options);
	  return mergedSchema
	}

	mergeJsonSchemas = { mergeSchemas, keywordsResolvers, defaultResolver, ...errors };
	return mergeJsonSchemas;
}

var mergeSchemas_1;
var hasRequiredMergeSchemas;

function requireMergeSchemas () {
	if (hasRequiredMergeSchemas) return mergeSchemas_1;
	hasRequiredMergeSchemas = 1;

	const { mergeSchemas: _mergeSchemas } = requireMergeJsonSchemas();

	function mergeSchemas (schemas) {
	  return _mergeSchemas(schemas, { onConflict: 'skip' })
	}

	mergeSchemas_1 = mergeSchemas;
	return mergeSchemas_1;
}

var standalone$2 = {exports: {}};

var hasRequiredStandalone$3;

function requireStandalone$3 () {
	if (hasRequiredStandalone$3) return standalone$2.exports;
	hasRequiredStandalone$3 = 1;

	function buildStandaloneCode (contextFunc, context, serializer, validator) {
	  let ajvDependencyCode = '';
	  if (context.validatorSchemasIds.size > 0) {
	    ajvDependencyCode += 'const Validator = require(\'fast-json-stringify/lib/validator\')\n';
	    ajvDependencyCode += `const validatorState = ${JSON.stringify(validator.getState())}\n`;
	    ajvDependencyCode += 'const validator = Validator.restoreFromState(validatorState)\n';
	  } else {
	    ajvDependencyCode += 'const validator = null\n';
	  }

	  // Don't need to keep external schemas once compiled
	  // validatorState will hold external schemas if it needs them
	  const { schema, ...serializerState } = serializer.getState();

	  return `
  'use strict'

  const Serializer = require('fast-json-stringify/lib/serializer')
  const serializerState = ${JSON.stringify(serializerState)}
  const serializer = Serializer.restoreFromState(serializerState)

  ${ajvDependencyCode}

  module.exports = ${contextFunc.toString()}(validator, serializer)`
	}

	standalone$2.exports = buildStandaloneCode;

	standalone$2.exports.dependencies = {
	  Serializer: requireSerializer(),
	  Validator: requireValidator()
	};
	return standalone$2.exports;
}

var hasRequiredFastJsonStringify;

function requireFastJsonStringify () {
	if (hasRequiredFastJsonStringify) return fastJsonStringify.exports;
	hasRequiredFastJsonStringify = 1;

	/* eslint no-prototype-builtins: 0 */

	const { RefResolver } = requireJsonSchemaRefResolver();

	const Serializer = requireSerializer();
	const Validator = requireValidator();
	const Location = requireLocation();
	const validate = requireSchemaValidator();
	const mergeSchemas = requireMergeSchemas();

	const SINGLE_TICK = /'/g;

	let largeArraySize = 2e4;
	let largeArrayMechanism = 'default';

	const validRoundingMethods = [
	  'floor',
	  'ceil',
	  'round',
	  'trunc'
	];

	const validLargeArrayMechanisms = [
	  'default',
	  'json-stringify'
	];

	let schemaIdCounter = 0;

	function isValidSchema (schema, name) {
	  if (!validate(schema)) {
	    if (name) {
	      name = `"${name}" `;
	    } else {
	      name = '';
	    }
	    const first = validate.errors[0];
	    const err = new Error(`${name}schema is invalid: data${first.instancePath} ${first.message}`);
	    err.errors = isValidSchema.errors;
	    throw err
	  }
	}

	function resolveRef (context, location) {
	  const ref = location.schema.$ref;

	  let hashIndex = ref.indexOf('#');
	  if (hashIndex === -1) {
	    hashIndex = ref.length;
	  }

	  const schemaId = ref.slice(0, hashIndex) || location.schemaId;
	  const jsonPointer = ref.slice(hashIndex) || '#';

	  const schema = context.refResolver.getSchema(schemaId, jsonPointer);
	  if (schema === null) {
	    throw new Error(`Cannot find reference "${ref}"`)
	  }

	  const newLocation = new Location(schema, schemaId, jsonPointer);
	  if (schema.$ref !== undefined) {
	    return resolveRef(context, newLocation)
	  }

	  return newLocation
	}

	function getMergedLocation (context, mergedSchemaId) {
	  const mergedSchema = context.refResolver.getSchema(mergedSchemaId, '#');
	  return new Location(mergedSchema, mergedSchemaId, '#')
	}

	function getSchemaId (schema, rootSchemaId) {
	  if (schema.$id && schema.$id.charAt(0) !== '#') {
	    return schema.$id
	  }
	  return rootSchemaId
	}

	function build (schema, options) {
	  isValidSchema(schema);

	  options = options || {};

	  const context = {
	    functions: [],
	    functionsCounter: 0,
	    functionsNamesBySchema: new Map(),
	    options,
	    refResolver: new RefResolver(),
	    rootSchemaId: schema.$id || `__fjs_root_${schemaIdCounter++}`,
	    validatorSchemasIds: new Set(),
	    mergedSchemasIds: new Map()
	  };

	  const schemaId = getSchemaId(schema, context.rootSchemaId);
	  if (!context.refResolver.hasSchema(schemaId)) {
	    context.refResolver.addSchema(schema, context.rootSchemaId);
	  }

	  if (options.schema) {
	    for (const key in options.schema) {
	      const schema = options.schema[key];
	      const schemaId = getSchemaId(schema, key);
	      if (!context.refResolver.hasSchema(schemaId)) {
	        isValidSchema(schema, key);
	        context.refResolver.addSchema(schema, key);
	      }
	    }
	  }

	  if (options.rounding) {
	    if (!validRoundingMethods.includes(options.rounding)) {
	      throw new Error(`Unsupported integer rounding method ${options.rounding}`)
	    }
	  }

	  if (options.largeArrayMechanism) {
	    if (validLargeArrayMechanisms.includes(options.largeArrayMechanism)) {
	      largeArrayMechanism = options.largeArrayMechanism;
	    } else {
	      throw new Error(`Unsupported large array mechanism ${options.largeArrayMechanism}`)
	    }
	  }

	  if (options.largeArraySize) {
	    if (typeof options.largeArraySize === 'string' && Number.isFinite(Number.parseInt(options.largeArraySize, 10))) {
	      largeArraySize = Number.parseInt(options.largeArraySize, 10);
	    } else if (typeof options.largeArraySize === 'number' && Number.isInteger(options.largeArraySize)) {
	      largeArraySize = options.largeArraySize;
	    } else if (typeof options.largeArraySize === 'bigint') {
	      largeArraySize = Number(options.largeArraySize);
	    } else {
	      throw new Error(`Unsupported large array size. Expected integer-like, got ${typeof options.largeArraySize} with value ${options.largeArraySize}`)
	    }
	  }

	  const location = new Location(schema, context.rootSchemaId);
	  const code = buildValue(context, location, 'input');

	  let contextFunctionCode = `
    const JSON_STR_BEGIN_OBJECT = '{'
    const JSON_STR_END_OBJECT = '}'
    const JSON_STR_BEGIN_ARRAY = '['
    const JSON_STR_END_ARRAY = ']'
    const JSON_STR_COMMA = ','
    const JSON_STR_COLONS = ':'
    const JSON_STR_QUOTE = '"'
    const JSON_STR_EMPTY_OBJECT = JSON_STR_BEGIN_OBJECT + JSON_STR_END_OBJECT
    const JSON_STR_EMPTY_ARRAY = JSON_STR_BEGIN_ARRAY + JSON_STR_END_ARRAY
    const JSON_STR_EMPTY_STRING = JSON_STR_QUOTE + JSON_STR_QUOTE
    const JSON_STR_NULL = 'null'
  `;

	  // If we have only the invocation of the 'anonymous0' function, we would
	  // basically just wrap the 'anonymous0' function in the 'main' function and
	  // and the overhead of the intermediate variable 'json'. We can avoid the
	  // wrapping and the unnecessary memory allocation by aliasing 'anonymous0' to
	  // 'main'
	  if (code === 'json += anonymous0(input)') {
	    contextFunctionCode += `
    ${context.functions.join('\n')}
    const main = anonymous0
    return main
    `;
	  } else {
	    contextFunctionCode += `
    function main (input) {
      let json = ''
      ${code}
      return json
    }
    ${context.functions.join('\n')}
    return main
    `;
	  }

	  const serializer = new Serializer(options);
	  const validator = new Validator(options.ajv);

	  for (const schemaId of context.validatorSchemasIds) {
	    const schema = context.refResolver.getSchema(schemaId);
	    validator.addSchema(schema, schemaId);

	    const dependencies = context.refResolver.getSchemaDependencies(schemaId);
	    for (const [schemaId, schema] of Object.entries(dependencies)) {
	      validator.addSchema(schema, schemaId);
	    }
	  }

	  if (options.debugMode) {
	    options.mode = 'debug';
	  }

	  if (options.mode === 'debug') {
	    return {
	      validator,
	      serializer,
	      code: `validator\nserializer\n${contextFunctionCode}`,
	      ajv: validator.ajv
	    }
	  }

	  /* eslint no-new-func: "off" */
	  const contextFunc = new Function('validator', 'serializer', contextFunctionCode);

	  if (options.mode === 'standalone') {
	    const buildStandaloneCode = requireStandalone$3();
	    return buildStandaloneCode(contextFunc, context, serializer, validator)
	  }

	  return contextFunc(validator, serializer)
	}

	const objectKeywords = [
	  'properties',
	  'required',
	  'additionalProperties',
	  'patternProperties',
	  'maxProperties',
	  'minProperties',
	  'dependencies'
	];

	const arrayKeywords = [
	  'items',
	  'additionalItems',
	  'maxItems',
	  'minItems',
	  'uniqueItems',
	  'contains'
	];

	const stringKeywords = [
	  'maxLength',
	  'minLength',
	  'pattern'
	];

	const numberKeywords = [
	  'multipleOf',
	  'maximum',
	  'exclusiveMaximum',
	  'minimum',
	  'exclusiveMinimum'
	];

	/**
	 * Infer type based on keyword in order to generate optimized code
	 * https://datatracker.ietf.org/doc/html/draft-handrews-json-schema-validation-01#section-6
	 */
	function inferTypeByKeyword (schema) {
	  for (const keyword of objectKeywords) {
	    if (keyword in schema) return 'object'
	  }
	  for (const keyword of arrayKeywords) {
	    if (keyword in schema) return 'array'
	  }
	  for (const keyword of stringKeywords) {
	    if (keyword in schema) return 'string'
	  }
	  for (const keyword of numberKeywords) {
	    if (keyword in schema) return 'number'
	  }
	  return schema.type
	}

	function buildExtraObjectPropertiesSerializer (context, location, addComma) {
	  const schema = location.schema;
	  const propertiesKeys = Object.keys(schema.properties || {});

	  let code = `
    const propertiesKeys = ${JSON.stringify(propertiesKeys)}
    for (const [key, value] of Object.entries(obj)) {
      if (
        propertiesKeys.includes(key) ||
        value === undefined ||
        typeof value === 'function' ||
        typeof value === 'symbol'
      ) continue
  `;

	  const patternPropertiesLocation = location.getPropertyLocation('patternProperties');
	  const patternPropertiesSchema = patternPropertiesLocation.schema;

	  if (patternPropertiesSchema !== undefined) {
	    for (const propertyKey in patternPropertiesSchema) {
	      const propertyLocation = patternPropertiesLocation.getPropertyLocation(propertyKey);

	      code += `
        if (/${propertyKey.replace(/\\*\//g, '\\/')}/.test(key)) {
          ${addComma}
          json += serializer.asString(key) + JSON_STR_COLONS
          ${buildValue(context, propertyLocation, 'value')}
          continue
        }
      `;
	    }
	  }

	  const additionalPropertiesLocation = location.getPropertyLocation('additionalProperties');
	  const additionalPropertiesSchema = additionalPropertiesLocation.schema;

	  if (additionalPropertiesSchema !== undefined) {
	    if (additionalPropertiesSchema === true) {
	      code += `
        ${addComma}
        json += serializer.asString(key) + JSON_STR_COLONS + JSON.stringify(value)
      `;
	    } else {
	      const propertyLocation = location.getPropertyLocation('additionalProperties');
	      code += `
        ${addComma}
        json += serializer.asString(key) + JSON_STR_COLONS
        ${buildValue(context, propertyLocation, 'value')}
      `;
	    }
	  }

	  code += `
    }
  `;
	  return code
	}

	function buildInnerObject (context, location) {
	  const schema = location.schema;

	  const propertiesLocation = location.getPropertyLocation('properties');
	  const requiredProperties = schema.required || [];

	  // Should serialize required properties first
	  const propertiesKeys = Object.keys(schema.properties || {}).sort(
	    (key1, key2) => {
	      const required1 = requiredProperties.includes(key1);
	      const required2 = requiredProperties.includes(key2);
	      return required1 === required2 ? 0 : required1 ? -1 : 1
	    }
	  );
	  const hasRequiredProperties = requiredProperties.includes(propertiesKeys[0]);

	  let code = 'let value\n';

	  for (const key of requiredProperties) {
	    if (!propertiesKeys.includes(key)) {
	      const sanitizedKey = JSON.stringify(key);
	      code += `if (obj[${sanitizedKey}] === undefined) throw new Error('${sanitizedKey.replace(/'/g, '\\\'')} is required!')\n`;
	    }
	  }

	  code += 'let json = JSON_STR_BEGIN_OBJECT\n';

	  let addComma = '';
	  if (!hasRequiredProperties) {
	    code += 'let addComma = false\n';
	    addComma = '!addComma && (addComma = true) || (json += JSON_STR_COMMA)';
	  }

	  for (const key of propertiesKeys) {
	    let propertyLocation = propertiesLocation.getPropertyLocation(key);
	    if (propertyLocation.schema.$ref) {
	      propertyLocation = resolveRef(context, propertyLocation);
	    }

	    const sanitizedKey = JSON.stringify(key);
	    const defaultValue = propertyLocation.schema.default;
	    const isRequired = requiredProperties.includes(key);

	    code += `
      value = obj[${sanitizedKey}]
      if (value !== undefined) {
        ${addComma}
        json += ${JSON.stringify(sanitizedKey + ':')}
        ${buildValue(context, propertyLocation, 'value')}
      }`;

	    if (defaultValue !== undefined) {
	      code += ` else {
        ${addComma}
        json += ${JSON.stringify(sanitizedKey + ':' + JSON.stringify(defaultValue))}
      }
      `;
	    } else if (isRequired) {
	      code += ` else {
        throw new Error('${sanitizedKey.replace(/'/g, '\\\'')} is required!')
      }
      `;
	    } else {
	      code += '\n';
	    }

	    if (hasRequiredProperties) {
	      addComma = 'json += \',\'';
	    }
	  }

	  if (schema.patternProperties || schema.additionalProperties) {
	    code += buildExtraObjectPropertiesSerializer(context, location, addComma);
	  }

	  code += `
    return json + JSON_STR_END_OBJECT
  `;
	  return code
	}

	function mergeLocations (context, mergedSchemaId, mergedLocations) {
	  for (let i = 0; i < mergedLocations.length; i++) {
	    const location = mergedLocations[i];
	    const schema = location.schema;
	    if (schema.$ref) {
	      mergedLocations[i] = resolveRef(context, location);
	    }
	  }

	  const mergedSchemas = [];
	  for (const location of mergedLocations) {
	    const schema = cloneOriginSchema(context, location.schema, location.schemaId);
	    delete schema.$id;

	    mergedSchemas.push(schema);
	  }

	  const mergedSchema = mergeSchemas(mergedSchemas);
	  const mergedLocation = new Location(mergedSchema, mergedSchemaId);

	  context.refResolver.addSchema(mergedSchema, mergedSchemaId);
	  return mergedLocation
	}

	function cloneOriginSchema (context, schema, schemaId) {
	  const clonedSchema = Array.isArray(schema) ? [] : {};

	  if (
	    schema.$id !== undefined &&
	    schema.$id.charAt(0) !== '#'
	  ) {
	    schemaId = schema.$id;
	  }

	  const mergedSchemaRef = context.mergedSchemasIds.get(schema);
	  if (mergedSchemaRef) {
	    context.mergedSchemasIds.set(clonedSchema, mergedSchemaRef);
	  }

	  for (const key in schema) {
	    let value = schema[key];

	    if (key === '$ref' && typeof value === 'string' && value.charAt(0) === '#') {
	      value = schemaId + value;
	    }

	    if (typeof value === 'object' && value !== null) {
	      value = cloneOriginSchema(context, value, schemaId);
	    }

	    clonedSchema[key] = value;
	  }

	  return clonedSchema
	}

	function toJSON (variableName) {
	  return `(${variableName} && typeof ${variableName}.toJSON === 'function')
    ? ${variableName}.toJSON()
    : ${variableName}
  `
	}

	function buildObject (context, location) {
	  const schema = location.schema;

	  if (context.functionsNamesBySchema.has(schema)) {
	    return context.functionsNamesBySchema.get(schema)
	  }

	  const functionName = generateFuncName(context);
	  context.functionsNamesBySchema.set(schema, functionName);

	  let schemaRef = location.getSchemaRef();
	  if (schemaRef.startsWith(context.rootSchemaId)) {
	    schemaRef = schemaRef.replace(context.rootSchemaId, '');
	  }

	  let functionCode = `
  `;

	  const nullable = schema.nullable === true;
	  functionCode += `
    // ${schemaRef}
    function ${functionName} (input) {
      const obj = ${toJSON('input')}
      ${!nullable ? 'if (obj === null) return JSON_STR_EMPTY_OBJECT' : ''}

      ${buildInnerObject(context, location)}
    }
  `;

	  context.functions.push(functionCode);
	  return functionName
	}

	function buildArray (context, location) {
	  const schema = location.schema;

	  let itemsLocation = location.getPropertyLocation('items');
	  itemsLocation.schema = itemsLocation.schema || {};

	  if (itemsLocation.schema.$ref) {
	    itemsLocation = resolveRef(context, itemsLocation);
	  }

	  const itemsSchema = itemsLocation.schema;

	  if (context.functionsNamesBySchema.has(schema)) {
	    return context.functionsNamesBySchema.get(schema)
	  }

	  const functionName = generateFuncName(context);
	  context.functionsNamesBySchema.set(schema, functionName);

	  let schemaRef = location.getSchemaRef();
	  if (schemaRef.startsWith(context.rootSchemaId)) {
	    schemaRef = schemaRef.replace(context.rootSchemaId, '');
	  }

	  let functionCode = `
    function ${functionName} (obj) {
      // ${schemaRef}
  `;

	  const nullable = schema.nullable === true;
	  functionCode += `
    ${!nullable ? 'if (obj === null) return JSON_STR_EMPTY_ARRAY' : ''}
    if (!Array.isArray(obj)) {
      throw new TypeError(\`The value of '${schemaRef}' does not match schema definition.\`)
    }
    const arrayLength = obj.length
  `;

	  if (!schema.additionalItems && Array.isArray(itemsSchema)) {
	    functionCode += `
      if (arrayLength > ${itemsSchema.length}) {
        throw new Error(\`Item at ${itemsSchema.length} does not match schema definition.\`)
      }
    `;
	  }

	  if (largeArrayMechanism === 'json-stringify') {
	    functionCode += `if (arrayLength >= ${largeArraySize}) return JSON.stringify(obj)\n`;
	  }

	  functionCode += `
    const arrayEnd = arrayLength - 1
    let value
    let json = ''
  `;

	  if (Array.isArray(itemsSchema)) {
	    for (let i = 0; i < itemsSchema.length; i++) {
	      const item = itemsSchema[i];
	      functionCode += `value = obj[${i}]`;
	      const tmpRes = buildValue(context, itemsLocation.getPropertyLocation(i), 'value');
	      functionCode += `
        if (${i} < arrayLength) {
          if (${buildArrayTypeCondition(item.type)}) {
            ${tmpRes}
            if (${i} < arrayEnd) {
              json += JSON_STR_COMMA
            }
          } else {
            throw new Error(\`Item at ${i} does not match schema definition.\`)
          }
        }
        `;
	    }

	    if (schema.additionalItems) {
	      functionCode += `
        for (let i = ${itemsSchema.length}; i < arrayLength; i++) {
          json += JSON.stringify(obj[i])
          if (i < arrayEnd) {
            json += JSON_STR_COMMA
          }
        }`;
	    }
	  } else {
	    const code = buildValue(context, itemsLocation, 'obj[i]');
	    functionCode += `
      for (let i = 0; i < arrayLength; i++) {
        ${code}
        if (i < arrayEnd) {
          json += JSON_STR_COMMA
        }
      }`;
	  }

	  functionCode += `
    return JSON_STR_BEGIN_ARRAY + json + JSON_STR_END_ARRAY
  }`;

	  context.functions.push(functionCode);
	  return functionName
	}

	function buildArrayTypeCondition (type, accessor) {
	  let condition;
	  switch (type) {
	    case 'null':
	      condition = 'value === null';
	      break
	    case 'string':
	      condition = `typeof value === 'string' ||
      value === null ||
      value instanceof Date ||
      value instanceof RegExp ||
      (
        typeof value === "object" &&
        typeof value.toString === "function" &&
        value.toString !== Object.prototype.toString
      )`;
	      break
	    case 'integer':
	      condition = 'Number.isInteger(value)';
	      break
	    case 'number':
	      condition = 'Number.isFinite(value)';
	      break
	    case 'boolean':
	      condition = 'typeof value === \'boolean\'';
	      break
	    case 'object':
	      condition = 'value && typeof value === \'object\' && value.constructor === Object';
	      break
	    case 'array':
	      condition = 'Array.isArray(value)';
	      break
	    default:
	      if (Array.isArray(type)) {
	        const conditions = type.map((subType) => {
	          return buildArrayTypeCondition(subType)
	        });
	        condition = `(${conditions.join(' || ')})`;
	      }
	  }
	  return condition
	}

	function generateFuncName (context) {
	  return 'anonymous' + context.functionsCounter++
	}

	function buildMultiTypeSerializer (context, location, input) {
	  const schema = location.schema;
	  const types = schema.type.sort(t1 => t1 === 'null' ? -1 : 1);

	  let code = '';

	  types.forEach((type, index) => {
	    location.schema = { ...location.schema, type };
	    const nestedResult = buildSingleTypeSerializer(context, location, input);

	    const statement = index === 0 ? 'if' : 'else if';
	    switch (type) {
	      case 'null':
	        code += `
          ${statement} (${input} === null)
            ${nestedResult}
          `;
	        break
	      case 'string': {
	        code += `
          ${statement}(
            typeof ${input} === "string" ||
            ${input} === null ||
            ${input} instanceof Date ||
            ${input} instanceof RegExp ||
            (
              typeof ${input} === "object" &&
              typeof ${input}.toString === "function" &&
              ${input}.toString !== Object.prototype.toString
            )
          )
            ${nestedResult}
        `;
	        break
	      }
	      case 'array': {
	        code += `
          ${statement}(Array.isArray(${input}))
            ${nestedResult}
        `;
	        break
	      }
	      case 'integer': {
	        code += `
          ${statement}(Number.isInteger(${input}) || ${input} === null)
            ${nestedResult}
        `;
	        break
	      }
	      default: {
	        code += `
          ${statement}(typeof ${input} === "${type}" || ${input} === null)
            ${nestedResult}
        `;
	        break
	      }
	    }
	  });
	  let schemaRef = location.getSchemaRef();
	  if (schemaRef.startsWith(context.rootSchemaId)) {
	    schemaRef = schemaRef.replace(context.rootSchemaId, '');
	  }
	  code += `
    else throw new TypeError(\`The value of '${schemaRef}' does not match schema definition.\`)
  `;

	  return code
	}

	function buildSingleTypeSerializer (context, location, input) {
	  const schema = location.schema;

	  switch (schema.type) {
	    case 'null':
	      return 'json += JSON_STR_NULL'
	    case 'string': {
	      if (schema.format === 'date-time') {
	        return `json += serializer.asDateTime(${input})`
	      } else if (schema.format === 'date') {
	        return `json += serializer.asDate(${input})`
	      } else if (schema.format === 'time') {
	        return `json += serializer.asTime(${input})`
	      } else if (schema.format === 'unsafe') {
	        return `json += serializer.asUnsafeString(${input})`
	      } else {
	        return `
        if (typeof ${input} !== 'string') {
          if (${input} === null) {
            json += JSON_STR_EMPTY_STRING
          } else if (${input} instanceof Date) {
            json += JSON_STR_QUOTE + ${input}.toISOString() + JSON_STR_QUOTE
          } else if (${input} instanceof RegExp) {
            json += serializer.asString(${input}.source)
          } else {
            json += serializer.asString(${input}.toString())
          }
        } else {
          json += serializer.asString(${input})
        }
        `
	      }
	    }
	    case 'integer':
	      return `json += serializer.asInteger(${input})`
	    case 'number':
	      return `json += serializer.asNumber(${input})`
	    case 'boolean':
	      return `json += serializer.asBoolean(${input})`
	    case 'object': {
	      const funcName = buildObject(context, location);
	      return `json += ${funcName}(${input})`
	    }
	    case 'array': {
	      const funcName = buildArray(context, location);
	      return `json += ${funcName}(${input})`
	    }
	    case undefined:
	      return `json += JSON.stringify(${input})`
	    default:
	      throw new Error(`${schema.type} unsupported`)
	  }
	}

	function buildConstSerializer (location, input) {
	  const schema = location.schema;
	  const type = schema.type;

	  const hasNullType = Array.isArray(type) && type.includes('null');

	  let code = '';

	  if (hasNullType) {
	    code += `
      if (${input} === null) {
        json += JSON_STR_NULL
      } else {
    `;
	  }

	  code += `json += '${JSON.stringify(schema.const).replace(SINGLE_TICK, "\\'")}'`;

	  if (hasNullType) {
	    code += `
      }
    `;
	  }

	  return code
	}

	function buildAllOf (context, location, input) {
	  const schema = location.schema;

	  let mergedSchemaId = context.mergedSchemasIds.get(schema);
	  if (mergedSchemaId) {
	    const mergedLocation = getMergedLocation(context, mergedSchemaId);
	    return buildValue(context, mergedLocation, input)
	  }

	  mergedSchemaId = `__fjs_merged_${schemaIdCounter++}`;
	  context.mergedSchemasIds.set(schema, mergedSchemaId);

	  const { allOf, ...schemaWithoutAllOf } = location.schema;
	  const locations = [
	    new Location(
	      schemaWithoutAllOf,
	      location.schemaId,
	      location.jsonPointer
	    )
	  ];

	  const allOfsLocation = location.getPropertyLocation('allOf');
	  for (let i = 0; i < allOf.length; i++) {
	    locations.push(allOfsLocation.getPropertyLocation(i));
	  }

	  const mergedLocation = mergeLocations(context, mergedSchemaId, locations);
	  return buildValue(context, mergedLocation, input)
	}

	function buildOneOf (context, location, input) {
	  context.validatorSchemasIds.add(location.schemaId);

	  const schema = location.schema;

	  const type = schema.anyOf ? 'anyOf' : 'oneOf';
	  const { [type]: oneOfs, ...schemaWithoutAnyOf } = location.schema;

	  const locationWithoutOneOf = new Location(
	    schemaWithoutAnyOf,
	    location.schemaId,
	    location.jsonPointer
	  );
	  const oneOfsLocation = location.getPropertyLocation(type);

	  let code = '';

	  for (let index = 0; index < oneOfs.length; index++) {
	    const optionLocation = oneOfsLocation.getPropertyLocation(index);
	    const optionSchema = optionLocation.schema;

	    let mergedSchemaId = context.mergedSchemasIds.get(optionSchema);
	    let mergedLocation = null;
	    if (mergedSchemaId) {
	      mergedLocation = getMergedLocation(context, mergedSchemaId);
	    } else {
	      mergedSchemaId = `__fjs_merged_${schemaIdCounter++}`;
	      context.mergedSchemasIds.set(optionSchema, mergedSchemaId);

	      mergedLocation = mergeLocations(context, mergedSchemaId, [
	        locationWithoutOneOf,
	        optionLocation
	      ]);
	    }

	    const nestedResult = buildValue(context, mergedLocation, input);
	    const schemaRef = optionLocation.getSchemaRef();
	    code += `
      ${index === 0 ? 'if' : 'else if'}(validator.validate("${schemaRef}", ${input}))
        ${nestedResult}
    `;
	  }

	  let schemaRef = location.getSchemaRef();
	  if (schemaRef.startsWith(context.rootSchemaId)) {
	    schemaRef = schemaRef.replace(context.rootSchemaId, '');
	  }

	  code += `
    else throw new TypeError(\`The value of '${schemaRef}' does not match schema definition.\`)
  `;

	  return code
	}

	function buildIfThenElse (context, location, input) {
	  context.validatorSchemasIds.add(location.schemaId);

	  const {
	    if: ifSchema,
	    then: thenSchema,
	    else: elseSchema,
	    ...schemaWithoutIfThenElse
	  } = location.schema;

	  const rootLocation = new Location(
	    schemaWithoutIfThenElse,
	    location.schemaId,
	    location.jsonPointer
	  );

	  const ifLocation = location.getPropertyLocation('if');
	  const ifSchemaRef = ifLocation.getSchemaRef();

	  const thenLocation = location.getPropertyLocation('then');
	  let thenMergedSchemaId = context.mergedSchemasIds.get(thenSchema);
	  let thenMergedLocation = null;
	  if (thenMergedSchemaId) {
	    thenMergedLocation = getMergedLocation(context, thenMergedSchemaId);
	  } else {
	    thenMergedSchemaId = `__fjs_merged_${schemaIdCounter++}`;
	    context.mergedSchemasIds.set(thenSchema, thenMergedSchemaId);

	    thenMergedLocation = mergeLocations(context, thenMergedSchemaId, [
	      rootLocation,
	      thenLocation
	    ]);
	  }

	  if (!elseSchema) {
	    return `
      if (validator.validate("${ifSchemaRef}", ${input})) {
        ${buildValue(context, thenMergedLocation, input)}
      } else {
        ${buildValue(context, rootLocation, input)}
      }
    `
	  }

	  const elseLocation = location.getPropertyLocation('else');
	  let elseMergedSchemaId = context.mergedSchemasIds.get(elseSchema);
	  let elseMergedLocation = null;
	  if (elseMergedSchemaId) {
	    elseMergedLocation = getMergedLocation(context, elseMergedSchemaId);
	  } else {
	    elseMergedSchemaId = `__fjs_merged_${schemaIdCounter++}`;
	    context.mergedSchemasIds.set(elseSchema, elseMergedSchemaId);

	    elseMergedLocation = mergeLocations(context, elseMergedSchemaId, [
	      rootLocation,
	      elseLocation
	    ]);
	  }

	  return `
    if (validator.validate("${ifSchemaRef}", ${input})) {
      ${buildValue(context, thenMergedLocation, input)}
    } else {
      ${buildValue(context, elseMergedLocation, input)}
    }
  `
	}

	function buildValue (context, location, input) {
	  let schema = location.schema;

	  if (typeof schema === 'boolean') {
	    return `json += JSON.stringify(${input})`
	  }

	  if (schema.$ref) {
	    location = resolveRef(context, location);
	    schema = location.schema;
	  }

	  if (schema.allOf) {
	    return buildAllOf(context, location, input)
	  }

	  if (schema.anyOf || schema.oneOf) {
	    return buildOneOf(context, location, input)
	  }

	  if (schema.if && schema.then) {
	    return buildIfThenElse(context, location, input)
	  }

	  if (schema.type === undefined) {
	    const inferredType = inferTypeByKeyword(schema);
	    if (inferredType) {
	      schema.type = inferredType;
	    }
	  }

	  let code = '';

	  const type = schema.type;
	  const nullable = schema.nullable === true;
	  if (nullable) {
	    code += `
      if (${input} === null) {
        json += JSON_STR_NULL
      } else {
    `;
	  }

	  if (schema.const !== undefined) {
	    code += buildConstSerializer(location, input);
	  } else if (Array.isArray(type)) {
	    code += buildMultiTypeSerializer(context, location, input);
	  } else {
	    code += buildSingleTypeSerializer(context, location, input);
	  }

	  if (nullable) {
	    code += `
      }
    `;
	  }

	  return code
	}

	fastJsonStringify.exports = build;
	fastJsonStringify.exports.default = build;
	fastJsonStringify.exports.build = build;

	fastJsonStringify.exports.validLargeArrayMechanisms = validLargeArrayMechanisms;

	fastJsonStringify.exports.restore = function ({ code, validator, serializer }) {
	  // eslint-disable-next-line
	  return (Function.apply(null, ['validator', 'serializer', code])
	    .apply(null, [validator, serializer]))
	};
	return fastJsonStringify.exports;
}

var hasRequiredStandalone$2;

function requireStandalone$2 () {
	if (hasRequiredStandalone$2) return standalone$3;
	hasRequiredStandalone$2 = 1;

	const fastJsonStringify = requireFastJsonStringify();

	function SerializerSelector () {
	  return function buildSerializerFactory (externalSchemas, serializerOpts) {
	    const fjsOpts = Object.assign({}, serializerOpts, { schema: externalSchemas });
	    return responseSchemaCompiler.bind(null, fjsOpts)
	  }
	}

	function responseSchemaCompiler (fjsOpts, { schema /* method, url, httpStatus */ }) {
	  if (fjsOpts.schema && schema.$id && fjsOpts.schema[schema.$id]) {
	    fjsOpts.schema = { ...fjsOpts.schema };
	    delete fjsOpts.schema[schema.$id];
	  }
	  return fastJsonStringify(schema, fjsOpts)
	}

	function StandaloneSerializer (options = { readMode: true }) {
	  if (options.readMode === true && typeof options.restoreFunction !== 'function') {
	    throw new Error('You must provide a function for the restoreFunction-option when readMode ON')
	  }

	  if (options.readMode !== true && typeof options.storeFunction !== 'function') {
	    throw new Error('You must provide a function for the storeFunction-option when readMode OFF')
	  }

	  if (options.readMode === true) {
	    // READ MODE: it behalf only in the restore function provided by the user
	    return function wrapper () {
	      return function (opts) {
	        return options.restoreFunction(opts)
	      }
	    }
	  }

	  // WRITE MODE: it behalf on the default SerializerSelector, wrapping the API to run the Ajv Standalone code generation
	  const factory = SerializerSelector();
	  return function wrapper (externalSchemas, serializerOpts = {}) {
	    // to generate the serialization source code, this option is mandatory
	    serializerOpts.mode = 'standalone';

	    const compiler = factory(externalSchemas, serializerOpts);
	    return function (opts) { // { schema/*, method, url, httpPart */ }
	      const serializeFuncCode = compiler(opts);

	      options.storeFunction(opts, serializeFuncCode);

	      // eslint-disable-next-line no-new-func
	      return new Function(serializeFuncCode)
	    }
	  }
	}

	standalone$3.SerializerSelector = SerializerSelector;
	standalone$3.StandaloneSerializer = StandaloneSerializer;
	standalone$3.default = StandaloneSerializer;
	return standalone$3;
}

var hasRequiredFastJsonStringifyCompiler;

function requireFastJsonStringifyCompiler () {
	if (hasRequiredFastJsonStringifyCompiler) return fastJsonStringifyCompiler.exports;
	hasRequiredFastJsonStringifyCompiler = 1;

	const { SerializerSelector, StandaloneSerializer } = requireStandalone$2();

	fastJsonStringifyCompiler.exports = SerializerSelector;
	fastJsonStringifyCompiler.exports.default = SerializerSelector;
	fastJsonStringifyCompiler.exports.SerializerSelector = SerializerSelector;
	fastJsonStringifyCompiler.exports.StandaloneSerializer = StandaloneSerializer;
	return fastJsonStringifyCompiler.exports;
}

var ajvCompiler = {exports: {}};

var jtd$1 = {exports: {}};

var jtd = {};

var ref = {};

var metadata$1 = {};

var hasRequiredMetadata$1;

function requireMetadata$1 () {
	if (hasRequiredMetadata$1) return metadata$1;
	hasRequiredMetadata$1 = 1;
	Object.defineProperty(metadata$1, "__esModule", { value: true });
	metadata$1.checkMetadata = void 0;
	const util_1 = requireUtil$1();
	const def = {
	    keyword: "metadata",
	    schemaType: "object",
	    code(cxt) {
	        checkMetadata(cxt);
	        const { gen, schema, it } = cxt;
	        if ((0, util_1.alwaysValidSchema)(it, schema))
	            return;
	        const valid = gen.name("valid");
	        cxt.subschema({ keyword: "metadata", jtdMetadata: true }, valid);
	        cxt.ok(valid);
	    },
	};
	function checkMetadata({ it, keyword }, metadata) {
	    if (it.jtdMetadata !== metadata) {
	        throw new Error(`JTD: "${keyword}" cannot be used in this schema location`);
	    }
	}
	metadata$1.checkMetadata = checkMetadata;
	metadata$1.default = def;
	
	return metadata$1;
}

var hasRequiredRef;

function requireRef () {
	if (hasRequiredRef) return ref;
	hasRequiredRef = 1;
	Object.defineProperty(ref, "__esModule", { value: true });
	ref.hasRef = void 0;
	const compile_1 = requireCompile();
	const codegen_1 = requireCodegen();
	const ref_error_1 = requireRef_error();
	const names_1 = requireNames();
	const ref_1 = requireRef$1();
	const metadata_1 = requireMetadata$1();
	const def = {
	    keyword: "ref",
	    schemaType: "string",
	    code(cxt) {
	        (0, metadata_1.checkMetadata)(cxt);
	        const { gen, data, schema: ref, parentSchema, it } = cxt;
	        const { schemaEnv: { root }, } = it;
	        const valid = gen.name("valid");
	        if (parentSchema.nullable) {
	            gen.var(valid, (0, codegen_1._) `${data} === null`);
	            gen.if((0, codegen_1.not)(valid), validateJtdRef);
	        }
	        else {
	            gen.var(valid, false);
	            validateJtdRef();
	        }
	        cxt.ok(valid);
	        function validateJtdRef() {
	            var _a;
	            const refSchema = (_a = root.schema.definitions) === null || _a === void 0 ? void 0 : _a[ref];
	            if (!refSchema) {
	                throw new ref_error_1.default(it.opts.uriResolver, "", ref, `No definition ${ref}`);
	            }
	            if (hasRef(refSchema) || !it.opts.inlineRefs)
	                callValidate(refSchema);
	            else
	                inlineRefSchema(refSchema);
	        }
	        function callValidate(schema) {
	            const sch = compile_1.compileSchema.call(it.self, new compile_1.SchemaEnv({ schema, root, schemaPath: `/definitions/${ref}` }));
	            const v = (0, ref_1.getValidate)(cxt, sch);
	            const errsCount = gen.const("_errs", names_1.default.errors);
	            (0, ref_1.callRef)(cxt, v, sch, sch.$async);
	            gen.assign(valid, (0, codegen_1._) `${errsCount} === ${names_1.default.errors}`);
	        }
	        function inlineRefSchema(schema) {
	            const schName = gen.scopeValue("schema", it.opts.code.source === true ? { ref: schema, code: (0, codegen_1.stringify)(schema) } : { ref: schema });
	            cxt.subschema({
	                schema,
	                dataTypes: [],
	                schemaPath: codegen_1.nil,
	                topSchemaRef: schName,
	                errSchemaPath: `/definitions/${ref}`,
	            }, valid);
	        }
	    },
	};
	function hasRef(schema) {
	    for (const key in schema) {
	        let sch;
	        if (key === "ref" || (typeof (sch = schema[key]) == "object" && hasRef(sch)))
	            return true;
	    }
	    return false;
	}
	ref.hasRef = hasRef;
	ref.default = def;
	
	return ref;
}

var type = {};

var timestamp = {};

var hasRequiredTimestamp;

function requireTimestamp () {
	if (hasRequiredTimestamp) return timestamp;
	hasRequiredTimestamp = 1;
	Object.defineProperty(timestamp, "__esModule", { value: true });
	const DT_SEPARATOR = /t|\s/i;
	const DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
	const TIME = /^(\d\d):(\d\d):(\d\d)(?:\.\d+)?(?:z|([+-]\d\d)(?::?(\d\d))?)$/i;
	const DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
	function validTimestamp(str, allowDate) {
	    // http://tools.ietf.org/html/rfc3339#section-5.6
	    const dt = str.split(DT_SEPARATOR);
	    return ((dt.length === 2 && validDate(dt[0]) && validTime(dt[1])) ||
	        (allowDate && dt.length === 1 && validDate(dt[0])));
	}
	timestamp.default = validTimestamp;
	function validDate(str) {
	    const matches = DATE.exec(str);
	    if (!matches)
	        return false;
	    const y = +matches[1];
	    const m = +matches[2];
	    const d = +matches[3];
	    return (m >= 1 &&
	        m <= 12 &&
	        d >= 1 &&
	        (d <= DAYS[m] ||
	            // leap year: https://tools.ietf.org/html/rfc3339#appendix-C
	            (m === 2 && d === 29 && (y % 100 === 0 ? y % 400 === 0 : y % 4 === 0))));
	}
	function validTime(str) {
	    const matches = TIME.exec(str);
	    if (!matches)
	        return false;
	    const hr = +matches[1];
	    const min = +matches[2];
	    const sec = +matches[3];
	    const tzH = +(matches[4] || 0);
	    const tzM = +(matches[5] || 0);
	    return ((hr <= 23 && min <= 59 && sec <= 59) ||
	        // leap second
	        (hr - tzH === 23 && min - tzM === 59 && sec === 60));
	}
	validTimestamp.code = 'require("ajv/dist/runtime/timestamp").default';
	
	return timestamp;
}

var error = {};

var hasRequiredError;

function requireError () {
	if (hasRequiredError) return error;
	hasRequiredError = 1;
	Object.defineProperty(error, "__esModule", { value: true });
	error.typeErrorParams = error.typeErrorMessage = error.typeError = void 0;
	const codegen_1 = requireCodegen();
	function typeError(t) {
	    return {
	        message: (cxt) => typeErrorMessage(cxt, t),
	        params: (cxt) => typeErrorParams(cxt, t),
	    };
	}
	error.typeError = typeError;
	function typeErrorMessage({ parentSchema }, t) {
	    return (parentSchema === null || parentSchema === void 0 ? void 0 : parentSchema.nullable) ? `must be ${t} or null` : `must be ${t}`;
	}
	error.typeErrorMessage = typeErrorMessage;
	function typeErrorParams({ parentSchema }, t) {
	    return (0, codegen_1._) `{type: ${t}, nullable: ${!!(parentSchema === null || parentSchema === void 0 ? void 0 : parentSchema.nullable)}}`;
	}
	error.typeErrorParams = typeErrorParams;
	
	return error;
}

var hasRequiredType;

function requireType () {
	if (hasRequiredType) return type;
	hasRequiredType = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.intRange = void 0;
		const codegen_1 = requireCodegen();
		const timestamp_1 = requireTimestamp();
		const util_1 = requireUtil$1();
		const metadata_1 = requireMetadata$1();
		const error_1 = requireError();
		exports.intRange = {
		    int8: [-128, 127, 3],
		    uint8: [0, 255, 3],
		    int16: [-32768, 32767, 5],
		    uint16: [0, 65535, 5],
		    int32: [-2147483648, 2147483647, 10],
		    uint32: [0, 4294967295, 10],
		};
		const error = {
		    message: (cxt) => (0, error_1.typeErrorMessage)(cxt, cxt.schema),
		    params: (cxt) => (0, error_1.typeErrorParams)(cxt, cxt.schema),
		};
		function timestampCode(cxt) {
		    const { gen, data, it } = cxt;
		    const { timestamp, allowDate } = it.opts;
		    if (timestamp === "date")
		        return (0, codegen_1._) `${data} instanceof Date `;
		    const vts = (0, util_1.useFunc)(gen, timestamp_1.default);
		    const allowDateArg = allowDate ? (0, codegen_1._) `, true` : codegen_1.nil;
		    const validString = (0, codegen_1._) `typeof ${data} == "string" && ${vts}(${data}${allowDateArg})`;
		    return timestamp === "string" ? validString : (0, codegen_1.or)((0, codegen_1._) `${data} instanceof Date`, validString);
		}
		const def = {
		    keyword: "type",
		    schemaType: "string",
		    error,
		    code(cxt) {
		        (0, metadata_1.checkMetadata)(cxt);
		        const { data, schema, parentSchema, it } = cxt;
		        let cond;
		        switch (schema) {
		            case "boolean":
		            case "string":
		                cond = (0, codegen_1._) `typeof ${data} == ${schema}`;
		                break;
		            case "timestamp": {
		                cond = timestampCode(cxt);
		                break;
		            }
		            case "float32":
		            case "float64":
		                cond = (0, codegen_1._) `typeof ${data} == "number"`;
		                break;
		            default: {
		                const sch = schema;
		                cond = (0, codegen_1._) `typeof ${data} == "number" && isFinite(${data}) && !(${data} % 1)`;
		                if (!it.opts.int32range && (sch === "int32" || sch === "uint32")) {
		                    if (sch === "uint32")
		                        cond = (0, codegen_1._) `${cond} && ${data} >= 0`;
		                }
		                else {
		                    const [min, max] = exports.intRange[sch];
		                    cond = (0, codegen_1._) `${cond} && ${data} >= ${min} && ${data} <= ${max}`;
		                }
		            }
		        }
		        cxt.pass(parentSchema.nullable ? (0, codegen_1.or)((0, codegen_1._) `${data} === null`, cond) : cond);
		    },
		};
		exports.default = def;
		
	} (type));
	return type;
}

var _enum = {};

var nullable = {};

var hasRequiredNullable;

function requireNullable () {
	if (hasRequiredNullable) return nullable;
	hasRequiredNullable = 1;
	Object.defineProperty(nullable, "__esModule", { value: true });
	nullable.checkNullableObject = nullable.checkNullable = void 0;
	const codegen_1 = requireCodegen();
	function checkNullable({ gen, data, parentSchema }, cond = codegen_1.nil) {
	    const valid = gen.name("valid");
	    if (parentSchema.nullable) {
	        gen.let(valid, (0, codegen_1._) `${data} === null`);
	        cond = (0, codegen_1.not)(valid);
	    }
	    else {
	        gen.let(valid, false);
	    }
	    return [valid, cond];
	}
	nullable.checkNullable = checkNullable;
	function checkNullableObject(cxt, cond) {
	    const [valid, cond_] = checkNullable(cxt, cond);
	    return [valid, (0, codegen_1._) `${cond_} && typeof ${cxt.data} == "object" && !Array.isArray(${cxt.data})`];
	}
	nullable.checkNullableObject = checkNullableObject;
	
	return nullable;
}

var hasRequired_enum;

function require_enum () {
	if (hasRequired_enum) return _enum;
	hasRequired_enum = 1;
	Object.defineProperty(_enum, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const metadata_1 = requireMetadata$1();
	const nullable_1 = requireNullable();
	const error = {
	    message: "must be equal to one of the allowed values",
	    params: ({ schemaCode }) => (0, codegen_1._) `{allowedValues: ${schemaCode}}`,
	};
	const def = {
	    keyword: "enum",
	    schemaType: "array",
	    error,
	    code(cxt) {
	        (0, metadata_1.checkMetadata)(cxt);
	        const { gen, data, schema, schemaValue, parentSchema, it } = cxt;
	        if (schema.length === 0)
	            throw new Error("enum must have non-empty array");
	        if (schema.length !== new Set(schema).size)
	            throw new Error("enum items must be unique");
	        let valid;
	        const isString = (0, codegen_1._) `typeof ${data} == "string"`;
	        if (schema.length >= it.opts.loopEnum) {
	            let cond;
	            [valid, cond] = (0, nullable_1.checkNullable)(cxt, isString);
	            gen.if(cond, loopEnum);
	        }
	        else {
	            /* istanbul ignore if */
	            if (!Array.isArray(schema))
	                throw new Error("ajv implementation error");
	            valid = (0, codegen_1.and)(isString, (0, codegen_1.or)(...schema.map((value) => (0, codegen_1._) `${data} === ${value}`)));
	            if (parentSchema.nullable)
	                valid = (0, codegen_1.or)((0, codegen_1._) `${data} === null`, valid);
	        }
	        cxt.pass(valid);
	        function loopEnum() {
	            gen.forOf("v", schemaValue, (v) => gen.if((0, codegen_1._) `${valid} = ${data} === ${v}`, () => gen.break()));
	        }
	    },
	};
	_enum.default = def;
	
	return _enum;
}

var elements = {};

var hasRequiredElements;

function requireElements () {
	if (hasRequiredElements) return elements;
	hasRequiredElements = 1;
	Object.defineProperty(elements, "__esModule", { value: true });
	const util_1 = requireUtil$1();
	const code_1 = requireCode();
	const codegen_1 = requireCodegen();
	const metadata_1 = requireMetadata$1();
	const nullable_1 = requireNullable();
	const error_1 = requireError();
	const def = {
	    keyword: "elements",
	    schemaType: "object",
	    error: (0, error_1.typeError)("array"),
	    code(cxt) {
	        (0, metadata_1.checkMetadata)(cxt);
	        const { gen, data, schema, it } = cxt;
	        if ((0, util_1.alwaysValidSchema)(it, schema))
	            return;
	        const [valid] = (0, nullable_1.checkNullable)(cxt);
	        gen.if((0, codegen_1.not)(valid), () => gen.if((0, codegen_1._) `Array.isArray(${data})`, () => gen.assign(valid, (0, code_1.validateArray)(cxt)), () => cxt.error()));
	        cxt.ok(valid);
	    },
	};
	elements.default = def;
	
	return elements;
}

var properties = {};

var hasRequiredProperties;

function requireProperties () {
	if (hasRequiredProperties) return properties;
	hasRequiredProperties = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.validateProperties = exports.error = void 0;
		const code_1 = requireCode();
		const util_1 = requireUtil$1();
		const codegen_1 = requireCodegen();
		const metadata_1 = requireMetadata$1();
		const nullable_1 = requireNullable();
		const error_1 = requireError();
		var PropError;
		(function (PropError) {
		    PropError["Additional"] = "additional";
		    PropError["Missing"] = "missing";
		})(PropError || (PropError = {}));
		exports.error = {
		    message: (cxt) => {
		        const { params } = cxt;
		        return params.propError
		            ? params.propError === PropError.Additional
		                ? "must NOT have additional properties"
		                : `must have property '${params.missingProperty}'`
		            : (0, error_1.typeErrorMessage)(cxt, "object");
		    },
		    params: (cxt) => {
		        const { params } = cxt;
		        return params.propError
		            ? params.propError === PropError.Additional
		                ? (0, codegen_1._) `{error: ${params.propError}, additionalProperty: ${params.additionalProperty}}`
		                : (0, codegen_1._) `{error: ${params.propError}, missingProperty: ${params.missingProperty}}`
		            : (0, error_1.typeErrorParams)(cxt, "object");
		    },
		};
		const def = {
		    keyword: "properties",
		    schemaType: "object",
		    error: exports.error,
		    code: validateProperties,
		};
		// const error: KeywordErrorDefinition = {
		//   message: "should NOT have additional properties",
		//   params: ({params}) => _`{additionalProperty: ${params.additionalProperty}}`,
		// }
		function validateProperties(cxt) {
		    (0, metadata_1.checkMetadata)(cxt);
		    const { gen, data, parentSchema, it } = cxt;
		    const { additionalProperties, nullable } = parentSchema;
		    if (it.jtdDiscriminator && nullable)
		        throw new Error("JTD: nullable inside discriminator mapping");
		    if (commonProperties()) {
		        throw new Error("JTD: properties and optionalProperties have common members");
		    }
		    const [allProps, properties] = schemaProperties("properties");
		    const [allOptProps, optProperties] = schemaProperties("optionalProperties");
		    if (properties.length === 0 && optProperties.length === 0 && additionalProperties) {
		        return;
		    }
		    const [valid, cond] = it.jtdDiscriminator === undefined
		        ? (0, nullable_1.checkNullableObject)(cxt, data)
		        : [gen.let("valid", false), true];
		    gen.if(cond, () => gen.assign(valid, true).block(() => {
		        validateProps(properties, "properties", true);
		        validateProps(optProperties, "optionalProperties");
		        if (!additionalProperties)
		            validateAdditional();
		    }));
		    cxt.pass(valid);
		    function commonProperties() {
		        const props = parentSchema.properties;
		        const optProps = parentSchema.optionalProperties;
		        if (!(props && optProps))
		            return false;
		        for (const p in props) {
		            if (Object.prototype.hasOwnProperty.call(optProps, p))
		                return true;
		        }
		        return false;
		    }
		    function schemaProperties(keyword) {
		        const schema = parentSchema[keyword];
		        const allPs = schema ? (0, code_1.allSchemaProperties)(schema) : [];
		        if (it.jtdDiscriminator && allPs.some((p) => p === it.jtdDiscriminator)) {
		            throw new Error(`JTD: discriminator tag used in ${keyword}`);
		        }
		        const ps = allPs.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));
		        return [allPs, ps];
		    }
		    function validateProps(props, keyword, required) {
		        const _valid = gen.var("valid");
		        for (const prop of props) {
		            gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties), () => applyPropertySchema(prop, keyword, _valid), () => missingProperty(prop));
		            cxt.ok(_valid);
		        }
		        function missingProperty(prop) {
		            if (required) {
		                gen.assign(_valid, false);
		                cxt.error(false, { propError: PropError.Missing, missingProperty: prop }, { schemaPath: prop });
		            }
		            else {
		                gen.assign(_valid, true);
		            }
		        }
		    }
		    function applyPropertySchema(prop, keyword, _valid) {
		        cxt.subschema({
		            keyword,
		            schemaProp: prop,
		            dataProp: prop,
		        }, _valid);
		    }
		    function validateAdditional() {
		        gen.forIn("key", data, (key) => {
		            const addProp = isAdditional(key, allProps, "properties", it.jtdDiscriminator);
		            const addOptProp = isAdditional(key, allOptProps, "optionalProperties");
		            const extra = addProp === true ? addOptProp : addOptProp === true ? addProp : (0, codegen_1.and)(addProp, addOptProp);
		            gen.if(extra, () => {
		                if (it.opts.removeAdditional) {
		                    gen.code((0, codegen_1._) `delete ${data}[${key}]`);
		                }
		                else {
		                    cxt.error(false, { propError: PropError.Additional, additionalProperty: key }, { instancePath: key, parentSchema: true });
		                    if (!it.opts.allErrors)
		                        gen.break();
		                }
		            });
		        });
		    }
		    function isAdditional(key, props, keyword, jtdDiscriminator) {
		        let additional;
		        if (props.length > 8) {
		            // TODO maybe an option instead of hard-coded 8?
		            const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema[keyword], keyword);
		            additional = (0, codegen_1.not)((0, code_1.isOwnProperty)(gen, propsSchema, key));
		            if (jtdDiscriminator !== undefined) {
		                additional = (0, codegen_1.and)(additional, (0, codegen_1._) `${key} !== ${jtdDiscriminator}`);
		            }
		        }
		        else if (props.length || jtdDiscriminator !== undefined) {
		            const ps = jtdDiscriminator === undefined ? props : [jtdDiscriminator].concat(props);
		            additional = (0, codegen_1.and)(...ps.map((p) => (0, codegen_1._) `${key} !== ${p}`));
		        }
		        else {
		            additional = true;
		        }
		        return additional;
		    }
		}
		exports.validateProperties = validateProperties;
		exports.default = def;
		
	} (properties));
	return properties;
}

var optionalProperties = {};

var hasRequiredOptionalProperties;

function requireOptionalProperties () {
	if (hasRequiredOptionalProperties) return optionalProperties;
	hasRequiredOptionalProperties = 1;
	Object.defineProperty(optionalProperties, "__esModule", { value: true });
	const properties_1 = requireProperties();
	const def = {
	    keyword: "optionalProperties",
	    schemaType: "object",
	    error: properties_1.error,
	    code(cxt) {
	        if (cxt.parentSchema.properties)
	            return;
	        (0, properties_1.validateProperties)(cxt);
	    },
	};
	optionalProperties.default = def;
	
	return optionalProperties;
}

var discriminator = {};

var hasRequiredDiscriminator;

function requireDiscriminator () {
	if (hasRequiredDiscriminator) return discriminator;
	hasRequiredDiscriminator = 1;
	Object.defineProperty(discriminator, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const metadata_1 = requireMetadata$1();
	const nullable_1 = requireNullable();
	const error_1 = requireError();
	const types_1 = requireTypes$3();
	const error = {
	    message: (cxt) => {
	        const { schema, params } = cxt;
	        return params.discrError
	            ? params.discrError === types_1.DiscrError.Tag
	                ? `tag "${schema}" must be string`
	                : `value of tag "${schema}" must be in mapping`
	            : (0, error_1.typeErrorMessage)(cxt, "object");
	    },
	    params: (cxt) => {
	        const { schema, params } = cxt;
	        return params.discrError
	            ? (0, codegen_1._) `{error: ${params.discrError}, tag: ${schema}, tagValue: ${params.tag}}`
	            : (0, error_1.typeErrorParams)(cxt, "object");
	    },
	};
	const def = {
	    keyword: "discriminator",
	    schemaType: "string",
	    implements: ["mapping"],
	    error,
	    code(cxt) {
	        (0, metadata_1.checkMetadata)(cxt);
	        const { gen, data, schema, parentSchema } = cxt;
	        const [valid, cond] = (0, nullable_1.checkNullableObject)(cxt, data);
	        gen.if(cond);
	        validateDiscriminator();
	        gen.elseIf((0, codegen_1.not)(valid));
	        cxt.error();
	        gen.endIf();
	        cxt.ok(valid);
	        function validateDiscriminator() {
	            const tag = gen.const("tag", (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(schema)}`);
	            gen.if((0, codegen_1._) `${tag} === undefined`);
	            cxt.error(false, { discrError: types_1.DiscrError.Tag, tag });
	            gen.elseIf((0, codegen_1._) `typeof ${tag} == "string"`);
	            validateMapping(tag);
	            gen.else();
	            cxt.error(false, { discrError: types_1.DiscrError.Tag, tag }, { instancePath: schema });
	            gen.endIf();
	        }
	        function validateMapping(tag) {
	            gen.if(false);
	            for (const tagValue in parentSchema.mapping) {
	                gen.elseIf((0, codegen_1._) `${tag} === ${tagValue}`);
	                gen.assign(valid, applyTagSchema(tagValue));
	            }
	            gen.else();
	            cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag }, { instancePath: schema, schemaPath: "mapping", parentSchema: true });
	            gen.endIf();
	        }
	        function applyTagSchema(schemaProp) {
	            const _valid = gen.name("valid");
	            cxt.subschema({
	                keyword: "mapping",
	                schemaProp,
	                jtdDiscriminator: schema,
	            }, _valid);
	            return _valid;
	        }
	    },
	};
	discriminator.default = def;
	
	return discriminator;
}

var values = {};

var hasRequiredValues;

function requireValues () {
	if (hasRequiredValues) return values;
	hasRequiredValues = 1;
	Object.defineProperty(values, "__esModule", { value: true });
	const util_1 = requireUtil$1();
	const codegen_1 = requireCodegen();
	const metadata_1 = requireMetadata$1();
	const nullable_1 = requireNullable();
	const error_1 = requireError();
	const def = {
	    keyword: "values",
	    schemaType: "object",
	    error: (0, error_1.typeError)("object"),
	    code(cxt) {
	        (0, metadata_1.checkMetadata)(cxt);
	        const { gen, data, schema, it } = cxt;
	        const [valid, cond] = (0, nullable_1.checkNullableObject)(cxt, data);
	        if ((0, util_1.alwaysValidSchema)(it, schema)) {
	            gen.if((0, codegen_1.not)((0, codegen_1.or)(cond, valid)), () => cxt.error());
	        }
	        else {
	            gen.if(cond);
	            gen.assign(valid, validateMap());
	            gen.elseIf((0, codegen_1.not)(valid));
	            cxt.error();
	            gen.endIf();
	        }
	        cxt.ok(valid);
	        function validateMap() {
	            const _valid = gen.name("valid");
	            if (it.allErrors) {
	                const validMap = gen.let("valid", true);
	                validateValues(() => gen.assign(validMap, false));
	                return validMap;
	            }
	            gen.var(_valid, true);
	            validateValues(() => gen.break());
	            return _valid;
	            function validateValues(notValid) {
	                gen.forIn("key", data, (key) => {
	                    cxt.subschema({
	                        keyword: "values",
	                        dataProp: key,
	                        dataPropType: util_1.Type.Str,
	                    }, _valid);
	                    gen.if((0, codegen_1.not)(_valid), notValid);
	                });
	            }
	        }
	    },
	};
	values.default = def;
	
	return values;
}

var union = {};

var hasRequiredUnion;

function requireUnion () {
	if (hasRequiredUnion) return union;
	hasRequiredUnion = 1;
	Object.defineProperty(union, "__esModule", { value: true });
	const code_1 = requireCode();
	const def = {
	    keyword: "union",
	    schemaType: "array",
	    trackErrors: true,
	    code: code_1.validateUnion,
	    error: { message: "must match a schema in union" },
	};
	union.default = def;
	
	return union;
}

var hasRequiredJtd$1;

function requireJtd$1 () {
	if (hasRequiredJtd$1) return jtd;
	hasRequiredJtd$1 = 1;
	Object.defineProperty(jtd, "__esModule", { value: true });
	const ref_1 = requireRef();
	const type_1 = requireType();
	const enum_1 = require_enum();
	const elements_1 = requireElements();
	const properties_1 = requireProperties();
	const optionalProperties_1 = requireOptionalProperties();
	const discriminator_1 = requireDiscriminator();
	const values_1 = requireValues();
	const union_1 = requireUnion();
	const metadata_1 = requireMetadata$1();
	const jtdVocabulary = [
	    "definitions",
	    ref_1.default,
	    type_1.default,
	    enum_1.default,
	    elements_1.default,
	    properties_1.default,
	    optionalProperties_1.default,
	    discriminator_1.default,
	    values_1.default,
	    union_1.default,
	    metadata_1.default,
	    { keyword: "additionalProperties", schemaType: "boolean" },
	    { keyword: "nullable", schemaType: "boolean" },
	];
	jtd.default = jtdVocabulary;
	
	return jtd;
}

var jtdSchema = {};

var hasRequiredJtdSchema;

function requireJtdSchema () {
	if (hasRequiredJtdSchema) return jtdSchema;
	hasRequiredJtdSchema = 1;
	Object.defineProperty(jtdSchema, "__esModule", { value: true });
	const shared = (root) => {
	    const sch = {
	        nullable: { type: "boolean" },
	        metadata: {
	            optionalProperties: {
	                union: { elements: { ref: "schema" } },
	            },
	            additionalProperties: true,
	        },
	    };
	    if (root)
	        sch.definitions = { values: { ref: "schema" } };
	    return sch;
	};
	const emptyForm = (root) => ({
	    optionalProperties: shared(root),
	});
	const refForm = (root) => ({
	    properties: {
	        ref: { type: "string" },
	    },
	    optionalProperties: shared(root),
	});
	const typeForm = (root) => ({
	    properties: {
	        type: {
	            enum: [
	                "boolean",
	                "timestamp",
	                "string",
	                "float32",
	                "float64",
	                "int8",
	                "uint8",
	                "int16",
	                "uint16",
	                "int32",
	                "uint32",
	            ],
	        },
	    },
	    optionalProperties: shared(root),
	});
	const enumForm = (root) => ({
	    properties: {
	        enum: { elements: { type: "string" } },
	    },
	    optionalProperties: shared(root),
	});
	const elementsForm = (root) => ({
	    properties: {
	        elements: { ref: "schema" },
	    },
	    optionalProperties: shared(root),
	});
	const propertiesForm = (root) => ({
	    properties: {
	        properties: { values: { ref: "schema" } },
	    },
	    optionalProperties: {
	        optionalProperties: { values: { ref: "schema" } },
	        additionalProperties: { type: "boolean" },
	        ...shared(root),
	    },
	});
	const optionalPropertiesForm = (root) => ({
	    properties: {
	        optionalProperties: { values: { ref: "schema" } },
	    },
	    optionalProperties: {
	        additionalProperties: { type: "boolean" },
	        ...shared(root),
	    },
	});
	const discriminatorForm = (root) => ({
	    properties: {
	        discriminator: { type: "string" },
	        mapping: {
	            values: {
	                metadata: {
	                    union: [propertiesForm(false), optionalPropertiesForm(false)],
	                },
	            },
	        },
	    },
	    optionalProperties: shared(root),
	});
	const valuesForm = (root) => ({
	    properties: {
	        values: { ref: "schema" },
	    },
	    optionalProperties: shared(root),
	});
	const schema = (root) => ({
	    metadata: {
	        union: [
	            emptyForm,
	            refForm,
	            typeForm,
	            enumForm,
	            elementsForm,
	            propertiesForm,
	            optionalPropertiesForm,
	            discriminatorForm,
	            valuesForm,
	        ].map((s) => s(root)),
	    },
	});
	const jtdMetaSchema = {
	    definitions: {
	        schema: schema(false),
	    },
	    ...schema(true),
	};
	jtdSchema.default = jtdMetaSchema;
	
	return jtdSchema;
}

var serialize = {};

var types$2 = {};

var hasRequiredTypes$2;

function requireTypes$2 () {
	if (hasRequiredTypes$2) return types$2;
	hasRequiredTypes$2 = 1;
	Object.defineProperty(types$2, "__esModule", { value: true });
	types$2.jtdForms = void 0;
	types$2.jtdForms = [
	    "elements",
	    "values",
	    "discriminator",
	    "properties",
	    "optionalProperties",
	    "enum",
	    "type",
	    "ref",
	];
	
	return types$2;
}

var quote = {};

var hasRequiredQuote;

function requireQuote () {
	if (hasRequiredQuote) return quote;
	hasRequiredQuote = 1;
	Object.defineProperty(quote, "__esModule", { value: true });
	const rxEscapable = 
	// eslint-disable-next-line no-control-regex, no-misleading-character-class
	/[\\"\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
	const escaped = {
	    "\b": "\\b",
	    "\t": "\\t",
	    "\n": "\\n",
	    "\f": "\\f",
	    "\r": "\\r",
	    '"': '\\"',
	    "\\": "\\\\",
	};
	function quote$1(s) {
	    rxEscapable.lastIndex = 0;
	    return ('"' +
	        (rxEscapable.test(s)
	            ? s.replace(rxEscapable, (a) => {
	                const c = escaped[a];
	                return typeof c === "string"
	                    ? c
	                    : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
	            })
	            : s) +
	        '"');
	}
	quote.default = quote$1;
	quote$1.code = 'require("ajv/dist/runtime/quote").default';
	
	return quote;
}

var hasRequiredSerialize;

function requireSerialize () {
	if (hasRequiredSerialize) return serialize;
	hasRequiredSerialize = 1;
	Object.defineProperty(serialize, "__esModule", { value: true });
	const types_1 = requireTypes$2();
	const __1 = requireCompile();
	const codegen_1 = requireCodegen();
	const ref_error_1 = requireRef_error();
	const names_1 = requireNames();
	const code_1 = requireCode();
	const ref_1 = requireRef();
	const util_1 = requireUtil$1();
	const quote_1 = requireQuote();
	const genSerialize = {
	    elements: serializeElements,
	    values: serializeValues,
	    discriminator: serializeDiscriminator,
	    properties: serializeProperties,
	    optionalProperties: serializeProperties,
	    enum: serializeString,
	    type: serializeType,
	    ref: serializeRef,
	};
	function compileSerializer(sch, definitions) {
	    const _sch = __1.getCompilingSchema.call(this, sch);
	    if (_sch)
	        return _sch;
	    const { es5, lines } = this.opts.code;
	    const { ownProperties } = this.opts;
	    const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
	    const serializeName = gen.scopeName("serialize");
	    const cxt = {
	        self: this,
	        gen,
	        schema: sch.schema,
	        schemaEnv: sch,
	        definitions,
	        data: names_1.default.data,
	    };
	    let sourceCode;
	    try {
	        this._compilations.add(sch);
	        sch.serializeName = serializeName;
	        gen.func(serializeName, names_1.default.data, false, () => {
	            gen.let(names_1.default.json, (0, codegen_1.str) ``);
	            serializeCode(cxt);
	            gen.return(names_1.default.json);
	        });
	        gen.optimize(this.opts.code.optimize);
	        const serializeFuncCode = gen.toString();
	        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${serializeFuncCode}`;
	        const makeSerialize = new Function(`${names_1.default.scope}`, sourceCode);
	        const serialize = makeSerialize(this.scope.get());
	        this.scope.value(serializeName, { ref: serialize });
	        sch.serialize = serialize;
	    }
	    catch (e) {
	        if (sourceCode)
	            this.logger.error("Error compiling serializer, function code:", sourceCode);
	        delete sch.serialize;
	        delete sch.serializeName;
	        throw e;
	    }
	    finally {
	        this._compilations.delete(sch);
	    }
	    return sch;
	}
	serialize.default = compileSerializer;
	function serializeCode(cxt) {
	    let form;
	    for (const key of types_1.jtdForms) {
	        if (key in cxt.schema) {
	            form = key;
	            break;
	        }
	    }
	    serializeNullable(cxt, form ? genSerialize[form] : serializeEmpty);
	}
	function serializeNullable(cxt, serializeForm) {
	    const { gen, schema, data } = cxt;
	    if (!schema.nullable)
	        return serializeForm(cxt);
	    gen.if((0, codegen_1._) `${data} === undefined || ${data} === null`, () => gen.add(names_1.default.json, (0, codegen_1._) `"null"`), () => serializeForm(cxt));
	}
	function serializeElements(cxt) {
	    const { gen, schema, data } = cxt;
	    gen.add(names_1.default.json, (0, codegen_1.str) `[`);
	    const first = gen.let("first", true);
	    gen.forOf("el", data, (el) => {
	        addComma(cxt, first);
	        serializeCode({ ...cxt, schema: schema.elements, data: el });
	    });
	    gen.add(names_1.default.json, (0, codegen_1.str) `]`);
	}
	function serializeValues(cxt) {
	    const { gen, schema, data } = cxt;
	    gen.add(names_1.default.json, (0, codegen_1.str) `{`);
	    const first = gen.let("first", true);
	    gen.forIn("key", data, (key) => serializeKeyValue(cxt, key, schema.values, first));
	    gen.add(names_1.default.json, (0, codegen_1.str) `}`);
	}
	function serializeKeyValue(cxt, key, schema, first) {
	    const { gen, data } = cxt;
	    addComma(cxt, first);
	    serializeString({ ...cxt, data: key });
	    gen.add(names_1.default.json, (0, codegen_1.str) `:`);
	    const value = gen.const("value", (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(key)}`);
	    serializeCode({ ...cxt, schema, data: value });
	}
	function serializeDiscriminator(cxt) {
	    const { gen, schema, data } = cxt;
	    const { discriminator } = schema;
	    gen.add(names_1.default.json, (0, codegen_1.str) `{${JSON.stringify(discriminator)}:`);
	    const tag = gen.const("tag", (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(discriminator)}`);
	    serializeString({ ...cxt, data: tag });
	    gen.if(false);
	    for (const tagValue in schema.mapping) {
	        gen.elseIf((0, codegen_1._) `${tag} === ${tagValue}`);
	        const sch = schema.mapping[tagValue];
	        serializeSchemaProperties({ ...cxt, schema: sch }, discriminator);
	    }
	    gen.endIf();
	    gen.add(names_1.default.json, (0, codegen_1.str) `}`);
	}
	function serializeProperties(cxt) {
	    const { gen } = cxt;
	    gen.add(names_1.default.json, (0, codegen_1.str) `{`);
	    serializeSchemaProperties(cxt);
	    gen.add(names_1.default.json, (0, codegen_1.str) `}`);
	}
	function serializeSchemaProperties(cxt, discriminator) {
	    const { gen, schema, data } = cxt;
	    const { properties, optionalProperties } = schema;
	    const props = keys(properties);
	    const optProps = keys(optionalProperties);
	    const allProps = allProperties(props.concat(optProps));
	    let first = !discriminator;
	    let firstProp;
	    for (const key of props) {
	        if (first)
	            first = false;
	        else
	            gen.add(names_1.default.json, (0, codegen_1.str) `,`);
	        serializeProperty(key, properties[key], keyValue(key));
	    }
	    if (first)
	        firstProp = gen.let("first", true);
	    for (const key of optProps) {
	        const value = keyValue(key);
	        gen.if((0, codegen_1.and)((0, codegen_1._) `${value} !== undefined`, (0, code_1.isOwnProperty)(gen, data, key)), () => {
	            addComma(cxt, firstProp);
	            serializeProperty(key, optionalProperties[key], value);
	        });
	    }
	    if (schema.additionalProperties) {
	        gen.forIn("key", data, (key) => gen.if(isAdditional(key, allProps), () => serializeKeyValue(cxt, key, {}, firstProp)));
	    }
	    function keys(ps) {
	        return ps ? Object.keys(ps) : [];
	    }
	    function allProperties(ps) {
	        if (discriminator)
	            ps.push(discriminator);
	        if (new Set(ps).size !== ps.length) {
	            throw new Error("JTD: properties/optionalProperties/disciminator overlap");
	        }
	        return ps;
	    }
	    function keyValue(key) {
	        return gen.const("value", (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(key)}`);
	    }
	    function serializeProperty(key, propSchema, value) {
	        gen.add(names_1.default.json, (0, codegen_1.str) `${JSON.stringify(key)}:`);
	        serializeCode({ ...cxt, schema: propSchema, data: value });
	    }
	    function isAdditional(key, ps) {
	        return ps.length ? (0, codegen_1.and)(...ps.map((p) => (0, codegen_1._) `${key} !== ${p}`)) : true;
	    }
	}
	function serializeType(cxt) {
	    const { gen, schema, data } = cxt;
	    switch (schema.type) {
	        case "boolean":
	            gen.add(names_1.default.json, (0, codegen_1._) `${data} ? "true" : "false"`);
	            break;
	        case "string":
	            serializeString(cxt);
	            break;
	        case "timestamp":
	            gen.if((0, codegen_1._) `${data} instanceof Date`, () => gen.add(names_1.default.json, (0, codegen_1._) `'"' + ${data}.toISOString() + '"'`), () => serializeString(cxt));
	            break;
	        default:
	            serializeNumber(cxt);
	    }
	}
	function serializeString({ gen, data }) {
	    gen.add(names_1.default.json, (0, codegen_1._) `${(0, util_1.useFunc)(gen, quote_1.default)}(${data})`);
	}
	function serializeNumber({ gen, data }) {
	    gen.add(names_1.default.json, (0, codegen_1._) `"" + ${data}`);
	}
	function serializeRef(cxt) {
	    const { gen, self, data, definitions, schema, schemaEnv } = cxt;
	    const { ref } = schema;
	    const refSchema = definitions[ref];
	    if (!refSchema)
	        throw new ref_error_1.default(self.opts.uriResolver, "", ref, `No definition ${ref}`);
	    if (!(0, ref_1.hasRef)(refSchema))
	        return serializeCode({ ...cxt, schema: refSchema });
	    const { root } = schemaEnv;
	    const sch = compileSerializer.call(self, new __1.SchemaEnv({ schema: refSchema, root }), definitions);
	    gen.add(names_1.default.json, (0, codegen_1._) `${getSerialize(gen, sch)}(${data})`);
	}
	function getSerialize(gen, sch) {
	    return sch.serialize
	        ? gen.scopeValue("serialize", { ref: sch.serialize })
	        : (0, codegen_1._) `${gen.scopeValue("wrapper", { ref: sch })}.serialize`;
	}
	function serializeEmpty({ gen, data }) {
	    gen.add(names_1.default.json, (0, codegen_1._) `JSON.stringify(${data})`);
	}
	function addComma({ gen }, first) {
	    if (first) {
	        gen.if(first, () => gen.assign(first, false), () => gen.add(names_1.default.json, (0, codegen_1.str) `,`));
	    }
	    else {
	        gen.add(names_1.default.json, (0, codegen_1.str) `,`);
	    }
	}
	
	return serialize;
}

var parse$2 = {};

var parseJson = {};

var hasRequiredParseJson;

function requireParseJson () {
	if (hasRequiredParseJson) return parseJson;
	hasRequiredParseJson = 1;
	Object.defineProperty(parseJson, "__esModule", { value: true });
	parseJson.parseJsonString = parseJson.parseJsonNumber = parseJson.parseJson = void 0;
	const rxParseJson = /position\s(\d+)(?: \(line \d+ column \d+\))?$/;
	function parseJson$1(s, pos) {
	    let endPos;
	    parseJson$1.message = undefined;
	    let matches;
	    if (pos)
	        s = s.slice(pos);
	    try {
	        parseJson$1.position = pos + s.length;
	        return JSON.parse(s);
	    }
	    catch (e) {
	        matches = rxParseJson.exec(e.message);
	        if (!matches) {
	            parseJson$1.message = "unexpected end";
	            return undefined;
	        }
	        endPos = +matches[1];
	        const c = s[endPos];
	        s = s.slice(0, endPos);
	        parseJson$1.position = pos + endPos;
	        try {
	            return JSON.parse(s);
	        }
	        catch (e1) {
	            parseJson$1.message = `unexpected token ${c}`;
	            return undefined;
	        }
	    }
	}
	parseJson.parseJson = parseJson$1;
	parseJson$1.message = undefined;
	parseJson$1.position = 0;
	parseJson$1.code = 'require("ajv/dist/runtime/parseJson").parseJson';
	function parseJsonNumber(s, pos, maxDigits) {
	    let numStr = "";
	    let c;
	    parseJsonNumber.message = undefined;
	    if (s[pos] === "-") {
	        numStr += "-";
	        pos++;
	    }
	    if (s[pos] === "0") {
	        numStr += "0";
	        pos++;
	    }
	    else {
	        if (!parseDigits(maxDigits)) {
	            errorMessage();
	            return undefined;
	        }
	    }
	    if (maxDigits) {
	        parseJsonNumber.position = pos;
	        return +numStr;
	    }
	    if (s[pos] === ".") {
	        numStr += ".";
	        pos++;
	        if (!parseDigits()) {
	            errorMessage();
	            return undefined;
	        }
	    }
	    if (((c = s[pos]), c === "e" || c === "E")) {
	        numStr += "e";
	        pos++;
	        if (((c = s[pos]), c === "+" || c === "-")) {
	            numStr += c;
	            pos++;
	        }
	        if (!parseDigits()) {
	            errorMessage();
	            return undefined;
	        }
	    }
	    parseJsonNumber.position = pos;
	    return +numStr;
	    function parseDigits(maxLen) {
	        let digit = false;
	        while (((c = s[pos]), c >= "0" && c <= "9" && (maxLen === undefined || maxLen-- > 0))) {
	            digit = true;
	            numStr += c;
	            pos++;
	        }
	        return digit;
	    }
	    function errorMessage() {
	        parseJsonNumber.position = pos;
	        parseJsonNumber.message = pos < s.length ? `unexpected token ${s[pos]}` : "unexpected end";
	    }
	}
	parseJson.parseJsonNumber = parseJsonNumber;
	parseJsonNumber.message = undefined;
	parseJsonNumber.position = 0;
	parseJsonNumber.code = 'require("ajv/dist/runtime/parseJson").parseJsonNumber';
	const escapedChars = {
	    b: "\b",
	    f: "\f",
	    n: "\n",
	    r: "\r",
	    t: "\t",
	    '"': '"',
	    "/": "/",
	    "\\": "\\",
	};
	const CODE_A = "a".charCodeAt(0);
	const CODE_0 = "0".charCodeAt(0);
	function parseJsonString(s, pos) {
	    let str = "";
	    let c;
	    parseJsonString.message = undefined;
	    // eslint-disable-next-line no-constant-condition, @typescript-eslint/no-unnecessary-condition
	    while (true) {
	        c = s[pos++];
	        if (c === '"')
	            break;
	        if (c === "\\") {
	            c = s[pos];
	            if (c in escapedChars) {
	                str += escapedChars[c];
	                pos++;
	            }
	            else if (c === "u") {
	                pos++;
	                let count = 4;
	                let code = 0;
	                while (count--) {
	                    code <<= 4;
	                    c = s[pos];
	                    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
	                    if (c === undefined) {
	                        errorMessage("unexpected end");
	                        return undefined;
	                    }
	                    c = c.toLowerCase();
	                    if (c >= "a" && c <= "f") {
	                        code += c.charCodeAt(0) - CODE_A + 10;
	                    }
	                    else if (c >= "0" && c <= "9") {
	                        code += c.charCodeAt(0) - CODE_0;
	                    }
	                    else {
	                        errorMessage(`unexpected token ${c}`);
	                        return undefined;
	                    }
	                    pos++;
	                }
	                str += String.fromCharCode(code);
	            }
	            else {
	                errorMessage(`unexpected token ${c}`);
	                return undefined;
	            }
	            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
	        }
	        else if (c === undefined) {
	            errorMessage("unexpected end");
	            return undefined;
	        }
	        else {
	            if (c.charCodeAt(0) >= 0x20) {
	                str += c;
	            }
	            else {
	                errorMessage(`unexpected token ${c}`);
	                return undefined;
	            }
	        }
	    }
	    parseJsonString.position = pos;
	    return str;
	    function errorMessage(msg) {
	        parseJsonString.position = pos;
	        parseJsonString.message = msg;
	    }
	}
	parseJson.parseJsonString = parseJsonString;
	parseJsonString.message = undefined;
	parseJsonString.position = 0;
	parseJsonString.code = 'require("ajv/dist/runtime/parseJson").parseJsonString';
	
	return parseJson;
}

var hasRequiredParse$2;

function requireParse$2 () {
	if (hasRequiredParse$2) return parse$2;
	hasRequiredParse$2 = 1;
	Object.defineProperty(parse$2, "__esModule", { value: true });
	const types_1 = requireTypes$2();
	const __1 = requireCompile();
	const codegen_1 = requireCodegen();
	const ref_error_1 = requireRef_error();
	const names_1 = requireNames();
	const code_1 = requireCode();
	const ref_1 = requireRef();
	const type_1 = requireType();
	const parseJson_1 = requireParseJson();
	const util_1 = requireUtil$1();
	const timestamp_1 = requireTimestamp();
	const genParse = {
	    elements: parseElements,
	    values: parseValues,
	    discriminator: parseDiscriminator,
	    properties: parseProperties,
	    optionalProperties: parseProperties,
	    enum: parseEnum,
	    type: parseType,
	    ref: parseRef,
	};
	function compileParser(sch, definitions) {
	    const _sch = __1.getCompilingSchema.call(this, sch);
	    if (_sch)
	        return _sch;
	    const { es5, lines } = this.opts.code;
	    const { ownProperties } = this.opts;
	    const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
	    const parseName = gen.scopeName("parse");
	    const cxt = {
	        self: this,
	        gen,
	        schema: sch.schema,
	        schemaEnv: sch,
	        definitions,
	        data: names_1.default.data,
	        parseName,
	        char: gen.name("c"),
	    };
	    let sourceCode;
	    try {
	        this._compilations.add(sch);
	        sch.parseName = parseName;
	        parserFunction(cxt);
	        gen.optimize(this.opts.code.optimize);
	        const parseFuncCode = gen.toString();
	        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${parseFuncCode}`;
	        const makeParse = new Function(`${names_1.default.scope}`, sourceCode);
	        const parse = makeParse(this.scope.get());
	        this.scope.value(parseName, { ref: parse });
	        sch.parse = parse;
	    }
	    catch (e) {
	        if (sourceCode)
	            this.logger.error("Error compiling parser, function code:", sourceCode);
	        delete sch.parse;
	        delete sch.parseName;
	        throw e;
	    }
	    finally {
	        this._compilations.delete(sch);
	    }
	    return sch;
	}
	parse$2.default = compileParser;
	const undef = (0, codegen_1._) `undefined`;
	function parserFunction(cxt) {
	    const { gen, parseName, char } = cxt;
	    gen.func(parseName, (0, codegen_1._) `${names_1.default.json}, ${names_1.default.jsonPos}, ${names_1.default.jsonPart}`, false, () => {
	        gen.let(names_1.default.data);
	        gen.let(char);
	        gen.assign((0, codegen_1._) `${parseName}.message`, undef);
	        gen.assign((0, codegen_1._) `${parseName}.position`, undef);
	        gen.assign(names_1.default.jsonPos, (0, codegen_1._) `${names_1.default.jsonPos} || 0`);
	        gen.const(names_1.default.jsonLen, (0, codegen_1._) `${names_1.default.json}.length`);
	        parseCode(cxt);
	        skipWhitespace(cxt);
	        gen.if(names_1.default.jsonPart, () => {
	            gen.assign((0, codegen_1._) `${parseName}.position`, names_1.default.jsonPos);
	            gen.return(names_1.default.data);
	        });
	        gen.if((0, codegen_1._) `${names_1.default.jsonPos} === ${names_1.default.jsonLen}`, () => gen.return(names_1.default.data));
	        jsonSyntaxError(cxt);
	    });
	}
	function parseCode(cxt) {
	    let form;
	    for (const key of types_1.jtdForms) {
	        if (key in cxt.schema) {
	            form = key;
	            break;
	        }
	    }
	    if (form)
	        parseNullable(cxt, genParse[form]);
	    else
	        parseEmpty(cxt);
	}
	const parseBoolean = parseBooleanToken(true, parseBooleanToken(false, jsonSyntaxError));
	function parseNullable(cxt, parseForm) {
	    const { gen, schema, data } = cxt;
	    if (!schema.nullable)
	        return parseForm(cxt);
	    tryParseToken(cxt, "null", parseForm, () => gen.assign(data, null));
	}
	function parseElements(cxt) {
	    const { gen, schema, data } = cxt;
	    parseToken(cxt, "[");
	    const ix = gen.let("i", 0);
	    gen.assign(data, (0, codegen_1._) `[]`);
	    parseItems(cxt, "]", () => {
	        const el = gen.let("el");
	        parseCode({ ...cxt, schema: schema.elements, data: el });
	        gen.assign((0, codegen_1._) `${data}[${ix}++]`, el);
	    });
	}
	function parseValues(cxt) {
	    const { gen, schema, data } = cxt;
	    parseToken(cxt, "{");
	    gen.assign(data, (0, codegen_1._) `{}`);
	    parseItems(cxt, "}", () => parseKeyValue(cxt, schema.values));
	}
	function parseItems(cxt, endToken, block) {
	    tryParseItems(cxt, endToken, block);
	    parseToken(cxt, endToken);
	}
	function tryParseItems(cxt, endToken, block) {
	    const { gen } = cxt;
	    gen.for((0, codegen_1._) `;${names_1.default.jsonPos}<${names_1.default.jsonLen} && ${jsonSlice(1)}!==${endToken};`, () => {
	        block();
	        tryParseToken(cxt, ",", () => gen.break(), hasItem);
	    });
	    function hasItem() {
	        tryParseToken(cxt, endToken, () => { }, jsonSyntaxError);
	    }
	}
	function parseKeyValue(cxt, schema) {
	    const { gen } = cxt;
	    const key = gen.let("key");
	    parseString({ ...cxt, data: key });
	    parseToken(cxt, ":");
	    parsePropertyValue(cxt, key, schema);
	}
	function parseDiscriminator(cxt) {
	    const { gen, data, schema } = cxt;
	    const { discriminator, mapping } = schema;
	    parseToken(cxt, "{");
	    gen.assign(data, (0, codegen_1._) `{}`);
	    const startPos = gen.const("pos", names_1.default.jsonPos);
	    const value = gen.let("value");
	    const tag = gen.let("tag");
	    tryParseItems(cxt, "}", () => {
	        const key = gen.let("key");
	        parseString({ ...cxt, data: key });
	        parseToken(cxt, ":");
	        gen.if((0, codegen_1._) `${key} === ${discriminator}`, () => {
	            parseString({ ...cxt, data: tag });
	            gen.assign((0, codegen_1._) `${data}[${key}]`, tag);
	            gen.break();
	        }, () => parseEmpty({ ...cxt, data: value }) // can be discarded/skipped
	        );
	    });
	    gen.assign(names_1.default.jsonPos, startPos);
	    gen.if((0, codegen_1._) `${tag} === undefined`);
	    parsingError(cxt, (0, codegen_1.str) `discriminator tag not found`);
	    for (const tagValue in mapping) {
	        gen.elseIf((0, codegen_1._) `${tag} === ${tagValue}`);
	        parseSchemaProperties({ ...cxt, schema: mapping[tagValue] }, discriminator);
	    }
	    gen.else();
	    parsingError(cxt, (0, codegen_1.str) `discriminator value not in schema`);
	    gen.endIf();
	}
	function parseProperties(cxt) {
	    const { gen, data } = cxt;
	    parseToken(cxt, "{");
	    gen.assign(data, (0, codegen_1._) `{}`);
	    parseSchemaProperties(cxt);
	}
	function parseSchemaProperties(cxt, discriminator) {
	    const { gen, schema, data } = cxt;
	    const { properties, optionalProperties, additionalProperties } = schema;
	    parseItems(cxt, "}", () => {
	        const key = gen.let("key");
	        parseString({ ...cxt, data: key });
	        parseToken(cxt, ":");
	        gen.if(false);
	        parseDefinedProperty(cxt, key, properties);
	        parseDefinedProperty(cxt, key, optionalProperties);
	        if (discriminator) {
	            gen.elseIf((0, codegen_1._) `${key} === ${discriminator}`);
	            const tag = gen.let("tag");
	            parseString({ ...cxt, data: tag }); // can be discarded, it is already assigned
	        }
	        gen.else();
	        if (additionalProperties) {
	            parseEmpty({ ...cxt, data: (0, codegen_1._) `${data}[${key}]` });
	        }
	        else {
	            parsingError(cxt, (0, codegen_1.str) `property ${key} not allowed`);
	        }
	        gen.endIf();
	    });
	    if (properties) {
	        const hasProp = (0, code_1.hasPropFunc)(gen);
	        const allProps = (0, codegen_1.and)(...Object.keys(properties).map((p) => (0, codegen_1._) `${hasProp}.call(${data}, ${p})`));
	        gen.if((0, codegen_1.not)(allProps), () => parsingError(cxt, (0, codegen_1.str) `missing required properties`));
	    }
	}
	function parseDefinedProperty(cxt, key, schemas = {}) {
	    const { gen } = cxt;
	    for (const prop in schemas) {
	        gen.elseIf((0, codegen_1._) `${key} === ${prop}`);
	        parsePropertyValue(cxt, key, schemas[prop]);
	    }
	}
	function parsePropertyValue(cxt, key, schema) {
	    parseCode({ ...cxt, schema, data: (0, codegen_1._) `${cxt.data}[${key}]` });
	}
	function parseType(cxt) {
	    const { gen, schema, data, self } = cxt;
	    switch (schema.type) {
	        case "boolean":
	            parseBoolean(cxt);
	            break;
	        case "string":
	            parseString(cxt);
	            break;
	        case "timestamp": {
	            parseString(cxt);
	            const vts = (0, util_1.useFunc)(gen, timestamp_1.default);
	            const { allowDate, parseDate } = self.opts;
	            const notValid = allowDate ? (0, codegen_1._) `!${vts}(${data}, true)` : (0, codegen_1._) `!${vts}(${data})`;
	            const fail = parseDate
	                ? (0, codegen_1.or)(notValid, (0, codegen_1._) `(${data} = new Date(${data}), false)`, (0, codegen_1._) `isNaN(${data}.valueOf())`)
	                : notValid;
	            gen.if(fail, () => parsingError(cxt, (0, codegen_1.str) `invalid timestamp`));
	            break;
	        }
	        case "float32":
	        case "float64":
	            parseNumber(cxt);
	            break;
	        default: {
	            const t = schema.type;
	            if (!self.opts.int32range && (t === "int32" || t === "uint32")) {
	                parseNumber(cxt, 16); // 2 ** 53 - max safe integer
	                if (t === "uint32") {
	                    gen.if((0, codegen_1._) `${data} < 0`, () => parsingError(cxt, (0, codegen_1.str) `integer out of range`));
	                }
	            }
	            else {
	                const [min, max, maxDigits] = type_1.intRange[t];
	                parseNumber(cxt, maxDigits);
	                gen.if((0, codegen_1._) `${data} < ${min} || ${data} > ${max}`, () => parsingError(cxt, (0, codegen_1.str) `integer out of range`));
	            }
	        }
	    }
	}
	function parseString(cxt) {
	    parseToken(cxt, '"');
	    parseWith(cxt, parseJson_1.parseJsonString);
	}
	function parseEnum(cxt) {
	    const { gen, data, schema } = cxt;
	    const enumSch = schema.enum;
	    parseToken(cxt, '"');
	    // TODO loopEnum
	    gen.if(false);
	    for (const value of enumSch) {
	        const valueStr = JSON.stringify(value).slice(1); // remove starting quote
	        gen.elseIf((0, codegen_1._) `${jsonSlice(valueStr.length)} === ${valueStr}`);
	        gen.assign(data, (0, codegen_1.str) `${value}`);
	        gen.add(names_1.default.jsonPos, valueStr.length);
	    }
	    gen.else();
	    jsonSyntaxError(cxt);
	    gen.endIf();
	}
	function parseNumber(cxt, maxDigits) {
	    const { gen } = cxt;
	    skipWhitespace(cxt);
	    gen.if((0, codegen_1._) `"-0123456789".indexOf(${jsonSlice(1)}) < 0`, () => jsonSyntaxError(cxt), () => parseWith(cxt, parseJson_1.parseJsonNumber, maxDigits));
	}
	function parseBooleanToken(bool, fail) {
	    return (cxt) => {
	        const { gen, data } = cxt;
	        tryParseToken(cxt, `${bool}`, () => fail(cxt), () => gen.assign(data, bool));
	    };
	}
	function parseRef(cxt) {
	    const { gen, self, definitions, schema, schemaEnv } = cxt;
	    const { ref } = schema;
	    const refSchema = definitions[ref];
	    if (!refSchema)
	        throw new ref_error_1.default(self.opts.uriResolver, "", ref, `No definition ${ref}`);
	    if (!(0, ref_1.hasRef)(refSchema))
	        return parseCode({ ...cxt, schema: refSchema });
	    const { root } = schemaEnv;
	    const sch = compileParser.call(self, new __1.SchemaEnv({ schema: refSchema, root }), definitions);
	    partialParse(cxt, getParser(gen, sch), true);
	}
	function getParser(gen, sch) {
	    return sch.parse
	        ? gen.scopeValue("parse", { ref: sch.parse })
	        : (0, codegen_1._) `${gen.scopeValue("wrapper", { ref: sch })}.parse`;
	}
	function parseEmpty(cxt) {
	    parseWith(cxt, parseJson_1.parseJson);
	}
	function parseWith(cxt, parseFunc, args) {
	    partialParse(cxt, (0, util_1.useFunc)(cxt.gen, parseFunc), args);
	}
	function partialParse(cxt, parseFunc, args) {
	    const { gen, data } = cxt;
	    gen.assign(data, (0, codegen_1._) `${parseFunc}(${names_1.default.json}, ${names_1.default.jsonPos}${args ? (0, codegen_1._) `, ${args}` : codegen_1.nil})`);
	    gen.assign(names_1.default.jsonPos, (0, codegen_1._) `${parseFunc}.position`);
	    gen.if((0, codegen_1._) `${data} === undefined`, () => parsingError(cxt, (0, codegen_1._) `${parseFunc}.message`));
	}
	function parseToken(cxt, tok) {
	    tryParseToken(cxt, tok, jsonSyntaxError);
	}
	function tryParseToken(cxt, tok, fail, success) {
	    const { gen } = cxt;
	    const n = tok.length;
	    skipWhitespace(cxt);
	    gen.if((0, codegen_1._) `${jsonSlice(n)} === ${tok}`, () => {
	        gen.add(names_1.default.jsonPos, n);
	        success === null || success === void 0 ? void 0 : success(cxt);
	    }, () => fail(cxt));
	}
	function skipWhitespace({ gen, char: c }) {
	    gen.code((0, codegen_1._) `while((${c}=${names_1.default.json}[${names_1.default.jsonPos}],${c}===" "||${c}==="\\n"||${c}==="\\r"||${c}==="\\t"))${names_1.default.jsonPos}++;`);
	}
	function jsonSlice(len) {
	    return len === 1
	        ? (0, codegen_1._) `${names_1.default.json}[${names_1.default.jsonPos}]`
	        : (0, codegen_1._) `${names_1.default.json}.slice(${names_1.default.jsonPos}, ${names_1.default.jsonPos}+${len})`;
	}
	function jsonSyntaxError(cxt) {
	    parsingError(cxt, (0, codegen_1._) `"unexpected token " + ${names_1.default.json}[${names_1.default.jsonPos}]`);
	}
	function parsingError({ gen, parseName }, msg) {
	    gen.assign((0, codegen_1._) `${parseName}.message`, msg);
	    gen.assign((0, codegen_1._) `${parseName}.position`, names_1.default.jsonPos);
	    gen.return(undef);
	}
	
	return parse$2;
}

var hasRequiredJtd;

function requireJtd () {
	if (hasRequiredJtd) return jtd$1.exports;
	hasRequiredJtd = 1;
	(function (module, exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = exports.Ajv = void 0;
		const core_1 = requireCore$1();
		const jtd_1 = requireJtd$1();
		const jtd_schema_1 = requireJtdSchema();
		const serialize_1 = requireSerialize();
		const parse_1 = requireParse$2();
		const META_SCHEMA_ID = "JTD-meta-schema";
		class Ajv extends core_1.default {
		    constructor(opts = {}) {
		        super({
		            ...opts,
		            jtd: true,
		        });
		    }
		    _addVocabularies() {
		        super._addVocabularies();
		        this.addVocabulary(jtd_1.default);
		    }
		    _addDefaultMetaSchema() {
		        super._addDefaultMetaSchema();
		        if (!this.opts.meta)
		            return;
		        this.addMetaSchema(jtd_schema_1.default, META_SCHEMA_ID, false);
		    }
		    defaultMeta() {
		        return (this.opts.defaultMeta =
		            super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined));
		    }
		    compileSerializer(schema) {
		        const sch = this._addSchema(schema);
		        return sch.serialize || this._compileSerializer(sch);
		    }
		    compileParser(schema) {
		        const sch = this._addSchema(schema);
		        return (sch.parse || this._compileParser(sch));
		    }
		    _compileSerializer(sch) {
		        serialize_1.default.call(this, sch, sch.schema.definitions || {});
		        /* istanbul ignore if */
		        if (!sch.serialize)
		            throw new Error("ajv implementation error");
		        return sch.serialize;
		    }
		    _compileParser(sch) {
		        parse_1.default.call(this, sch, sch.schema.definitions || {});
		        /* istanbul ignore if */
		        if (!sch.parse)
		            throw new Error("ajv implementation error");
		        return sch.parse;
		    }
		}
		exports.Ajv = Ajv;
		module.exports = exports = Ajv;
		module.exports.Ajv = Ajv;
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.default = Ajv;
		var validate_1 = requireValidate();
		Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function () { return validate_1.KeywordCxt; } });
		var codegen_1 = requireCodegen();
		Object.defineProperty(exports, "_", { enumerable: true, get: function () { return codegen_1._; } });
		Object.defineProperty(exports, "str", { enumerable: true, get: function () { return codegen_1.str; } });
		Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return codegen_1.stringify; } });
		Object.defineProperty(exports, "nil", { enumerable: true, get: function () { return codegen_1.nil; } });
		Object.defineProperty(exports, "Name", { enumerable: true, get: function () { return codegen_1.Name; } });
		Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function () { return codegen_1.CodeGen; } });
		var validation_error_1 = requireValidation_error();
		Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function () { return validation_error_1.default; } });
		var ref_error_1 = requireRef_error();
		Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: function () { return ref_error_1.default; } });
		
	} (jtd$1, jtd$1.exports));
	return jtd$1.exports;
}

var defaultAjvOptions;
var hasRequiredDefaultAjvOptions;

function requireDefaultAjvOptions () {
	if (hasRequiredDefaultAjvOptions) return defaultAjvOptions;
	hasRequiredDefaultAjvOptions = 1;

	const fastUri = requireFastUri();

	defaultAjvOptions = Object.freeze({
	  coerceTypes: 'array',
	  useDefaults: true,
	  removeAdditional: true,
	  uriResolver: fastUri,
	  addUsedSchema: false,
	  // Explicitly set allErrors to `false`.
	  // When set to `true`, a DoS attack is possible.
	  allErrors: false
	});
	return defaultAjvOptions;
}

var validatorCompiler;
var hasRequiredValidatorCompiler;

function requireValidatorCompiler () {
	if (hasRequiredValidatorCompiler) return validatorCompiler;
	hasRequiredValidatorCompiler = 1;

	const Ajv = requireAjv().default;
	const AjvJTD = requireJtd();

	const defaultAjvOptions = requireDefaultAjvOptions();

	class ValidatorCompiler {
	  constructor (externalSchemas, options) {
	    // This instance of Ajv is private
	    // it should not be customized or used
	    if (options.mode === 'JTD') {
	      this.ajv = new AjvJTD(Object.assign({}, defaultAjvOptions, options.customOptions));
	    } else {
	      this.ajv = new Ajv(Object.assign({}, defaultAjvOptions, options.customOptions));
	    }

	    let addFormatPlugin = true;
	    if (options.plugins && options.plugins.length > 0) {
	      for (const plugin of options.plugins) {
	        if (Array.isArray(plugin)) {
	          addFormatPlugin = addFormatPlugin && plugin[0].name !== 'formatsPlugin';
	          plugin[0](this.ajv, plugin[1]);
	        } else {
	          addFormatPlugin = addFormatPlugin && plugin.name !== 'formatsPlugin';
	          plugin(this.ajv);
	        }
	      }
	    }

	    if (addFormatPlugin) {
	      requireDist$3()(this.ajv);
	    }

	    options.onCreate?.(this.ajv);

	    const sourceSchemas = Object.values(externalSchemas);
	    for (const extSchema of sourceSchemas) {
	      this.ajv.addSchema(extSchema);
	    }
	  }

	  buildValidatorFunction ({ schema/*, method, url, httpPart */ }) {
	    // Ajv does not support compiling two schemas with the same
	    // id inside the same instance. Therefore if we have already
	    // compiled the schema with the given id, we just return it.
	    if (schema.$id) {
	      const stored = this.ajv.getSchema(schema.$id);
	      if (stored) {
	        return stored
	      }
	    }

	    return this.ajv.compile(schema)
	  }
	}

	validatorCompiler = ValidatorCompiler;
	return validatorCompiler;
}

var serializerCompiler;
var hasRequiredSerializerCompiler;

function requireSerializerCompiler () {
	if (hasRequiredSerializerCompiler) return serializerCompiler;
	hasRequiredSerializerCompiler = 1;

	const AjvJTD = requireJtd();

	const defaultAjvOptions = requireDefaultAjvOptions();

	class SerializerCompiler {
	  constructor (_externalSchemas, options) {
	    this.ajv = new AjvJTD(Object.assign({}, defaultAjvOptions, options));

	    /**
	     * https://ajv.js.org/json-type-definition.html#ref-form
	     * Unlike JSON Schema, JTD does not allow to reference:
	     * - any schema fragment other than root level definitions member
	     * - root of the schema - there is another way to define a self-recursive schema (see Example 2)
	     * - another schema file (but you can still combine schemas from multiple files using JavaScript).
	     *
	     * So we ignore the externalSchemas parameter.
	     */
	  }

	  buildSerializerFunction ({ schema/*, method, url, httpStatus */ }) {
	    return this.ajv.compileSerializer(schema)
	  }
	}

	serializerCompiler = SerializerCompiler;
	return serializerCompiler;
}

var standalone$1 = {exports: {}};

var hasRequiredStandalone$1;

function requireStandalone$1 () {
	if (hasRequiredStandalone$1) return standalone$1.exports;
	hasRequiredStandalone$1 = 1;
	(function (module, exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		const scope_1 = requireScope();
		const code_1 = requireCode$1();
		function standaloneCode(ajv, refsOrFunc) {
		    if (!ajv.opts.code.source) {
		        throw new Error("moduleCode: ajv instance must have code.source option");
		    }
		    const { _n } = ajv.scope.opts;
		    return typeof refsOrFunc == "function"
		        ? funcExportCode(refsOrFunc.source)
		        : refsOrFunc !== undefined
		            ? multiExportsCode(refsOrFunc, getValidate)
		            : multiExportsCode(ajv.schemas, (sch) => sch.meta ? undefined : ajv.compile(sch.schema));
		    function getValidate(id) {
		        const v = ajv.getSchema(id);
		        if (!v)
		            throw new Error(`moduleCode: no schema with id ${id}`);
		        return v;
		    }
		    function funcExportCode(source) {
		        const usedValues = {};
		        const n = source === null || source === void 0 ? void 0 : source.validateName;
		        const vCode = validateCode(usedValues, source);
		        if (ajv.opts.code.esm) {
		            // Always do named export as `validate` rather than the variable `n` which is `validateXX` for known export value
		            return `"use strict";${_n}export const validate = ${n};${_n}export default ${n};${_n}${vCode}`;
		        }
		        return `"use strict";${_n}module.exports = ${n};${_n}module.exports.default = ${n};${_n}${vCode}`;
		    }
		    function multiExportsCode(schemas, getValidateFunc) {
		        var _a;
		        const usedValues = {};
		        let code = (0, code_1._) `"use strict";`;
		        for (const name in schemas) {
		            const v = getValidateFunc(schemas[name]);
		            if (v) {
		                const vCode = validateCode(usedValues, v.source);
		                const exportSyntax = ajv.opts.code.esm
		                    ? (0, code_1._) `export const ${(0, code_1.getEsmExportName)(name)}`
		                    : (0, code_1._) `exports${(0, code_1.getProperty)(name)}`;
		                code = (0, code_1._) `${code}${_n}${exportSyntax} = ${(_a = v.source) === null || _a === void 0 ? void 0 : _a.validateName};${_n}${vCode}`;
		            }
		        }
		        return `${code}`;
		    }
		    function validateCode(usedValues, s) {
		        if (!s)
		            throw new Error('moduleCode: function does not have "source" property');
		        if (usedState(s.validateName) === scope_1.UsedValueState.Completed)
		            return code_1.nil;
		        setUsedState(s.validateName, scope_1.UsedValueState.Started);
		        const scopeCode = ajv.scope.scopeCode(s.scopeValues, usedValues, refValidateCode);
		        const code = new code_1._Code(`${scopeCode}${_n}${s.validateCode}`);
		        return s.evaluated ? (0, code_1._) `${code}${s.validateName}.evaluated = ${s.evaluated};${_n}` : code;
		        function refValidateCode(n) {
		            var _a;
		            const vRef = (_a = n.value) === null || _a === void 0 ? void 0 : _a.ref;
		            if (n.prefix === "validate" && typeof vRef == "function") {
		                const v = vRef;
		                return validateCode(usedValues, v.source);
		            }
		            else if ((n.prefix === "root" || n.prefix === "wrapper") && typeof vRef == "object") {
		                const { validate, validateName } = vRef;
		                if (!validateName)
		                    throw new Error("ajv internal error");
		                const def = ajv.opts.code.es5 ? scope_1.varKinds.var : scope_1.varKinds.const;
		                const wrapper = (0, code_1._) `${def} ${n} = {validate: ${validateName}};`;
		                if (usedState(validateName) === scope_1.UsedValueState.Started)
		                    return wrapper;
		                const vCode = validateCode(usedValues, validate === null || validate === void 0 ? void 0 : validate.source);
		                return (0, code_1._) `${wrapper}${_n}${vCode}`;
		            }
		            return undefined;
		        }
		        function usedState(name) {
		            var _a;
		            return (_a = usedValues[name.prefix]) === null || _a === void 0 ? void 0 : _a.get(name);
		        }
		        function setUsedState(name, state) {
		            const { prefix } = name;
		            const names = (usedValues[prefix] = usedValues[prefix] || new Map());
		            names.set(name, state);
		        }
		    }
		}
		module.exports = exports = standaloneCode;
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.default = standaloneCode;
		
	} (standalone$1, standalone$1.exports));
	return standalone$1.exports;
}

var standalone;
var hasRequiredStandalone;

function requireStandalone () {
	if (hasRequiredStandalone) return standalone;
	hasRequiredStandalone = 1;

	const ValidatorSelector = requireAjvCompiler();
	const standaloneCode = requireStandalone$1().default;

	function StandaloneValidator (options = { readMode: true }) {
	  if (options.readMode === true && !options.restoreFunction) {
	    throw new Error('You must provide a restoreFunction options when readMode ON')
	  }

	  if (options.readMode !== true && !options.storeFunction) {
	    throw new Error('You must provide a storeFunction options when readMode OFF')
	  }

	  if (options.readMode === true) {
	    // READ MODE: it behalf only in the restore function provided by the user
	    return function wrapper () {
	      return function (opts) {
	        return options.restoreFunction(opts)
	      }
	    }
	  }

	  // WRITE MODE: it behalf on the default ValidatorSelector, wrapping the API to run the Ajv Standalone code generation
	  const factory = ValidatorSelector();
	  return function wrapper (externalSchemas, ajvOptions = {}) {
	    if (!ajvOptions.customOptions || !ajvOptions.customOptions.code) {
	      // to generate the validation source code, these options are mandatory
	      ajvOptions.customOptions = Object.assign({}, ajvOptions.customOptions, { code: { source: true } });
	    }

	    const compiler = factory(externalSchemas, ajvOptions);
	    return function (opts) { // { schema/*, method, url, httpPart */ }
	      const validationFunc = compiler(opts);

	      const schemaValidationCode = standaloneCode(compiler[ValidatorSelector.AjvReference].ajv, validationFunc);
	      options.storeFunction(opts, schemaValidationCode);

	      return validationFunc
	    }
	  }
	}

	standalone = StandaloneValidator;
	return standalone;
}

var hasRequiredAjvCompiler;

function requireAjvCompiler () {
	if (hasRequiredAjvCompiler) return ajvCompiler.exports;
	hasRequiredAjvCompiler = 1;

	const AjvReference = Symbol.for('fastify.ajv-compiler.reference');
	const ValidatorCompiler = requireValidatorCompiler();
	const SerializerCompiler = requireSerializerCompiler();

	function AjvCompiler (opts) {
	  const validatorPool = new Map();
	  const serializerPool = new Map();

	  if (opts && opts.jtdSerializer === true) {
	    return function buildSerializerFromPool (externalSchemas, serializerOpts) {
	      const uniqueAjvKey = getPoolKey({}, serializerOpts);
	      if (serializerPool.has(uniqueAjvKey)) {
	        return serializerPool.get(uniqueAjvKey)
	      }

	      const compiler = new SerializerCompiler(externalSchemas, serializerOpts);
	      const ret = compiler.buildSerializerFunction.bind(compiler);
	      serializerPool.set(uniqueAjvKey, ret);

	      return ret
	    }
	  }

	  return function buildCompilerFromPool (externalSchemas, options) {
	    const uniqueAjvKey = getPoolKey(externalSchemas, options.customOptions);
	    if (validatorPool.has(uniqueAjvKey)) {
	      return validatorPool.get(uniqueAjvKey)
	    }

	    const compiler = new ValidatorCompiler(externalSchemas, options);
	    const ret = compiler.buildValidatorFunction.bind(compiler);
	    validatorPool.set(uniqueAjvKey, ret);

	    if (options.customOptions.code !== undefined) {
	      ret[AjvReference] = compiler;
	    }

	    return ret
	  }
	}

	function getPoolKey (externalSchemas, options) {
	  const externals = JSON.stringify(externalSchemas);
	  const ajvConfig = JSON.stringify(options);
	  return `${externals}${ajvConfig}`
	}
	ajvCompiler.exports = AjvCompiler;
	ajvCompiler.exports.default = AjvCompiler;
	ajvCompiler.exports.AjvCompiler = AjvCompiler;
	ajvCompiler.exports.AjvReference = AjvReference;
	ajvCompiler.exports.StandaloneValidator = requireStandalone();
	return ajvCompiler.exports;
}

var schemaController;
var hasRequiredSchemaController;

function requireSchemaController () {
	if (hasRequiredSchemaController) return schemaController;
	hasRequiredSchemaController = 1;

	const { buildSchemas } = requireSchemas();
	const SerializerSelector = requireFastJsonStringifyCompiler();
	const ValidatorSelector = requireAjvCompiler();

	/**
	 * Called at every fastify context that is being created.
	 * @param {object} parentSchemaCtrl: the SchemaController instance of the Fastify parent context
	 * @param {object} opts: the `schemaController` server option. It can be undefined when a parentSchemaCtrl is set
	 * @return {object}:a new SchemaController
	 */
	function buildSchemaController (parentSchemaCtrl, opts) {
	  if (parentSchemaCtrl) {
	    return new SchemaController(parentSchemaCtrl, opts)
	  }

	  const compilersFactory = Object.assign({
	    buildValidator: null,
	    buildSerializer: null
	  }, opts?.compilersFactory);

	  if (!compilersFactory.buildValidator) {
	    compilersFactory.buildValidator = ValidatorSelector();
	  }
	  if (!compilersFactory.buildSerializer) {
	    compilersFactory.buildSerializer = SerializerSelector();
	  }

	  const option = {
	    bucket: (opts && opts.bucket) || buildSchemas,
	    compilersFactory,
	    isCustomValidatorCompiler: typeof opts?.compilersFactory?.buildValidator === 'function',
	    isCustomSerializerCompiler: typeof opts?.compilersFactory?.buildValidator === 'function'
	  };

	  return new SchemaController(undefined, option)
	}

	class SchemaController {
	  constructor (parent, options) {
	    this.opts = options || parent?.opts;
	    this.addedSchemas = false;

	    this.compilersFactory = this.opts.compilersFactory;

	    if (parent) {
	      this.schemaBucket = this.opts.bucket(parent.getSchemas());
	      this.validatorCompiler = parent.getValidatorCompiler();
	      this.serializerCompiler = parent.getSerializerCompiler();
	      this.isCustomValidatorCompiler = parent.isCustomValidatorCompiler;
	      this.isCustomSerializerCompiler = parent.isCustomSerializerCompiler;
	      this.parent = parent;
	    } else {
	      this.schemaBucket = this.opts.bucket();
	      this.isCustomValidatorCompiler = this.opts.isCustomValidatorCompiler || false;
	      this.isCustomSerializerCompiler = this.opts.isCustomSerializerCompiler || false;
	    }
	  }

	  // Bucket interface
	  add (schema) {
	    this.addedSchemas = true;
	    return this.schemaBucket.add(schema)
	  }

	  getSchema (schemaId) {
	    return this.schemaBucket.getSchema(schemaId)
	  }

	  getSchemas () {
	    return this.schemaBucket.getSchemas()
	  }

	  setValidatorCompiler (validatorCompiler) {
	    // Set up as if the fixed validator compiler had been provided
	    // by a custom 'options.compilersFactory.buildValidator' that
	    // always returns the same compiler object. This is required because:
	    //
	    // - setValidatorCompiler must immediately install a compiler to preserve
	    //   legacy behavior
	    // - setupValidator will recreate compilers from builders in some
	    //   circumstances, so we have to install this adapter to make it
	    //   behave the same if the legacy API is used
	    //
	    // The cloning of the compilersFactory object is necessary because
	    // we are aliasing the parent compilersFactory if none was provided
	    // to us (see constructor.)
	    this.compilersFactory = Object.assign(
	      {},
	      this.compilersFactory,
	      { buildValidator: () => validatorCompiler });
	    this.validatorCompiler = validatorCompiler;
	    this.isCustomValidatorCompiler = true;
	  }

	  setSerializerCompiler (serializerCompiler) {
	    // Set up as if the fixed serializer compiler had been provided
	    // by a custom 'options.compilersFactory.buildSerializer' that
	    // always returns the same compiler object. This is required because:
	    //
	    // - setSerializerCompiler must immediately install a compiler to preserve
	    //   legacy behavior
	    // - setupSerializer will recreate compilers from builders in some
	    //   circumstances, so we have to install this adapter to make it
	    //   behave the same if the legacy API is used
	    //
	    // The cloning of the compilersFactory object is necessary because
	    // we are aliasing the parent compilersFactory if none was provided
	    // to us (see constructor.)
	    this.compilersFactory = Object.assign(
	      {},
	      this.compilersFactory,
	      { buildSerializer: () => serializerCompiler });
	    this.serializerCompiler = serializerCompiler;
	    this.isCustomSerializerCompiler = true;
	  }

	  getValidatorCompiler () {
	    return this.validatorCompiler || (this.parent && this.parent.getValidatorCompiler())
	  }

	  getSerializerCompiler () {
	    return this.serializerCompiler || (this.parent && this.parent.getSerializerCompiler())
	  }

	  getSerializerBuilder () {
	    return this.compilersFactory.buildSerializer || (this.parent && this.parent.getSerializerBuilder())
	  }

	  getValidatorBuilder () {
	    return this.compilersFactory.buildValidator || (this.parent && this.parent.getValidatorBuilder())
	  }

	  /**
	   * This method will be called when a validator must be setup.
	   * Do not setup the compiler more than once
	   * @param {object} serverOptions the fastify server options
	   */
	  setupValidator (serverOptions) {
	    const isReady = this.validatorCompiler !== undefined && !this.addedSchemas;
	    if (isReady) {
	      return
	    }
	    this.validatorCompiler = this.getValidatorBuilder()(this.schemaBucket.getSchemas(), serverOptions.ajv);
	  }

	  /**
	   * This method will be called when a serializer must be setup.
	   * Do not setup the compiler more than once
	   * @param {object} serverOptions the fastify server options
	   */
	  setupSerializer (serverOptions) {
	    const isReady = this.serializerCompiler !== undefined && !this.addedSchemas;
	    if (isReady) {
	      return
	    }

	    this.serializerCompiler = this.getSerializerBuilder()(this.schemaBucket.getSchemas(), serverOptions.serializerOpts);
	  }
	}

	SchemaController.buildSchemaController = buildSchemaController;
	schemaController = SchemaController;
	return schemaController;
}

var pluginUtils = {exports: {}};

var re = {exports: {}};

var constants$1;
var hasRequiredConstants;

function requireConstants () {
	if (hasRequiredConstants) return constants$1;
	hasRequiredConstants = 1;

	// Note: this is the semver.org version of the spec that it implements
	// Not necessarily the package version of this code.
	const SEMVER_SPEC_VERSION = '2.0.0';

	const MAX_LENGTH = 256;
	const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
	/* istanbul ignore next */ 9007199254740991;

	// Max safe segment length for coercion.
	const MAX_SAFE_COMPONENT_LENGTH = 16;

	// Max safe length for a build identifier. The max length minus 6 characters for
	// the shortest version with a build 0.0.0+BUILD.
	const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;

	const RELEASE_TYPES = [
	  'major',
	  'premajor',
	  'minor',
	  'preminor',
	  'patch',
	  'prepatch',
	  'prerelease',
	];

	constants$1 = {
	  MAX_LENGTH,
	  MAX_SAFE_COMPONENT_LENGTH,
	  MAX_SAFE_BUILD_LENGTH,
	  MAX_SAFE_INTEGER,
	  RELEASE_TYPES,
	  SEMVER_SPEC_VERSION,
	  FLAG_INCLUDE_PRERELEASE: 0b001,
	  FLAG_LOOSE: 0b010,
	};
	return constants$1;
}

var debug_1;
var hasRequiredDebug;

function requireDebug () {
	if (hasRequiredDebug) return debug_1;
	hasRequiredDebug = 1;

	const debug = (
	  typeof process === 'object' &&
	  process.env &&
	  process.env.NODE_DEBUG &&
	  /\bsemver\b/i.test(process.env.NODE_DEBUG)
	) ? (...args) => console.error('SEMVER', ...args)
	  : () => {};

	debug_1 = debug;
	return debug_1;
}

var hasRequiredRe;

function requireRe () {
	if (hasRequiredRe) return re.exports;
	hasRequiredRe = 1;
	(function (module, exports) {

		const {
		  MAX_SAFE_COMPONENT_LENGTH,
		  MAX_SAFE_BUILD_LENGTH,
		  MAX_LENGTH,
		} = requireConstants();
		const debug = requireDebug();
		exports = module.exports = {};

		// The actual regexps go on exports.re
		const re = exports.re = [];
		const safeRe = exports.safeRe = [];
		const src = exports.src = [];
		const safeSrc = exports.safeSrc = [];
		const t = exports.t = {};
		let R = 0;

		const LETTERDASHNUMBER = '[a-zA-Z0-9-]';

		// Replace some greedy regex tokens to prevent regex dos issues. These regex are
		// used internally via the safeRe object since all inputs in this library get
		// normalized first to trim and collapse all extra whitespace. The original
		// regexes are exported for userland consumption and lower level usage. A
		// future breaking change could export the safer regex only with a note that
		// all input should have extra whitespace removed.
		const safeRegexReplacements = [
		  ['\\s', 1],
		  ['\\d', MAX_LENGTH],
		  [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH],
		];

		const makeSafeRegex = (value) => {
		  for (const [token, max] of safeRegexReplacements) {
		    value = value
		      .split(`${token}*`).join(`${token}{0,${max}}`)
		      .split(`${token}+`).join(`${token}{1,${max}}`);
		  }
		  return value
		};

		const createToken = (name, value, isGlobal) => {
		  const safe = makeSafeRegex(value);
		  const index = R++;
		  debug(name, index, value);
		  t[name] = index;
		  src[index] = value;
		  safeSrc[index] = safe;
		  re[index] = new RegExp(value, isGlobal ? 'g' : undefined);
		  safeRe[index] = new RegExp(safe, isGlobal ? 'g' : undefined);
		};

		// The following Regular Expressions can be used for tokenizing,
		// validating, and parsing SemVer version strings.

		// ## Numeric Identifier
		// A single `0`, or a non-zero digit followed by zero or more digits.

		createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*');
		createToken('NUMERICIDENTIFIERLOOSE', '\\d+');

		// ## Non-numeric Identifier
		// Zero or more digits, followed by a letter or hyphen, and then zero or
		// more letters, digits, or hyphens.

		createToken('NONNUMERICIDENTIFIER', `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);

		// ## Main Version
		// Three dot-separated numeric identifiers.

		createToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\.` +
		                   `(${src[t.NUMERICIDENTIFIER]})\\.` +
		                   `(${src[t.NUMERICIDENTIFIER]})`);

		createToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
		                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
		                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`);

		// ## Pre-release Version Identifier
		// A numeric identifier, or a non-numeric identifier.
		// Non-numberic identifiers include numberic identifiers but can be longer.
		// Therefore non-numberic identifiers must go first.

		createToken('PRERELEASEIDENTIFIER', `(?:${src[t.NONNUMERICIDENTIFIER]
		}|${src[t.NUMERICIDENTIFIER]})`);

		createToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NONNUMERICIDENTIFIER]
		}|${src[t.NUMERICIDENTIFIERLOOSE]})`);

		// ## Pre-release Version
		// Hyphen, followed by one or more dot-separated pre-release version
		// identifiers.

		createToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]
		}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);

		createToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]
		}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);

		// ## Build Metadata Identifier
		// Any combination of digits, letters, or hyphens.

		createToken('BUILDIDENTIFIER', `${LETTERDASHNUMBER}+`);

		// ## Build Metadata
		// Plus sign, followed by one or more period-separated build metadata
		// identifiers.

		createToken('BUILD', `(?:\\+(${src[t.BUILDIDENTIFIER]
		}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);

		// ## Full Version String
		// A main version, followed optionally by a pre-release version and
		// build metadata.

		// Note that the only major, minor, patch, and pre-release sections of
		// the version string are capturing groups.  The build metadata is not a
		// capturing group, because it should not ever be used in version
		// comparison.

		createToken('FULLPLAIN', `v?${src[t.MAINVERSION]
		}${src[t.PRERELEASE]}?${
		  src[t.BUILD]}?`);

		createToken('FULL', `^${src[t.FULLPLAIN]}$`);

		// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
		// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
		// common in the npm registry.
		createToken('LOOSEPLAIN', `[v=\\s]*${src[t.MAINVERSIONLOOSE]
		}${src[t.PRERELEASELOOSE]}?${
		  src[t.BUILD]}?`);

		createToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`);

		createToken('GTLT', '((?:<|>)?=?)');

		// Something like "2.*" or "1.2.x".
		// Note that "x.x" is a valid xRange identifer, meaning "any version"
		// Only the first item is strictly required.
		createToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
		createToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);

		createToken('XRANGEPLAIN', `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` +
		                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
		                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
		                   `(?:${src[t.PRERELEASE]})?${
		                     src[t.BUILD]}?` +
		                   `)?)?`);

		createToken('XRANGEPLAINLOOSE', `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +
		                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
		                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
		                        `(?:${src[t.PRERELEASELOOSE]})?${
		                          src[t.BUILD]}?` +
		                        `)?)?`);

		createToken('XRANGE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
		createToken('XRANGELOOSE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);

		// Coercion.
		// Extract anything that could conceivably be a part of a valid semver
		createToken('COERCEPLAIN', `${'(^|[^\\d])' +
		              '(\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +
		              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
		              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
		createToken('COERCE', `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
		createToken('COERCEFULL', src[t.COERCEPLAIN] +
		              `(?:${src[t.PRERELEASE]})?` +
		              `(?:${src[t.BUILD]})?` +
		              `(?:$|[^\\d])`);
		createToken('COERCERTL', src[t.COERCE], true);
		createToken('COERCERTLFULL', src[t.COERCEFULL], true);

		// Tilde ranges.
		// Meaning is "reasonably at or greater than"
		createToken('LONETILDE', '(?:~>?)');

		createToken('TILDETRIM', `(\\s*)${src[t.LONETILDE]}\\s+`, true);
		exports.tildeTrimReplace = '$1~';

		createToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
		createToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);

		// Caret ranges.
		// Meaning is "at least and backwards compatible with"
		createToken('LONECARET', '(?:\\^)');

		createToken('CARETTRIM', `(\\s*)${src[t.LONECARET]}\\s+`, true);
		exports.caretTrimReplace = '$1^';

		createToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
		createToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);

		// A simple gt/lt/eq thing, or just "" to indicate "any version"
		createToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
		createToken('COMPARATOR', `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);

		// An expression to strip any whitespace between the gtlt and the thing
		// it modifies, so that `> 1.2.3` ==> `>1.2.3`
		createToken('COMPARATORTRIM', `(\\s*)${src[t.GTLT]
		}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
		exports.comparatorTrimReplace = '$1$2$3';

		// Something like `1.2.3 - 1.2.4`
		// Note that these all use the loose form, because they'll be
		// checked against either the strict or loose comparator form
		// later.
		createToken('HYPHENRANGE', `^\\s*(${src[t.XRANGEPLAIN]})` +
		                   `\\s+-\\s+` +
		                   `(${src[t.XRANGEPLAIN]})` +
		                   `\\s*$`);

		createToken('HYPHENRANGELOOSE', `^\\s*(${src[t.XRANGEPLAINLOOSE]})` +
		                        `\\s+-\\s+` +
		                        `(${src[t.XRANGEPLAINLOOSE]})` +
		                        `\\s*$`);

		// Star ranges basically just allow anything at all.
		createToken('STAR', '(<|>)?=?\\s*\\*');
		// >=0.0.0 is like a star
		createToken('GTE0', '^\\s*>=\\s*0\\.0\\.0\\s*$');
		createToken('GTE0PRE', '^\\s*>=\\s*0\\.0\\.0-0\\s*$'); 
	} (re, re.exports));
	return re.exports;
}

var parseOptions_1;
var hasRequiredParseOptions;

function requireParseOptions () {
	if (hasRequiredParseOptions) return parseOptions_1;
	hasRequiredParseOptions = 1;

	// parse out just the options we care about
	const looseOption = Object.freeze({ loose: true });
	const emptyOpts = Object.freeze({ });
	const parseOptions = options => {
	  if (!options) {
	    return emptyOpts
	  }

	  if (typeof options !== 'object') {
	    return looseOption
	  }

	  return options
	};
	parseOptions_1 = parseOptions;
	return parseOptions_1;
}

var identifiers;
var hasRequiredIdentifiers;

function requireIdentifiers () {
	if (hasRequiredIdentifiers) return identifiers;
	hasRequiredIdentifiers = 1;

	const numeric = /^[0-9]+$/;
	const compareIdentifiers = (a, b) => {
	  const anum = numeric.test(a);
	  const bnum = numeric.test(b);

	  if (anum && bnum) {
	    a = +a;
	    b = +b;
	  }

	  return a === b ? 0
	    : (anum && !bnum) ? -1
	    : (bnum && !anum) ? 1
	    : a < b ? -1
	    : 1
	};

	const rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);

	identifiers = {
	  compareIdentifiers,
	  rcompareIdentifiers,
	};
	return identifiers;
}

var semver$1;
var hasRequiredSemver$1;

function requireSemver$1 () {
	if (hasRequiredSemver$1) return semver$1;
	hasRequiredSemver$1 = 1;

	const debug = requireDebug();
	const { MAX_LENGTH, MAX_SAFE_INTEGER } = requireConstants();
	const { safeRe: re, t } = requireRe();

	const parseOptions = requireParseOptions();
	const { compareIdentifiers } = requireIdentifiers();
	class SemVer {
	  constructor (version, options) {
	    options = parseOptions(options);

	    if (version instanceof SemVer) {
	      if (version.loose === !!options.loose &&
	        version.includePrerelease === !!options.includePrerelease) {
	        return version
	      } else {
	        version = version.version;
	      }
	    } else if (typeof version !== 'string') {
	      throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`)
	    }

	    if (version.length > MAX_LENGTH) {
	      throw new TypeError(
	        `version is longer than ${MAX_LENGTH} characters`
	      )
	    }

	    debug('SemVer', version, options);
	    this.options = options;
	    this.loose = !!options.loose;
	    // this isn't actually relevant for versions, but keep it so that we
	    // don't run into trouble passing this.options around.
	    this.includePrerelease = !!options.includePrerelease;

	    const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);

	    if (!m) {
	      throw new TypeError(`Invalid Version: ${version}`)
	    }

	    this.raw = version;

	    // these are actually numbers
	    this.major = +m[1];
	    this.minor = +m[2];
	    this.patch = +m[3];

	    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
	      throw new TypeError('Invalid major version')
	    }

	    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
	      throw new TypeError('Invalid minor version')
	    }

	    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
	      throw new TypeError('Invalid patch version')
	    }

	    // numberify any prerelease numeric ids
	    if (!m[4]) {
	      this.prerelease = [];
	    } else {
	      this.prerelease = m[4].split('.').map((id) => {
	        if (/^[0-9]+$/.test(id)) {
	          const num = +id;
	          if (num >= 0 && num < MAX_SAFE_INTEGER) {
	            return num
	          }
	        }
	        return id
	      });
	    }

	    this.build = m[5] ? m[5].split('.') : [];
	    this.format();
	  }

	  format () {
	    this.version = `${this.major}.${this.minor}.${this.patch}`;
	    if (this.prerelease.length) {
	      this.version += `-${this.prerelease.join('.')}`;
	    }
	    return this.version
	  }

	  toString () {
	    return this.version
	  }

	  compare (other) {
	    debug('SemVer.compare', this.version, this.options, other);
	    if (!(other instanceof SemVer)) {
	      if (typeof other === 'string' && other === this.version) {
	        return 0
	      }
	      other = new SemVer(other, this.options);
	    }

	    if (other.version === this.version) {
	      return 0
	    }

	    return this.compareMain(other) || this.comparePre(other)
	  }

	  compareMain (other) {
	    if (!(other instanceof SemVer)) {
	      other = new SemVer(other, this.options);
	    }

	    return (
	      compareIdentifiers(this.major, other.major) ||
	      compareIdentifiers(this.minor, other.minor) ||
	      compareIdentifiers(this.patch, other.patch)
	    )
	  }

	  comparePre (other) {
	    if (!(other instanceof SemVer)) {
	      other = new SemVer(other, this.options);
	    }

	    // NOT having a prerelease is > having one
	    if (this.prerelease.length && !other.prerelease.length) {
	      return -1
	    } else if (!this.prerelease.length && other.prerelease.length) {
	      return 1
	    } else if (!this.prerelease.length && !other.prerelease.length) {
	      return 0
	    }

	    let i = 0;
	    do {
	      const a = this.prerelease[i];
	      const b = other.prerelease[i];
	      debug('prerelease compare', i, a, b);
	      if (a === undefined && b === undefined) {
	        return 0
	      } else if (b === undefined) {
	        return 1
	      } else if (a === undefined) {
	        return -1
	      } else if (a === b) {
	        continue
	      } else {
	        return compareIdentifiers(a, b)
	      }
	    } while (++i)
	  }

	  compareBuild (other) {
	    if (!(other instanceof SemVer)) {
	      other = new SemVer(other, this.options);
	    }

	    let i = 0;
	    do {
	      const a = this.build[i];
	      const b = other.build[i];
	      debug('build compare', i, a, b);
	      if (a === undefined && b === undefined) {
	        return 0
	      } else if (b === undefined) {
	        return 1
	      } else if (a === undefined) {
	        return -1
	      } else if (a === b) {
	        continue
	      } else {
	        return compareIdentifiers(a, b)
	      }
	    } while (++i)
	  }

	  // preminor will bump the version up to the next minor release, and immediately
	  // down to pre-release. premajor and prepatch work the same way.
	  inc (release, identifier, identifierBase) {
	    if (release.startsWith('pre')) {
	      if (!identifier && identifierBase === false) {
	        throw new Error('invalid increment argument: identifier is empty')
	      }
	      // Avoid an invalid semver results
	      if (identifier) {
	        const match = `-${identifier}`.match(this.options.loose ? re[t.PRERELEASELOOSE] : re[t.PRERELEASE]);
	        if (!match || match[1] !== identifier) {
	          throw new Error(`invalid identifier: ${identifier}`)
	        }
	      }
	    }

	    switch (release) {
	      case 'premajor':
	        this.prerelease.length = 0;
	        this.patch = 0;
	        this.minor = 0;
	        this.major++;
	        this.inc('pre', identifier, identifierBase);
	        break
	      case 'preminor':
	        this.prerelease.length = 0;
	        this.patch = 0;
	        this.minor++;
	        this.inc('pre', identifier, identifierBase);
	        break
	      case 'prepatch':
	        // If this is already a prerelease, it will bump to the next version
	        // drop any prereleases that might already exist, since they are not
	        // relevant at this point.
	        this.prerelease.length = 0;
	        this.inc('patch', identifier, identifierBase);
	        this.inc('pre', identifier, identifierBase);
	        break
	      // If the input is a non-prerelease version, this acts the same as
	      // prepatch.
	      case 'prerelease':
	        if (this.prerelease.length === 0) {
	          this.inc('patch', identifier, identifierBase);
	        }
	        this.inc('pre', identifier, identifierBase);
	        break
	      case 'release':
	        if (this.prerelease.length === 0) {
	          throw new Error(`version ${this.raw} is not a prerelease`)
	        }
	        this.prerelease.length = 0;
	        break

	      case 'major':
	        // If this is a pre-major version, bump up to the same major version.
	        // Otherwise increment major.
	        // 1.0.0-5 bumps to 1.0.0
	        // 1.1.0 bumps to 2.0.0
	        if (
	          this.minor !== 0 ||
	          this.patch !== 0 ||
	          this.prerelease.length === 0
	        ) {
	          this.major++;
	        }
	        this.minor = 0;
	        this.patch = 0;
	        this.prerelease = [];
	        break
	      case 'minor':
	        // If this is a pre-minor version, bump up to the same minor version.
	        // Otherwise increment minor.
	        // 1.2.0-5 bumps to 1.2.0
	        // 1.2.1 bumps to 1.3.0
	        if (this.patch !== 0 || this.prerelease.length === 0) {
	          this.minor++;
	        }
	        this.patch = 0;
	        this.prerelease = [];
	        break
	      case 'patch':
	        // If this is not a pre-release version, it will increment the patch.
	        // If it is a pre-release it will bump up to the same patch version.
	        // 1.2.0-5 patches to 1.2.0
	        // 1.2.0 patches to 1.2.1
	        if (this.prerelease.length === 0) {
	          this.patch++;
	        }
	        this.prerelease = [];
	        break
	      // This probably shouldn't be used publicly.
	      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
	      case 'pre': {
	        const base = Number(identifierBase) ? 1 : 0;

	        if (this.prerelease.length === 0) {
	          this.prerelease = [base];
	        } else {
	          let i = this.prerelease.length;
	          while (--i >= 0) {
	            if (typeof this.prerelease[i] === 'number') {
	              this.prerelease[i]++;
	              i = -2;
	            }
	          }
	          if (i === -1) {
	            // didn't increment anything
	            if (identifier === this.prerelease.join('.') && identifierBase === false) {
	              throw new Error('invalid increment argument: identifier already exists')
	            }
	            this.prerelease.push(base);
	          }
	        }
	        if (identifier) {
	          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
	          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
	          let prerelease = [identifier, base];
	          if (identifierBase === false) {
	            prerelease = [identifier];
	          }
	          if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
	            if (isNaN(this.prerelease[1])) {
	              this.prerelease = prerelease;
	            }
	          } else {
	            this.prerelease = prerelease;
	          }
	        }
	        break
	      }
	      default:
	        throw new Error(`invalid increment argument: ${release}`)
	    }
	    this.raw = this.format();
	    if (this.build.length) {
	      this.raw += `+${this.build.join('.')}`;
	    }
	    return this
	  }
	}

	semver$1 = SemVer;
	return semver$1;
}

var parse_1$1;
var hasRequiredParse$1;

function requireParse$1 () {
	if (hasRequiredParse$1) return parse_1$1;
	hasRequiredParse$1 = 1;

	const SemVer = requireSemver$1();
	const parse = (version, options, throwErrors = false) => {
	  if (version instanceof SemVer) {
	    return version
	  }
	  try {
	    return new SemVer(version, options)
	  } catch (er) {
	    if (!throwErrors) {
	      return null
	    }
	    throw er
	  }
	};

	parse_1$1 = parse;
	return parse_1$1;
}

var valid_1;
var hasRequiredValid$1;

function requireValid$1 () {
	if (hasRequiredValid$1) return valid_1;
	hasRequiredValid$1 = 1;

	const parse = requireParse$1();
	const valid = (version, options) => {
	  const v = parse(version, options);
	  return v ? v.version : null
	};
	valid_1 = valid;
	return valid_1;
}

var clean_1;
var hasRequiredClean;

function requireClean () {
	if (hasRequiredClean) return clean_1;
	hasRequiredClean = 1;

	const parse = requireParse$1();
	const clean = (version, options) => {
	  const s = parse(version.trim().replace(/^[=v]+/, ''), options);
	  return s ? s.version : null
	};
	clean_1 = clean;
	return clean_1;
}

var inc_1;
var hasRequiredInc;

function requireInc () {
	if (hasRequiredInc) return inc_1;
	hasRequiredInc = 1;

	const SemVer = requireSemver$1();

	const inc = (version, release, options, identifier, identifierBase) => {
	  if (typeof (options) === 'string') {
	    identifierBase = identifier;
	    identifier = options;
	    options = undefined;
	  }

	  try {
	    return new SemVer(
	      version instanceof SemVer ? version.version : version,
	      options
	    ).inc(release, identifier, identifierBase).version
	  } catch (er) {
	    return null
	  }
	};
	inc_1 = inc;
	return inc_1;
}

var diff_1;
var hasRequiredDiff;

function requireDiff () {
	if (hasRequiredDiff) return diff_1;
	hasRequiredDiff = 1;

	const parse = requireParse$1();

	const diff = (version1, version2) => {
	  const v1 = parse(version1, null, true);
	  const v2 = parse(version2, null, true);
	  const comparison = v1.compare(v2);

	  if (comparison === 0) {
	    return null
	  }

	  const v1Higher = comparison > 0;
	  const highVersion = v1Higher ? v1 : v2;
	  const lowVersion = v1Higher ? v2 : v1;
	  const highHasPre = !!highVersion.prerelease.length;
	  const lowHasPre = !!lowVersion.prerelease.length;

	  if (lowHasPre && !highHasPre) {
	    // Going from prerelease -> no prerelease requires some special casing

	    // If the low version has only a major, then it will always be a major
	    // Some examples:
	    // 1.0.0-1 -> 1.0.0
	    // 1.0.0-1 -> 1.1.1
	    // 1.0.0-1 -> 2.0.0
	    if (!lowVersion.patch && !lowVersion.minor) {
	      return 'major'
	    }

	    // If the main part has no difference
	    if (lowVersion.compareMain(highVersion) === 0) {
	      if (lowVersion.minor && !lowVersion.patch) {
	        return 'minor'
	      }
	      return 'patch'
	    }
	  }

	  // add the `pre` prefix if we are going to a prerelease version
	  const prefix = highHasPre ? 'pre' : '';

	  if (v1.major !== v2.major) {
	    return prefix + 'major'
	  }

	  if (v1.minor !== v2.minor) {
	    return prefix + 'minor'
	  }

	  if (v1.patch !== v2.patch) {
	    return prefix + 'patch'
	  }

	  // high and low are preleases
	  return 'prerelease'
	};

	diff_1 = diff;
	return diff_1;
}

var major_1;
var hasRequiredMajor;

function requireMajor () {
	if (hasRequiredMajor) return major_1;
	hasRequiredMajor = 1;

	const SemVer = requireSemver$1();
	const major = (a, loose) => new SemVer(a, loose).major;
	major_1 = major;
	return major_1;
}

var minor_1;
var hasRequiredMinor;

function requireMinor () {
	if (hasRequiredMinor) return minor_1;
	hasRequiredMinor = 1;

	const SemVer = requireSemver$1();
	const minor = (a, loose) => new SemVer(a, loose).minor;
	minor_1 = minor;
	return minor_1;
}

var patch_1;
var hasRequiredPatch;

function requirePatch () {
	if (hasRequiredPatch) return patch_1;
	hasRequiredPatch = 1;

	const SemVer = requireSemver$1();
	const patch = (a, loose) => new SemVer(a, loose).patch;
	patch_1 = patch;
	return patch_1;
}

var prerelease_1;
var hasRequiredPrerelease;

function requirePrerelease () {
	if (hasRequiredPrerelease) return prerelease_1;
	hasRequiredPrerelease = 1;

	const parse = requireParse$1();
	const prerelease = (version, options) => {
	  const parsed = parse(version, options);
	  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
	};
	prerelease_1 = prerelease;
	return prerelease_1;
}

var compare_1;
var hasRequiredCompare;

function requireCompare () {
	if (hasRequiredCompare) return compare_1;
	hasRequiredCompare = 1;

	const SemVer = requireSemver$1();
	const compare = (a, b, loose) =>
	  new SemVer(a, loose).compare(new SemVer(b, loose));

	compare_1 = compare;
	return compare_1;
}

var rcompare_1;
var hasRequiredRcompare;

function requireRcompare () {
	if (hasRequiredRcompare) return rcompare_1;
	hasRequiredRcompare = 1;

	const compare = requireCompare();
	const rcompare = (a, b, loose) => compare(b, a, loose);
	rcompare_1 = rcompare;
	return rcompare_1;
}

var compareLoose_1;
var hasRequiredCompareLoose;

function requireCompareLoose () {
	if (hasRequiredCompareLoose) return compareLoose_1;
	hasRequiredCompareLoose = 1;

	const compare = requireCompare();
	const compareLoose = (a, b) => compare(a, b, true);
	compareLoose_1 = compareLoose;
	return compareLoose_1;
}

var compareBuild_1;
var hasRequiredCompareBuild;

function requireCompareBuild () {
	if (hasRequiredCompareBuild) return compareBuild_1;
	hasRequiredCompareBuild = 1;

	const SemVer = requireSemver$1();
	const compareBuild = (a, b, loose) => {
	  const versionA = new SemVer(a, loose);
	  const versionB = new SemVer(b, loose);
	  return versionA.compare(versionB) || versionA.compareBuild(versionB)
	};
	compareBuild_1 = compareBuild;
	return compareBuild_1;
}

var sort_1;
var hasRequiredSort;

function requireSort () {
	if (hasRequiredSort) return sort_1;
	hasRequiredSort = 1;

	const compareBuild = requireCompareBuild();
	const sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
	sort_1 = sort;
	return sort_1;
}

var rsort_1;
var hasRequiredRsort;

function requireRsort () {
	if (hasRequiredRsort) return rsort_1;
	hasRequiredRsort = 1;

	const compareBuild = requireCompareBuild();
	const rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
	rsort_1 = rsort;
	return rsort_1;
}

var gt_1;
var hasRequiredGt;

function requireGt () {
	if (hasRequiredGt) return gt_1;
	hasRequiredGt = 1;

	const compare = requireCompare();
	const gt = (a, b, loose) => compare(a, b, loose) > 0;
	gt_1 = gt;
	return gt_1;
}

var lt_1;
var hasRequiredLt;

function requireLt () {
	if (hasRequiredLt) return lt_1;
	hasRequiredLt = 1;

	const compare = requireCompare();
	const lt = (a, b, loose) => compare(a, b, loose) < 0;
	lt_1 = lt;
	return lt_1;
}

var eq_1;
var hasRequiredEq;

function requireEq () {
	if (hasRequiredEq) return eq_1;
	hasRequiredEq = 1;

	const compare = requireCompare();
	const eq = (a, b, loose) => compare(a, b, loose) === 0;
	eq_1 = eq;
	return eq_1;
}

var neq_1;
var hasRequiredNeq;

function requireNeq () {
	if (hasRequiredNeq) return neq_1;
	hasRequiredNeq = 1;

	const compare = requireCompare();
	const neq = (a, b, loose) => compare(a, b, loose) !== 0;
	neq_1 = neq;
	return neq_1;
}

var gte_1;
var hasRequiredGte;

function requireGte () {
	if (hasRequiredGte) return gte_1;
	hasRequiredGte = 1;

	const compare = requireCompare();
	const gte = (a, b, loose) => compare(a, b, loose) >= 0;
	gte_1 = gte;
	return gte_1;
}

var lte_1;
var hasRequiredLte;

function requireLte () {
	if (hasRequiredLte) return lte_1;
	hasRequiredLte = 1;

	const compare = requireCompare();
	const lte = (a, b, loose) => compare(a, b, loose) <= 0;
	lte_1 = lte;
	return lte_1;
}

var cmp_1;
var hasRequiredCmp;

function requireCmp () {
	if (hasRequiredCmp) return cmp_1;
	hasRequiredCmp = 1;

	const eq = requireEq();
	const neq = requireNeq();
	const gt = requireGt();
	const gte = requireGte();
	const lt = requireLt();
	const lte = requireLte();

	const cmp = (a, op, b, loose) => {
	  switch (op) {
	    case '===':
	      if (typeof a === 'object') {
	        a = a.version;
	      }
	      if (typeof b === 'object') {
	        b = b.version;
	      }
	      return a === b

	    case '!==':
	      if (typeof a === 'object') {
	        a = a.version;
	      }
	      if (typeof b === 'object') {
	        b = b.version;
	      }
	      return a !== b

	    case '':
	    case '=':
	    case '==':
	      return eq(a, b, loose)

	    case '!=':
	      return neq(a, b, loose)

	    case '>':
	      return gt(a, b, loose)

	    case '>=':
	      return gte(a, b, loose)

	    case '<':
	      return lt(a, b, loose)

	    case '<=':
	      return lte(a, b, loose)

	    default:
	      throw new TypeError(`Invalid operator: ${op}`)
	  }
	};
	cmp_1 = cmp;
	return cmp_1;
}

var coerce_1;
var hasRequiredCoerce;

function requireCoerce () {
	if (hasRequiredCoerce) return coerce_1;
	hasRequiredCoerce = 1;

	const SemVer = requireSemver$1();
	const parse = requireParse$1();
	const { safeRe: re, t } = requireRe();

	const coerce = (version, options) => {
	  if (version instanceof SemVer) {
	    return version
	  }

	  if (typeof version === 'number') {
	    version = String(version);
	  }

	  if (typeof version !== 'string') {
	    return null
	  }

	  options = options || {};

	  let match = null;
	  if (!options.rtl) {
	    match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
	  } else {
	    // Find the right-most coercible string that does not share
	    // a terminus with a more left-ward coercible string.
	    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
	    // With includePrerelease option set, '1.2.3.4-rc' wants to coerce '2.3.4-rc', not '2.3.4'
	    //
	    // Walk through the string checking with a /g regexp
	    // Manually set the index so as to pick up overlapping matches.
	    // Stop when we get a match that ends at the string end, since no
	    // coercible string can be more right-ward without the same terminus.
	    const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
	    let next;
	    while ((next = coerceRtlRegex.exec(version)) &&
	        (!match || match.index + match[0].length !== version.length)
	    ) {
	      if (!match ||
	            next.index + next[0].length !== match.index + match[0].length) {
	        match = next;
	      }
	      coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
	    }
	    // leave it in a clean state
	    coerceRtlRegex.lastIndex = -1;
	  }

	  if (match === null) {
	    return null
	  }

	  const major = match[2];
	  const minor = match[3] || '0';
	  const patch = match[4] || '0';
	  const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : '';
	  const build = options.includePrerelease && match[6] ? `+${match[6]}` : '';

	  return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options)
	};
	coerce_1 = coerce;
	return coerce_1;
}

var lrucache;
var hasRequiredLrucache;

function requireLrucache () {
	if (hasRequiredLrucache) return lrucache;
	hasRequiredLrucache = 1;

	class LRUCache {
	  constructor () {
	    this.max = 1000;
	    this.map = new Map();
	  }

	  get (key) {
	    const value = this.map.get(key);
	    if (value === undefined) {
	      return undefined
	    } else {
	      // Remove the key from the map and add it to the end
	      this.map.delete(key);
	      this.map.set(key, value);
	      return value
	    }
	  }

	  delete (key) {
	    return this.map.delete(key)
	  }

	  set (key, value) {
	    const deleted = this.delete(key);

	    if (!deleted && value !== undefined) {
	      // If cache is full, delete the least recently used item
	      if (this.map.size >= this.max) {
	        const firstKey = this.map.keys().next().value;
	        this.delete(firstKey);
	      }

	      this.map.set(key, value);
	    }

	    return this
	  }
	}

	lrucache = LRUCache;
	return lrucache;
}

var range;
var hasRequiredRange;

function requireRange () {
	if (hasRequiredRange) return range;
	hasRequiredRange = 1;

	const SPACE_CHARACTERS = /\s+/g;

	// hoisted class for cyclic dependency
	class Range {
	  constructor (range, options) {
	    options = parseOptions(options);

	    if (range instanceof Range) {
	      if (
	        range.loose === !!options.loose &&
	        range.includePrerelease === !!options.includePrerelease
	      ) {
	        return range
	      } else {
	        return new Range(range.raw, options)
	      }
	    }

	    if (range instanceof Comparator) {
	      // just put it in the set and return
	      this.raw = range.value;
	      this.set = [[range]];
	      this.formatted = undefined;
	      return this
	    }

	    this.options = options;
	    this.loose = !!options.loose;
	    this.includePrerelease = !!options.includePrerelease;

	    // First reduce all whitespace as much as possible so we do not have to rely
	    // on potentially slow regexes like \s*. This is then stored and used for
	    // future error messages as well.
	    this.raw = range.trim().replace(SPACE_CHARACTERS, ' ');

	    // First, split on ||
	    this.set = this.raw
	      .split('||')
	      // map the range to a 2d array of comparators
	      .map(r => this.parseRange(r.trim()))
	      // throw out any comparator lists that are empty
	      // this generally means that it was not a valid range, which is allowed
	      // in loose mode, but will still throw if the WHOLE range is invalid.
	      .filter(c => c.length);

	    if (!this.set.length) {
	      throw new TypeError(`Invalid SemVer Range: ${this.raw}`)
	    }

	    // if we have any that are not the null set, throw out null sets.
	    if (this.set.length > 1) {
	      // keep the first one, in case they're all null sets
	      const first = this.set[0];
	      this.set = this.set.filter(c => !isNullSet(c[0]));
	      if (this.set.length === 0) {
	        this.set = [first];
	      } else if (this.set.length > 1) {
	        // if we have any that are *, then the range is just *
	        for (const c of this.set) {
	          if (c.length === 1 && isAny(c[0])) {
	            this.set = [c];
	            break
	          }
	        }
	      }
	    }

	    this.formatted = undefined;
	  }

	  get range () {
	    if (this.formatted === undefined) {
	      this.formatted = '';
	      for (let i = 0; i < this.set.length; i++) {
	        if (i > 0) {
	          this.formatted += '||';
	        }
	        const comps = this.set[i];
	        for (let k = 0; k < comps.length; k++) {
	          if (k > 0) {
	            this.formatted += ' ';
	          }
	          this.formatted += comps[k].toString().trim();
	        }
	      }
	    }
	    return this.formatted
	  }

	  format () {
	    return this.range
	  }

	  toString () {
	    return this.range
	  }

	  parseRange (range) {
	    // memoize range parsing for performance.
	    // this is a very hot path, and fully deterministic.
	    const memoOpts =
	      (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) |
	      (this.options.loose && FLAG_LOOSE);
	    const memoKey = memoOpts + ':' + range;
	    const cached = cache.get(memoKey);
	    if (cached) {
	      return cached
	    }

	    const loose = this.options.loose;
	    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
	    const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
	    range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
	    debug('hyphen replace', range);

	    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
	    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
	    debug('comparator trim', range);

	    // `~ 1.2.3` => `~1.2.3`
	    range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
	    debug('tilde trim', range);

	    // `^ 1.2.3` => `^1.2.3`
	    range = range.replace(re[t.CARETTRIM], caretTrimReplace);
	    debug('caret trim', range);

	    // At this point, the range is completely trimmed and
	    // ready to be split into comparators.

	    let rangeList = range
	      .split(' ')
	      .map(comp => parseComparator(comp, this.options))
	      .join(' ')
	      .split(/\s+/)
	      // >=0.0.0 is equivalent to *
	      .map(comp => replaceGTE0(comp, this.options));

	    if (loose) {
	      // in loose mode, throw out any that are not valid comparators
	      rangeList = rangeList.filter(comp => {
	        debug('loose invalid filter', comp, this.options);
	        return !!comp.match(re[t.COMPARATORLOOSE])
	      });
	    }
	    debug('range list', rangeList);

	    // if any comparators are the null set, then replace with JUST null set
	    // if more than one comparator, remove any * comparators
	    // also, don't include the same comparator more than once
	    const rangeMap = new Map();
	    const comparators = rangeList.map(comp => new Comparator(comp, this.options));
	    for (const comp of comparators) {
	      if (isNullSet(comp)) {
	        return [comp]
	      }
	      rangeMap.set(comp.value, comp);
	    }
	    if (rangeMap.size > 1 && rangeMap.has('')) {
	      rangeMap.delete('');
	    }

	    const result = [...rangeMap.values()];
	    cache.set(memoKey, result);
	    return result
	  }

	  intersects (range, options) {
	    if (!(range instanceof Range)) {
	      throw new TypeError('a Range is required')
	    }

	    return this.set.some((thisComparators) => {
	      return (
	        isSatisfiable(thisComparators, options) &&
	        range.set.some((rangeComparators) => {
	          return (
	            isSatisfiable(rangeComparators, options) &&
	            thisComparators.every((thisComparator) => {
	              return rangeComparators.every((rangeComparator) => {
	                return thisComparator.intersects(rangeComparator, options)
	              })
	            })
	          )
	        })
	      )
	    })
	  }

	  // if ANY of the sets match ALL of its comparators, then pass
	  test (version) {
	    if (!version) {
	      return false
	    }

	    if (typeof version === 'string') {
	      try {
	        version = new SemVer(version, this.options);
	      } catch (er) {
	        return false
	      }
	    }

	    for (let i = 0; i < this.set.length; i++) {
	      if (testSet(this.set[i], version, this.options)) {
	        return true
	      }
	    }
	    return false
	  }
	}

	range = Range;

	const LRU = requireLrucache();
	const cache = new LRU();

	const parseOptions = requireParseOptions();
	const Comparator = requireComparator();
	const debug = requireDebug();
	const SemVer = requireSemver$1();
	const {
	  safeRe: re,
	  t,
	  comparatorTrimReplace,
	  tildeTrimReplace,
	  caretTrimReplace,
	} = requireRe();
	const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = requireConstants();

	const isNullSet = c => c.value === '<0.0.0-0';
	const isAny = c => c.value === '';

	// take a set of comparators and determine whether there
	// exists a version which can satisfy it
	const isSatisfiable = (comparators, options) => {
	  let result = true;
	  const remainingComparators = comparators.slice();
	  let testComparator = remainingComparators.pop();

	  while (result && remainingComparators.length) {
	    result = remainingComparators.every((otherComparator) => {
	      return testComparator.intersects(otherComparator, options)
	    });

	    testComparator = remainingComparators.pop();
	  }

	  return result
	};

	// comprised of xranges, tildes, stars, and gtlt's at this point.
	// already replaced the hyphen ranges
	// turn into a set of JUST comparators.
	const parseComparator = (comp, options) => {
	  debug('comp', comp, options);
	  comp = replaceCarets(comp, options);
	  debug('caret', comp);
	  comp = replaceTildes(comp, options);
	  debug('tildes', comp);
	  comp = replaceXRanges(comp, options);
	  debug('xrange', comp);
	  comp = replaceStars(comp, options);
	  debug('stars', comp);
	  return comp
	};

	const isX = id => !id || id.toLowerCase() === 'x' || id === '*';

	// ~, ~> --> * (any, kinda silly)
	// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0
	// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0
	// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0
	// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0
	// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0
	// ~0.0.1 --> >=0.0.1 <0.1.0-0
	const replaceTildes = (comp, options) => {
	  return comp
	    .trim()
	    .split(/\s+/)
	    .map((c) => replaceTilde(c, options))
	    .join(' ')
	};

	const replaceTilde = (comp, options) => {
	  const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
	  return comp.replace(r, (_, M, m, p, pr) => {
	    debug('tilde', comp, _, M, m, p, pr);
	    let ret;

	    if (isX(M)) {
	      ret = '';
	    } else if (isX(m)) {
	      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
	    } else if (isX(p)) {
	      // ~1.2 == >=1.2.0 <1.3.0-0
	      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
	    } else if (pr) {
	      debug('replaceTilde pr', pr);
	      ret = `>=${M}.${m}.${p}-${pr
	      } <${M}.${+m + 1}.0-0`;
	    } else {
	      // ~1.2.3 == >=1.2.3 <1.3.0-0
	      ret = `>=${M}.${m}.${p
	      } <${M}.${+m + 1}.0-0`;
	    }

	    debug('tilde return', ret);
	    return ret
	  })
	};

	// ^ --> * (any, kinda silly)
	// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0
	// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0
	// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0
	// ^1.2.3 --> >=1.2.3 <2.0.0-0
	// ^1.2.0 --> >=1.2.0 <2.0.0-0
	// ^0.0.1 --> >=0.0.1 <0.0.2-0
	// ^0.1.0 --> >=0.1.0 <0.2.0-0
	const replaceCarets = (comp, options) => {
	  return comp
	    .trim()
	    .split(/\s+/)
	    .map((c) => replaceCaret(c, options))
	    .join(' ')
	};

	const replaceCaret = (comp, options) => {
	  debug('caret', comp, options);
	  const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
	  const z = options.includePrerelease ? '-0' : '';
	  return comp.replace(r, (_, M, m, p, pr) => {
	    debug('caret', comp, _, M, m, p, pr);
	    let ret;

	    if (isX(M)) {
	      ret = '';
	    } else if (isX(m)) {
	      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
	    } else if (isX(p)) {
	      if (M === '0') {
	        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
	      } else {
	        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
	      }
	    } else if (pr) {
	      debug('replaceCaret pr', pr);
	      if (M === '0') {
	        if (m === '0') {
	          ret = `>=${M}.${m}.${p}-${pr
	          } <${M}.${m}.${+p + 1}-0`;
	        } else {
	          ret = `>=${M}.${m}.${p}-${pr
	          } <${M}.${+m + 1}.0-0`;
	        }
	      } else {
	        ret = `>=${M}.${m}.${p}-${pr
	        } <${+M + 1}.0.0-0`;
	      }
	    } else {
	      debug('no pr');
	      if (M === '0') {
	        if (m === '0') {
	          ret = `>=${M}.${m}.${p
	          }${z} <${M}.${m}.${+p + 1}-0`;
	        } else {
	          ret = `>=${M}.${m}.${p
	          }${z} <${M}.${+m + 1}.0-0`;
	        }
	      } else {
	        ret = `>=${M}.${m}.${p
	        } <${+M + 1}.0.0-0`;
	      }
	    }

	    debug('caret return', ret);
	    return ret
	  })
	};

	const replaceXRanges = (comp, options) => {
	  debug('replaceXRanges', comp, options);
	  return comp
	    .split(/\s+/)
	    .map((c) => replaceXRange(c, options))
	    .join(' ')
	};

	const replaceXRange = (comp, options) => {
	  comp = comp.trim();
	  const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
	  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
	    debug('xRange', comp, ret, gtlt, M, m, p, pr);
	    const xM = isX(M);
	    const xm = xM || isX(m);
	    const xp = xm || isX(p);
	    const anyX = xp;

	    if (gtlt === '=' && anyX) {
	      gtlt = '';
	    }

	    // if we're including prereleases in the match, then we need
	    // to fix this to -0, the lowest possible prerelease value
	    pr = options.includePrerelease ? '-0' : '';

	    if (xM) {
	      if (gtlt === '>' || gtlt === '<') {
	        // nothing is allowed
	        ret = '<0.0.0-0';
	      } else {
	        // nothing is forbidden
	        ret = '*';
	      }
	    } else if (gtlt && anyX) {
	      // we know patch is an x, because we have any x at all.
	      // replace X with 0
	      if (xm) {
	        m = 0;
	      }
	      p = 0;

	      if (gtlt === '>') {
	        // >1 => >=2.0.0
	        // >1.2 => >=1.3.0
	        gtlt = '>=';
	        if (xm) {
	          M = +M + 1;
	          m = 0;
	          p = 0;
	        } else {
	          m = +m + 1;
	          p = 0;
	        }
	      } else if (gtlt === '<=') {
	        // <=0.7.x is actually <0.8.0, since any 0.7.x should
	        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
	        gtlt = '<';
	        if (xm) {
	          M = +M + 1;
	        } else {
	          m = +m + 1;
	        }
	      }

	      if (gtlt === '<') {
	        pr = '-0';
	      }

	      ret = `${gtlt + M}.${m}.${p}${pr}`;
	    } else if (xm) {
	      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
	    } else if (xp) {
	      ret = `>=${M}.${m}.0${pr
	      } <${M}.${+m + 1}.0-0`;
	    }

	    debug('xRange return', ret);

	    return ret
	  })
	};

	// Because * is AND-ed with everything else in the comparator,
	// and '' means "any version", just remove the *s entirely.
	const replaceStars = (comp, options) => {
	  debug('replaceStars', comp, options);
	  // Looseness is ignored here.  star is always as loose as it gets!
	  return comp
	    .trim()
	    .replace(re[t.STAR], '')
	};

	const replaceGTE0 = (comp, options) => {
	  debug('replaceGTE0', comp, options);
	  return comp
	    .trim()
	    .replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '')
	};

	// This function is passed to string.replace(re[t.HYPHENRANGE])
	// M, m, patch, prerelease, build
	// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
	// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do
	// 1.2 - 3.4 => >=1.2.0 <3.5.0-0
	// TODO build?
	const hyphenReplace = incPr => ($0,
	  from, fM, fm, fp, fpr, fb,
	  to, tM, tm, tp, tpr) => {
	  if (isX(fM)) {
	    from = '';
	  } else if (isX(fm)) {
	    from = `>=${fM}.0.0${incPr ? '-0' : ''}`;
	  } else if (isX(fp)) {
	    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`;
	  } else if (fpr) {
	    from = `>=${from}`;
	  } else {
	    from = `>=${from}${incPr ? '-0' : ''}`;
	  }

	  if (isX(tM)) {
	    to = '';
	  } else if (isX(tm)) {
	    to = `<${+tM + 1}.0.0-0`;
	  } else if (isX(tp)) {
	    to = `<${tM}.${+tm + 1}.0-0`;
	  } else if (tpr) {
	    to = `<=${tM}.${tm}.${tp}-${tpr}`;
	  } else if (incPr) {
	    to = `<${tM}.${tm}.${+tp + 1}-0`;
	  } else {
	    to = `<=${to}`;
	  }

	  return `${from} ${to}`.trim()
	};

	const testSet = (set, version, options) => {
	  for (let i = 0; i < set.length; i++) {
	    if (!set[i].test(version)) {
	      return false
	    }
	  }

	  if (version.prerelease.length && !options.includePrerelease) {
	    // Find the set of versions that are allowed to have prereleases
	    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
	    // That should allow `1.2.3-pr.2` to pass.
	    // However, `1.2.4-alpha.notready` should NOT be allowed,
	    // even though it's within the range set by the comparators.
	    for (let i = 0; i < set.length; i++) {
	      debug(set[i].semver);
	      if (set[i].semver === Comparator.ANY) {
	        continue
	      }

	      if (set[i].semver.prerelease.length > 0) {
	        const allowed = set[i].semver;
	        if (allowed.major === version.major &&
	            allowed.minor === version.minor &&
	            allowed.patch === version.patch) {
	          return true
	        }
	      }
	    }

	    // Version has a -pre, but it's not one of the ones we like.
	    return false
	  }

	  return true
	};
	return range;
}

var comparator;
var hasRequiredComparator;

function requireComparator () {
	if (hasRequiredComparator) return comparator;
	hasRequiredComparator = 1;

	const ANY = Symbol('SemVer ANY');
	// hoisted class for cyclic dependency
	class Comparator {
	  static get ANY () {
	    return ANY
	  }

	  constructor (comp, options) {
	    options = parseOptions(options);

	    if (comp instanceof Comparator) {
	      if (comp.loose === !!options.loose) {
	        return comp
	      } else {
	        comp = comp.value;
	      }
	    }

	    comp = comp.trim().split(/\s+/).join(' ');
	    debug('comparator', comp, options);
	    this.options = options;
	    this.loose = !!options.loose;
	    this.parse(comp);

	    if (this.semver === ANY) {
	      this.value = '';
	    } else {
	      this.value = this.operator + this.semver.version;
	    }

	    debug('comp', this);
	  }

	  parse (comp) {
	    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
	    const m = comp.match(r);

	    if (!m) {
	      throw new TypeError(`Invalid comparator: ${comp}`)
	    }

	    this.operator = m[1] !== undefined ? m[1] : '';
	    if (this.operator === '=') {
	      this.operator = '';
	    }

	    // if it literally is just '>' or '' then allow anything.
	    if (!m[2]) {
	      this.semver = ANY;
	    } else {
	      this.semver = new SemVer(m[2], this.options.loose);
	    }
	  }

	  toString () {
	    return this.value
	  }

	  test (version) {
	    debug('Comparator.test', version, this.options.loose);

	    if (this.semver === ANY || version === ANY) {
	      return true
	    }

	    if (typeof version === 'string') {
	      try {
	        version = new SemVer(version, this.options);
	      } catch (er) {
	        return false
	      }
	    }

	    return cmp(version, this.operator, this.semver, this.options)
	  }

	  intersects (comp, options) {
	    if (!(comp instanceof Comparator)) {
	      throw new TypeError('a Comparator is required')
	    }

	    if (this.operator === '') {
	      if (this.value === '') {
	        return true
	      }
	      return new Range(comp.value, options).test(this.value)
	    } else if (comp.operator === '') {
	      if (comp.value === '') {
	        return true
	      }
	      return new Range(this.value, options).test(comp.semver)
	    }

	    options = parseOptions(options);

	    // Special cases where nothing can possibly be lower
	    if (options.includePrerelease &&
	      (this.value === '<0.0.0-0' || comp.value === '<0.0.0-0')) {
	      return false
	    }
	    if (!options.includePrerelease &&
	      (this.value.startsWith('<0.0.0') || comp.value.startsWith('<0.0.0'))) {
	      return false
	    }

	    // Same direction increasing (> or >=)
	    if (this.operator.startsWith('>') && comp.operator.startsWith('>')) {
	      return true
	    }
	    // Same direction decreasing (< or <=)
	    if (this.operator.startsWith('<') && comp.operator.startsWith('<')) {
	      return true
	    }
	    // same SemVer and both sides are inclusive (<= or >=)
	    if (
	      (this.semver.version === comp.semver.version) &&
	      this.operator.includes('=') && comp.operator.includes('=')) {
	      return true
	    }
	    // opposite directions less than
	    if (cmp(this.semver, '<', comp.semver, options) &&
	      this.operator.startsWith('>') && comp.operator.startsWith('<')) {
	      return true
	    }
	    // opposite directions greater than
	    if (cmp(this.semver, '>', comp.semver, options) &&
	      this.operator.startsWith('<') && comp.operator.startsWith('>')) {
	      return true
	    }
	    return false
	  }
	}

	comparator = Comparator;

	const parseOptions = requireParseOptions();
	const { safeRe: re, t } = requireRe();
	const cmp = requireCmp();
	const debug = requireDebug();
	const SemVer = requireSemver$1();
	const Range = requireRange();
	return comparator;
}

var satisfies_1;
var hasRequiredSatisfies;

function requireSatisfies () {
	if (hasRequiredSatisfies) return satisfies_1;
	hasRequiredSatisfies = 1;

	const Range = requireRange();
	const satisfies = (version, range, options) => {
	  try {
	    range = new Range(range, options);
	  } catch (er) {
	    return false
	  }
	  return range.test(version)
	};
	satisfies_1 = satisfies;
	return satisfies_1;
}

var toComparators_1;
var hasRequiredToComparators;

function requireToComparators () {
	if (hasRequiredToComparators) return toComparators_1;
	hasRequiredToComparators = 1;

	const Range = requireRange();

	// Mostly just for testing and legacy API reasons
	const toComparators = (range, options) =>
	  new Range(range, options).set
	    .map(comp => comp.map(c => c.value).join(' ').trim().split(' '));

	toComparators_1 = toComparators;
	return toComparators_1;
}

var maxSatisfying_1;
var hasRequiredMaxSatisfying;

function requireMaxSatisfying () {
	if (hasRequiredMaxSatisfying) return maxSatisfying_1;
	hasRequiredMaxSatisfying = 1;

	const SemVer = requireSemver$1();
	const Range = requireRange();

	const maxSatisfying = (versions, range, options) => {
	  let max = null;
	  let maxSV = null;
	  let rangeObj = null;
	  try {
	    rangeObj = new Range(range, options);
	  } catch (er) {
	    return null
	  }
	  versions.forEach((v) => {
	    if (rangeObj.test(v)) {
	      // satisfies(v, range, options)
	      if (!max || maxSV.compare(v) === -1) {
	        // compare(max, v, true)
	        max = v;
	        maxSV = new SemVer(max, options);
	      }
	    }
	  });
	  return max
	};
	maxSatisfying_1 = maxSatisfying;
	return maxSatisfying_1;
}

var minSatisfying_1;
var hasRequiredMinSatisfying;

function requireMinSatisfying () {
	if (hasRequiredMinSatisfying) return minSatisfying_1;
	hasRequiredMinSatisfying = 1;

	const SemVer = requireSemver$1();
	const Range = requireRange();
	const minSatisfying = (versions, range, options) => {
	  let min = null;
	  let minSV = null;
	  let rangeObj = null;
	  try {
	    rangeObj = new Range(range, options);
	  } catch (er) {
	    return null
	  }
	  versions.forEach((v) => {
	    if (rangeObj.test(v)) {
	      // satisfies(v, range, options)
	      if (!min || minSV.compare(v) === 1) {
	        // compare(min, v, true)
	        min = v;
	        minSV = new SemVer(min, options);
	      }
	    }
	  });
	  return min
	};
	minSatisfying_1 = minSatisfying;
	return minSatisfying_1;
}

var minVersion_1;
var hasRequiredMinVersion;

function requireMinVersion () {
	if (hasRequiredMinVersion) return minVersion_1;
	hasRequiredMinVersion = 1;

	const SemVer = requireSemver$1();
	const Range = requireRange();
	const gt = requireGt();

	const minVersion = (range, loose) => {
	  range = new Range(range, loose);

	  let minver = new SemVer('0.0.0');
	  if (range.test(minver)) {
	    return minver
	  }

	  minver = new SemVer('0.0.0-0');
	  if (range.test(minver)) {
	    return minver
	  }

	  minver = null;
	  for (let i = 0; i < range.set.length; ++i) {
	    const comparators = range.set[i];

	    let setMin = null;
	    comparators.forEach((comparator) => {
	      // Clone to avoid manipulating the comparator's semver object.
	      const compver = new SemVer(comparator.semver.version);
	      switch (comparator.operator) {
	        case '>':
	          if (compver.prerelease.length === 0) {
	            compver.patch++;
	          } else {
	            compver.prerelease.push(0);
	          }
	          compver.raw = compver.format();
	          /* fallthrough */
	        case '':
	        case '>=':
	          if (!setMin || gt(compver, setMin)) {
	            setMin = compver;
	          }
	          break
	        case '<':
	        case '<=':
	          /* Ignore maximum versions */
	          break
	        /* istanbul ignore next */
	        default:
	          throw new Error(`Unexpected operation: ${comparator.operator}`)
	      }
	    });
	    if (setMin && (!minver || gt(minver, setMin))) {
	      minver = setMin;
	    }
	  }

	  if (minver && range.test(minver)) {
	    return minver
	  }

	  return null
	};
	minVersion_1 = minVersion;
	return minVersion_1;
}

var valid;
var hasRequiredValid;

function requireValid () {
	if (hasRequiredValid) return valid;
	hasRequiredValid = 1;

	const Range = requireRange();
	const validRange = (range, options) => {
	  try {
	    // Return '*' instead of '' so that truthiness works.
	    // This will throw if it's invalid anyway
	    return new Range(range, options).range || '*'
	  } catch (er) {
	    return null
	  }
	};
	valid = validRange;
	return valid;
}

var outside_1;
var hasRequiredOutside;

function requireOutside () {
	if (hasRequiredOutside) return outside_1;
	hasRequiredOutside = 1;

	const SemVer = requireSemver$1();
	const Comparator = requireComparator();
	const { ANY } = Comparator;
	const Range = requireRange();
	const satisfies = requireSatisfies();
	const gt = requireGt();
	const lt = requireLt();
	const lte = requireLte();
	const gte = requireGte();

	const outside = (version, range, hilo, options) => {
	  version = new SemVer(version, options);
	  range = new Range(range, options);

	  let gtfn, ltefn, ltfn, comp, ecomp;
	  switch (hilo) {
	    case '>':
	      gtfn = gt;
	      ltefn = lte;
	      ltfn = lt;
	      comp = '>';
	      ecomp = '>=';
	      break
	    case '<':
	      gtfn = lt;
	      ltefn = gte;
	      ltfn = gt;
	      comp = '<';
	      ecomp = '<=';
	      break
	    default:
	      throw new TypeError('Must provide a hilo val of "<" or ">"')
	  }

	  // If it satisfies the range it is not outside
	  if (satisfies(version, range, options)) {
	    return false
	  }

	  // From now on, variable terms are as if we're in "gtr" mode.
	  // but note that everything is flipped for the "ltr" function.

	  for (let i = 0; i < range.set.length; ++i) {
	    const comparators = range.set[i];

	    let high = null;
	    let low = null;

	    comparators.forEach((comparator) => {
	      if (comparator.semver === ANY) {
	        comparator = new Comparator('>=0.0.0');
	      }
	      high = high || comparator;
	      low = low || comparator;
	      if (gtfn(comparator.semver, high.semver, options)) {
	        high = comparator;
	      } else if (ltfn(comparator.semver, low.semver, options)) {
	        low = comparator;
	      }
	    });

	    // If the edge version comparator has a operator then our version
	    // isn't outside it
	    if (high.operator === comp || high.operator === ecomp) {
	      return false
	    }

	    // If the lowest version comparator has an operator and our version
	    // is less than it then it isn't higher than the range
	    if ((!low.operator || low.operator === comp) &&
	        ltefn(version, low.semver)) {
	      return false
	    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
	      return false
	    }
	  }
	  return true
	};

	outside_1 = outside;
	return outside_1;
}

var gtr_1;
var hasRequiredGtr;

function requireGtr () {
	if (hasRequiredGtr) return gtr_1;
	hasRequiredGtr = 1;

	// Determine if version is greater than all the versions possible in the range.
	const outside = requireOutside();
	const gtr = (version, range, options) => outside(version, range, '>', options);
	gtr_1 = gtr;
	return gtr_1;
}

var ltr_1;
var hasRequiredLtr;

function requireLtr () {
	if (hasRequiredLtr) return ltr_1;
	hasRequiredLtr = 1;

	const outside = requireOutside();
	// Determine if version is less than all the versions possible in the range
	const ltr = (version, range, options) => outside(version, range, '<', options);
	ltr_1 = ltr;
	return ltr_1;
}

var intersects_1;
var hasRequiredIntersects;

function requireIntersects () {
	if (hasRequiredIntersects) return intersects_1;
	hasRequiredIntersects = 1;

	const Range = requireRange();
	const intersects = (r1, r2, options) => {
	  r1 = new Range(r1, options);
	  r2 = new Range(r2, options);
	  return r1.intersects(r2, options)
	};
	intersects_1 = intersects;
	return intersects_1;
}

var simplify;
var hasRequiredSimplify;

function requireSimplify () {
	if (hasRequiredSimplify) return simplify;
	hasRequiredSimplify = 1;

	// given a set of versions and a range, create a "simplified" range
	// that includes the same versions that the original range does
	// If the original range is shorter than the simplified one, return that.
	const satisfies = requireSatisfies();
	const compare = requireCompare();
	simplify = (versions, range, options) => {
	  const set = [];
	  let first = null;
	  let prev = null;
	  const v = versions.sort((a, b) => compare(a, b, options));
	  for (const version of v) {
	    const included = satisfies(version, range, options);
	    if (included) {
	      prev = version;
	      if (!first) {
	        first = version;
	      }
	    } else {
	      if (prev) {
	        set.push([first, prev]);
	      }
	      prev = null;
	      first = null;
	    }
	  }
	  if (first) {
	    set.push([first, null]);
	  }

	  const ranges = [];
	  for (const [min, max] of set) {
	    if (min === max) {
	      ranges.push(min);
	    } else if (!max && min === v[0]) {
	      ranges.push('*');
	    } else if (!max) {
	      ranges.push(`>=${min}`);
	    } else if (min === v[0]) {
	      ranges.push(`<=${max}`);
	    } else {
	      ranges.push(`${min} - ${max}`);
	    }
	  }
	  const simplified = ranges.join(' || ');
	  const original = typeof range.raw === 'string' ? range.raw : String(range);
	  return simplified.length < original.length ? simplified : range
	};
	return simplify;
}

var subset_1;
var hasRequiredSubset;

function requireSubset () {
	if (hasRequiredSubset) return subset_1;
	hasRequiredSubset = 1;

	const Range = requireRange();
	const Comparator = requireComparator();
	const { ANY } = Comparator;
	const satisfies = requireSatisfies();
	const compare = requireCompare();

	// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:
	// - Every simple range `r1, r2, ...` is a null set, OR
	// - Every simple range `r1, r2, ...` which is not a null set is a subset of
	//   some `R1, R2, ...`
	//
	// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:
	// - If c is only the ANY comparator
	//   - If C is only the ANY comparator, return true
	//   - Else if in prerelease mode, return false
	//   - else replace c with `[>=0.0.0]`
	// - If C is only the ANY comparator
	//   - if in prerelease mode, return true
	//   - else replace C with `[>=0.0.0]`
	// - Let EQ be the set of = comparators in c
	// - If EQ is more than one, return true (null set)
	// - Let GT be the highest > or >= comparator in c
	// - Let LT be the lowest < or <= comparator in c
	// - If GT and LT, and GT.semver > LT.semver, return true (null set)
	// - If any C is a = range, and GT or LT are set, return false
	// - If EQ
	//   - If GT, and EQ does not satisfy GT, return true (null set)
	//   - If LT, and EQ does not satisfy LT, return true (null set)
	//   - If EQ satisfies every C, return true
	//   - Else return false
	// - If GT
	//   - If GT.semver is lower than any > or >= comp in C, return false
	//   - If GT is >=, and GT.semver does not satisfy every C, return false
	//   - If GT.semver has a prerelease, and not in prerelease mode
	//     - If no C has a prerelease and the GT.semver tuple, return false
	// - If LT
	//   - If LT.semver is greater than any < or <= comp in C, return false
	//   - If LT is <=, and LT.semver does not satisfy every C, return false
	//   - If GT.semver has a prerelease, and not in prerelease mode
	//     - If no C has a prerelease and the LT.semver tuple, return false
	// - Else return true

	const subset = (sub, dom, options = {}) => {
	  if (sub === dom) {
	    return true
	  }

	  sub = new Range(sub, options);
	  dom = new Range(dom, options);
	  let sawNonNull = false;

	  OUTER: for (const simpleSub of sub.set) {
	    for (const simpleDom of dom.set) {
	      const isSub = simpleSubset(simpleSub, simpleDom, options);
	      sawNonNull = sawNonNull || isSub !== null;
	      if (isSub) {
	        continue OUTER
	      }
	    }
	    // the null set is a subset of everything, but null simple ranges in
	    // a complex range should be ignored.  so if we saw a non-null range,
	    // then we know this isn't a subset, but if EVERY simple range was null,
	    // then it is a subset.
	    if (sawNonNull) {
	      return false
	    }
	  }
	  return true
	};

	const minimumVersionWithPreRelease = [new Comparator('>=0.0.0-0')];
	const minimumVersion = [new Comparator('>=0.0.0')];

	const simpleSubset = (sub, dom, options) => {
	  if (sub === dom) {
	    return true
	  }

	  if (sub.length === 1 && sub[0].semver === ANY) {
	    if (dom.length === 1 && dom[0].semver === ANY) {
	      return true
	    } else if (options.includePrerelease) {
	      sub = minimumVersionWithPreRelease;
	    } else {
	      sub = minimumVersion;
	    }
	  }

	  if (dom.length === 1 && dom[0].semver === ANY) {
	    if (options.includePrerelease) {
	      return true
	    } else {
	      dom = minimumVersion;
	    }
	  }

	  const eqSet = new Set();
	  let gt, lt;
	  for (const c of sub) {
	    if (c.operator === '>' || c.operator === '>=') {
	      gt = higherGT(gt, c, options);
	    } else if (c.operator === '<' || c.operator === '<=') {
	      lt = lowerLT(lt, c, options);
	    } else {
	      eqSet.add(c.semver);
	    }
	  }

	  if (eqSet.size > 1) {
	    return null
	  }

	  let gtltComp;
	  if (gt && lt) {
	    gtltComp = compare(gt.semver, lt.semver, options);
	    if (gtltComp > 0) {
	      return null
	    } else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<=')) {
	      return null
	    }
	  }

	  // will iterate one or zero times
	  for (const eq of eqSet) {
	    if (gt && !satisfies(eq, String(gt), options)) {
	      return null
	    }

	    if (lt && !satisfies(eq, String(lt), options)) {
	      return null
	    }

	    for (const c of dom) {
	      if (!satisfies(eq, String(c), options)) {
	        return false
	      }
	    }

	    return true
	  }

	  let higher, lower;
	  let hasDomLT, hasDomGT;
	  // if the subset has a prerelease, we need a comparator in the superset
	  // with the same tuple and a prerelease, or it's not a subset
	  let needDomLTPre = lt &&
	    !options.includePrerelease &&
	    lt.semver.prerelease.length ? lt.semver : false;
	  let needDomGTPre = gt &&
	    !options.includePrerelease &&
	    gt.semver.prerelease.length ? gt.semver : false;
	  // exception: <1.2.3-0 is the same as <1.2.3
	  if (needDomLTPre && needDomLTPre.prerelease.length === 1 &&
	      lt.operator === '<' && needDomLTPre.prerelease[0] === 0) {
	    needDomLTPre = false;
	  }

	  for (const c of dom) {
	    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>=';
	    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<=';
	    if (gt) {
	      if (needDomGTPre) {
	        if (c.semver.prerelease && c.semver.prerelease.length &&
	            c.semver.major === needDomGTPre.major &&
	            c.semver.minor === needDomGTPre.minor &&
	            c.semver.patch === needDomGTPre.patch) {
	          needDomGTPre = false;
	        }
	      }
	      if (c.operator === '>' || c.operator === '>=') {
	        higher = higherGT(gt, c, options);
	        if (higher === c && higher !== gt) {
	          return false
	        }
	      } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options)) {
	        return false
	      }
	    }
	    if (lt) {
	      if (needDomLTPre) {
	        if (c.semver.prerelease && c.semver.prerelease.length &&
	            c.semver.major === needDomLTPre.major &&
	            c.semver.minor === needDomLTPre.minor &&
	            c.semver.patch === needDomLTPre.patch) {
	          needDomLTPre = false;
	        }
	      }
	      if (c.operator === '<' || c.operator === '<=') {
	        lower = lowerLT(lt, c, options);
	        if (lower === c && lower !== lt) {
	          return false
	        }
	      } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options)) {
	        return false
	      }
	    }
	    if (!c.operator && (lt || gt) && gtltComp !== 0) {
	      return false
	    }
	  }

	  // if there was a < or >, and nothing in the dom, then must be false
	  // UNLESS it was limited by another range in the other direction.
	  // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0
	  if (gt && hasDomLT && !lt && gtltComp !== 0) {
	    return false
	  }

	  if (lt && hasDomGT && !gt && gtltComp !== 0) {
	    return false
	  }

	  // we needed a prerelease range in a specific tuple, but didn't get one
	  // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,
	  // because it includes prereleases in the 1.2.3 tuple
	  if (needDomGTPre || needDomLTPre) {
	    return false
	  }

	  return true
	};

	// >=1.2.3 is lower than >1.2.3
	const higherGT = (a, b, options) => {
	  if (!a) {
	    return b
	  }
	  const comp = compare(a.semver, b.semver, options);
	  return comp > 0 ? a
	    : comp < 0 ? b
	    : b.operator === '>' && a.operator === '>=' ? b
	    : a
	};

	// <=1.2.3 is higher than <1.2.3
	const lowerLT = (a, b, options) => {
	  if (!a) {
	    return b
	  }
	  const comp = compare(a.semver, b.semver, options);
	  return comp < 0 ? a
	    : comp > 0 ? b
	    : b.operator === '<' && a.operator === '<=' ? b
	    : a
	};

	subset_1 = subset;
	return subset_1;
}

var semver;
var hasRequiredSemver;

function requireSemver () {
	if (hasRequiredSemver) return semver;
	hasRequiredSemver = 1;

	// just pre-load all the stuff that index.js lazily exports
	const internalRe = requireRe();
	const constants = requireConstants();
	const SemVer = requireSemver$1();
	const identifiers = requireIdentifiers();
	const parse = requireParse$1();
	const valid = requireValid$1();
	const clean = requireClean();
	const inc = requireInc();
	const diff = requireDiff();
	const major = requireMajor();
	const minor = requireMinor();
	const patch = requirePatch();
	const prerelease = requirePrerelease();
	const compare = requireCompare();
	const rcompare = requireRcompare();
	const compareLoose = requireCompareLoose();
	const compareBuild = requireCompareBuild();
	const sort = requireSort();
	const rsort = requireRsort();
	const gt = requireGt();
	const lt = requireLt();
	const eq = requireEq();
	const neq = requireNeq();
	const gte = requireGte();
	const lte = requireLte();
	const cmp = requireCmp();
	const coerce = requireCoerce();
	const Comparator = requireComparator();
	const Range = requireRange();
	const satisfies = requireSatisfies();
	const toComparators = requireToComparators();
	const maxSatisfying = requireMaxSatisfying();
	const minSatisfying = requireMinSatisfying();
	const minVersion = requireMinVersion();
	const validRange = requireValid();
	const outside = requireOutside();
	const gtr = requireGtr();
	const ltr = requireLtr();
	const intersects = requireIntersects();
	const simplifyRange = requireSimplify();
	const subset = requireSubset();
	semver = {
	  parse,
	  valid,
	  clean,
	  inc,
	  diff,
	  major,
	  minor,
	  patch,
	  prerelease,
	  compare,
	  rcompare,
	  compareLoose,
	  compareBuild,
	  sort,
	  rsort,
	  gt,
	  lt,
	  eq,
	  neq,
	  gte,
	  lte,
	  cmp,
	  coerce,
	  Comparator,
	  Range,
	  satisfies,
	  toComparators,
	  maxSatisfying,
	  minSatisfying,
	  minVersion,
	  validRange,
	  outside,
	  gtr,
	  ltr,
	  intersects,
	  simplifyRange,
	  subset,
	  SemVer,
	  re: internalRe.re,
	  src: internalRe.src,
	  tokens: internalRe.t,
	  SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
	  RELEASE_TYPES: constants.RELEASE_TYPES,
	  compareIdentifiers: identifiers.compareIdentifiers,
	  rcompareIdentifiers: identifiers.rcompareIdentifiers,
	};
	return semver;
}

var hasRequiredPluginUtils;

function requirePluginUtils () {
	if (hasRequiredPluginUtils) return pluginUtils.exports;
	hasRequiredPluginUtils = 1;
	(function (module) {

		const semver = requireSemver();
		const assert = require$$0$9;
		const kRegisteredPlugins = Symbol.for('registered-plugin');
		const {
		  kTestInternals
		} = requireSymbols$1();
		const { exist, existReply, existRequest } = requireDecorate();
		const {
		  FST_ERR_PLUGIN_VERSION_MISMATCH,
		  FST_ERR_PLUGIN_NOT_PRESENT_IN_INSTANCE,
		  FST_ERR_PLUGIN_INVALID_ASYNC_HANDLER
		} = requireErrors$2();

		const rcRegex = /-(?:rc|pre|alpha).+$/u;

		function getMeta (fn) {
		  return fn[Symbol.for('plugin-meta')]
		}

		function getPluginName (func) {
		  const display = getDisplayName(func);
		  if (display) {
		    return display
		  }

		  // let's see if this is a file, and in that case use that
		  // this is common for plugins
		  const cache = {};
		  // cache is undefined inside SEA
		  if (cache) {
		    const keys = Object.keys(cache);

		    for (let i = 0; i < keys.length; i++) {
		      const key = keys[i];
		      if (cache[key].exports === func) {
		        return key
		      }
		    }
		  }

		  // if not maybe it's a named function, so use that
		  if (func.name) {
		    return func.name
		  }

		  return null
		}

		function getFuncPreview (func) {
		  // takes the first two lines of the function if nothing else works
		  return func.toString().split('\n', 2).map(s => s.trim()).join(' -- ')
		}

		function getDisplayName (fn) {
		  return fn[Symbol.for('fastify.display-name')]
		}

		function shouldSkipOverride (fn) {
		  return !!fn[Symbol.for('skip-override')]
		}

		function checkDependencies (fn) {
		  const meta = getMeta(fn);
		  if (!meta) return

		  const dependencies = meta.dependencies;
		  if (!dependencies) return
		  assert(Array.isArray(dependencies), 'The dependencies should be an array of strings');

		  dependencies.forEach(dependency => {
		    assert(
		      this[kRegisteredPlugins].indexOf(dependency) > -1,
		      `The dependency '${dependency}' of plugin '${meta.name}' is not registered`
		    );
		  });
		}

		function checkDecorators (fn) {
		  const meta = getMeta(fn);
		  if (!meta) return

		  const { decorators, name } = meta;
		  if (!decorators) return

		  if (decorators.fastify) _checkDecorators(this, 'Fastify', decorators.fastify, name);
		  if (decorators.reply) _checkDecorators(this, 'Reply', decorators.reply, name);
		  if (decorators.request) _checkDecorators(this, 'Request', decorators.request, name);
		}

		const checks = {
		  Fastify: exist,
		  Request: existRequest,
		  Reply: existReply
		};

		function _checkDecorators (that, instance, decorators, name) {
		  assert(Array.isArray(decorators), 'The decorators should be an array of strings');

		  decorators.forEach(decorator => {
		    const withPluginName = typeof name === 'string' ? ` required by '${name}'` : '';
		    if (!checks[instance].call(that, decorator)) {
		      throw new FST_ERR_PLUGIN_NOT_PRESENT_IN_INSTANCE(decorator, withPluginName, instance)
		    }
		  });
		}

		function checkVersion (fn) {
		  const meta = getMeta(fn);
		  if (meta?.fastify == null) return

		  const requiredVersion = meta.fastify;

		  const fastifyRc = rcRegex.test(this.version);
		  if (fastifyRc === true && semver.gt(this.version, semver.coerce(requiredVersion)) === true) {
		    // A Fastify release candidate phase is taking place. In order to reduce
		    // the effort needed to test plugins with the RC, we allow plugins targeting
		    // the prior Fastify release to be loaded.
		    return
		  }
		  if (requiredVersion && semver.satisfies(this.version, requiredVersion, { includePrerelease: fastifyRc }) === false) {
		    // We are not in a release candidate phase. Thus, we must honor the semver
		    // ranges defined by the plugin's metadata. Which is to say, if the plugin
		    // expects an older version of Fastify than the _current_ version, we will
		    // throw an error.
		    throw new FST_ERR_PLUGIN_VERSION_MISMATCH(meta.name, requiredVersion, this.version)
		  }
		}

		function registerPluginName (fn) {
		  const meta = getMeta(fn);
		  if (!meta) return

		  const name = meta.name;
		  if (!name) return
		  this[kRegisteredPlugins].push(name);
		  return name
		}

		function checkPluginHealthiness (fn, pluginName) {
		  if (fn.constructor.name === 'AsyncFunction' && fn.length === 3) {
		    throw new FST_ERR_PLUGIN_INVALID_ASYNC_HANDLER(pluginName)
		  }
		}

		function registerPlugin (fn) {
		  const pluginName = registerPluginName.call(this, fn) || getPluginName(fn);
		  checkPluginHealthiness.call(this, fn, pluginName);
		  checkVersion.call(this, fn);
		  checkDecorators.call(this, fn);
		  checkDependencies.call(this, fn);
		  return shouldSkipOverride(fn)
		}

		module.exports = {
		  getPluginName,
		  getFuncPreview,
		  kRegisteredPlugins,
		  getDisplayName,
		  registerPlugin
		};

		module.exports[kTestInternals] = {
		  shouldSkipOverride,
		  getMeta,
		  checkDecorators,
		  checkDependencies
		}; 
	} (pluginUtils));
	return pluginUtils.exports;
}

var reqIdGenFactory_1;
var hasRequiredReqIdGenFactory;

function requireReqIdGenFactory () {
	if (hasRequiredReqIdGenFactory) return reqIdGenFactory_1;
	hasRequiredReqIdGenFactory = 1;

	/**
	 * @callback GenerateRequestId
	 * @param {Object} req
	 * @returns {string}
	 */

	/**
	 * @param {string} [requestIdHeader]
	 * @param {GenerateRequestId} [optGenReqId]
	 * @returns {GenerateRequestId}
	 */
	function reqIdGenFactory (requestIdHeader, optGenReqId) {
	  const genReqId = optGenReqId || buildDefaultGenReqId();

	  if (requestIdHeader) {
	    return buildOptionalHeaderReqId(requestIdHeader, genReqId)
	  }

	  return genReqId
	}

	function getGenReqId (contextServer, req) {
	  return contextServer.genReqId(req)
	}

	function buildDefaultGenReqId () {
	  // 2,147,483,647 (2^31 ‚àí 1) stands for max SMI value (an internal optimization of V8).
	  // With this upper bound, if you'll be generating 1k ids/sec, you're going to hit it in ~25 days.
	  // This is very likely to happen in real-world applications, hence the limit is enforced.
	  // Growing beyond this value will make the id generation slower and cause a deopt.
	  // In the worst cases, it will become a float, losing accuracy.
	  const maxInt = 2147483647;

	  let nextReqId = 0;
	  return function defaultGenReqId () {
	    nextReqId = (nextReqId + 1) & maxInt;
	    return `req-${nextReqId.toString(36)}`
	  }
	}

	function buildOptionalHeaderReqId (requestIdHeader, genReqId) {
	  return function (req) {
	    return req.headers[requestIdHeader] || genReqId(req)
	  }
	}

	reqIdGenFactory_1 = {
	  getGenReqId,
	  reqIdGenFactory
	};
	return reqIdGenFactory_1;
}

var lib$1 = {exports: {}};

var fastDecodeUriComponent;
var hasRequiredFastDecodeUriComponent;

function requireFastDecodeUriComponent () {
	if (hasRequiredFastDecodeUriComponent) return fastDecodeUriComponent;
	hasRequiredFastDecodeUriComponent = 1;

	var UTF8_ACCEPT = 12;
	var UTF8_REJECT = 0;
	var UTF8_DATA = [
	  // The first part of the table maps bytes to character to a transition.
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
	  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	  4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
	  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
	  6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7,
	  10, 9, 9, 9, 11, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,

	  // The second part of the table maps a state to a new state when adding a
	  // transition.
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	  12, 0, 0, 0, 0, 24, 36, 48, 60, 72, 84, 96,
	  0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0,
	  0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0,
	  0, 24, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0,
	  0, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	  0, 48, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0,
	  0, 0, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0,
	  0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,

	  // The third part maps the current transition to a mask that needs to apply
	  // to the byte.
	  0x7F, 0x3F, 0x3F, 0x3F, 0x00, 0x1F, 0x0F, 0x0F, 0x0F, 0x07, 0x07, 0x07
	];

	function decodeURIComponent (uri) {
	  var percentPosition = uri.indexOf('%');
	  if (percentPosition === -1) return uri

	  var length = uri.length;
	  var decoded = '';
	  var last = 0;
	  var codepoint = 0;
	  var startOfOctets = percentPosition;
	  var state = UTF8_ACCEPT;

	  while (percentPosition > -1 && percentPosition < length) {
	    var high = hexCodeToInt(uri[percentPosition + 1], 4);
	    var low = hexCodeToInt(uri[percentPosition + 2], 0);
	    var byte = high | low;
	    var type = UTF8_DATA[byte];
	    state = UTF8_DATA[256 + state + type];
	    codepoint = (codepoint << 6) | (byte & UTF8_DATA[364 + type]);

	    if (state === UTF8_ACCEPT) {
	      decoded += uri.slice(last, startOfOctets);

	      decoded += (codepoint <= 0xFFFF)
	        ? String.fromCharCode(codepoint)
	        : String.fromCharCode(
	          (0xD7C0 + (codepoint >> 10)),
	          (0xDC00 + (codepoint & 0x3FF))
	        );

	      codepoint = 0;
	      last = percentPosition + 3;
	      percentPosition = startOfOctets = uri.indexOf('%', last);
	    } else if (state === UTF8_REJECT) {
	      return null
	    } else {
	      percentPosition += 3;
	      if (percentPosition < length && uri.charCodeAt(percentPosition) === 37) continue
	      return null
	    }
	  }

	  return decoded + uri.slice(last)
	}

	var HEX = {
	  '0': 0,
	  '1': 1,
	  '2': 2,
	  '3': 3,
	  '4': 4,
	  '5': 5,
	  '6': 6,
	  '7': 7,
	  '8': 8,
	  '9': 9,
	  'a': 10,
	  'A': 10,
	  'b': 11,
	  'B': 11,
	  'c': 12,
	  'C': 12,
	  'd': 13,
	  'D': 13,
	  'e': 14,
	  'E': 14,
	  'f': 15,
	  'F': 15
	};

	function hexCodeToInt (c, shift) {
	  var i = HEX[c];
	  return i === undefined ? 255 : i << shift
	}

	fastDecodeUriComponent = decodeURIComponent;
	return fastDecodeUriComponent;
}

var parse_1;
var hasRequiredParse;

function requireParse () {
	if (hasRequiredParse) return parse_1;
	hasRequiredParse = 1;

	const fastDecode = requireFastDecodeUriComponent();

	const plusRegex = /\+/g;
	const Empty = function () {};
	Empty.prototype = Object.create(null);

	/**
	 * @callback parse
	 * @param {string} input
	 */
	function parse(input) {
	  // Optimization: Use new Empty() instead of Object.create(null) for performance
	  // v8 has a better optimization for initializing functions compared to Object
	  const result = new Empty();

	  if (typeof input !== "string") {
	    return result;
	  }

	  let inputLength = input.length;
	  let key = "";
	  let value = "";
	  let startingIndex = -1;
	  let equalityIndex = -1;
	  let shouldDecodeKey = false;
	  let shouldDecodeValue = false;
	  let keyHasPlus = false;
	  let valueHasPlus = false;
	  let hasBothKeyValuePair = false;
	  let c = 0;

	  // Have a boundary of input.length + 1 to access last pair inside the loop.
	  for (let i = 0; i < inputLength + 1; i++) {
	    c = i !== inputLength ? input.charCodeAt(i) : 38;

	    // Handle '&' and end of line to pass the current values to result
	    if (c === 38) {
	      hasBothKeyValuePair = equalityIndex > startingIndex;

	      // Optimization: Reuse equality index to store the end of key
	      if (!hasBothKeyValuePair) {
	        equalityIndex = i;
	      }

	      key = input.slice(startingIndex + 1, equalityIndex);

	      // Add key/value pair only if the range size is greater than 1; a.k.a. contains at least "="
	      if (hasBothKeyValuePair || key.length > 0) {
	        // Optimization: Replace '+' with space
	        if (keyHasPlus) {
	          key = key.replace(plusRegex, " ");
	        }

	        // Optimization: Do not decode if it's not necessary.
	        if (shouldDecodeKey) {
	          key = fastDecode(key) || key;
	        }

	        if (hasBothKeyValuePair) {
	          value = input.slice(equalityIndex + 1, i);

	          if (valueHasPlus) {
	            value = value.replace(plusRegex, " ");
	          }

	          if (shouldDecodeValue) {
	            value = fastDecode(value) || value;
	          }
	        }
	        const currentValue = result[key];

	        if (currentValue === undefined) {
	          result[key] = value;
	        } else {
	          // Optimization: value.pop is faster than Array.isArray(value)
	          if (currentValue.pop) {
	            currentValue.push(value);
	          } else {
	            result[key] = [currentValue, value];
	          }
	        }
	      }

	      // Reset reading key value pairs
	      value = "";
	      startingIndex = i;
	      equalityIndex = i;
	      shouldDecodeKey = false;
	      shouldDecodeValue = false;
	      keyHasPlus = false;
	      valueHasPlus = false;
	    }
	    // Check '='
	    else if (c === 61) {
	      if (equalityIndex <= startingIndex) {
	        equalityIndex = i;
	      }
	      // If '=' character occurs again, we should decode the input.
	      else {
	        shouldDecodeValue = true;
	      }
	    }
	    // Check '+', and remember to replace it with empty space.
	    else if (c === 43) {
	      if (equalityIndex > startingIndex) {
	        valueHasPlus = true;
	      } else {
	        keyHasPlus = true;
	      }
	    }
	    // Check '%' character for encoding
	    else if (c === 37) {
	      if (equalityIndex > startingIndex) {
	        shouldDecodeValue = true;
	      } else {
	        shouldDecodeKey = true;
	      }
	    }
	  }

	  return result;
	}

	parse_1 = parse;
	return parse_1;
}

var querystring;
var hasRequiredQuerystring;

function requireQuerystring () {
	if (hasRequiredQuerystring) return querystring;
	hasRequiredQuerystring = 1;
	// This file is taken from Node.js project.
	// Full implementation can be found from https://github.com/nodejs/node/blob/main/lib/internal/querystring.js

	const hexTable = Array.from(
	  { length: 256 },
	  (_, i) => "%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase(),
	);

	// These characters do not need escaping when generating query strings:
	// ! - . _ ~
	// ' ( ) *
	// digits
	// alpha (uppercase)
	// alpha (lowercase)
	// rome-ignore format: the array should not be formatted
	const noEscape = new Int8Array([
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31
	  0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, // 32 - 47
	  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63
	  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79
	  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, // 80 - 95
	  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111
	  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, // 112 - 127
	]);

	/**
	 * @param {string} str
	 * @returns {string}
	 */
	function encodeString(str) {
	  const len = str.length;
	  if (len === 0) return "";

	  let out = "";
	  let lastPos = 0;
	  let i = 0;

	  outer: for (; i < len; i++) {
	    let c = str.charCodeAt(i);

	    // ASCII
	    while (c < 0x80) {
	      if (noEscape[c] !== 1) {
	        if (lastPos < i) out += str.slice(lastPos, i);
	        lastPos = i + 1;
	        out += hexTable[c];
	      }

	      if (++i === len) break outer;

	      c = str.charCodeAt(i);
	    }

	    if (lastPos < i) out += str.slice(lastPos, i);

	    // Multi-byte characters ...
	    if (c < 0x800) {
	      lastPos = i + 1;
	      out += hexTable[0xc0 | (c >> 6)] + hexTable[0x80 | (c & 0x3f)];
	      continue;
	    }
	    if (c < 0xd800 || c >= 0xe000) {
	      lastPos = i + 1;
	      out +=
	        hexTable[0xe0 | (c >> 12)] +
	        hexTable[0x80 | ((c >> 6) & 0x3f)] +
	        hexTable[0x80 | (c & 0x3f)];
	      continue;
	    }
	    // Surrogate pair
	    ++i;

	    // This branch should never happen because all URLSearchParams entries
	    // should already be converted to USVString. But, included for
	    // completion's sake anyway.
	    if (i >= len) {
	      throw new Error("URI malformed");
	    }

	    const c2 = str.charCodeAt(i) & 0x3ff;

	    lastPos = i + 1;
	    c = 0x10000 + (((c & 0x3ff) << 10) | c2);
	    out +=
	      hexTable[0xf0 | (c >> 18)] +
	      hexTable[0x80 | ((c >> 12) & 0x3f)] +
	      hexTable[0x80 | ((c >> 6) & 0x3f)] +
	      hexTable[0x80 | (c & 0x3f)];
	  }
	  if (lastPos === 0) return str;
	  if (lastPos < len) return out + str.slice(lastPos);
	  return out;
	}

	querystring = { encodeString };
	return querystring;
}

var stringify_1;
var hasRequiredStringify;

function requireStringify () {
	if (hasRequiredStringify) return stringify_1;
	hasRequiredStringify = 1;

	const { encodeString } = requireQuerystring();

	function getAsPrimitive(value) {
	  const type = typeof value;

	  if (type === "string") {
	    // Length check is handled inside encodeString function
	    return encodeString(value);
	  } else if (type === "bigint") {
	    return value.toString();
	  } else if (type === "boolean") {
	    return value ? "true" : "false";
	  } else if (type === "number" && Number.isFinite(value)) {
	    return value < 1e21 ? "" + value : encodeString("" + value);
	  }

	  return "";
	}

	/**
	 * @param {Record<string, string | number | boolean
	 * | ReadonlyArray<string | number | boolean> | null>} input
	 * @returns {string}
	 */
	function stringify(input) {
	  let result = "";

	  if (input === null || typeof input !== "object") {
	    return result;
	  }

	  const separator = "&";
	  const keys = Object.keys(input);
	  const keyLength = keys.length;
	  let valueLength = 0;

	  for (let i = 0; i < keyLength; i++) {
	    const key = keys[i];
	    const value = input[key];
	    const encodedKey = encodeString(key) + "=";

	    if (i) {
	      result += separator;
	    }

	    if (Array.isArray(value)) {
	      valueLength = value.length;
	      for (let j = 0; j < valueLength; j++) {
	        if (j) {
	          result += separator;
	        }

	        // Optimization: Dividing into multiple lines improves the performance.
	        // Since v8 does not need to care about the '+' character if it was one-liner.
	        result += encodedKey;
	        result += getAsPrimitive(value[j]);
	      }
	    } else {
	      result += encodedKey;
	      result += getAsPrimitive(value);
	    }
	  }

	  return result;
	}

	stringify_1 = stringify;
	return stringify_1;
}

var hasRequiredLib$1;

function requireLib$1 () {
	if (hasRequiredLib$1) return lib$1.exports;
	hasRequiredLib$1 = 1;

	const parse = requireParse();
	const stringify = requireStringify();

	const fastQuerystring = {
	  parse,
	  stringify,
	};

	/**
	 * Enable TS and JS support
	 *
	 * - `const qs = require('fast-querystring')`
	 * - `import qs from 'fast-querystring'`
	 */
	lib$1.exports = fastQuerystring;
	lib$1.exports.default = fastQuerystring;
	lib$1.exports.parse = parse;
	lib$1.exports.stringify = stringify;
	return lib$1.exports;
}

var safeRegex2 = {exports: {}};

var dist$3 = {exports: {}};

var types$1 = {};

var tokens = {};

var hasRequiredTokens;

function requireTokens () {
	if (hasRequiredTokens) return tokens;
	hasRequiredTokens = 1;
	Object.defineProperty(tokens, "__esModule", { value: true });
	
	return tokens;
}

var types = {};

var hasRequiredTypes$1;

function requireTypes$1 () {
	if (hasRequiredTypes$1) return types;
	hasRequiredTypes$1 = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.types = void 0;
		(function (types) {
		    types[types["ROOT"] = 0] = "ROOT";
		    types[types["GROUP"] = 1] = "GROUP";
		    types[types["POSITION"] = 2] = "POSITION";
		    types[types["SET"] = 3] = "SET";
		    types[types["RANGE"] = 4] = "RANGE";
		    types[types["REPETITION"] = 5] = "REPETITION";
		    types[types["REFERENCE"] = 6] = "REFERENCE";
		    types[types["CHAR"] = 7] = "CHAR";
		})(exports.types || (exports.types = {}));
		
	} (types));
	return types;
}

var setLookup = {};

var hasRequiredSetLookup;

function requireSetLookup () {
	if (hasRequiredSetLookup) return setLookup;
	hasRequiredSetLookup = 1;
	Object.defineProperty(setLookup, "__esModule", { value: true });
	
	return setLookup;
}

var hasRequiredTypes;

function requireTypes () {
	if (hasRequiredTypes) return types$1;
	hasRequiredTypes = 1;
	(function (exports) {
		var __createBinding = (types$1 && types$1.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (types$1 && types$1.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		__exportStar(requireTokens(), exports);
		__exportStar(requireTypes$1(), exports);
		__exportStar(requireSetLookup(), exports);
		
	} (types$1));
	return types$1;
}

var tokenizer = {};

var util = {};

var sets = {};

var hasRequiredSets;

function requireSets () {
	if (hasRequiredSets) return sets;
	hasRequiredSets = 1;
	Object.defineProperty(sets, "__esModule", { value: true });
	sets.anyChar = sets.notWhitespace = sets.whitespace = sets.notInts = sets.ints = sets.notWords = sets.words = void 0;
	const types_1 = requireTypes();
	const INTS = () => [{ type: types_1.types.RANGE, from: 48, to: 57 }];
	const WORDS = () => [
	    { type: types_1.types.CHAR, value: 95 },
	    { type: types_1.types.RANGE, from: 97, to: 122 },
	    { type: types_1.types.RANGE, from: 65, to: 90 },
	    { type: types_1.types.RANGE, from: 48, to: 57 },
	];
	const WHITESPACE = () => [
	    { type: types_1.types.CHAR, value: 9 },
	    { type: types_1.types.CHAR, value: 10 },
	    { type: types_1.types.CHAR, value: 11 },
	    { type: types_1.types.CHAR, value: 12 },
	    { type: types_1.types.CHAR, value: 13 },
	    { type: types_1.types.CHAR, value: 32 },
	    { type: types_1.types.CHAR, value: 160 },
	    { type: types_1.types.CHAR, value: 5760 },
	    { type: types_1.types.RANGE, from: 8192, to: 8202 },
	    { type: types_1.types.CHAR, value: 8232 },
	    { type: types_1.types.CHAR, value: 8233 },
	    { type: types_1.types.CHAR, value: 8239 },
	    { type: types_1.types.CHAR, value: 8287 },
	    { type: types_1.types.CHAR, value: 12288 },
	    { type: types_1.types.CHAR, value: 65279 },
	];
	const NOTANYCHAR = () => [
	    { type: types_1.types.CHAR, value: 10 },
	    { type: types_1.types.CHAR, value: 13 },
	    { type: types_1.types.CHAR, value: 8232 },
	    { type: types_1.types.CHAR, value: 8233 },
	];
	// Predefined class objects.
	sets.words = () => ({ type: types_1.types.SET, set: WORDS(), not: false });
	sets.notWords = () => ({ type: types_1.types.SET, set: WORDS(), not: true });
	sets.ints = () => ({ type: types_1.types.SET, set: INTS(), not: false });
	sets.notInts = () => ({ type: types_1.types.SET, set: INTS(), not: true });
	sets.whitespace = () => ({ type: types_1.types.SET, set: WHITESPACE(), not: false });
	sets.notWhitespace = () => ({ type: types_1.types.SET, set: WHITESPACE(), not: true });
	sets.anyChar = () => ({ type: types_1.types.SET, set: NOTANYCHAR(), not: true });
	
	return sets;
}

var hasRequiredUtil;

function requireUtil () {
	if (hasRequiredUtil) return util;
	hasRequiredUtil = 1;
	var __createBinding = (util && util.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (util && util.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (util && util.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(util, "__esModule", { value: true });
	util.tokenizeClass = util.strToChars = void 0;
	const types_1 = requireTypes();
	const sets = __importStar(requireSets());
	const CTRL = '@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^ ?';
	/**
	 * Finds character representations in str and convert all to
	 * their respective characters.
	 *
	 * @param {string} str
	 * @returns {string}
	 */
	util.strToChars = (str) => {
	    const charsRegex = /(\[\\b\])|(\\)?\\(?:u([A-F0-9]{4})|x([A-F0-9]{2})|c([@A-Z[\\\]^?])|([0tnvfr]))/g;
	    return str.replace(charsRegex, (s, b, lbs, a16, b16, dctrl, eslsh) => {
	        if (lbs) {
	            return s;
	        }
	        let code = b ? 8 :
	            a16 ? parseInt(a16, 16) :
	                b16 ? parseInt(b16, 16) :
	                    dctrl ? CTRL.indexOf(dctrl) : {
	                        0: 0,
	                        t: 9,
	                        n: 10,
	                        v: 11,
	                        f: 12,
	                        r: 13,
	                    }[eslsh];
	        let c = String.fromCharCode(code);
	        // Escape special regex characters.
	        return /[[\]{}^$.|?*+()]/.test(c) ? `\\${c}` : c;
	    });
	};
	/**
	 * Turns class into tokens
	 * reads str until it encounters a ] not preceeded by a \
	 *
	 * @param {string} str
	 * @param {string} regexpStr
	 * @returns {Array.<Array.<Object>, number>}
	 */
	util.tokenizeClass = (str, regexpStr) => {
	    var _a, _b, _c, _d, _e, _f, _g;
	    let tokens = [], rs, c;
	    const regexp = /\\(?:(w)|(d)|(s)|(W)|(D)|(S))|((?:(?:\\)(.)|([^\]\\]))-(((?:\\)])|(((?:\\)?([^\]])))))|(\])|(?:\\)?([^])/g;
	    while ((rs = regexp.exec(str)) !== null) {
	        const p = (_g = (_f = (_e = (_d = (_c = (_b = (_a = (rs[1] && sets.words())) !== null && _a !== void 0 ? _a : (rs[2] && sets.ints())) !== null && _b !== void 0 ? _b : (rs[3] && sets.whitespace())) !== null && _c !== void 0 ? _c : (rs[4] && sets.notWords())) !== null && _d !== void 0 ? _d : (rs[5] && sets.notInts())) !== null && _e !== void 0 ? _e : (rs[6] && sets.notWhitespace())) !== null && _f !== void 0 ? _f : (rs[7] && {
	            type: types_1.types.RANGE,
	            from: (rs[8] || rs[9]).charCodeAt(0),
	            to: (c = rs[10]).charCodeAt(c.length - 1),
	        })) !== null && _g !== void 0 ? _g : ((c = rs[16]) && { type: types_1.types.CHAR, value: c.charCodeAt(0) });
	        if (p) {
	            tokens.push(p);
	        }
	        else {
	            return [tokens, regexp.lastIndex];
	        }
	    }
	    throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Unterminated character class`);
	};
	
	return util;
}

var hasRequiredTokenizer;

function requireTokenizer () {
	if (hasRequiredTokenizer) return tokenizer;
	hasRequiredTokenizer = 1;
	var __createBinding = (tokenizer && tokenizer.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (tokenizer && tokenizer.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (tokenizer && tokenizer.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(tokenizer, "__esModule", { value: true });
	tokenizer.tokenizer = void 0;
	const util = __importStar(requireUtil());
	const types_1 = requireTypes();
	const sets = __importStar(requireSets());
	/**
	 * Valid opening characters for capture group names.
	 */
	const captureGroupFirstChar = /^[a-zA-Z_$]$/i;
	/**
	 * Valid characters for capture group names.
	 */
	const captureGroupChars = /^[a-zA-Z0-9_$]$/i;
	const digit = /\d/;
	/**
	 * Tokenizes a regular expression (that is currently a string)
	 * @param {string} regexpStr String of regular expression to be tokenized
	 *
	 * @returns {Root}
	 */
	tokenizer.tokenizer = (regexpStr) => {
	    let i = 0, c;
	    let start = { type: types_1.types.ROOT, stack: [] };
	    // Keep track of last clause/group and stack.
	    let lastGroup = start;
	    let last = start.stack;
	    let groupStack = [];
	    let referenceQueue = [];
	    let groupCount = 0;
	    const repeatErr = (col) => {
	        throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Nothing to repeat at column ${col - 1}`);
	    };
	    // Decode a few escaped characters.
	    let str = util.strToChars(regexpStr);
	    // Iterate through each character in string.
	    while (i < str.length) {
	        switch (c = str[i++]) {
	            // Handle escaped characters, inclues a few sets.
	            case '\\':
	                if (i === str.length) {
	                    throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: \\ at end of pattern`);
	                }
	                switch (c = str[i++]) {
	                    case 'b':
	                        last.push({ type: types_1.types.POSITION, value: 'b' });
	                        break;
	                    case 'B':
	                        last.push({ type: types_1.types.POSITION, value: 'B' });
	                        break;
	                    case 'w':
	                        last.push(sets.words());
	                        break;
	                    case 'W':
	                        last.push(sets.notWords());
	                        break;
	                    case 'd':
	                        last.push(sets.ints());
	                        break;
	                    case 'D':
	                        last.push(sets.notInts());
	                        break;
	                    case 's':
	                        last.push(sets.whitespace());
	                        break;
	                    case 'S':
	                        last.push(sets.notWhitespace());
	                        break;
	                    default:
	                        // Check if c is integer.
	                        // In which case it's a reference.
	                        if (digit.test(c)) {
	                            let digits = c;
	                            while (i < str.length && digit.test(str[i])) {
	                                digits += str[i++];
	                            }
	                            let value = parseInt(digits, 10);
	                            const reference = { type: types_1.types.REFERENCE, value };
	                            last.push(reference);
	                            referenceQueue.push({ reference, stack: last, index: last.length - 1 });
	                            // Escaped character.
	                        }
	                        else {
	                            last.push({ type: types_1.types.CHAR, value: c.charCodeAt(0) });
	                        }
	                }
	                break;
	            // Positionals.
	            case '^':
	                last.push({ type: types_1.types.POSITION, value: '^' });
	                break;
	            case '$':
	                last.push({ type: types_1.types.POSITION, value: '$' });
	                break;
	            // Handle custom sets.
	            case '[': {
	                // Check if this class is 'anti' i.e. [^abc].
	                let not;
	                if (str[i] === '^') {
	                    not = true;
	                    i++;
	                }
	                else {
	                    not = false;
	                }
	                // Get all the characters in class.
	                let classTokens = util.tokenizeClass(str.slice(i), regexpStr);
	                // Increase index by length of class.
	                i += classTokens[1];
	                last.push({
	                    type: types_1.types.SET,
	                    set: classTokens[0],
	                    not,
	                });
	                break;
	            }
	            // Class of any character except \n.
	            case '.':
	                last.push(sets.anyChar());
	                break;
	            // Push group onto stack.
	            case '(': {
	                // Create group.
	                let group = {
	                    type: types_1.types.GROUP,
	                    stack: [],
	                    remember: true,
	                };
	                // If this is a special kind of group.
	                if (str[i] === '?') {
	                    c = str[i + 1];
	                    i += 2;
	                    // Match if followed by.
	                    if (c === '=') {
	                        group.followedBy = true;
	                        group.remember = false;
	                        // Match if not followed by.
	                    }
	                    else if (c === '!') {
	                        group.notFollowedBy = true;
	                        group.remember = false;
	                    }
	                    else if (c === '<') {
	                        let name = '';
	                        if (captureGroupFirstChar.test(str[i])) {
	                            name += str[i];
	                            i++;
	                        }
	                        else {
	                            throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Invalid capture group name, character '${str[i]}'` +
	                                ` after '<' at column ${i + 1}`);
	                        }
	                        while (i < str.length && captureGroupChars.test(str[i])) {
	                            name += str[i];
	                            i++;
	                        }
	                        if (!name) {
	                            throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Invalid capture group name, character '${str[i]}'` +
	                                ` after '<' at column ${i + 1}`);
	                        }
	                        if (str[i] !== '>') {
	                            throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Unclosed capture group name, expected '>', found` +
	                                ` '${str[i]}' at column ${i + 1}`);
	                        }
	                        group.name = name;
	                        i++;
	                    }
	                    else if (c === ':') {
	                        group.remember = false;
	                    }
	                    else {
	                        throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Invalid group, character '${c}'` +
	                            ` after '?' at column ${i - 1}`);
	                    }
	                }
	                else {
	                    groupCount += 1;
	                }
	                // Insert subgroup into current group stack.
	                last.push(group);
	                // Remember the current group for when the group closes.
	                groupStack.push(lastGroup);
	                // Make this new group the current group.
	                lastGroup = group;
	                last = group.stack;
	                break;
	            }
	            // Pop group out of stack.
	            case ')':
	                if (groupStack.length === 0) {
	                    throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Unmatched ) at column ${i - 1}`);
	                }
	                lastGroup = groupStack.pop();
	                // Check if this group has a PIPE.
	                // To get back the correct last stack.
	                last = lastGroup.options ?
	                    lastGroup.options[lastGroup.options.length - 1] :
	                    lastGroup.stack;
	                break;
	            // Use pipe character to give more choices.
	            case '|': {
	                // Create array where options are if this is the first PIPE
	                // in this clause.
	                if (!lastGroup.options) {
	                    lastGroup.options = [lastGroup.stack];
	                    delete lastGroup.stack;
	                }
	                // Create a new stack and add to options for rest of clause.
	                let stack = [];
	                lastGroup.options.push(stack);
	                last = stack;
	                break;
	            }
	            // Repetition.
	            // For every repetition, remove last element from last stack
	            // then insert back a RANGE object.
	            // This design is chosen because there could be more than
	            // one repetition symbols in a regex i.e. `a?+{2,3}`.
	            case '{': {
	                let rs = /^(\d+)(,(\d+)?)?\}/.exec(str.slice(i)), min, max;
	                if (rs !== null) {
	                    if (last.length === 0) {
	                        repeatErr(i);
	                    }
	                    min = parseInt(rs[1], 10);
	                    max = rs[2] ? rs[3] ? parseInt(rs[3], 10) : Infinity : min;
	                    i += rs[0].length;
	                    last.push({
	                        type: types_1.types.REPETITION,
	                        min,
	                        max,
	                        value: last.pop(),
	                    });
	                }
	                else {
	                    last.push({
	                        type: types_1.types.CHAR,
	                        value: 123,
	                    });
	                }
	                break;
	            }
	            case '?':
	                if (last.length === 0) {
	                    repeatErr(i);
	                }
	                last.push({
	                    type: types_1.types.REPETITION,
	                    min: 0,
	                    max: 1,
	                    value: last.pop(),
	                });
	                break;
	            case '+':
	                if (last.length === 0) {
	                    repeatErr(i);
	                }
	                last.push({
	                    type: types_1.types.REPETITION,
	                    min: 1,
	                    max: Infinity,
	                    value: last.pop(),
	                });
	                break;
	            case '*':
	                if (last.length === 0) {
	                    repeatErr(i);
	                }
	                last.push({
	                    type: types_1.types.REPETITION,
	                    min: 0,
	                    max: Infinity,
	                    value: last.pop(),
	                });
	                break;
	            // Default is a character that is not `\[](){}?+*^$`.
	            default:
	                last.push({
	                    type: types_1.types.CHAR,
	                    value: c.charCodeAt(0),
	                });
	        }
	    }
	    // Check if any groups have not been closed.
	    if (groupStack.length !== 0) {
	        throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Unterminated group`);
	    }
	    updateReferences(referenceQueue, groupCount);
	    return start;
	};
	/**
	 * This is a side effecting function that changes references to chars
	 * if there are not enough capturing groups to reference
	 * See: https://github.com/fent/ret.js/pull/39#issuecomment-1006475703
	 * See: https://github.com/fent/ret.js/issues/38
	 * @param {(Reference | Char)[]} referenceQueue
	 * @param {number} groupCount
	 * @returns {void}
	 */
	function updateReferences(referenceQueue, groupCount) {
	    // Note: We go through the queue in reverse order so
	    // that index we use is correct even if we have to add
	    // multiple tokens to one stack
	    for (const elem of referenceQueue.reverse()) {
	        if (groupCount < elem.reference.value) {
	            // If there is nothing to reference then turn this into a char token
	            elem.reference.type = types_1.types.CHAR;
	            const valueString = elem.reference.value.toString();
	            elem.reference.value = parseInt(valueString, 8);
	            // If the number is not octal then we need to create multiple tokens
	            // https://github.com/fent/ret.js/pull/39#issuecomment-1008229226
	            if (!/^[0-7]+$/.test(valueString)) {
	                let i = 0;
	                while (valueString[i] !== '8' && valueString[i] !== '9') {
	                    i += 1;
	                }
	                if (i === 0) {
	                    // Handling case when escaped number starts with 8 or 9
	                    elem.reference.value = valueString.charCodeAt(0);
	                    i += 1;
	                }
	                else {
	                    // If the escaped number does not start with 8 or 9, then all
	                    // 0-7 digits before the first 8/9 form the first character code
	                    // see: https://github.com/fent/ret.js/pull/39#discussion_r780747085
	                    elem.reference.value = parseInt(valueString.slice(0, i), 8);
	                }
	                if (valueString.length > i) {
	                    const tail = elem.stack.splice(elem.index + 1);
	                    for (const char of valueString.slice(i)) {
	                        elem.stack.push({
	                            type: types_1.types.CHAR,
	                            value: char.charCodeAt(0),
	                        });
	                    }
	                    elem.stack.push(...tail);
	                }
	            }
	        }
	    }
	}
	
	return tokenizer;
}

var reconstruct = {};

var writeSetTokens = {};

var setsLookup = {};

var hasRequiredSetsLookup;

function requireSetsLookup () {
	if (hasRequiredSetsLookup) return setsLookup;
	hasRequiredSetsLookup = 1;
	var __createBinding = (setsLookup && setsLookup.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (setsLookup && setsLookup.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (setsLookup && setsLookup.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(setsLookup, "__esModule", { value: true });
	setsLookup.NOTANYCHAR = setsLookup.WHITESPACE = setsLookup.WORDS = setsLookup.INTS = void 0;
	const Sets = __importStar(requireSets());
	const types_1 = requireTypes();
	function setToLookup(tokens) {
	    let lookup = {};
	    let len = 0;
	    for (const token of tokens) {
	        if (token.type === types_1.types.CHAR) {
	            lookup[token.value] = true;
	        }
	        // Note this is in an if statement because
	        // the SetTokens type is (Char | Range | Set)[]
	        // so a type error is thrown if it is not.
	        // If the SetTokens type is modified the if statement
	        // can be removed
	        if (token.type === types_1.types.RANGE) {
	            lookup[`${token.from}-${token.to}`] = true;
	        }
	        len += 1;
	    }
	    return {
	        lookup: () => (Object.assign({}, lookup)),
	        len,
	    };
	}
	setsLookup.INTS = setToLookup(Sets.ints().set);
	setsLookup.WORDS = setToLookup(Sets.words().set);
	setsLookup.WHITESPACE = setToLookup(Sets.whitespace().set);
	setsLookup.NOTANYCHAR = setToLookup(Sets.anyChar().set);
	
	return setsLookup;
}

var hasRequiredWriteSetTokens;

function requireWriteSetTokens () {
	if (hasRequiredWriteSetTokens) return writeSetTokens;
	hasRequiredWriteSetTokens = 1;
	var __createBinding = (writeSetTokens && writeSetTokens.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (writeSetTokens && writeSetTokens.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (writeSetTokens && writeSetTokens.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(writeSetTokens, "__esModule", { value: true });
	writeSetTokens.writeSetTokens = writeSetTokens.setChar = void 0;
	const types_1 = requireTypes();
	const sets = __importStar(requireSetsLookup());
	/**
	 * Takes character code and returns character to be displayed in a set
	 * @param {number} charCode Character code of set element
	 * @returns {string} The string for the sets character
	 */
	function setChar(charCode) {
	    return charCode === 94 ? '\\^' :
	        charCode === 92 ? '\\\\' :
	            charCode === 93 ? '\\]' :
	                charCode === 45 ? '\\-' :
	                    String.fromCharCode(charCode);
	}
	writeSetTokens.setChar = setChar;
	/**
	 * Test if a character set matches a 'set-lookup'
	 * @param {SetTokens} set The set to be tested
	 * @param {SetLookup} param The predefined 'set-lookup' & the number of elements in the lookup
	 * @returns {boolean} True if the character set corresponds to the 'set-lookup'
	 */
	function isSameSet(set, { lookup, len }) {
	    // If the set and the lookup are not of the same length
	    // then we immediately know that the lookup will be false
	    if (len !== set.length) {
	        return false;
	    }
	    const map = lookup();
	    for (const elem of set) {
	        if (elem.type === types_1.types.SET) {
	            return false;
	        }
	        const key = elem.type === types_1.types.CHAR ? elem.value : `${elem.from}-${elem.to}`;
	        if (map[key]) {
	            map[key] = false;
	        }
	        else {
	            return false;
	        }
	    }
	    return true;
	}
	/**
	 * Writes the tokens for a set
	 * @param {Set} set The set to display
	 * @param {boolean} isNested Whether the token is nested inside another set token
	 * @returns {string} The tokens for the set
	 */
	function writeSetTokens$1(set, isNested = false) {
	    if (isSameSet(set.set, sets.INTS)) {
	        return set.not ? '\\D' : '\\d';
	    }
	    if (isSameSet(set.set, sets.WORDS)) {
	        return set.not ? '\\W' : '\\w';
	    }
	    // Notanychar is only relevant when not nested inside another set token
	    if (set.not && isSameSet(set.set, sets.NOTANYCHAR)) {
	        return '.';
	    }
	    if (isSameSet(set.set, sets.WHITESPACE)) {
	        return set.not ? '\\S' : '\\s';
	    }
	    let tokenString = '';
	    for (let i = 0; i < set.set.length; i++) {
	        const subset = set.set[i];
	        tokenString += writeSetToken(subset);
	    }
	    const contents = `${set.not ? '^' : ''}${tokenString}`;
	    return isNested ? contents : `[${contents}]`;
	}
	writeSetTokens.writeSetTokens = writeSetTokens$1;
	/**
	 * Writes a token within a set
	 * @param {Range | Char | Set} set The set token to display
	 * @returns {string} The token as a string
	 */
	function writeSetToken(set) {
	    if (set.type === types_1.types.CHAR) {
	        return setChar(set.value);
	    }
	    else if (set.type === types_1.types.RANGE) {
	        return `${setChar(set.from)}-${setChar(set.to)}`;
	    }
	    return writeSetTokens$1(set, true);
	}
	
	return writeSetTokens;
}

var hasRequiredReconstruct;

function requireReconstruct () {
	if (hasRequiredReconstruct) return reconstruct;
	hasRequiredReconstruct = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.reconstruct = void 0;
		const types_1 = requireTypes();
		const write_set_tokens_1 = requireWriteSetTokens();
		const reduceStack = (stack) => stack.map(exports.reconstruct).join('');
		const createAlternate = (token) => {
		    if ('options' in token) {
		        return token.options.map(reduceStack).join('|');
		    }
		    else if ('stack' in token) {
		        return reduceStack(token.stack);
		    }
		    else {
		        throw new Error(`options or stack must be Root or Group token`);
		    }
		};
		exports.reconstruct = (token) => {
		    switch (token.type) {
		        case types_1.types.ROOT:
		            return createAlternate(token);
		        case types_1.types.CHAR: {
		            const c = String.fromCharCode(token.value);
		            // Note that the escaping for characters inside classes is handled
		            // in the write-set-tokens module so '-' and ']' are not escaped here
		            return (/[[\\{}$^.|?*+()]/.test(c) ? '\\' : '') + c;
		        }
		        case types_1.types.POSITION:
		            if (token.value === '^' || token.value === '$') {
		                return token.value;
		            }
		            else {
		                return `\\${token.value}`;
		            }
		        case types_1.types.REFERENCE:
		            return `\\${token.value}`;
		        case types_1.types.SET:
		            return write_set_tokens_1.writeSetTokens(token);
		        case types_1.types.GROUP: {
		            // Check token.remember
		            const prefix = token.name ? `?<${token.name}>` :
		                token.remember ? '' :
		                    token.followedBy ? '?=' :
		                        token.notFollowedBy ? '?!' :
		                            '?:';
		            return `(${prefix}${createAlternate(token)})`;
		        }
		        case types_1.types.REPETITION: {
		            const { min, max } = token;
		            let endWith;
		            if (min === 0 && max === 1) {
		                endWith = '?';
		            }
		            else if (min === 1 && max === Infinity) {
		                endWith = '+';
		            }
		            else if (min === 0 && max === Infinity) {
		                endWith = '*';
		            }
		            else if (max === Infinity) {
		                endWith = `{${min},}`;
		            }
		            else if (min === max) {
		                endWith = `{${min}}`;
		            }
		            else {
		                endWith = `{${min},${max}}`;
		            }
		            return `${exports.reconstruct(token.value)}${endWith}`;
		        }
		        case types_1.types.RANGE:
		            return `${write_set_tokens_1.setChar(token.from)}-${write_set_tokens_1.setChar(token.to)}`;
		        default:
		            throw new Error(`Invalid token type ${token}`);
		    }
		};
		
	} (reconstruct));
	return reconstruct;
}

var dist$2 = dist$3.exports;

var hasRequiredDist$2;

function requireDist$2 () {
	if (hasRequiredDist$2) return dist$3.exports;
	hasRequiredDist$2 = 1;
	(function (module, exports) {
		var __createBinding = (dist$2 && dist$2.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (dist$2 && dist$2.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.types = void 0;
		/* istanbul ignore file */
		const types_1 = requireTypes();
		Object.defineProperty(exports, "types", { enumerable: true, get: function () { return types_1.types; } });
		__exportStar(requireTokenizer(), exports);
		__exportStar(requireReconstruct(), exports);
		const tokenizer_1 = requireTokenizer();
		const reconstruct_1 = requireReconstruct();
		__exportStar(requireTypes(), exports);
		exports.default = tokenizer_1.tokenizer;
		module.exports = tokenizer_1.tokenizer;
		module.exports.types = types_1.types;
		module.exports.reconstruct = reconstruct_1.reconstruct;
		
	} (dist$3, dist$3.exports));
	return dist$3.exports;
}

var hasRequiredSafeRegex2;

function requireSafeRegex2 () {
	if (hasRequiredSafeRegex2) return safeRegex2.exports;
	hasRequiredSafeRegex2 = 1;

	const parse = requireDist$2();
	const types = parse.types;

	function safeRegex (re, opts) {
	  if (!opts) opts = {};
	  /* c8 ignore next */
	  const replimit = opts.limit === undefined ? 25 : opts.limit;

	  /* c8 ignore next 2 */
	  if (isRegExp(re)) re = re.source;
	  else if (typeof re !== 'string') re = String(re);

	  try { re = parse(re); } catch { return false }

	  let reps = 0;
	  return (function walk (node, starHeight) {
	    let i;
	    let ok;
	    let len;

	    if (node.type === types.REPETITION) {
	      starHeight++;
	      reps++;
	      if (starHeight > 1) return false
	      if (reps > replimit) return false
	    }

	    if (node.options) {
	      for (i = 0, len = node.options.length; i < len; i++) {
	        ok = walk({ stack: node.options[i] }, starHeight);
	        if (!ok) return false
	      }
	    }
	    const stack = node.stack || node.value?.stack;
	    if (!stack) return true

	    for (i = 0; i < stack.length; i++) {
	      ok = walk(stack[i], starHeight);
	      if (!ok) return false
	    }

	    return true
	  })(re, 0)
	}

	function isRegExp (x) {
	  return {}.toString.call(x) === '[object RegExp]'
	}

	safeRegex2.exports = safeRegex;
	safeRegex2.exports.default = safeRegex;
	safeRegex2.exports.safeRegex = safeRegex;
	return safeRegex2.exports;
}

var httpMethod;
var hasRequiredHttpMethod;

function requireHttpMethod () {
	if (hasRequiredHttpMethod) return httpMethod;
	hasRequiredHttpMethod = 1;

	httpMethod = {
	  name: '__fmw_internal_strategy_merged_tree_http_method__',
	  storage: function () {
	    const handlers = new Map();
	    return {
	      get: (type) => { return handlers.get(type) || null },
	      set: (type, store) => { handlers.set(type, store); }
	    }
	  },
	  /* c8 ignore next 1 */
	  deriveConstraint: (req) => req.method,
	  mustMatchWhenDerived: true
	};
	return httpMethod;
}

var prettyPrint;
var hasRequiredPrettyPrint;

function requirePrettyPrint () {
	if (hasRequiredPrettyPrint) return prettyPrint;
	hasRequiredPrettyPrint = 1;

	const deepEqual = requireFastDeepEqual();

	const httpMethodStrategy = requireHttpMethod();
	const treeDataSymbol = Symbol('treeData');

	function printObjectTree (obj, parentPrefix = '') {
	  let tree = '';
	  const keys = Object.keys(obj);
	  for (let i = 0; i < keys.length; i++) {
	    const key = keys[i];
	    const value = obj[key];
	    const isLast = i === keys.length - 1;

	    const nodePrefix = isLast ? '‚îî‚îÄ‚îÄ ' : '‚îú‚îÄ‚îÄ ';
	    const childPrefix = isLast ? '    ' : '‚îÇ   ';

	    const nodeData = value[treeDataSymbol] || '';
	    const prefixedNodeData = nodeData.replaceAll('\n', '\n' + parentPrefix + childPrefix);

	    tree += parentPrefix + nodePrefix + key + prefixedNodeData + '\n';
	    tree += printObjectTree(value, parentPrefix + childPrefix);
	  }
	  return tree
	}

	function parseFunctionName (fn) {
	  let fName = fn.name || '';

	  fName = fName.replace('bound', '').trim();
	  fName = (fName || 'anonymous') + '()';
	  return fName
	}

	function parseMeta (meta) {
	  if (Array.isArray(meta)) return meta.map(m => parseMeta(m))
	  if (typeof meta === 'symbol') return meta.toString()
	  if (typeof meta === 'function') return parseFunctionName(meta)
	  return meta
	}

	function getRouteMetaData (route, options) {
	  if (!options.includeMeta) return {}

	  const metaDataObject = options.buildPrettyMeta(route);
	  const filteredMetaData = {};

	  let includeMetaKeys = options.includeMeta;
	  if (!Array.isArray(includeMetaKeys)) {
	    includeMetaKeys = Reflect.ownKeys(metaDataObject);
	  }

	  for (const metaKey of includeMetaKeys) {
	    if (!Object.prototype.hasOwnProperty.call(metaDataObject, metaKey)) continue

	    const serializedKey = metaKey.toString();
	    const metaValue = metaDataObject[metaKey];

	    if (metaValue !== undefined && metaValue !== null) {
	      const serializedValue = JSON.stringify(parseMeta(metaValue));
	      filteredMetaData[serializedKey] = serializedValue;
	    }
	  }

	  return filteredMetaData
	}

	function serializeMetaData (metaData) {
	  let serializedMetaData = '';
	  for (const [key, value] of Object.entries(metaData)) {
	    serializedMetaData += `\n‚Ä¢ (${key}) ${value}`;
	  }
	  return serializedMetaData
	}

	// get original merged tree node route
	function normalizeRoute (route) {
	  const constraints = { ...route.opts.constraints };
	  const method = constraints[httpMethodStrategy.name];
	  delete constraints[httpMethodStrategy.name];
	  return { ...route, method, opts: { constraints } }
	}

	function serializeRoute (route) {
	  let serializedRoute = ` (${route.method})`;

	  const constraints = route.opts.constraints || {};
	  if (Object.keys(constraints).length !== 0) {
	    serializedRoute += ' ' + JSON.stringify(constraints);
	  }

	  serializedRoute += serializeMetaData(route.metaData);
	  return serializedRoute
	}

	function mergeSimilarRoutes (routes) {
	  return routes.reduce((mergedRoutes, route) => {
	    for (const nodeRoute of mergedRoutes) {
	      if (
	        deepEqual(route.opts.constraints, nodeRoute.opts.constraints) &&
	        deepEqual(route.metaData, nodeRoute.metaData)
	      ) {
	        nodeRoute.method += ', ' + route.method;
	        return mergedRoutes
	      }
	    }
	    mergedRoutes.push(route);
	    return mergedRoutes
	  }, [])
	}

	function serializeNode (node, prefix, options) {
	  let routes = node.routes;

	  if (options.method === undefined) {
	    routes = routes.map(normalizeRoute);
	  }

	  routes = routes.map(route => {
	    route.metaData = getRouteMetaData(route, options);
	    return route
	  });

	  if (options.method === undefined) {
	    routes = mergeSimilarRoutes(routes);
	  }

	  return routes.map(serializeRoute).join(`\n${prefix}`)
	}

	function buildObjectTree (node, tree, prefix, options) {
	  if (node.isLeafNode || options.commonPrefix !== false) {
	    prefix = prefix || '(empty root node)';
	    tree = tree[prefix] = {};

	    if (node.isLeafNode) {
	      tree[treeDataSymbol] = serializeNode(node, prefix, options);
	    }

	    prefix = '';
	  }

	  if (node.staticChildren) {
	    for (const child of Object.values(node.staticChildren)) {
	      buildObjectTree(child, tree, prefix + child.prefix, options);
	    }
	  }

	  if (node.parametricChildren) {
	    for (const child of Object.values(node.parametricChildren)) {
	      const childPrefix = Array.from(child.nodePaths).join('|');
	      buildObjectTree(child, tree, prefix + childPrefix, options);
	    }
	  }

	  if (node.wildcardChild) {
	    buildObjectTree(node.wildcardChild, tree, '*', options);
	  }
	}

	function prettyPrintTree (root, options) {
	  const objectTree = {};
	  buildObjectTree(root, objectTree, root.prefix, options);
	  return printObjectTree(objectTree)
	}

	prettyPrint = { prettyPrintTree };
	return prettyPrint;
}

var nullObject;
var hasRequiredNullObject;

function requireNullObject () {
	if (hasRequiredNullObject) return nullObject;
	hasRequiredNullObject = 1;

	const NullObject = function () {};
	NullObject.prototype = Object.create(null);

	nullObject = {
	  NullObject
	};
	return nullObject;
}

var handlerStorage;
var hasRequiredHandlerStorage;

function requireHandlerStorage () {
	if (hasRequiredHandlerStorage) return handlerStorage;
	hasRequiredHandlerStorage = 1;

	const { NullObject } = requireNullObject();
	const httpMethodStrategy = requireHttpMethod();

	class HandlerStorage {
	  constructor () {
	    this.unconstrainedHandler = null; // optimized reference to the handler that will match most of the time
	    this.constraints = [];
	    this.handlers = []; // unoptimized list of handler objects for which the fast matcher function will be compiled
	    this.constrainedHandlerStores = null;
	  }

	  // This is the hot path for node handler finding -- change with care!
	  getMatchingHandler (derivedConstraints) {
	    if (derivedConstraints === undefined) {
	      return this.unconstrainedHandler
	    }
	    return this._getHandlerMatchingConstraints(derivedConstraints)
	  }

	  addHandler (constrainer, route) {
	    const params = route.params;
	    const constraints = route.opts.constraints || {};

	    const handlerObject = {
	      params,
	      constraints,
	      handler: route.handler,
	      store: route.store || null,
	      _createParamsObject: this._compileCreateParamsObject(params)
	    };

	    const constraintsNames = Object.keys(constraints);
	    if (constraintsNames.length === 0) {
	      this.unconstrainedHandler = handlerObject;
	    }

	    for (const constraint of constraintsNames) {
	      if (!this.constraints.includes(constraint)) {
	        if (constraint === 'version') {
	          // always check the version constraint first as it is the most selective
	          this.constraints.unshift(constraint);
	        } else {
	          this.constraints.push(constraint);
	        }
	      }
	    }

	    const isMergedTree = constraintsNames.includes(httpMethodStrategy.name);
	    if (!isMergedTree && this.handlers.length >= 31) {
	      throw new Error('find-my-way supports a maximum of 31 route handlers per node when there are constraints, limit reached')
	    }

	    this.handlers.push(handlerObject);
	    // Sort the most constrained handlers to the front of the list of handlers so they are tested first.
	    this.handlers.sort((a, b) => Object.keys(a.constraints).length - Object.keys(b.constraints).length);

	    if (!isMergedTree) {
	      this._compileGetHandlerMatchingConstraints(constrainer, constraints);
	    }
	  }

	  _compileCreateParamsObject (params) {
	    const fnBody = [];

	    fnBody.push('const fn = function _createParamsObject (paramsArray) {');

	    fnBody.push('const params = new NullObject()');
	    for (let i = 0; i < params.length; i++) {
	      fnBody.push(`params['${params[i]}'] = paramsArray[${i}]`);
	    }
	    fnBody.push('return params');
	    fnBody.push('}');

	    fnBody.push('return fn');

	    return new Function('NullObject', fnBody.join('\n'))(NullObject)  // eslint-disable-line
	  }

	  _getHandlerMatchingConstraints () {
	    return null
	  }

	  // Builds a store object that maps from constraint values to a bitmap of handler indexes which pass the constraint for a value
	  // So for a host constraint, this might look like { "fastify.io": 0b0010, "google.ca": 0b0101 }, meaning the 3rd handler is constrainted to fastify.io, and the 2nd and 4th handlers are constrained to google.ca.
	  // The store's implementation comes from the strategies provided to the Router.
	  _buildConstraintStore (store, constraint) {
	    for (let i = 0; i < this.handlers.length; i++) {
	      const handler = this.handlers[i];
	      const constraintValue = handler.constraints[constraint];
	      if (constraintValue !== undefined) {
	        let indexes = store.get(constraintValue) || 0;
	        indexes |= 1 << i; // set the i-th bit for the mask because this handler is constrained by this value https://stackoverflow.com/questions/1436438/how-do-you-set-clear-and-toggle-a-single-bit-in-javascrip
	        store.set(constraintValue, indexes);
	      }
	    }
	  }

	  // Builds a bitmask for a given constraint that has a bit for each handler index that is 0 when that handler *is* constrained and 1 when the handler *isnt* constrainted. This is opposite to what might be obvious, but is just for convienience when doing the bitwise operations.
	  _constrainedIndexBitmask (constraint) {
	    let mask = 0;
	    for (let i = 0; i < this.handlers.length; i++) {
	      const handler = this.handlers[i];
	      const constraintValue = handler.constraints[constraint];
	      if (constraintValue !== undefined) {
	        mask |= 1 << i;
	      }
	    }
	    return ~mask
	  }

	  // Compile a fast function to match the handlers for this node
	  // The function implements a general case multi-constraint matching algorithm.
	  // The general idea is this: we have a bunch of handlers, each with a potentially different set of constraints, and sometimes none at all. We're given a list of constraint values and we have to use the constraint-value-comparison strategies to see which handlers match the constraint values passed in.
	  // We do this by asking each constraint store which handler indexes match the given constraint value for each store. Trickily, the handlers that a store says match are the handlers constrained by that store, but handlers that aren't constrained at all by that store could still match just fine. So, each constraint store can only describe matches for it, and it won't have any bearing on the handlers it doesn't care about. For this reason, we have to ask each stores which handlers match and track which have been matched (or not cared about) by all of them.
	  // We use bitmaps to represent these lists of matches so we can use bitwise operations to implement this efficiently. Bitmaps are cheap to allocate, let us implement this masking behaviour in one CPU instruction, and are quite compact in memory. We start with a bitmap set to all 1s representing every handler that is a match candidate, and then for each constraint, see which handlers match using the store, and then mask the result by the mask of handlers that that store applies to, and bitwise AND with the candidate list. Phew.
	  // We consider all this compiling function complexity to be worth it, because the naive implementation that just loops over the handlers asking which stores match is quite a bit slower.
	  _compileGetHandlerMatchingConstraints (constrainer) {
	    this.constrainedHandlerStores = {};

	    for (const constraint of this.constraints) {
	      const store = constrainer.newStoreForConstraint(constraint);
	      this.constrainedHandlerStores[constraint] = store;

	      this._buildConstraintStore(store, constraint);
	    }

	    const lines = [];
	    lines.push(`
    let candidates = ${(1 << this.handlers.length) - 1}
    let mask, matches
    `);
	    for (const constraint of this.constraints) {
	      // Setup the mask for indexes this constraint applies to. The mask bits are set to 1 for each position if the constraint applies.
	      lines.push(`
      mask = ${this._constrainedIndexBitmask(constraint)}
      value = derivedConstraints.${constraint}
      `);

	      // If there's no constraint value, none of the handlers constrained by this constraint can match. Remove them from the candidates.
	      // If there is a constraint value, get the matching indexes bitmap from the store, and mask it down to only the indexes this constraint applies to, and then bitwise and with the candidates list to leave only matching candidates left.
	      const strategy = constrainer.strategies[constraint];
	      const matchMask = strategy.mustMatchWhenDerived ? 'matches' : '(matches | mask)';

	      lines.push(`
      if (value === undefined) {
        candidates &= mask
      } else {
        matches = this.constrainedHandlerStores.${constraint}.get(value) || 0
        candidates &= ${matchMask}
      }
      if (candidates === 0) return null;
      `);
	    }

	    // There are some constraints that can be derived and marked as "must match", where if they are derived, they only match routes that actually have a constraint on the value, like the SemVer version constraint.
	    // An example: a request comes in for version 1.x, and this node has a handler that matches the path, but there's no version constraint. For SemVer, the find-my-way semantics do not match this handler to that request.
	    // This function is used by Nodes with handlers to match when they don't have any constrained routes to exclude request that do have must match derived constraints present.
	    for (const constraint in constrainer.strategies) {
	      const strategy = constrainer.strategies[constraint];
	      if (strategy.mustMatchWhenDerived && !this.constraints.includes(constraint)) {
	        lines.push(`if (derivedConstraints.${constraint} !== undefined) return null`);
	      }
	    }

	    // Return the first handler who's bit is set in the candidates https://stackoverflow.com/questions/18134985/how-to-find-index-of-first-set-bit
	    lines.push('return this.handlers[Math.floor(Math.log2(candidates))]');

	    this._getHandlerMatchingConstraints = new Function('derivedConstraints', lines.join('\n')); // eslint-disable-line
	  }
	}

	handlerStorage = HandlerStorage;
	return handlerStorage;
}

var node;
var hasRequiredNode;

function requireNode () {
	if (hasRequiredNode) return node;
	hasRequiredNode = 1;

	const HandlerStorage = requireHandlerStorage();

	const NODE_TYPES = {
	  STATIC: 0,
	  PARAMETRIC: 1,
	  WILDCARD: 2
	};

	class Node {
	  constructor () {
	    this.isLeafNode = false;
	    this.routes = null;
	    this.handlerStorage = null;
	  }

	  addRoute (route, constrainer) {
	    if (this.routes === null) {
	      this.routes = [];
	    }
	    if (this.handlerStorage === null) {
	      this.handlerStorage = new HandlerStorage();
	    }
	    this.isLeafNode = true;
	    this.routes.push(route);
	    this.handlerStorage.addHandler(constrainer, route);
	  }
	}

	class ParentNode extends Node {
	  constructor () {
	    super();
	    this.staticChildren = {};
	  }

	  findStaticMatchingChild (path, pathIndex) {
	    const staticChild = this.staticChildren[path.charAt(pathIndex)];
	    if (staticChild === undefined || !staticChild.matchPrefix(path, pathIndex)) {
	      return null
	    }
	    return staticChild
	  }

	  getStaticChild (path, pathIndex = 0) {
	    if (path.length === pathIndex) {
	      return this
	    }

	    const staticChild = this.findStaticMatchingChild(path, pathIndex);
	    if (staticChild) {
	      return staticChild.getStaticChild(path, pathIndex + staticChild.prefix.length)
	    }

	    return null
	  }

	  createStaticChild (path) {
	    if (path.length === 0) {
	      return this
	    }

	    let staticChild = this.staticChildren[path.charAt(0)];
	    if (staticChild) {
	      let i = 1;
	      for (; i < staticChild.prefix.length; i++) {
	        if (path.charCodeAt(i) !== staticChild.prefix.charCodeAt(i)) {
	          staticChild = staticChild.split(this, i);
	          break
	        }
	      }
	      return staticChild.createStaticChild(path.slice(i))
	    }

	    const label = path.charAt(0);
	    this.staticChildren[label] = new StaticNode(path);
	    return this.staticChildren[label]
	  }
	}

	class StaticNode extends ParentNode {
	  constructor (prefix) {
	    super();
	    this.prefix = prefix;
	    this.wildcardChild = null;
	    this.parametricChildren = [];
	    this.kind = NODE_TYPES.STATIC;
	    this._compilePrefixMatch();
	  }

	  getParametricChild (regex) {
	    const regexpSource = regex && regex.source;

	    const parametricChild = this.parametricChildren.find(child => {
	      const childRegexSource = child.regex && child.regex.source;
	      return childRegexSource === regexpSource
	    });

	    if (parametricChild) {
	      return parametricChild
	    }

	    return null
	  }

	  createParametricChild (regex, staticSuffix, nodePath) {
	    let parametricChild = this.getParametricChild(regex);
	    if (parametricChild) {
	      parametricChild.nodePaths.add(nodePath);
	      return parametricChild
	    }

	    parametricChild = new ParametricNode(regex, staticSuffix, nodePath);
	    this.parametricChildren.push(parametricChild);
	    this.parametricChildren.sort((child1, child2) => {
	      if (!child1.isRegex) return 1
	      if (!child2.isRegex) return -1

	      if (child1.staticSuffix === null) return 1
	      if (child2.staticSuffix === null) return -1

	      if (child2.staticSuffix.endsWith(child1.staticSuffix)) return 1
	      if (child1.staticSuffix.endsWith(child2.staticSuffix)) return -1

	      return 0
	    });

	    return parametricChild
	  }

	  getWildcardChild () {
	    return this.wildcardChild
	  }

	  createWildcardChild () {
	    this.wildcardChild = this.getWildcardChild() || new WildcardNode();
	    return this.wildcardChild
	  }

	  split (parentNode, length) {
	    const parentPrefix = this.prefix.slice(0, length);
	    const childPrefix = this.prefix.slice(length);

	    this.prefix = childPrefix;
	    this._compilePrefixMatch();

	    const staticNode = new StaticNode(parentPrefix);
	    staticNode.staticChildren[childPrefix.charAt(0)] = this;
	    parentNode.staticChildren[parentPrefix.charAt(0)] = staticNode;

	    return staticNode
	  }

	  getNextNode (path, pathIndex, nodeStack, paramsCount) {
	    let node = this.findStaticMatchingChild(path, pathIndex);
	    let parametricBrotherNodeIndex = 0;

	    if (node === null) {
	      if (this.parametricChildren.length === 0) {
	        return this.wildcardChild
	      }

	      node = this.parametricChildren[0];
	      parametricBrotherNodeIndex = 1;
	    }

	    if (this.wildcardChild !== null) {
	      nodeStack.push({
	        paramsCount,
	        brotherPathIndex: pathIndex,
	        brotherNode: this.wildcardChild
	      });
	    }

	    for (let i = this.parametricChildren.length - 1; i >= parametricBrotherNodeIndex; i--) {
	      nodeStack.push({
	        paramsCount,
	        brotherPathIndex: pathIndex,
	        brotherNode: this.parametricChildren[i]
	      });
	    }

	    return node
	  }

	  _compilePrefixMatch () {
	    if (this.prefix.length === 1) {
	      this.matchPrefix = () => true;
	      return
	    }

	    const lines = [];
	    for (let i = 1; i < this.prefix.length; i++) {
	      const charCode = this.prefix.charCodeAt(i);
	      lines.push(`path.charCodeAt(i + ${i}) === ${charCode}`);
	    }
	    this.matchPrefix = new Function('path', 'i', `return ${lines.join(' && ')}`); // eslint-disable-line
	  }
	}

	class ParametricNode extends ParentNode {
	  constructor (regex, staticSuffix, nodePath) {
	    super();
	    this.isRegex = !!regex;
	    this.regex = regex || null;
	    this.staticSuffix = staticSuffix || null;
	    this.kind = NODE_TYPES.PARAMETRIC;

	    this.nodePaths = new Set([nodePath]);
	  }

	  getNextNode (path, pathIndex) {
	    return this.findStaticMatchingChild(path, pathIndex)
	  }
	}

	class WildcardNode extends Node {
	  constructor () {
	    super();
	    this.kind = NODE_TYPES.WILDCARD;
	  }

	  getNextNode () {
	    return null
	  }
	}

	node = { StaticNode, ParametricNode, WildcardNode, NODE_TYPES };
	return node;
}

var acceptVersion;
var hasRequiredAcceptVersion;

function requireAcceptVersion () {
	if (hasRequiredAcceptVersion) return acceptVersion;
	hasRequiredAcceptVersion = 1;

	const assert = require$$0$9;

	function SemVerStore () {
	  if (!(this instanceof SemVerStore)) {
	    return new SemVerStore()
	  }

	  this.store = new Map();
	  this.maxMajor = 0;
	  this.maxMinors = {};
	  this.maxPatches = {};
	}

	SemVerStore.prototype.set = function (version, store) {
	  if (typeof version !== 'string') {
	    throw new TypeError('Version should be a string')
	  }
	  let [major, minor, patch] = version.split('.', 3);

	  if (isNaN(major)) {
	    throw new TypeError('Major version must be a numeric value')
	  }

	  major = Number(major);
	  minor = Number(minor) || 0;
	  patch = Number(patch) || 0;

	  if (major >= this.maxMajor) {
	    this.maxMajor = major;
	    this.store.set('x', store);
	    this.store.set('*', store);
	    this.store.set('x.x', store);
	    this.store.set('x.x.x', store);
	  }

	  if (minor >= (this.maxMinors[major] || 0)) {
	    this.maxMinors[major] = minor;
	    this.store.set(`${major}.x`, store);
	    this.store.set(`${major}.x.x`, store);
	  }

	  if (patch >= (this.maxPatches[`${major}.${minor}`] || 0)) {
	    this.maxPatches[`${major}.${minor}`] = patch;
	    this.store.set(`${major}.${minor}.x`, store);
	  }

	  this.store.set(`${major}.${minor}.${patch}`, store);
	  return this
	};

	SemVerStore.prototype.get = function (version) {
	  return this.store.get(version)
	};

	acceptVersion = {
	  name: 'version',
	  mustMatchWhenDerived: true,
	  storage: SemVerStore,
	  validate (value) {
	    assert(typeof value === 'string', 'Version should be a string');
	  }
	};
	return acceptVersion;
}

var acceptHost;
var hasRequiredAcceptHost;

function requireAcceptHost () {
	if (hasRequiredAcceptHost) return acceptHost;
	hasRequiredAcceptHost = 1;
	const assert = require$$0$9;

	function HostStorage () {
	  const hosts = new Map();
	  const regexHosts = [];
	  return {
	    get: (host) => {
	      const exact = hosts.get(host);
	      if (exact) {
	        return exact
	      }
	      for (const regex of regexHosts) {
	        if (regex.host.test(host)) {
	          return regex.value
	        }
	      }
	    },
	    set: (host, value) => {
	      if (host instanceof RegExp) {
	        regexHosts.push({ host, value });
	      } else {
	        hosts.set(host, value);
	      }
	    }
	  }
	}

	acceptHost = {
	  name: 'host',
	  mustMatchWhenDerived: false,
	  storage: HostStorage,
	  validate (value) {
	    assert(typeof value === 'string' || Object.prototype.toString.call(value) === '[object RegExp]', 'Host should be a string or a RegExp');
	  }
	};
	return acceptHost;
}

var constrainer;
var hasRequiredConstrainer;

function requireConstrainer () {
	if (hasRequiredConstrainer) return constrainer;
	hasRequiredConstrainer = 1;

	const acceptVersionStrategy = requireAcceptVersion();
	const acceptHostStrategy = requireAcceptHost();
	const assert = require$$0$9;

	class Constrainer {
	  constructor (customStrategies) {
	    this.strategies = {
	      version: acceptVersionStrategy,
	      host: acceptHostStrategy
	    };

	    this.strategiesInUse = new Set();
	    this.asyncStrategiesInUse = new Set();

	    // validate and optimize prototypes of given custom strategies
	    if (customStrategies) {
	      for (const strategy of Object.values(customStrategies)) {
	        this.addConstraintStrategy(strategy);
	      }
	    }
	  }

	  isStrategyUsed (strategyName) {
	    return this.strategiesInUse.has(strategyName) ||
	      this.asyncStrategiesInUse.has(strategyName)
	  }

	  hasConstraintStrategy (strategyName) {
	    const customConstraintStrategy = this.strategies[strategyName];
	    if (customConstraintStrategy !== undefined) {
	      return customConstraintStrategy.isCustom ||
	        this.isStrategyUsed(strategyName)
	    }
	    return false
	  }

	  addConstraintStrategy (strategy) {
	    assert(typeof strategy.name === 'string' && strategy.name !== '', 'strategy.name is required.');
	    assert(strategy.storage && typeof strategy.storage === 'function', 'strategy.storage function is required.');
	    assert(strategy.deriveConstraint && typeof strategy.deriveConstraint === 'function', 'strategy.deriveConstraint function is required.');

	    if (this.strategies[strategy.name] && this.strategies[strategy.name].isCustom) {
	      throw new Error(`There already exists a custom constraint with the name ${strategy.name}.`)
	    }

	    if (this.isStrategyUsed(strategy.name)) {
	      throw new Error(`There already exists a route with ${strategy.name} constraint.`)
	    }

	    strategy.isCustom = true;
	    strategy.isAsync = strategy.deriveConstraint.length === 3;
	    this.strategies[strategy.name] = strategy;

	    if (strategy.mustMatchWhenDerived) {
	      this.noteUsage({ [strategy.name]: strategy });
	    }
	  }

	  deriveConstraints (req, ctx, done) {
	    const constraints = this.deriveSyncConstraints(req, ctx);

	    if (done === undefined) {
	      return constraints
	    }

	    this.deriveAsyncConstraints(constraints, req, ctx, done);
	  }

	  deriveSyncConstraints (req, ctx) {
	    return undefined
	  }

	  // When new constraints start getting used, we need to rebuild the deriver to derive them. Do so if we see novel constraints used.
	  noteUsage (constraints) {
	    if (constraints) {
	      const beforeSize = this.strategiesInUse.size;
	      for (const key in constraints) {
	        const strategy = this.strategies[key];
	        if (strategy.isAsync) {
	          this.asyncStrategiesInUse.add(key);
	        } else {
	          this.strategiesInUse.add(key);
	        }
	      }
	      if (beforeSize !== this.strategiesInUse.size) {
	        this._buildDeriveConstraints();
	      }
	    }
	  }

	  newStoreForConstraint (constraint) {
	    if (!this.strategies[constraint]) {
	      throw new Error(`No strategy registered for constraint key ${constraint}`)
	    }
	    return this.strategies[constraint].storage()
	  }

	  validateConstraints (constraints) {
	    for (const key in constraints) {
	      const value = constraints[key];
	      if (typeof value === 'undefined') {
	        throw new Error('Can\'t pass an undefined constraint value, must pass null or no key at all')
	      }
	      const strategy = this.strategies[key];
	      if (!strategy) {
	        throw new Error(`No strategy registered for constraint key ${key}`)
	      }
	      if (strategy.validate) {
	        strategy.validate(value);
	      }
	    }
	  }

	  deriveAsyncConstraints (constraints, req, ctx, done) {
	    let asyncConstraintsCount = this.asyncStrategiesInUse.size;

	    if (asyncConstraintsCount === 0) {
	      done(null, constraints);
	      return
	    }

	    constraints = constraints || {};
	    for (const key of this.asyncStrategiesInUse) {
	      const strategy = this.strategies[key];
	      strategy.deriveConstraint(req, ctx, (err, constraintValue) => {
	        if (err !== null) {
	          done(err);
	          return
	        }

	        constraints[key] = constraintValue;

	        if (--asyncConstraintsCount === 0) {
	          done(null, constraints);
	        }
	      });
	    }
	  }

	  // Optimization: build a fast function for deriving the constraints for all the strategies at once. We inline the definitions of the version constraint and the host constraint for performance.
	  // If no constraining strategies are in use (no routes constrain on host, or version, or any custom strategies) then we don't need to derive constraints for each route match, so don't do anything special, and just return undefined
	  // This allows us to not allocate an object to hold constraint values if no constraints are defined.
	  _buildDeriveConstraints () {
	    if (this.strategiesInUse.size === 0) return

	    const lines = ['return {'];

	    for (const key of this.strategiesInUse) {
	      const strategy = this.strategies[key];
	      // Optimization: inline the derivation for the common built in constraints
	      if (!strategy.isCustom) {
	        if (key === 'version') {
	          lines.push('   version: req.headers[\'accept-version\'],');
	        } else {
	          lines.push('   host: req.headers.host || req.headers[\':authority\'],');
	        }
	      } else {
	        lines.push(`  ${strategy.name}: this.strategies.${key}.deriveConstraint(req, ctx),`);
	      }
	    }

	    lines.push('}');

	    this.deriveSyncConstraints = new Function('req', 'ctx', lines.join('\n')).bind(this); // eslint-disable-line
	  }
	}

	constrainer = Constrainer;
	return constrainer;
}

var httpMethods_1;
var hasRequiredHttpMethods;

function requireHttpMethods () {
	if (hasRequiredHttpMethods) return httpMethods_1;
	hasRequiredHttpMethods = 1;

	// defined by Node.js http module, a snapshot from Node.js 22.9.0
	const httpMethods = [
	  'ACL', 'BIND', 'CHECKOUT', 'CONNECT', 'COPY', 'DELETE',
	  'GET', 'HEAD', 'LINK', 'LOCK', 'M-SEARCH', 'MERGE',
	  'MKACTIVITY', 'MKCALENDAR', 'MKCOL', 'MOVE', 'NOTIFY', 'OPTIONS',
	  'PATCH', 'POST', 'PROPFIND', 'PROPPATCH', 'PURGE', 'PUT', 'QUERY',
	  'REBIND', 'REPORT', 'SEARCH', 'SOURCE', 'SUBSCRIBE', 'TRACE',
	  'UNBIND', 'UNLINK', 'UNLOCK', 'UNSUBSCRIBE'
	];

	httpMethods_1 = httpMethods;
	return httpMethods_1;
}

var urlSanitizer;
var hasRequiredUrlSanitizer;

function requireUrlSanitizer () {
	if (hasRequiredUrlSanitizer) return urlSanitizer;
	hasRequiredUrlSanitizer = 1;

	// It must spot all the chars where decodeURIComponent(x) !== decodeURI(x)
	// The chars are: # $ & + , / : ; = ? @
	function decodeComponentChar (highCharCode, lowCharCode) {
	  if (highCharCode === 50) {
	    if (lowCharCode === 53) return '%'

	    if (lowCharCode === 51) return '#'
	    if (lowCharCode === 52) return '$'
	    if (lowCharCode === 54) return '&'
	    if (lowCharCode === 66) return '+'
	    if (lowCharCode === 98) return '+'
	    if (lowCharCode === 67) return ','
	    if (lowCharCode === 99) return ','
	    if (lowCharCode === 70) return '/'
	    if (lowCharCode === 102) return '/'
	    return null
	  }
	  if (highCharCode === 51) {
	    if (lowCharCode === 65) return ':'
	    if (lowCharCode === 97) return ':'
	    if (lowCharCode === 66) return ';'
	    if (lowCharCode === 98) return ';'
	    if (lowCharCode === 68) return '='
	    if (lowCharCode === 100) return '='
	    if (lowCharCode === 70) return '?'
	    if (lowCharCode === 102) return '?'
	    return null
	  }
	  if (highCharCode === 52 && lowCharCode === 48) {
	    return '@'
	  }
	  return null
	}

	function safeDecodeURI (path, useSemicolonDelimiter) {
	  let shouldDecode = false;
	  let shouldDecodeParam = false;

	  let querystring = '';

	  for (let i = 1; i < path.length; i++) {
	    const charCode = path.charCodeAt(i);

	    if (charCode === 37) {
	      const highCharCode = path.charCodeAt(i + 1);
	      const lowCharCode = path.charCodeAt(i + 2);

	      if (decodeComponentChar(highCharCode, lowCharCode) === null) {
	        shouldDecode = true;
	      } else {
	        shouldDecodeParam = true;
	        // %25 - encoded % char. We need to encode one more time to prevent double decoding
	        if (highCharCode === 50 && lowCharCode === 53) {
	          shouldDecode = true;
	          path = path.slice(0, i + 1) + '25' + path.slice(i + 1);
	          i += 2;
	        }
	        i += 2;
	      }
	    // Some systems do not follow RFC and separate the path and query
	    // string with a `;` character (code 59), e.g. `/foo;jsessionid=123456`.
	    // Thus, we need to split on `;` as well as `?` and `#` if the useSemicolonDelimiter option is enabled.
	    } else if (charCode === 63 || charCode === 35 || (charCode === 59 && useSemicolonDelimiter)) {
	      querystring = path.slice(i + 1);
	      path = path.slice(0, i);
	      break
	    }
	  }
	  const decodedPath = shouldDecode ? decodeURI(path) : path;
	  return { path: decodedPath, querystring, shouldDecodeParam }
	}

	function safeDecodeURIComponent (uriComponent) {
	  const startIndex = uriComponent.indexOf('%');
	  if (startIndex === -1) return uriComponent

	  let decoded = '';
	  let lastIndex = startIndex;

	  for (let i = startIndex; i < uriComponent.length; i++) {
	    if (uriComponent.charCodeAt(i) === 37) {
	      const highCharCode = uriComponent.charCodeAt(i + 1);
	      const lowCharCode = uriComponent.charCodeAt(i + 2);

	      const decodedChar = decodeComponentChar(highCharCode, lowCharCode);
	      decoded += uriComponent.slice(lastIndex, i) + decodedChar;

	      lastIndex = i + 3;
	    }
	  }
	  return uriComponent.slice(0, startIndex) + decoded + uriComponent.slice(lastIndex)
	}

	urlSanitizer = { safeDecodeURI, safeDecodeURIComponent };
	return urlSanitizer;
}

var findMyWay;
var hasRequiredFindMyWay;

function requireFindMyWay () {
	if (hasRequiredFindMyWay) return findMyWay;
	hasRequiredFindMyWay = 1;

	/*
	  Char codes:
	    '!': 33 - !
	    '#': 35 - %23
	    '$': 36 - %24
	    '%': 37 - %25
	    '&': 38 - %26
	    ''': 39 - '
	    '(': 40 - (
	    ')': 41 - )
	    '*': 42 - *
	    '+': 43 - %2B
	    ',': 44 - %2C
	    '-': 45 - -
	    '.': 46 - .
	    '/': 47 - %2F
	    ':': 58 - %3A
	    ';': 59 - %3B
	    '=': 61 - %3D
	    '?': 63 - %3F
	    '@': 64 - %40
	    '_': 95 - _
	    '~': 126 - ~
	*/

	const assert = require$$0$9;
	const querystring = requireLib$1();
	const isRegexSafe = requireSafeRegex2();
	const deepEqual = requireFastDeepEqual();
	const { prettyPrintTree } = requirePrettyPrint();
	const { StaticNode, NODE_TYPES } = requireNode();
	const Constrainer = requireConstrainer();
	const httpMethods = requireHttpMethods();
	const httpMethodStrategy = requireHttpMethod();
	const { safeDecodeURI, safeDecodeURIComponent } = requireUrlSanitizer();

	const FULL_PATH_REGEXP = /^https?:\/\/.*?\//;
	const OPTIONAL_PARAM_REGEXP = /(\/:[^/()]*?)\?(\/?)/;
	const ESCAPE_REGEXP = /[.*+?^${}()|[\]\\]/g;
	const REMOVE_DUPLICATE_SLASHES_REGEXP = /\/\/+/g;

	if (!isRegexSafe(FULL_PATH_REGEXP)) {
	  throw new Error('the FULL_PATH_REGEXP is not safe, update this module')
	}

	if (!isRegexSafe(OPTIONAL_PARAM_REGEXP)) {
	  throw new Error('the OPTIONAL_PARAM_REGEXP is not safe, update this module')
	}

	if (!isRegexSafe(ESCAPE_REGEXP)) {
	  throw new Error('the ESCAPE_REGEXP is not safe, update this module')
	}

	if (!isRegexSafe(REMOVE_DUPLICATE_SLASHES_REGEXP)) {
	  throw new Error('the REMOVE_DUPLICATE_SLASHES_REGEXP is not safe, update this module')
	}

	function Router (opts) {
	  if (!(this instanceof Router)) {
	    return new Router(opts)
	  }
	  opts = opts || {};
	  this._opts = opts;

	  if (opts.defaultRoute) {
	    assert(typeof opts.defaultRoute === 'function', 'The default route must be a function');
	    this.defaultRoute = opts.defaultRoute;
	  } else {
	    this.defaultRoute = null;
	  }

	  if (opts.onBadUrl) {
	    assert(typeof opts.onBadUrl === 'function', 'The bad url handler must be a function');
	    this.onBadUrl = opts.onBadUrl;
	  } else {
	    this.onBadUrl = null;
	  }

	  if (opts.buildPrettyMeta) {
	    assert(typeof opts.buildPrettyMeta === 'function', 'buildPrettyMeta must be a function');
	    this.buildPrettyMeta = opts.buildPrettyMeta;
	  } else {
	    this.buildPrettyMeta = defaultBuildPrettyMeta;
	  }

	  if (opts.querystringParser) {
	    assert(typeof opts.querystringParser === 'function', 'querystringParser must be a function');
	    this.querystringParser = opts.querystringParser;
	  } else {
	    this.querystringParser = (query) => query.length === 0 ? {} : querystring.parse(query);
	  }

	  this.caseSensitive = opts.caseSensitive === undefined ? true : opts.caseSensitive;
	  this.ignoreTrailingSlash = opts.ignoreTrailingSlash || false;
	  this.ignoreDuplicateSlashes = opts.ignoreDuplicateSlashes || false;
	  this.maxParamLength = opts.maxParamLength || 100;
	  this.allowUnsafeRegex = opts.allowUnsafeRegex || false;
	  this.constrainer = new Constrainer(opts.constraints);
	  this.useSemicolonDelimiter = opts.useSemicolonDelimiter || false;

	  this.routes = [];
	  this.trees = {};
	}

	Router.prototype.on = function on (method, path, opts, handler, store) {
	  if (typeof opts === 'function') {
	    if (handler !== undefined) {
	      store = handler;
	    }
	    handler = opts;
	    opts = {};
	  }
	  // path validation
	  assert(typeof path === 'string', 'Path should be a string');
	  assert(path.length > 0, 'The path could not be empty');
	  assert(path[0] === '/' || path[0] === '*', 'The first character of a path should be `/` or `*`');
	  // handler validation
	  assert(typeof handler === 'function', 'Handler should be a function');

	  // path ends with optional parameter
	  const optionalParamMatch = path.match(OPTIONAL_PARAM_REGEXP);
	  if (optionalParamMatch) {
	    assert(path.length === optionalParamMatch.index + optionalParamMatch[0].length, 'Optional Parameter needs to be the last parameter of the path');

	    const pathFull = path.replace(OPTIONAL_PARAM_REGEXP, '$1$2');
	    const pathOptional = path.replace(OPTIONAL_PARAM_REGEXP, '$2') || '/';

	    this.on(method, pathFull, opts, handler, store);
	    this.on(method, pathOptional, opts, handler, store);
	    return
	  }

	  const route = path;

	  if (this.ignoreDuplicateSlashes) {
	    path = removeDuplicateSlashes(path);
	  }

	  if (this.ignoreTrailingSlash) {
	    path = trimLastSlash(path);
	  }

	  const methods = Array.isArray(method) ? method : [method];
	  for (const method of methods) {
	    assert(typeof method === 'string', 'Method should be a string');
	    assert(httpMethods.includes(method), `Method '${method}' is not an http method.`);
	    this._on(method, path, opts, handler, store, route);
	  }
	};

	Router.prototype._on = function _on (method, path, opts, handler, store) {
	  let constraints = {};
	  if (opts.constraints !== undefined) {
	    assert(typeof opts.constraints === 'object' && opts.constraints !== null, 'Constraints should be an object');
	    if (Object.keys(opts.constraints).length !== 0) {
	      constraints = opts.constraints;
	    }
	  }

	  this.constrainer.validateConstraints(constraints);
	  // Let the constrainer know if any constraints are being used now
	  this.constrainer.noteUsage(constraints);

	  // Boot the tree for this method if it doesn't exist yet
	  if (this.trees[method] === undefined) {
	    this.trees[method] = new StaticNode('/');
	  }

	  let pattern = path;
	  if (pattern === '*' && this.trees[method].prefix.length !== 0) {
	    const currentRoot = this.trees[method];
	    this.trees[method] = new StaticNode('');
	    this.trees[method].staticChildren['/'] = currentRoot;
	  }

	  let currentNode = this.trees[method];
	  let parentNodePathIndex = currentNode.prefix.length;

	  const params = [];
	  for (let i = 0; i <= pattern.length; i++) {
	    if (pattern.charCodeAt(i) === 58 && pattern.charCodeAt(i + 1) === 58) {
	      // It's a double colon
	      i++;
	      continue
	    }

	    const isParametricNode = pattern.charCodeAt(i) === 58 && pattern.charCodeAt(i + 1) !== 58;
	    const isWildcardNode = pattern.charCodeAt(i) === 42;

	    if (isParametricNode || isWildcardNode || (i === pattern.length && i !== parentNodePathIndex)) {
	      let staticNodePath = pattern.slice(parentNodePathIndex, i);
	      if (!this.caseSensitive) {
	        staticNodePath = staticNodePath.toLowerCase();
	      }
	      staticNodePath = staticNodePath.replaceAll('::', ':');
	      staticNodePath = staticNodePath.replaceAll('%', '%25');
	      // add the static part of the route to the tree
	      currentNode = currentNode.createStaticChild(staticNodePath);
	    }

	    if (isParametricNode) {
	      let isRegexNode = false;
	      let isParamSafe = true;
	      let backtrack = '';
	      const regexps = [];

	      let lastParamStartIndex = i + 1;
	      for (let j = lastParamStartIndex; ; j++) {
	        const charCode = pattern.charCodeAt(j);

	        const isRegexParam = charCode === 40;
	        const isStaticPart = charCode === 45 || charCode === 46;
	        const isEndOfNode = charCode === 47 || j === pattern.length;

	        if (isRegexParam || isStaticPart || isEndOfNode) {
	          const paramName = pattern.slice(lastParamStartIndex, j);
	          params.push(paramName);

	          isRegexNode = isRegexNode || isRegexParam || isStaticPart;

	          if (isRegexParam) {
	            const endOfRegexIndex = getClosingParenthensePosition(pattern, j);
	            const regexString = pattern.slice(j, endOfRegexIndex + 1);

	            if (!this.allowUnsafeRegex) {
	              assert(isRegexSafe(new RegExp(regexString)), `The regex '${regexString}' is not safe!`);
	            }

	            regexps.push(trimRegExpStartAndEnd(regexString));

	            j = endOfRegexIndex + 1;
	            isParamSafe = true;
	          } else {
	            regexps.push(isParamSafe ? '(.*?)' : `(${backtrack}|(?:(?!${backtrack}).)*)`);
	            isParamSafe = false;
	          }

	          const staticPartStartIndex = j;
	          for (; j < pattern.length; j++) {
	            const charCode = pattern.charCodeAt(j);
	            if (charCode === 47) break
	            if (charCode === 58) {
	              const nextCharCode = pattern.charCodeAt(j + 1);
	              if (nextCharCode === 58) j++;
	              else break
	            }
	          }

	          let staticPart = pattern.slice(staticPartStartIndex, j);
	          if (staticPart) {
	            staticPart = staticPart.replaceAll('::', ':');
	            staticPart = staticPart.replaceAll('%', '%25');
	            regexps.push(backtrack = escapeRegExp(staticPart));
	          }

	          lastParamStartIndex = j + 1;

	          if (isEndOfNode || pattern.charCodeAt(j) === 47 || j === pattern.length) {
	            const nodePattern = isRegexNode ? '()' + staticPart : staticPart;
	            const nodePath = pattern.slice(i, j);

	            pattern = pattern.slice(0, i + 1) + nodePattern + pattern.slice(j);
	            i += nodePattern.length;

	            const regex = isRegexNode ? new RegExp('^' + regexps.join('') + '$') : null;
	            currentNode = currentNode.createParametricChild(regex, staticPart || null, nodePath);
	            parentNodePathIndex = i + 1;
	            break
	          }
	        }
	      }
	    } else if (isWildcardNode) {
	      // add the wildcard parameter
	      params.push('*');
	      currentNode = currentNode.createWildcardChild();
	      parentNodePathIndex = i + 1;

	      if (i !== pattern.length - 1) {
	        throw new Error('Wildcard must be the last character in the route')
	      }
	    }
	  }

	  if (!this.caseSensitive) {
	    pattern = pattern.toLowerCase();
	  }

	  if (pattern === '*') {
	    pattern = '/*';
	  }

	  for (const existRoute of this.routes) {
	    const routeConstraints = existRoute.opts.constraints || {};
	    if (
	      existRoute.method === method &&
	      existRoute.pattern === pattern &&
	      deepEqual(routeConstraints, constraints)
	    ) {
	      throw new Error(`Method '${method}' already declared for route '${pattern}' with constraints '${JSON.stringify(constraints)}'`)
	    }
	  }

	  const route = { method, path, pattern, params, opts, handler, store };
	  this.routes.push(route);
	  currentNode.addRoute(route, this.constrainer);
	};

	Router.prototype.hasRoute = function hasRoute (method, path, constraints) {
	  const route = this.findRoute(method, path, constraints);
	  return route !== null
	};

	Router.prototype.findRoute = function findNode (method, path, constraints = {}) {
	  if (this.trees[method] === undefined) {
	    return null
	  }

	  let pattern = path;

	  let currentNode = this.trees[method];
	  let parentNodePathIndex = currentNode.prefix.length;
	  for (let i = 0; i <= pattern.length; i++) {
	    if (pattern.charCodeAt(i) === 58 && pattern.charCodeAt(i + 1) === 58) {
	      // It's a double colon
	      i++;
	      continue
	    }

	    const isParametricNode = pattern.charCodeAt(i) === 58 && pattern.charCodeAt(i + 1) !== 58;
	    const isWildcardNode = pattern.charCodeAt(i) === 42;

	    if (isParametricNode || isWildcardNode || (i === pattern.length && i !== parentNodePathIndex)) {
	      let staticNodePath = pattern.slice(parentNodePathIndex, i);
	      if (!this.caseSensitive) {
	        staticNodePath = staticNodePath.toLowerCase();
	      }
	      staticNodePath = staticNodePath.replaceAll('::', ':');
	      staticNodePath = staticNodePath.replaceAll('%', '%25');
	      // add the static part of the route to the tree
	      currentNode = currentNode.getStaticChild(staticNodePath);
	      if (currentNode === null) {
	        return null
	      }
	    }

	    if (isParametricNode) {
	      let isRegexNode = false;
	      let isParamSafe = true;
	      let backtrack = '';
	      const regexps = [];

	      let lastParamStartIndex = i + 1;
	      for (let j = lastParamStartIndex; ; j++) {
	        const charCode = pattern.charCodeAt(j);

	        const isRegexParam = charCode === 40;
	        const isStaticPart = charCode === 45 || charCode === 46;
	        const isEndOfNode = charCode === 47 || j === pattern.length;

	        if (isRegexParam || isStaticPart || isEndOfNode) {
	          pattern.slice(lastParamStartIndex, j);

	          isRegexNode = isRegexNode || isRegexParam || isStaticPart;

	          if (isRegexParam) {
	            const endOfRegexIndex = getClosingParenthensePosition(pattern, j);
	            const regexString = pattern.slice(j, endOfRegexIndex + 1);

	            if (!this.allowUnsafeRegex) {
	              assert(isRegexSafe(new RegExp(regexString)), `The regex '${regexString}' is not safe!`);
	            }

	            regexps.push(trimRegExpStartAndEnd(regexString));

	            j = endOfRegexIndex + 1;
	            isParamSafe = false;
	          } else {
	            regexps.push(isParamSafe ? '(.*?)' : `(${backtrack}|(?:(?!${backtrack}).)*)`);
	            isParamSafe = false;
	          }

	          const staticPartStartIndex = j;
	          for (; j < pattern.length; j++) {
	            const charCode = pattern.charCodeAt(j);
	            if (charCode === 47) break
	            if (charCode === 58) {
	              const nextCharCode = pattern.charCodeAt(j + 1);
	              if (nextCharCode === 58) j++;
	              else break
	            }
	          }

	          let staticPart = pattern.slice(staticPartStartIndex, j);
	          if (staticPart) {
	            staticPart = staticPart.replaceAll('::', ':');
	            staticPart = staticPart.replaceAll('%', '%25');
	            regexps.push(backtrack = escapeRegExp(staticPart));
	          }

	          lastParamStartIndex = j + 1;

	          if (isEndOfNode || pattern.charCodeAt(j) === 47 || j === pattern.length) {
	            const nodePattern = isRegexNode ? '()' + staticPart : staticPart;
	            const nodePath = pattern.slice(i, j);

	            pattern = pattern.slice(0, i + 1) + nodePattern + pattern.slice(j);
	            i += nodePattern.length;

	            const regex = isRegexNode ? new RegExp('^' + regexps.join('') + '$') : null;
	            currentNode = currentNode.getParametricChild(regex, staticPart || null, nodePath);
	            if (currentNode === null) {
	              return null
	            }
	            parentNodePathIndex = i + 1;
	            break
	          }
	        }
	      }
	    } else if (isWildcardNode) {
	      currentNode = currentNode.getWildcardChild();

	      parentNodePathIndex = i + 1;

	      if (i !== pattern.length - 1) {
	        throw new Error('Wildcard must be the last character in the route')
	      }
	    }
	  }

	  if (!this.caseSensitive) {
	    pattern = pattern.toLowerCase();
	  }

	  for (const existRoute of this.routes) {
	    const routeConstraints = existRoute.opts.constraints || {};
	    if (
	      existRoute.method === method &&
	      existRoute.pattern === pattern &&
	      deepEqual(routeConstraints, constraints)
	    ) {
	      return {
	        handler: existRoute.handler,
	        store: existRoute.store,
	        params: existRoute.params
	      }
	    }
	  }

	  return null
	};

	Router.prototype.hasConstraintStrategy = function (strategyName) {
	  return this.constrainer.hasConstraintStrategy(strategyName)
	};

	Router.prototype.addConstraintStrategy = function (constraints) {
	  this.constrainer.addConstraintStrategy(constraints);
	  this._rebuild(this.routes);
	};

	Router.prototype.reset = function reset () {
	  this.trees = {};
	  this.routes = [];
	};

	Router.prototype.off = function off (method, path, constraints) {
	  // path validation
	  assert(typeof path === 'string', 'Path should be a string');
	  assert(path.length > 0, 'The path could not be empty');
	  assert(path[0] === '/' || path[0] === '*', 'The first character of a path should be `/` or `*`');
	  // options validation
	  assert(
	    typeof constraints === 'undefined' ||
	    (typeof constraints === 'object' && !Array.isArray(constraints) && constraints !== null),
	    'Constraints should be an object or undefined.');

	  // path ends with optional parameter
	  const optionalParamMatch = path.match(OPTIONAL_PARAM_REGEXP);
	  if (optionalParamMatch) {
	    assert(path.length === optionalParamMatch.index + optionalParamMatch[0].length, 'Optional Parameter needs to be the last parameter of the path');

	    const pathFull = path.replace(OPTIONAL_PARAM_REGEXP, '$1$2');
	    const pathOptional = path.replace(OPTIONAL_PARAM_REGEXP, '$2');

	    this.off(method, pathFull, constraints);
	    this.off(method, pathOptional, constraints);
	    return
	  }

	  if (this.ignoreDuplicateSlashes) {
	    path = removeDuplicateSlashes(path);
	  }

	  if (this.ignoreTrailingSlash) {
	    path = trimLastSlash(path);
	  }

	  const methods = Array.isArray(method) ? method : [method];
	  for (const method of methods) {
	    this._off(method, path, constraints);
	  }
	};

	Router.prototype._off = function _off (method, path, constraints) {
	  // method validation
	  assert(typeof method === 'string', 'Method should be a string');
	  assert(httpMethods.includes(method), `Method '${method}' is not an http method.`);

	  function matcherWithoutConstraints (route) {
	    return method !== route.method || path !== route.path
	  }

	  function matcherWithConstraints (route) {
	    return matcherWithoutConstraints(route) || !deepEqual(constraints, route.opts.constraints || {})
	  }

	  const predicate = constraints ? matcherWithConstraints : matcherWithoutConstraints;

	  // Rebuild tree without the specific route
	  const newRoutes = this.routes.filter(predicate);
	  this._rebuild(newRoutes);
	};

	Router.prototype.lookup = function lookup (req, res, ctx, done) {
	  if (typeof ctx === 'function') {
	    done = ctx;
	    ctx = undefined;
	  }

	  if (done === undefined) {
	    const constraints = this.constrainer.deriveConstraints(req, ctx);
	    const handle = this.find(req.method, req.url, constraints);
	    return this.callHandler(handle, req, res, ctx)
	  }

	  this.constrainer.deriveConstraints(req, ctx, (err, constraints) => {
	    if (err !== null) {
	      done(err);
	      return
	    }

	    try {
	      const handle = this.find(req.method, req.url, constraints);
	      const result = this.callHandler(handle, req, res, ctx);
	      done(null, result);
	    } catch (err) {
	      done(err);
	    }
	  });
	};

	Router.prototype.callHandler = function callHandler (handle, req, res, ctx) {
	  if (handle === null) return this._defaultRoute(req, res, ctx)
	  return ctx === undefined
	    ? handle.handler(req, res, handle.params, handle.store, handle.searchParams)
	    : handle.handler.call(ctx, req, res, handle.params, handle.store, handle.searchParams)
	};

	Router.prototype.find = function find (method, path, derivedConstraints) {
	  let currentNode = this.trees[method];
	  if (currentNode === undefined) return null

	  if (path.charCodeAt(0) !== 47) { // 47 is '/'
	    path = path.replace(FULL_PATH_REGEXP, '/');
	  }

	  // This must be run before sanitizeUrl as the resulting function
	  // .sliceParameter must be constructed with same URL string used
	  // throughout the rest of this function.
	  if (this.ignoreDuplicateSlashes) {
	    path = removeDuplicateSlashes(path);
	  }

	  let sanitizedUrl;
	  let querystring;
	  let shouldDecodeParam;

	  try {
	    sanitizedUrl = safeDecodeURI(path, this.useSemicolonDelimiter);
	    path = sanitizedUrl.path;
	    querystring = sanitizedUrl.querystring;
	    shouldDecodeParam = sanitizedUrl.shouldDecodeParam;
	  } catch (error) {
	    return this._onBadUrl(path)
	  }

	  if (this.ignoreTrailingSlash) {
	    path = trimLastSlash(path);
	  }

	  const originPath = path;

	  if (this.caseSensitive === false) {
	    path = path.toLowerCase();
	  }

	  const maxParamLength = this.maxParamLength;

	  let pathIndex = currentNode.prefix.length;
	  const params = [];
	  const pathLen = path.length;

	  const brothersNodesStack = [];

	  while (true) {
	    if (pathIndex === pathLen && currentNode.isLeafNode) {
	      const handle = currentNode.handlerStorage.getMatchingHandler(derivedConstraints);
	      if (handle !== null) {
	        return {
	          handler: handle.handler,
	          store: handle.store,
	          params: handle._createParamsObject(params),
	          searchParams: this.querystringParser(querystring)
	        }
	      }
	    }

	    let node = currentNode.getNextNode(path, pathIndex, brothersNodesStack, params.length);

	    if (node === null) {
	      if (brothersNodesStack.length === 0) {
	        return null
	      }

	      const brotherNodeState = brothersNodesStack.pop();
	      pathIndex = brotherNodeState.brotherPathIndex;
	      params.splice(brotherNodeState.paramsCount);
	      node = brotherNodeState.brotherNode;
	    }

	    currentNode = node;

	    // static route
	    if (currentNode.kind === NODE_TYPES.STATIC) {
	      pathIndex += currentNode.prefix.length;
	      continue
	    }

	    if (currentNode.kind === NODE_TYPES.WILDCARD) {
	      let param = originPath.slice(pathIndex);
	      if (shouldDecodeParam) {
	        param = safeDecodeURIComponent(param);
	      }

	      params.push(param);
	      pathIndex = pathLen;
	      continue
	    }

	    // parametric node
	    let paramEndIndex = originPath.indexOf('/', pathIndex);
	    if (paramEndIndex === -1) {
	      paramEndIndex = pathLen;
	    }

	    let param = originPath.slice(pathIndex, paramEndIndex);
	    if (shouldDecodeParam) {
	      param = safeDecodeURIComponent(param);
	    }

	    if (currentNode.isRegex) {
	      const matchedParameters = currentNode.regex.exec(param);
	      if (matchedParameters === null) continue

	      for (let i = 1; i < matchedParameters.length; i++) {
	        const matchedParam = matchedParameters[i];
	        if (matchedParam.length > maxParamLength) {
	          return null
	        }
	        params.push(matchedParam);
	      }
	    } else {
	      if (param.length > maxParamLength) {
	        return null
	      }
	      params.push(param);
	    }

	    pathIndex = paramEndIndex;
	  }
	};

	Router.prototype._rebuild = function (routes) {
	  this.reset();

	  for (const route of routes) {
	    const { method, path, opts, handler, store } = route;
	    this._on(method, path, opts, handler, store);
	  }
	};

	Router.prototype._defaultRoute = function (req, res, ctx) {
	  if (this.defaultRoute !== null) {
	    return ctx === undefined
	      ? this.defaultRoute(req, res)
	      : this.defaultRoute.call(ctx, req, res)
	  } else {
	    res.statusCode = 404;
	    res.end();
	  }
	};

	Router.prototype._onBadUrl = function (path) {
	  if (this.onBadUrl === null) {
	    return null
	  }
	  const onBadUrl = this.onBadUrl;
	  return {
	    handler: (req, res, ctx) => onBadUrl(path, req, res),
	    params: {},
	    store: null
	  }
	};

	Router.prototype.prettyPrint = function (options = {}) {
	  const method = options.method;

	  options.buildPrettyMeta = this.buildPrettyMeta.bind(this);

	  let tree = null;
	  if (method === undefined) {
	    const { version, host, ...constraints } = this.constrainer.strategies;
	    constraints[httpMethodStrategy.name] = httpMethodStrategy;

	    const mergedRouter = new Router({ ...this._opts, constraints });
	    const mergedRoutes = this.routes.map(route => {
	      const constraints = {
	        ...route.opts.constraints,
	        [httpMethodStrategy.name]: route.method
	      };
	      return { ...route, method: 'MERGED', opts: { constraints } }
	    });
	    mergedRouter._rebuild(mergedRoutes);
	    tree = mergedRouter.trees.MERGED;
	  } else {
	    tree = this.trees[method];
	  }

	  if (tree == null) return '(empty tree)'
	  return prettyPrintTree(tree, options)
	};

	for (const i in httpMethods) {
	  /* eslint no-prototype-builtins: "off" */
	  if (!httpMethods.hasOwnProperty(i)) continue
	  const m = httpMethods[i];
	  const methodName = m.toLowerCase();

	  Router.prototype[methodName] = function (path, handler, store) {
	    return this.on(m, path, handler, store)
	  };
	}

	Router.prototype.all = function (path, handler, store) {
	  this.on(httpMethods, path, handler, store);
	};

	findMyWay = Router;

	function escapeRegExp (string) {
	  return string.replace(ESCAPE_REGEXP, '\\$&')
	}

	function removeDuplicateSlashes (path) {
	  return path.indexOf('//') !== -1 ? path.replace(REMOVE_DUPLICATE_SLASHES_REGEXP, '/') : path
	}

	function trimLastSlash (path) {
	  if (path.length > 1 && path.charCodeAt(path.length - 1) === 47) {
	    return path.slice(0, -1)
	  }
	  return path
	}

	function trimRegExpStartAndEnd (regexString) {
	  // removes chars that marks start "^" and end "$" of regexp
	  if (regexString.charCodeAt(1) === 94) {
	    regexString = regexString.slice(0, 1) + regexString.slice(2);
	  }

	  if (regexString.charCodeAt(regexString.length - 2) === 36) {
	    regexString = regexString.slice(0, regexString.length - 2) + regexString.slice(regexString.length - 1);
	  }

	  return regexString
	}

	function getClosingParenthensePosition (path, idx) {
	  // `path.indexOf()` will always return the first position of the closing parenthese,
	  // but it's inefficient for grouped or wrong regexp expressions.
	  // see issues #62 and #63 for more info

	  let parentheses = 1;

	  while (idx < path.length) {
	    idx++;

	    // ignore skipped chars "\"
	    if (path.charCodeAt(idx) === 92) {
	      idx++;
	      continue
	    }

	    if (path.charCodeAt(idx) === 41) {
	      parentheses--;
	    } else if (path.charCodeAt(idx) === 40) {
	      parentheses++;
	    }

	    if (!parentheses) return idx
	  }

	  throw new TypeError('Invalid regexp expression in "' + path + '"')
	}

	function defaultBuildPrettyMeta (route) {
	  // buildPrettyMeta function must return an object, which will be parsed into key/value pairs for display
	  if (!route) return {}
	  if (!route.store) return {}
	  return Object.assign({}, route.store)
	}
	return findMyWay;
}

var headRoute;
var hasRequiredHeadRoute;

function requireHeadRoute () {
	if (hasRequiredHeadRoute) return headRoute;
	hasRequiredHeadRoute = 1;
	function headRouteOnSendHandler (req, reply, payload, done) {
	  // If payload is undefined
	  if (payload === undefined) {
	    reply.header('content-length', '0');
	    done(null, null);
	    return
	  }

	  if (typeof payload.resume === 'function') {
	    payload.on('error', (err) => {
	      reply.log.error({ err }, 'Error on Stream found for HEAD route');
	    });
	    payload.resume();
	    done(null, null);
	    return
	  }

	  const size = '' + Buffer.byteLength(payload);

	  reply.header('content-length', size);

	  done(null, null);
	}

	function parseHeadOnSendHandlers (onSendHandlers) {
	  if (onSendHandlers == null) return headRouteOnSendHandler
	  return Array.isArray(onSendHandlers) ? [...onSendHandlers, headRouteOnSendHandler] : [onSendHandlers, headRouteOnSendHandler]
	}

	headRoute = {
	  parseHeadOnSendHandlers
	};
	return headRoute;
}

var route;
var hasRequiredRoute;

function requireRoute () {
	if (hasRequiredRoute) return route;
	hasRequiredRoute = 1;

	const FindMyWay = requireFindMyWay();
	const Context = requireContext();
	const handleRequest = requireHandleRequest();
	const { onRequestAbortHookRunner, lifecycleHooks, preParsingHookRunner, onTimeoutHookRunner, onRequestHookRunner } = requireHooks();
	const { normalizeSchema } = requireSchemas();
	const { parseHeadOnSendHandlers } = requireHeadRoute();

	const {
	  compileSchemasForValidation,
	  compileSchemasForSerialization
	} = requireValidation$1();

	const {
	  FST_ERR_SCH_VALIDATION_BUILD,
	  FST_ERR_SCH_SERIALIZATION_BUILD,
	  FST_ERR_DUPLICATED_ROUTE,
	  FST_ERR_INVALID_URL,
	  FST_ERR_HOOK_INVALID_HANDLER,
	  FST_ERR_ROUTE_OPTIONS_NOT_OBJ,
	  FST_ERR_ROUTE_DUPLICATED_HANDLER,
	  FST_ERR_ROUTE_HANDLER_NOT_FN,
	  FST_ERR_ROUTE_MISSING_HANDLER,
	  FST_ERR_ROUTE_METHOD_NOT_SUPPORTED,
	  FST_ERR_ROUTE_METHOD_INVALID,
	  FST_ERR_ROUTE_BODY_VALIDATION_SCHEMA_NOT_SUPPORTED,
	  FST_ERR_ROUTE_BODY_LIMIT_OPTION_NOT_INT,
	  FST_ERR_HOOK_INVALID_ASYNC_HANDLER
	} = requireErrors$2();

	const {
	  kRoutePrefix,
	  kSupportedHTTPMethods,
	  kLogLevel,
	  kLogSerializers,
	  kHooks,
	  kSchemaController,
	  kOptions,
	  kReplySerializerDefault,
	  kReplyIsError,
	  kRequestPayloadStream,
	  kDisableRequestLogging,
	  kSchemaErrorFormatter,
	  kErrorHandler,
	  kHasBeenDecorated,
	  kRequestAcceptVersion,
	  kRouteByFastify,
	  kRouteContext
	} = requireSymbols$1();
	const { buildErrorHandler } = requireErrorHandler();
	const { createChildLogger } = requireLoggerFactory();
	const { getGenReqId } = requireReqIdGenFactory();

	function buildRouting (options) {
	  const router = FindMyWay(options.config);

	  let avvio;
	  let fourOhFour;
	  let logger;
	  let hasLogger;
	  let setupResponseListeners;
	  let throwIfAlreadyStarted;
	  let disableRequestLogging;
	  let ignoreTrailingSlash;
	  let ignoreDuplicateSlashes;
	  let return503OnClosing;
	  let globalExposeHeadRoutes;
	  let keepAliveConnections;

	  let closing = false;

	  return {
	    /**
	     * @param {import('../fastify').FastifyServerOptions} options
	     * @param {*} fastifyArgs
	     */
	    setup (options, fastifyArgs) {
	      avvio = fastifyArgs.avvio;
	      fourOhFour = fastifyArgs.fourOhFour;
	      logger = fastifyArgs.logger;
	      hasLogger = fastifyArgs.hasLogger;
	      setupResponseListeners = fastifyArgs.setupResponseListeners;
	      throwIfAlreadyStarted = fastifyArgs.throwIfAlreadyStarted;

	      globalExposeHeadRoutes = options.exposeHeadRoutes;
	      disableRequestLogging = options.disableRequestLogging;
	      ignoreTrailingSlash = options.ignoreTrailingSlash;
	      ignoreDuplicateSlashes = options.ignoreDuplicateSlashes;
	      return503OnClosing = Object.hasOwn(options, 'return503OnClosing') ? options.return503OnClosing : true;
	      keepAliveConnections = fastifyArgs.keepAliveConnections;
	    },
	    routing: router.lookup.bind(router), // router func to find the right handler to call
	    route, // configure a route in the fastify instance
	    hasRoute,
	    prepareRoute,
	    routeHandler,
	    closeRoutes: () => { closing = true; },
	    printRoutes: router.prettyPrint.bind(router),
	    addConstraintStrategy,
	    hasConstraintStrategy,
	    isAsyncConstraint,
	    findRoute
	  }

	  function addConstraintStrategy (strategy) {
	    throwIfAlreadyStarted('Cannot add constraint strategy!');
	    return router.addConstraintStrategy(strategy)
	  }

	  function hasConstraintStrategy (strategyName) {
	    return router.hasConstraintStrategy(strategyName)
	  }

	  function isAsyncConstraint () {
	    return router.constrainer.asyncStrategiesInUse.size > 0
	  }

	  // Convert shorthand to extended route declaration
	  function prepareRoute ({ method, url, options, handler, isFastify }) {
	    if (typeof url !== 'string') {
	      throw new FST_ERR_INVALID_URL(typeof url)
	    }

	    if (!handler && typeof options === 'function') {
	      handler = options; // for support over direct function calls such as fastify.get() options are reused as the handler
	      options = {};
	    } else if (handler && typeof handler === 'function') {
	      if (Object.prototype.toString.call(options) !== '[object Object]') {
	        throw new FST_ERR_ROUTE_OPTIONS_NOT_OBJ(method, url)
	      } else if (options.handler) {
	        if (typeof options.handler === 'function') {
	          throw new FST_ERR_ROUTE_DUPLICATED_HANDLER(method, url)
	        } else {
	          throw new FST_ERR_ROUTE_HANDLER_NOT_FN(method, url)
	        }
	      }
	    }

	    options = Object.assign({}, options, {
	      method,
	      url,
	      path: url,
	      handler: handler || (options && options.handler)
	    });

	    return route.call(this, { options, isFastify })
	  }

	  function hasRoute ({ options }) {
	    const normalizedMethod = options.method?.toUpperCase() ?? '';
	    return router.hasRoute(
	      normalizedMethod,
	      options.url || '',
	      options.constraints
	    )
	  }

	  function findRoute (options) {
	    const route = router.find(
	      options.method,
	      options.url || '',
	      options.constraints
	    );
	    if (route) {
	      // we must reduce the expose surface, otherwise
	      // we provide the ability for the user to modify
	      // all the route and server information in runtime
	      return {
	        handler: route.handler,
	        params: route.params,
	        searchParams: route.searchParams
	      }
	    } else {
	      return null
	    }
	  }

	  /**
	   * Route management
	   * @param {{ options: import('../fastify').RouteOptions, isFastify: boolean }}
	   */
	  function route ({ options, isFastify }) {
	    throwIfAlreadyStarted('Cannot add route!');

	    // Since we are mutating/assigning only top level props, it is fine to have a shallow copy using the spread operator
	    const opts = { ...options };

	    const path = opts.url || opts.path || '';

	    if (!opts.handler) {
	      throw new FST_ERR_ROUTE_MISSING_HANDLER(opts.method, path)
	    }

	    if (opts.errorHandler !== undefined && typeof opts.errorHandler !== 'function') {
	      throw new FST_ERR_ROUTE_HANDLER_NOT_FN(opts.method, path)
	    }

	    validateBodyLimitOption(opts.bodyLimit);

	    const shouldExposeHead = opts.exposeHeadRoute ?? globalExposeHeadRoutes;

	    let isGetRoute = false;
	    let isHeadRoute = false;

	    if (Array.isArray(opts.method)) {
	      for (let i = 0; i < opts.method.length; ++i) {
	        opts.method[i] = normalizeAndValidateMethod.call(this, opts.method[i]);
	        validateSchemaBodyOption.call(this, opts.method[i], path, opts.schema);

	        isGetRoute = opts.method.includes('GET');
	        isHeadRoute = opts.method.includes('HEAD');
	      }
	    } else {
	      opts.method = normalizeAndValidateMethod.call(this, opts.method);
	      validateSchemaBodyOption.call(this, opts.method, path, opts.schema);

	      isGetRoute = opts.method === 'GET';
	      isHeadRoute = opts.method === 'HEAD';
	    }

	    // we need to clone a set of initial options for HEAD route
	    const headOpts = shouldExposeHead && isGetRoute ? { ...options } : null;

	    const prefix = this[kRoutePrefix];

	    if (path === '/' && prefix.length > 0 && opts.method !== 'HEAD') {
	      switch (opts.prefixTrailingSlash) {
	        case 'slash':
	          addNewRoute.call(this, { path, isFastify });
	          break
	        case 'no-slash':
	          addNewRoute.call(this, { path: '', isFastify });
	          break
	        case 'both':
	        default:
	          addNewRoute.call(this, { path: '', isFastify });
	          // If ignoreTrailingSlash is set to true we need to add only the '' route to prevent adding an incomplete one.
	          if (ignoreTrailingSlash !== true && (ignoreDuplicateSlashes !== true || !prefix.endsWith('/'))) {
	            addNewRoute.call(this, { path, prefixing: true, isFastify });
	          }
	      }
	    } else if (path[0] === '/' && prefix.endsWith('/')) {
	      // Ensure that '/prefix/' + '/route' gets registered as '/prefix/route'
	      addNewRoute.call(this, { path: path.slice(1), isFastify });
	    } else {
	      addNewRoute.call(this, { path, isFastify });
	    }

	    // chainable api
	    return this

	    function addNewRoute ({ path, prefixing = false, isFastify = false }) {
	      const url = prefix + path;

	      opts.url = url;
	      opts.path = url;
	      opts.routePath = path;
	      opts.prefix = prefix;
	      opts.logLevel = opts.logLevel || this[kLogLevel];

	      if (this[kLogSerializers] || opts.logSerializers) {
	        opts.logSerializers = Object.assign(Object.create(this[kLogSerializers]), opts.logSerializers);
	      }

	      if (opts.attachValidation == null) {
	        opts.attachValidation = false;
	      }

	      if (prefixing === false) {
	        // run 'onRoute' hooks
	        for (const hook of this[kHooks].onRoute) {
	          hook.call(this, opts);
	        }
	      }

	      for (const hook of lifecycleHooks) {
	        if (opts && hook in opts) {
	          if (Array.isArray(opts[hook])) {
	            for (const func of opts[hook]) {
	              if (typeof func !== 'function') {
	                throw new FST_ERR_HOOK_INVALID_HANDLER(hook, Object.prototype.toString.call(func))
	              }

	              if (hook === 'onSend' || hook === 'preSerialization' || hook === 'onError' || hook === 'preParsing') {
	                if (func.constructor.name === 'AsyncFunction' && func.length === 4) {
	                  throw new FST_ERR_HOOK_INVALID_ASYNC_HANDLER()
	                }
	              } else if (hook === 'onRequestAbort') {
	                if (func.constructor.name === 'AsyncFunction' && func.length !== 1) {
	                  throw new FST_ERR_HOOK_INVALID_ASYNC_HANDLER()
	                }
	              } else {
	                if (func.constructor.name === 'AsyncFunction' && func.length === 3) {
	                  throw new FST_ERR_HOOK_INVALID_ASYNC_HANDLER()
	                }
	              }
	            }
	          } else if (opts[hook] !== undefined && typeof opts[hook] !== 'function') {
	            throw new FST_ERR_HOOK_INVALID_HANDLER(hook, Object.prototype.toString.call(opts[hook]))
	          }
	        }
	      }

	      const constraints = opts.constraints || {};
	      const config = {
	        ...opts.config,
	        url,
	        method: opts.method
	      };

	      const context = new Context({
	        schema: opts.schema,
	        handler: opts.handler.bind(this),
	        config,
	        errorHandler: opts.errorHandler,
	        childLoggerFactory: opts.childLoggerFactory,
	        bodyLimit: opts.bodyLimit,
	        logLevel: opts.logLevel,
	        logSerializers: opts.logSerializers,
	        attachValidation: opts.attachValidation,
	        schemaErrorFormatter: opts.schemaErrorFormatter,
	        replySerializer: this[kReplySerializerDefault],
	        validatorCompiler: opts.validatorCompiler,
	        serializerCompiler: opts.serializerCompiler,
	        exposeHeadRoute: shouldExposeHead,
	        prefixTrailingSlash: (opts.prefixTrailingSlash || 'both'),
	        server: this,
	        isFastify
	      });

	      const headHandler = router.findRoute('HEAD', opts.url, constraints);
	      const hasHEADHandler = headHandler !== null;

	      try {
	        router.on(opts.method, opts.url, { constraints }, routeHandler, context);
	      } catch (error) {
	        // any route insertion error created by fastify can be safely ignore
	        // because it only duplicate route for head
	        if (!context[kRouteByFastify]) {
	          const isDuplicatedRoute = error.message.includes(`Method '${opts.method}' already declared for route`);
	          if (isDuplicatedRoute) {
	            throw new FST_ERR_DUPLICATED_ROUTE(opts.method, opts.url)
	          }

	          throw error
	        }
	      }

	      this.after((notHandledErr, done) => {
	        // Send context async
	        context.errorHandler = opts.errorHandler ? buildErrorHandler(this[kErrorHandler], opts.errorHandler) : this[kErrorHandler];
	        context._parserOptions.limit = opts.bodyLimit || null;
	        context.logLevel = opts.logLevel;
	        context.logSerializers = opts.logSerializers;
	        context.attachValidation = opts.attachValidation;
	        context[kReplySerializerDefault] = this[kReplySerializerDefault];
	        context.schemaErrorFormatter = opts.schemaErrorFormatter || this[kSchemaErrorFormatter] || context.schemaErrorFormatter;

	        // Run hooks and more
	        avvio.once('preReady', () => {
	          for (const hook of lifecycleHooks) {
	            const toSet = this[kHooks][hook]
	              .concat(opts[hook] || [])
	              .map(h => h.bind(this));
	            context[hook] = toSet.length ? toSet : null;
	          }

	          // Optimization: avoid encapsulation if no decoration has been done.
	          while (!context.Request[kHasBeenDecorated] && context.Request.parent) {
	            context.Request = context.Request.parent;
	          }
	          while (!context.Reply[kHasBeenDecorated] && context.Reply.parent) {
	            context.Reply = context.Reply.parent;
	          }

	          // Must store the 404 Context in 'preReady' because it is only guaranteed to
	          // be available after all of the plugins and routes have been loaded.
	          fourOhFour.setContext(this, context);

	          if (opts.schema) {
	            context.schema = normalizeSchema(context.schema, this.initialConfig);

	            const schemaController = this[kSchemaController];
	            if (!opts.validatorCompiler && (opts.schema.body || opts.schema.headers || opts.schema.querystring || opts.schema.params)) {
	              schemaController.setupValidator(this[kOptions]);
	            }
	            try {
	              const isCustom = typeof opts?.validatorCompiler === 'function' || schemaController.isCustomValidatorCompiler;
	              compileSchemasForValidation(context, opts.validatorCompiler || schemaController.validatorCompiler, isCustom);
	            } catch (error) {
	              throw new FST_ERR_SCH_VALIDATION_BUILD(opts.method, url, error.message)
	            }

	            if (opts.schema.response && !opts.serializerCompiler) {
	              schemaController.setupSerializer(this[kOptions]);
	            }
	            try {
	              compileSchemasForSerialization(context, opts.serializerCompiler || schemaController.serializerCompiler);
	            } catch (error) {
	              throw new FST_ERR_SCH_SERIALIZATION_BUILD(opts.method, url, error.message)
	            }
	          }
	        });

	        done(notHandledErr);
	      });

	      // register head route in sync
	      // we must place it after the `this.after`

	      if (shouldExposeHead && isGetRoute && !isHeadRoute && !hasHEADHandler) {
	        const onSendHandlers = parseHeadOnSendHandlers(headOpts.onSend);
	        prepareRoute.call(this, { method: 'HEAD', url: path, options: { ...headOpts, onSend: onSendHandlers }, isFastify: true });
	      }
	    }
	  }

	  // HTTP request entry point, the routing has already been executed
	  function routeHandler (req, res, params, context, query) {
	    const id = getGenReqId(context.server, req);

	    const loggerOpts = {
	      level: context.logLevel
	    };

	    if (context.logSerializers) {
	      loggerOpts.serializers = context.logSerializers;
	    }
	    const childLogger = createChildLogger(context, logger, req, id, loggerOpts);
	    childLogger[kDisableRequestLogging] = disableRequestLogging;

	    if (closing === true) {
	      /* istanbul ignore next mac, windows */
	      if (req.httpVersionMajor !== 2) {
	        res.setHeader('Connection', 'close');
	      }

	      // TODO remove return503OnClosing after Node v18 goes EOL
	      /* istanbul ignore else */
	      if (return503OnClosing) {
	        // On Node v19 we cannot test this behavior as it won't be necessary
	        // anymore. It will close all the idle connections before they reach this
	        // stage.
	        const headers = {
	          'Content-Type': 'application/json',
	          'Content-Length': '80'
	        };
	        res.writeHead(503, headers);
	        res.end('{"error":"Service Unavailable","message":"Service Unavailable","statusCode":503}');
	        childLogger.info({ res: { statusCode: 503 } }, 'request aborted - refusing to accept new requests as server is closing');
	        return
	      }
	    }

	    // When server.forceCloseConnections is true, we will collect any requests
	    // that have indicated they want persistence so that they can be reaped
	    // on server close. Otherwise, the container is a noop container.
	    const connHeader = String.prototype.toLowerCase.call(req.headers.connection || '');
	    if (connHeader === 'keep-alive') {
	      if (keepAliveConnections.has(req.socket) === false) {
	        keepAliveConnections.add(req.socket);
	        req.socket.on('close', removeTrackedSocket.bind({ keepAliveConnections, socket: req.socket }));
	      }
	    }

	    // we revert the changes in defaultRoute
	    if (req.headers[kRequestAcceptVersion] !== undefined) {
	      req.headers['accept-version'] = req.headers[kRequestAcceptVersion];
	      req.headers[kRequestAcceptVersion] = undefined;
	    }

	    const request = new context.Request(id, params, req, query, childLogger, context);
	    const reply = new context.Reply(res, request, childLogger);
	    if (disableRequestLogging === false) {
	      childLogger.info({ req: request }, 'incoming request');
	    }

	    if (hasLogger === true || context.onResponse !== null) {
	      setupResponseListeners(reply);
	    }

	    if (context.onRequest !== null) {
	      onRequestHookRunner(
	        context.onRequest,
	        request,
	        reply,
	        runPreParsing
	      );
	    } else {
	      runPreParsing(null, request, reply);
	    }

	    if (context.onRequestAbort !== null) {
	      req.on('close', () => {
	        /* istanbul ignore else */
	        if (req.aborted) {
	          onRequestAbortHookRunner(
	            context.onRequestAbort,
	            request,
	            handleOnRequestAbortHooksErrors.bind(null, reply)
	          );
	        }
	      });
	    }

	    if (context.onTimeout !== null) {
	      if (!request.raw.socket._meta) {
	        request.raw.socket.on('timeout', handleTimeout);
	      }
	      request.raw.socket._meta = { context, request, reply };
	    }
	  }
	}

	function handleOnRequestAbortHooksErrors (reply, err) {
	  if (err) {
	    reply.log.error({ err }, 'onRequestAborted hook failed');
	  }
	}

	function handleTimeout () {
	  const { context, request, reply } = this._meta;
	  onTimeoutHookRunner(
	    context.onTimeout,
	    request,
	    reply,
	    noop
	  );
	}

	function normalizeAndValidateMethod (method) {
	  if (typeof method !== 'string') {
	    throw new FST_ERR_ROUTE_METHOD_INVALID()
	  }
	  method = method.toUpperCase();
	  if (!this[kSupportedHTTPMethods].bodyless.has(method) &&
	    !this[kSupportedHTTPMethods].bodywith.has(method)) {
	    throw new FST_ERR_ROUTE_METHOD_NOT_SUPPORTED(method)
	  }

	  return method
	}

	function validateSchemaBodyOption (method, path, schema) {
	  if (this[kSupportedHTTPMethods].bodyless.has(method) && schema?.body) {
	    throw new FST_ERR_ROUTE_BODY_VALIDATION_SCHEMA_NOT_SUPPORTED(method, path)
	  }
	}

	function validateBodyLimitOption (bodyLimit) {
	  if (bodyLimit === undefined) return
	  if (!Number.isInteger(bodyLimit) || bodyLimit <= 0) {
	    throw new FST_ERR_ROUTE_BODY_LIMIT_OPTION_NOT_INT(bodyLimit)
	  }
	}

	function runPreParsing (err, request, reply) {
	  if (reply.sent === true) return
	  if (err != null) {
	    reply[kReplyIsError] = true;
	    reply.send(err);
	    return
	  }

	  request[kRequestPayloadStream] = request.raw;

	  if (request[kRouteContext].preParsing !== null) {
	    preParsingHookRunner(request[kRouteContext].preParsing, request, reply, handleRequest.bind(request.server));
	  } else {
	    handleRequest.call(request.server, null, request, reply);
	  }
	}

	/**
	 * Used within the route handler as a `net.Socket.close` event handler.
	 * The purpose is to remove a socket from the tracked sockets collection when
	 * the socket has naturally timed out.
	 */
	function removeTrackedSocket () {
	  this.keepAliveConnections.delete(this.socket);
	}

	function noop () { }

	route = { buildRouting, validateBodyLimitOption };
	return route;
}

var fourOhFour_1;
var hasRequiredFourOhFour;

function requireFourOhFour () {
	if (hasRequiredFourOhFour) return fourOhFour_1;
	hasRequiredFourOhFour = 1;

	const FindMyWay = requireFindMyWay();

	const Reply = requireReply();
	const Request = requireRequest$1();
	const Context = requireContext();
	const {
	  kRoutePrefix,
	  kCanSetNotFoundHandler,
	  kFourOhFourLevelInstance,
	  kFourOhFourContext,
	  kHooks,
	  kErrorHandler
	} = requireSymbols$1();
	const { lifecycleHooks } = requireHooks();
	const { buildErrorHandler } = requireErrorHandler();
	const {
	  FST_ERR_NOT_FOUND
	} = requireErrors$2();
	const { createChildLogger } = requireLoggerFactory();
	const { getGenReqId } = requireReqIdGenFactory();

	/**
	 * Each fastify instance have a:
	 * kFourOhFourLevelInstance: point to a fastify instance that has the 404 handler set
	 * kCanSetNotFoundHandler: bool to track if the 404 handler has already been set
	 * kFourOhFour: the singleton instance of this 404 module
	 * kFourOhFourContext: the context in the reply object where the handler will be executed
	 */
	function fourOhFour (options) {
	  const { logger, disableRequestLogging } = options;

	  // 404 router, used for handling encapsulated 404 handlers
	  const router = FindMyWay({ onBadUrl: createOnBadUrl(), defaultRoute: fourOhFourFallBack });
	  let _onBadUrlHandler = null;

	  return { router, setNotFoundHandler, setContext, arrange404 }

	  function arrange404 (instance) {
	    // Change the pointer of the fastify instance to itself, so register + prefix can add new 404 handler
	    instance[kFourOhFourLevelInstance] = instance;
	    instance[kCanSetNotFoundHandler] = true;
	    // we need to bind instance for the context
	    router.onBadUrl = router.onBadUrl.bind(instance);
	    router.defaultRoute = router.defaultRoute.bind(instance);
	  }

	  function basic404 (request, reply) {
	    const { url, method } = request.raw;
	    const message = `Route ${method}:${url} not found`;
	    if (!disableRequestLogging) {
	      request.log.info(message);
	    }
	    reply.code(404).send({
	      message,
	      error: 'Not Found',
	      statusCode: 404
	    });
	  }

	  function createOnBadUrl () {
	    return function onBadUrl (path, req, res) {
	      const fourOhFourContext = this[kFourOhFourLevelInstance][kFourOhFourContext];
	      const id = getGenReqId(fourOhFourContext.server, req);
	      const childLogger = createChildLogger(fourOhFourContext, logger, req, id);
	      const request = new Request(id, null, req, null, childLogger, fourOhFourContext);
	      const reply = new Reply(res, request, childLogger);

	      _onBadUrlHandler(request, reply);
	    }
	  }

	  function setContext (instance, context) {
	    const _404Context = Object.assign({}, instance[kFourOhFourContext]);
	    _404Context.onSend = context.onSend;
	    context[kFourOhFourContext] = _404Context;
	  }

	  function setNotFoundHandler (opts, handler, avvio, routeHandler) {
	    // First initialization of the fastify root instance
	    if (this[kCanSetNotFoundHandler] === undefined) {
	      this[kCanSetNotFoundHandler] = true;
	    }
	    if (this[kFourOhFourContext] === undefined) {
	      this[kFourOhFourContext] = null;
	    }

	    const _fastify = this;
	    const prefix = this[kRoutePrefix] || '/';

	    if (this[kCanSetNotFoundHandler] === false) {
	      throw new Error(`Not found handler already set for Fastify instance with prefix: '${prefix}'`)
	    }

	    if (typeof opts === 'object') {
	      if (opts.preHandler) {
	        if (Array.isArray(opts.preHandler)) {
	          opts.preHandler = opts.preHandler.map(hook => hook.bind(_fastify));
	        } else {
	          opts.preHandler = opts.preHandler.bind(_fastify);
	        }
	      }

	      if (opts.preValidation) {
	        if (Array.isArray(opts.preValidation)) {
	          opts.preValidation = opts.preValidation.map(hook => hook.bind(_fastify));
	        } else {
	          opts.preValidation = opts.preValidation.bind(_fastify);
	        }
	      }
	    }

	    if (typeof opts === 'function') {
	      handler = opts;
	      opts = undefined;
	    }
	    opts = opts || {};

	    if (handler) {
	      this[kFourOhFourLevelInstance][kCanSetNotFoundHandler] = false;
	      handler = handler.bind(this);
	      // update onBadUrl handler
	      _onBadUrlHandler = handler;
	    } else {
	      handler = basic404;
	      // update onBadUrl handler
	      _onBadUrlHandler = basic404;
	    }

	    this.after((notHandledErr, done) => {
	      _setNotFoundHandler.call(this, prefix, opts, handler, avvio, routeHandler);
	      done(notHandledErr);
	    });
	  }

	  function _setNotFoundHandler (prefix, opts, handler, avvio, routeHandler) {
	    const context = new Context({
	      schema: opts.schema,
	      handler,
	      config: opts.config || {},
	      server: this
	    });

	    avvio.once('preReady', () => {
	      const context = this[kFourOhFourContext];
	      for (const hook of lifecycleHooks) {
	        const toSet = this[kHooks][hook]
	          .concat(opts[hook] || [])
	          .map(h => h.bind(this));
	        context[hook] = toSet.length ? toSet : null;
	      }
	      context.errorHandler = opts.errorHandler ? buildErrorHandler(this[kErrorHandler], opts.errorHandler) : this[kErrorHandler];
	    });

	    if (this[kFourOhFourContext] !== null && prefix === '/') {
	      Object.assign(this[kFourOhFourContext], context); // Replace the default 404 handler
	      return
	    }

	    this[kFourOhFourLevelInstance][kFourOhFourContext] = context;

	    router.all(prefix + (prefix.endsWith('/') ? '*' : '/*'), routeHandler, context);
	    router.all(prefix, routeHandler, context);
	  }

	  function fourOhFourFallBack (req, res) {
	    // if this happen, we have a very bad bug
	    // we might want to do some hard debugging
	    // here, let's print out as much info as
	    // we can
	    const fourOhFourContext = this[kFourOhFourLevelInstance][kFourOhFourContext];
	    const id = getGenReqId(fourOhFourContext.server, req);
	    const childLogger = createChildLogger(fourOhFourContext, logger, req, id);

	    childLogger.info({ req }, 'incoming request');

	    const request = new Request(id, null, req, null, childLogger, fourOhFourContext);
	    const reply = new Reply(res, request, childLogger);

	    request.log.warn('the default handler for 404 did not catch this, this is likely a fastify bug, please report it');
	    request.log.warn(router.prettyPrint());
	    reply.code(404).send(new FST_ERR_NOT_FOUND());
	  }
	}

	fourOhFour_1 = fourOhFour;
	return fourOhFour_1;
}

var initialConfigValidation = {exports: {}};

var configValidator$1 = {exports: {}};

var hasRequiredConfigValidator$1;

function requireConfigValidator$1 () {
	if (hasRequiredConfigValidator$1) return configValidator$1.exports;
	hasRequiredConfigValidator$1 = 1;
	configValidator$1.exports = validate10;
	configValidator$1.exports.default = validate10;
	const schema11 = {"properties":{"connectionTimeout":{"type":"integer","default":0},"keepAliveTimeout":{"type":"integer","default":72000},"forceCloseConnections":{"oneOf":[{"type":"string","pattern":"idle"},{"type":"boolean"}]},"maxRequestsPerSocket":{"type":"integer","default":0,"nullable":true},"requestTimeout":{"type":"integer","default":0},"bodyLimit":{"type":"integer","default":1048576},"caseSensitive":{"type":"boolean","default":true},"allowUnsafeRegex":{"type":"boolean","default":false},"http2":{"type":"boolean"},"https":{"if":{"not":{"oneOf":[{"type":"boolean"},{"type":"null"},{"type":"object","additionalProperties":false,"required":["allowHTTP1"],"properties":{"allowHTTP1":{"type":"boolean"}}}]}},"then":{"setDefaultValue":true}},"ignoreTrailingSlash":{"type":"boolean","default":false},"ignoreDuplicateSlashes":{"type":"boolean","default":false},"disableRequestLogging":{"type":"boolean","default":false},"maxParamLength":{"type":"integer","default":100},"onProtoPoisoning":{"type":"string","default":"error"},"onConstructorPoisoning":{"type":"string","default":"error"},"pluginTimeout":{"type":"integer","default":10000},"requestIdHeader":{"anyOf":[{"type":"boolean"},{"type":"string"}],"default":false},"requestIdLogLabel":{"type":"string","default":"reqId"},"http2SessionTimeout":{"type":"integer","default":72000},"exposeHeadRoutes":{"type":"boolean","default":true},"useSemicolonDelimiter":{"type":"boolean","default":false},"constraints":{"type":"object","additionalProperties":{"type":"object","required":["name","storage","validate","deriveConstraint"],"additionalProperties":true,"properties":{"name":{"type":"string"},"storage":{},"validate":{},"deriveConstraint":{}}}}}};
	const func2 = Object.prototype.hasOwnProperty;
	const pattern0 = new RegExp("idle", "u");

	function validate10(data, {instancePath="", parentData, parentDataProperty, rootData=data}={}){
	let vErrors = null;
	let errors = 0;
	if(errors === 0){
	if(data && typeof data == "object" && !Array.isArray(data)){
	if(data.connectionTimeout === undefined){
	data.connectionTimeout = 0;
	}
	if(data.keepAliveTimeout === undefined){
	data.keepAliveTimeout = 72000;
	}
	if(data.maxRequestsPerSocket === undefined){
	data.maxRequestsPerSocket = 0;
	}
	if(data.requestTimeout === undefined){
	data.requestTimeout = 0;
	}
	if(data.bodyLimit === undefined){
	data.bodyLimit = 1048576;
	}
	if(data.caseSensitive === undefined){
	data.caseSensitive = true;
	}
	if(data.allowUnsafeRegex === undefined){
	data.allowUnsafeRegex = false;
	}
	if(data.ignoreTrailingSlash === undefined){
	data.ignoreTrailingSlash = false;
	}
	if(data.ignoreDuplicateSlashes === undefined){
	data.ignoreDuplicateSlashes = false;
	}
	if(data.disableRequestLogging === undefined){
	data.disableRequestLogging = false;
	}
	if(data.maxParamLength === undefined){
	data.maxParamLength = 100;
	}
	if(data.onProtoPoisoning === undefined){
	data.onProtoPoisoning = "error";
	}
	if(data.onConstructorPoisoning === undefined){
	data.onConstructorPoisoning = "error";
	}
	if(data.pluginTimeout === undefined){
	data.pluginTimeout = 10000;
	}
	if(data.requestIdHeader === undefined){
	data.requestIdHeader = false;
	}
	if(data.requestIdLogLabel === undefined){
	data.requestIdLogLabel = "reqId";
	}
	if(data.http2SessionTimeout === undefined){
	data.http2SessionTimeout = 72000;
	}
	if(data.exposeHeadRoutes === undefined){
	data.exposeHeadRoutes = true;
	}
	if(data.useSemicolonDelimiter === undefined){
	data.useSemicolonDelimiter = false;
	}
	const _errs1 = errors;
	for(const key0 in data){
	if(!(func2.call(schema11.properties, key0))){
	delete data[key0];
	}
	}
	if(_errs1 === errors){
	let data0 = data.connectionTimeout;
	const _errs2 = errors;
	if(!(((typeof data0 == "number") && (!(data0 % 1) && !isNaN(data0))) && (isFinite(data0)))){
	let dataType0 = typeof data0;
	let coerced0 = undefined;
	if(!(coerced0 !== undefined)){
	if(dataType0 === "boolean" || data0 === null
	              || (dataType0 === "string" && data0 && data0 == +data0 && !(data0 % 1))){
	coerced0 = +data0;
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/connectionTimeout",schemaPath:"#/properties/connectionTimeout/type",keyword:"type",params:{type: "integer"},message:"must be integer"}];
	return false;
	}
	}
	if(coerced0 !== undefined){
	data0 = coerced0;
	if(data !== undefined){
	data["connectionTimeout"] = coerced0;
	}
	}
	}
	var valid0 = _errs2 === errors;
	if(valid0){
	let data1 = data.keepAliveTimeout;
	const _errs4 = errors;
	if(!(((typeof data1 == "number") && (!(data1 % 1) && !isNaN(data1))) && (isFinite(data1)))){
	let dataType1 = typeof data1;
	let coerced1 = undefined;
	if(!(coerced1 !== undefined)){
	if(dataType1 === "boolean" || data1 === null
	              || (dataType1 === "string" && data1 && data1 == +data1 && !(data1 % 1))){
	coerced1 = +data1;
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/keepAliveTimeout",schemaPath:"#/properties/keepAliveTimeout/type",keyword:"type",params:{type: "integer"},message:"must be integer"}];
	return false;
	}
	}
	if(coerced1 !== undefined){
	data1 = coerced1;
	if(data !== undefined){
	data["keepAliveTimeout"] = coerced1;
	}
	}
	}
	var valid0 = _errs4 === errors;
	if(valid0){
	if(data.forceCloseConnections !== undefined){
	let data2 = data.forceCloseConnections;
	const _errs6 = errors;
	const _errs7 = errors;
	let valid1 = false;
	let passing0 = null;
	const _errs8 = errors;
	if(typeof data2 !== "string"){
	let dataType2 = typeof data2;
	let coerced2 = undefined;
	if(!(coerced2 !== undefined)){
	if(dataType2 == "number" || dataType2 == "boolean"){
	coerced2 = "" + data2;
	}
	else if(data2 === null){
	coerced2 = "";
	}
	else {
	const err0 = {instancePath:instancePath+"/forceCloseConnections",schemaPath:"#/properties/forceCloseConnections/oneOf/0/type",keyword:"type",params:{type: "string"},message:"must be string"};
	if(vErrors === null){
	vErrors = [err0];
	}
	else {
	vErrors.push(err0);
	}
	errors++;
	}
	}
	if(coerced2 !== undefined){
	data2 = coerced2;
	if(data !== undefined){
	data["forceCloseConnections"] = coerced2;
	}
	}
	}
	if(errors === _errs8){
	if(typeof data2 === "string"){
	if(!pattern0.test(data2)){
	const err1 = {instancePath:instancePath+"/forceCloseConnections",schemaPath:"#/properties/forceCloseConnections/oneOf/0/pattern",keyword:"pattern",params:{pattern: "idle"},message:"must match pattern \""+"idle"+"\""};
	if(vErrors === null){
	vErrors = [err1];
	}
	else {
	vErrors.push(err1);
	}
	errors++;
	}
	}
	}
	var _valid0 = _errs8 === errors;
	if(_valid0){
	valid1 = true;
	passing0 = 0;
	}
	const _errs10 = errors;
	if(typeof data2 !== "boolean"){
	let coerced3 = undefined;
	if(!(coerced3 !== undefined)){
	if(data2 === "false" || data2 === 0 || data2 === null){
	coerced3 = false;
	}
	else if(data2 === "true" || data2 === 1){
	coerced3 = true;
	}
	else {
	const err2 = {instancePath:instancePath+"/forceCloseConnections",schemaPath:"#/properties/forceCloseConnections/oneOf/1/type",keyword:"type",params:{type: "boolean"},message:"must be boolean"};
	if(vErrors === null){
	vErrors = [err2];
	}
	else {
	vErrors.push(err2);
	}
	errors++;
	}
	}
	if(coerced3 !== undefined){
	data2 = coerced3;
	if(data !== undefined){
	data["forceCloseConnections"] = coerced3;
	}
	}
	}
	var _valid0 = _errs10 === errors;
	if(_valid0 && valid1){
	valid1 = false;
	passing0 = [passing0, 1];
	}
	else {
	if(_valid0){
	valid1 = true;
	passing0 = 1;
	}
	}
	if(!valid1){
	const err3 = {instancePath:instancePath+"/forceCloseConnections",schemaPath:"#/properties/forceCloseConnections/oneOf",keyword:"oneOf",params:{passingSchemas: passing0},message:"must match exactly one schema in oneOf"};
	if(vErrors === null){
	vErrors = [err3];
	}
	else {
	vErrors.push(err3);
	}
	errors++;
	validate10.errors = vErrors;
	return false;
	}
	else {
	errors = _errs7;
	if(vErrors !== null){
	if(_errs7){
	vErrors.length = _errs7;
	}
	else {
	vErrors = null;
	}
	}
	}
	var valid0 = _errs6 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	let data3 = data.maxRequestsPerSocket;
	const _errs12 = errors;
	if((!(((typeof data3 == "number") && (!(data3 % 1) && !isNaN(data3))) && (isFinite(data3)))) && (data3 !== null)){
	let dataType4 = typeof data3;
	let coerced4 = undefined;
	if(!(coerced4 !== undefined)){
	if(dataType4 === "boolean" || data3 === null
	              || (dataType4 === "string" && data3 && data3 == +data3 && !(data3 % 1))){
	coerced4 = +data3;
	}
	else if(data3 === "" || data3 === 0 || data3 === false){
	coerced4 = null;
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/maxRequestsPerSocket",schemaPath:"#/properties/maxRequestsPerSocket/type",keyword:"type",params:{type: "integer"},message:"must be integer"}];
	return false;
	}
	}
	if(coerced4 !== undefined){
	data3 = coerced4;
	if(data !== undefined){
	data["maxRequestsPerSocket"] = coerced4;
	}
	}
	}
	var valid0 = _errs12 === errors;
	if(valid0){
	let data4 = data.requestTimeout;
	const _errs15 = errors;
	if(!(((typeof data4 == "number") && (!(data4 % 1) && !isNaN(data4))) && (isFinite(data4)))){
	let dataType5 = typeof data4;
	let coerced5 = undefined;
	if(!(coerced5 !== undefined)){
	if(dataType5 === "boolean" || data4 === null
	              || (dataType5 === "string" && data4 && data4 == +data4 && !(data4 % 1))){
	coerced5 = +data4;
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/requestTimeout",schemaPath:"#/properties/requestTimeout/type",keyword:"type",params:{type: "integer"},message:"must be integer"}];
	return false;
	}
	}
	if(coerced5 !== undefined){
	data4 = coerced5;
	if(data !== undefined){
	data["requestTimeout"] = coerced5;
	}
	}
	}
	var valid0 = _errs15 === errors;
	if(valid0){
	let data5 = data.bodyLimit;
	const _errs17 = errors;
	if(!(((typeof data5 == "number") && (!(data5 % 1) && !isNaN(data5))) && (isFinite(data5)))){
	let dataType6 = typeof data5;
	let coerced6 = undefined;
	if(!(coerced6 !== undefined)){
	if(dataType6 === "boolean" || data5 === null
	              || (dataType6 === "string" && data5 && data5 == +data5 && !(data5 % 1))){
	coerced6 = +data5;
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/bodyLimit",schemaPath:"#/properties/bodyLimit/type",keyword:"type",params:{type: "integer"},message:"must be integer"}];
	return false;
	}
	}
	if(coerced6 !== undefined){
	data5 = coerced6;
	if(data !== undefined){
	data["bodyLimit"] = coerced6;
	}
	}
	}
	var valid0 = _errs17 === errors;
	if(valid0){
	let data6 = data.caseSensitive;
	const _errs19 = errors;
	if(typeof data6 !== "boolean"){
	let coerced7 = undefined;
	if(!(coerced7 !== undefined)){
	if(data6 === "false" || data6 === 0 || data6 === null){
	coerced7 = false;
	}
	else if(data6 === "true" || data6 === 1){
	coerced7 = true;
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/caseSensitive",schemaPath:"#/properties/caseSensitive/type",keyword:"type",params:{type: "boolean"},message:"must be boolean"}];
	return false;
	}
	}
	if(coerced7 !== undefined){
	data6 = coerced7;
	if(data !== undefined){
	data["caseSensitive"] = coerced7;
	}
	}
	}
	var valid0 = _errs19 === errors;
	if(valid0){
	let data7 = data.allowUnsafeRegex;
	const _errs21 = errors;
	if(typeof data7 !== "boolean"){
	let coerced8 = undefined;
	if(!(coerced8 !== undefined)){
	if(data7 === "false" || data7 === 0 || data7 === null){
	coerced8 = false;
	}
	else if(data7 === "true" || data7 === 1){
	coerced8 = true;
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/allowUnsafeRegex",schemaPath:"#/properties/allowUnsafeRegex/type",keyword:"type",params:{type: "boolean"},message:"must be boolean"}];
	return false;
	}
	}
	if(coerced8 !== undefined){
	data7 = coerced8;
	if(data !== undefined){
	data["allowUnsafeRegex"] = coerced8;
	}
	}
	}
	var valid0 = _errs21 === errors;
	if(valid0){
	if(data.http2 !== undefined){
	let data8 = data.http2;
	const _errs23 = errors;
	if(typeof data8 !== "boolean"){
	let coerced9 = undefined;
	if(!(coerced9 !== undefined)){
	if(data8 === "false" || data8 === 0 || data8 === null){
	coerced9 = false;
	}
	else if(data8 === "true" || data8 === 1){
	coerced9 = true;
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/http2",schemaPath:"#/properties/http2/type",keyword:"type",params:{type: "boolean"},message:"must be boolean"}];
	return false;
	}
	}
	if(coerced9 !== undefined){
	data8 = coerced9;
	if(data !== undefined){
	data["http2"] = coerced9;
	}
	}
	}
	var valid0 = _errs23 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.https !== undefined){
	let data9 = data.https;
	const _errs25 = errors;
	const _errs26 = errors;
	let valid2 = true;
	const _errs27 = errors;
	const _errs28 = errors;
	const _errs29 = errors;
	const _errs30 = errors;
	let valid4 = false;
	const _errs31 = errors;
	if(typeof data9 !== "boolean"){
	let coerced10 = undefined;
	if(!(coerced10 !== undefined)){
	if(data9 === "false" || data9 === 0 || data9 === null){
	coerced10 = false;
	}
	else if(data9 === "true" || data9 === 1){
	coerced10 = true;
	}
	else {
	const err4 = {};
	if(vErrors === null){
	vErrors = [err4];
	}
	else {
	vErrors.push(err4);
	}
	errors++;
	}
	}
	if(coerced10 !== undefined){
	data9 = coerced10;
	if(data !== undefined){
	data["https"] = coerced10;
	}
	}
	}
	var _valid2 = _errs31 === errors;
	if(_valid2){
	valid4 = true;
	}
	const _errs33 = errors;
	if(data9 !== null){
	let coerced11 = undefined;
	if(!(coerced11 !== undefined)){
	if(data9 === "" || data9 === 0 || data9 === false){
	coerced11 = null;
	}
	else {
	const err5 = {};
	if(vErrors === null){
	vErrors = [err5];
	}
	else {
	vErrors.push(err5);
	}
	errors++;
	}
	}
	if(coerced11 !== undefined){
	data9 = coerced11;
	if(data !== undefined){
	data["https"] = coerced11;
	}
	}
	}
	var _valid2 = _errs33 === errors;
	if(_valid2 && valid4){
	valid4 = false;
	}
	else {
	if(_valid2){
	valid4 = true;
	}
	const _errs35 = errors;
	if(errors === _errs35){
	if(data9 && typeof data9 == "object" && !Array.isArray(data9)){
	if((data9.allowHTTP1 === undefined) && ("allowHTTP1")){
	const err6 = {};
	if(vErrors === null){
	vErrors = [err6];
	}
	else {
	vErrors.push(err6);
	}
	errors++;
	}
	else {
	const _errs37 = errors;
	for(const key1 in data9){
	if(!(key1 === "allowHTTP1")){
	delete data9[key1];
	}
	}
	if(_errs37 === errors){
	if(data9.allowHTTP1 !== undefined){
	let data10 = data9.allowHTTP1;
	if(typeof data10 !== "boolean"){
	let coerced12 = undefined;
	if(!(coerced12 !== undefined)){
	if(data10 === "false" || data10 === 0 || data10 === null){
	coerced12 = false;
	}
	else if(data10 === "true" || data10 === 1){
	coerced12 = true;
	}
	else {
	const err7 = {};
	if(vErrors === null){
	vErrors = [err7];
	}
	else {
	vErrors.push(err7);
	}
	errors++;
	}
	}
	if(coerced12 !== undefined){
	data10 = coerced12;
	if(data9 !== undefined){
	data9["allowHTTP1"] = coerced12;
	}
	}
	}
	}
	}
	}
	}
	else {
	const err8 = {};
	if(vErrors === null){
	vErrors = [err8];
	}
	else {
	vErrors.push(err8);
	}
	errors++;
	}
	}
	var _valid2 = _errs35 === errors;
	if(_valid2 && valid4){
	valid4 = false;
	}
	else {
	if(_valid2){
	valid4 = true;
	}
	}
	}
	if(!valid4){
	const err9 = {};
	if(vErrors === null){
	vErrors = [err9];
	}
	else {
	vErrors.push(err9);
	}
	errors++;
	}
	else {
	errors = _errs30;
	if(vErrors !== null){
	if(_errs30){
	vErrors.length = _errs30;
	}
	else {
	vErrors = null;
	}
	}
	}
	var valid3 = _errs29 === errors;
	if(valid3){
	const err10 = {};
	if(vErrors === null){
	vErrors = [err10];
	}
	else {
	vErrors.push(err10);
	}
	errors++;
	}
	else {
	errors = _errs28;
	if(vErrors !== null){
	if(_errs28){
	vErrors.length = _errs28;
	}
	else {
	vErrors = null;
	}
	}
	}
	var _valid1 = _errs27 === errors;
	errors = _errs26;
	if(vErrors !== null){
	if(_errs26){
	vErrors.length = _errs26;
	}
	else {
	vErrors = null;
	}
	}
	if(_valid1){
	const _errs40 = errors;
	data["https"] = true;
	var _valid1 = _errs40 === errors;
	valid2 = _valid1;
	}
	if(!valid2){
	const err11 = {instancePath:instancePath+"/https",schemaPath:"#/properties/https/if",keyword:"if",params:{failingKeyword: "then"},message:"must match \"then\" schema"};
	if(vErrors === null){
	vErrors = [err11];
	}
	else {
	vErrors.push(err11);
	}
	errors++;
	validate10.errors = vErrors;
	return false;
	}
	var valid0 = _errs25 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	let data11 = data.ignoreTrailingSlash;
	const _errs41 = errors;
	if(typeof data11 !== "boolean"){
	let coerced13 = undefined;
	if(!(coerced13 !== undefined)){
	if(data11 === "false" || data11 === 0 || data11 === null){
	coerced13 = false;
	}
	else if(data11 === "true" || data11 === 1){
	coerced13 = true;
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/ignoreTrailingSlash",schemaPath:"#/properties/ignoreTrailingSlash/type",keyword:"type",params:{type: "boolean"},message:"must be boolean"}];
	return false;
	}
	}
	if(coerced13 !== undefined){
	data11 = coerced13;
	if(data !== undefined){
	data["ignoreTrailingSlash"] = coerced13;
	}
	}
	}
	var valid0 = _errs41 === errors;
	if(valid0){
	let data12 = data.ignoreDuplicateSlashes;
	const _errs43 = errors;
	if(typeof data12 !== "boolean"){
	let coerced14 = undefined;
	if(!(coerced14 !== undefined)){
	if(data12 === "false" || data12 === 0 || data12 === null){
	coerced14 = false;
	}
	else if(data12 === "true" || data12 === 1){
	coerced14 = true;
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/ignoreDuplicateSlashes",schemaPath:"#/properties/ignoreDuplicateSlashes/type",keyword:"type",params:{type: "boolean"},message:"must be boolean"}];
	return false;
	}
	}
	if(coerced14 !== undefined){
	data12 = coerced14;
	if(data !== undefined){
	data["ignoreDuplicateSlashes"] = coerced14;
	}
	}
	}
	var valid0 = _errs43 === errors;
	if(valid0){
	let data13 = data.disableRequestLogging;
	const _errs45 = errors;
	if(typeof data13 !== "boolean"){
	let coerced15 = undefined;
	if(!(coerced15 !== undefined)){
	if(data13 === "false" || data13 === 0 || data13 === null){
	coerced15 = false;
	}
	else if(data13 === "true" || data13 === 1){
	coerced15 = true;
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/disableRequestLogging",schemaPath:"#/properties/disableRequestLogging/type",keyword:"type",params:{type: "boolean"},message:"must be boolean"}];
	return false;
	}
	}
	if(coerced15 !== undefined){
	data13 = coerced15;
	if(data !== undefined){
	data["disableRequestLogging"] = coerced15;
	}
	}
	}
	var valid0 = _errs45 === errors;
	if(valid0){
	let data14 = data.maxParamLength;
	const _errs47 = errors;
	if(!(((typeof data14 == "number") && (!(data14 % 1) && !isNaN(data14))) && (isFinite(data14)))){
	let dataType16 = typeof data14;
	let coerced16 = undefined;
	if(!(coerced16 !== undefined)){
	if(dataType16 === "boolean" || data14 === null
	              || (dataType16 === "string" && data14 && data14 == +data14 && !(data14 % 1))){
	coerced16 = +data14;
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/maxParamLength",schemaPath:"#/properties/maxParamLength/type",keyword:"type",params:{type: "integer"},message:"must be integer"}];
	return false;
	}
	}
	if(coerced16 !== undefined){
	data14 = coerced16;
	if(data !== undefined){
	data["maxParamLength"] = coerced16;
	}
	}
	}
	var valid0 = _errs47 === errors;
	if(valid0){
	let data15 = data.onProtoPoisoning;
	const _errs49 = errors;
	if(typeof data15 !== "string"){
	let dataType17 = typeof data15;
	let coerced17 = undefined;
	if(!(coerced17 !== undefined)){
	if(dataType17 == "number" || dataType17 == "boolean"){
	coerced17 = "" + data15;
	}
	else if(data15 === null){
	coerced17 = "";
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/onProtoPoisoning",schemaPath:"#/properties/onProtoPoisoning/type",keyword:"type",params:{type: "string"},message:"must be string"}];
	return false;
	}
	}
	if(coerced17 !== undefined){
	data15 = coerced17;
	if(data !== undefined){
	data["onProtoPoisoning"] = coerced17;
	}
	}
	}
	var valid0 = _errs49 === errors;
	if(valid0){
	let data16 = data.onConstructorPoisoning;
	const _errs51 = errors;
	if(typeof data16 !== "string"){
	let dataType18 = typeof data16;
	let coerced18 = undefined;
	if(!(coerced18 !== undefined)){
	if(dataType18 == "number" || dataType18 == "boolean"){
	coerced18 = "" + data16;
	}
	else if(data16 === null){
	coerced18 = "";
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/onConstructorPoisoning",schemaPath:"#/properties/onConstructorPoisoning/type",keyword:"type",params:{type: "string"},message:"must be string"}];
	return false;
	}
	}
	if(coerced18 !== undefined){
	data16 = coerced18;
	if(data !== undefined){
	data["onConstructorPoisoning"] = coerced18;
	}
	}
	}
	var valid0 = _errs51 === errors;
	if(valid0){
	let data17 = data.pluginTimeout;
	const _errs53 = errors;
	if(!(((typeof data17 == "number") && (!(data17 % 1) && !isNaN(data17))) && (isFinite(data17)))){
	let dataType19 = typeof data17;
	let coerced19 = undefined;
	if(!(coerced19 !== undefined)){
	if(dataType19 === "boolean" || data17 === null
	              || (dataType19 === "string" && data17 && data17 == +data17 && !(data17 % 1))){
	coerced19 = +data17;
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/pluginTimeout",schemaPath:"#/properties/pluginTimeout/type",keyword:"type",params:{type: "integer"},message:"must be integer"}];
	return false;
	}
	}
	if(coerced19 !== undefined){
	data17 = coerced19;
	if(data !== undefined){
	data["pluginTimeout"] = coerced19;
	}
	}
	}
	var valid0 = _errs53 === errors;
	if(valid0){
	let data18 = data.requestIdHeader;
	const _errs55 = errors;
	const _errs56 = errors;
	let valid6 = false;
	const _errs57 = errors;
	if(typeof data18 !== "boolean"){
	let coerced20 = undefined;
	if(!(coerced20 !== undefined)){
	if(data18 === "false" || data18 === 0 || data18 === null){
	coerced20 = false;
	}
	else if(data18 === "true" || data18 === 1){
	coerced20 = true;
	}
	else {
	const err12 = {instancePath:instancePath+"/requestIdHeader",schemaPath:"#/properties/requestIdHeader/anyOf/0/type",keyword:"type",params:{type: "boolean"},message:"must be boolean"};
	if(vErrors === null){
	vErrors = [err12];
	}
	else {
	vErrors.push(err12);
	}
	errors++;
	}
	}
	if(coerced20 !== undefined){
	data18 = coerced20;
	if(data !== undefined){
	data["requestIdHeader"] = coerced20;
	}
	}
	}
	var _valid3 = _errs57 === errors;
	valid6 = valid6 || _valid3;
	if(!valid6){
	const _errs59 = errors;
	if(typeof data18 !== "string"){
	let dataType21 = typeof data18;
	let coerced21 = undefined;
	if(!(coerced21 !== undefined)){
	if(dataType21 == "number" || dataType21 == "boolean"){
	coerced21 = "" + data18;
	}
	else if(data18 === null){
	coerced21 = "";
	}
	else {
	const err13 = {instancePath:instancePath+"/requestIdHeader",schemaPath:"#/properties/requestIdHeader/anyOf/1/type",keyword:"type",params:{type: "string"},message:"must be string"};
	if(vErrors === null){
	vErrors = [err13];
	}
	else {
	vErrors.push(err13);
	}
	errors++;
	}
	}
	if(coerced21 !== undefined){
	data18 = coerced21;
	if(data !== undefined){
	data["requestIdHeader"] = coerced21;
	}
	}
	}
	var _valid3 = _errs59 === errors;
	valid6 = valid6 || _valid3;
	}
	if(!valid6){
	const err14 = {instancePath:instancePath+"/requestIdHeader",schemaPath:"#/properties/requestIdHeader/anyOf",keyword:"anyOf",params:{},message:"must match a schema in anyOf"};
	if(vErrors === null){
	vErrors = [err14];
	}
	else {
	vErrors.push(err14);
	}
	errors++;
	validate10.errors = vErrors;
	return false;
	}
	else {
	errors = _errs56;
	if(vErrors !== null){
	if(_errs56){
	vErrors.length = _errs56;
	}
	else {
	vErrors = null;
	}
	}
	}
	var valid0 = _errs55 === errors;
	if(valid0){
	let data19 = data.requestIdLogLabel;
	const _errs61 = errors;
	if(typeof data19 !== "string"){
	let dataType22 = typeof data19;
	let coerced22 = undefined;
	if(!(coerced22 !== undefined)){
	if(dataType22 == "number" || dataType22 == "boolean"){
	coerced22 = "" + data19;
	}
	else if(data19 === null){
	coerced22 = "";
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/requestIdLogLabel",schemaPath:"#/properties/requestIdLogLabel/type",keyword:"type",params:{type: "string"},message:"must be string"}];
	return false;
	}
	}
	if(coerced22 !== undefined){
	data19 = coerced22;
	if(data !== undefined){
	data["requestIdLogLabel"] = coerced22;
	}
	}
	}
	var valid0 = _errs61 === errors;
	if(valid0){
	let data20 = data.http2SessionTimeout;
	const _errs63 = errors;
	if(!(((typeof data20 == "number") && (!(data20 % 1) && !isNaN(data20))) && (isFinite(data20)))){
	let dataType23 = typeof data20;
	let coerced23 = undefined;
	if(!(coerced23 !== undefined)){
	if(dataType23 === "boolean" || data20 === null
	              || (dataType23 === "string" && data20 && data20 == +data20 && !(data20 % 1))){
	coerced23 = +data20;
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/http2SessionTimeout",schemaPath:"#/properties/http2SessionTimeout/type",keyword:"type",params:{type: "integer"},message:"must be integer"}];
	return false;
	}
	}
	if(coerced23 !== undefined){
	data20 = coerced23;
	if(data !== undefined){
	data["http2SessionTimeout"] = coerced23;
	}
	}
	}
	var valid0 = _errs63 === errors;
	if(valid0){
	let data21 = data.exposeHeadRoutes;
	const _errs65 = errors;
	if(typeof data21 !== "boolean"){
	let coerced24 = undefined;
	if(!(coerced24 !== undefined)){
	if(data21 === "false" || data21 === 0 || data21 === null){
	coerced24 = false;
	}
	else if(data21 === "true" || data21 === 1){
	coerced24 = true;
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/exposeHeadRoutes",schemaPath:"#/properties/exposeHeadRoutes/type",keyword:"type",params:{type: "boolean"},message:"must be boolean"}];
	return false;
	}
	}
	if(coerced24 !== undefined){
	data21 = coerced24;
	if(data !== undefined){
	data["exposeHeadRoutes"] = coerced24;
	}
	}
	}
	var valid0 = _errs65 === errors;
	if(valid0){
	let data22 = data.useSemicolonDelimiter;
	const _errs67 = errors;
	if(typeof data22 !== "boolean"){
	let coerced25 = undefined;
	if(!(coerced25 !== undefined)){
	if(data22 === "false" || data22 === 0 || data22 === null){
	coerced25 = false;
	}
	else if(data22 === "true" || data22 === 1){
	coerced25 = true;
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/useSemicolonDelimiter",schemaPath:"#/properties/useSemicolonDelimiter/type",keyword:"type",params:{type: "boolean"},message:"must be boolean"}];
	return false;
	}
	}
	if(coerced25 !== undefined){
	data22 = coerced25;
	if(data !== undefined){
	data["useSemicolonDelimiter"] = coerced25;
	}
	}
	}
	var valid0 = _errs67 === errors;
	if(valid0){
	if(data.constraints !== undefined){
	let data23 = data.constraints;
	const _errs69 = errors;
	if(errors === _errs69){
	if(data23 && typeof data23 == "object" && !Array.isArray(data23)){
	for(const key2 in data23){
	let data24 = data23[key2];
	const _errs72 = errors;
	if(errors === _errs72){
	if(data24 && typeof data24 == "object" && !Array.isArray(data24)){
	let missing1;
	if(((((data24.name === undefined) && (missing1 = "name")) || ((data24.storage === undefined) && (missing1 = "storage"))) || ((data24.validate === undefined) && (missing1 = "validate"))) || ((data24.deriveConstraint === undefined) && (missing1 = "deriveConstraint"))){
	validate10.errors = [{instancePath:instancePath+"/constraints/" + key2.replace(/~/g, "~0").replace(/\//g, "~1"),schemaPath:"#/properties/constraints/additionalProperties/required",keyword:"required",params:{missingProperty: missing1},message:"must have required property '"+missing1+"'"}];
	return false;
	}
	else {
	if(data24.name !== undefined){
	let data25 = data24.name;
	if(typeof data25 !== "string"){
	let dataType26 = typeof data25;
	let coerced26 = undefined;
	if(!(coerced26 !== undefined)){
	if(dataType26 == "number" || dataType26 == "boolean"){
	coerced26 = "" + data25;
	}
	else if(data25 === null){
	coerced26 = "";
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/constraints/" + key2.replace(/~/g, "~0").replace(/\//g, "~1")+"/name",schemaPath:"#/properties/constraints/additionalProperties/properties/name/type",keyword:"type",params:{type: "string"},message:"must be string"}];
	return false;
	}
	}
	if(coerced26 !== undefined){
	data25 = coerced26;
	if(data24 !== undefined){
	data24["name"] = coerced26;
	}
	}
	}
	}
	}
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/constraints/" + key2.replace(/~/g, "~0").replace(/\//g, "~1"),schemaPath:"#/properties/constraints/additionalProperties/type",keyword:"type",params:{type: "object"},message:"must be object"}];
	return false;
	}
	}
	var valid7 = _errs72 === errors;
	if(!valid7){
	break;
	}
	}
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/constraints",schemaPath:"#/properties/constraints/type",keyword:"type",params:{type: "object"},message:"must be object"}];
	return false;
	}
	}
	var valid0 = _errs69 === errors;
	}
	else {
	var valid0 = true;
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	else {
	validate10.errors = [{instancePath,schemaPath:"#/type",keyword:"type",params:{type: "object"},message:"must be object"}];
	return false;
	}
	}
	validate10.errors = vErrors;
	return errors === 0;
	}


	configValidator$1.exports.defaultInitOptions = {"connectionTimeout":0,"keepAliveTimeout":72000,"maxRequestsPerSocket":0,"requestTimeout":0,"bodyLimit":1048576,"caseSensitive":true,"allowUnsafeRegex":false,"disableRequestLogging":false,"ignoreTrailingSlash":false,"ignoreDuplicateSlashes":false,"maxParamLength":100,"onProtoPoisoning":"error","onConstructorPoisoning":"error","pluginTimeout":10000,"requestIdHeader":false,"requestIdLogLabel":"reqId","http2SessionTimeout":72000,"exposeHeadRoutes":true,"useSemicolonDelimiter":false,"allowErrorHandlerOverride":true};
	/* c8 ignore stop */
	return configValidator$1.exports;
}

var hasRequiredInitialConfigValidation;

function requireInitialConfigValidation () {
	if (hasRequiredInitialConfigValidation) return initialConfigValidation.exports;
	hasRequiredInitialConfigValidation = 1;

	const validate = requireConfigValidator$1();
	const deepClone = requireRfdc()({ circles: true, proto: false });
	const { FST_ERR_INIT_OPTS_INVALID } = requireErrors$2();

	function validateInitialConfig (options) {
	  const opts = deepClone(options);

	  if (!validate(opts)) {
	    const error = new FST_ERR_INIT_OPTS_INVALID(JSON.stringify(validate.errors.map(e => e.message)));
	    error.errors = validate.errors;
	    throw error
	  }

	  return deepFreezeObject(opts)
	}

	function deepFreezeObject (object) {
	  const properties = Object.getOwnPropertyNames(object);

	  for (const name of properties) {
	    const value = object[name];

	    if (ArrayBuffer.isView(value) && !(value instanceof DataView)) {
	      continue
	    }

	    object[name] = value && typeof value === 'object' ? deepFreezeObject(value) : value;
	  }

	  return Object.freeze(object)
	}

	initialConfigValidation.exports = validateInitialConfig;
	initialConfigValidation.exports.defaultInitOptions = validate.defaultInitOptions;
	initialConfigValidation.exports.utils = { deepFreezeObject };
	return initialConfigValidation.exports;
}

var pluginOverride;
var hasRequiredPluginOverride;

function requirePluginOverride () {
	if (hasRequiredPluginOverride) return pluginOverride;
	hasRequiredPluginOverride = 1;

	const {
	  kAvvioBoot,
	  kChildren,
	  kRoutePrefix,
	  kLogLevel,
	  kLogSerializers,
	  kHooks,
	  kSchemaController,
	  kContentTypeParser,
	  kReply,
	  kRequest,
	  kFourOhFour,
	  kPluginNameChain,
	  kErrorHandlerAlreadySet
	} = requireSymbols$1();

	const Reply = requireReply();
	const Request = requireRequest$1();
	const SchemaController = requireSchemaController();
	const ContentTypeParser = requireContentTypeParser();
	const { buildHooks } = requireHooks();
	const pluginUtils = requirePluginUtils();

	// Function that runs the encapsulation magic.
	// Everything that need to be encapsulated must be handled in this function.
	pluginOverride = function override (old, fn, opts) {
	  const shouldSkipOverride = pluginUtils.registerPlugin.call(old, fn);

	  const fnName = pluginUtils.getPluginName(fn) || pluginUtils.getFuncPreview(fn);
	  if (shouldSkipOverride) {
	    // after every plugin registration we will enter a new name
	    old[kPluginNameChain].push(fnName);
	    return old
	  }

	  const instance = Object.create(old);
	  old[kChildren].push(instance);
	  instance.ready = old[kAvvioBoot].bind(instance);
	  instance[kChildren] = [];

	  instance[kReply] = Reply.buildReply(instance[kReply]);
	  instance[kRequest] = Request.buildRequest(instance[kRequest]);

	  instance[kContentTypeParser] = ContentTypeParser.helpers.buildContentTypeParser(instance[kContentTypeParser]);
	  instance[kHooks] = buildHooks(instance[kHooks]);
	  instance[kRoutePrefix] = buildRoutePrefix(instance[kRoutePrefix], opts.prefix);
	  instance[kLogLevel] = opts.logLevel || instance[kLogLevel];
	  instance[kSchemaController] = SchemaController.buildSchemaController(old[kSchemaController]);
	  instance.getSchema = instance[kSchemaController].getSchema.bind(instance[kSchemaController]);
	  instance.getSchemas = instance[kSchemaController].getSchemas.bind(instance[kSchemaController]);

	  // Track the registered and loaded plugins since the root instance.
	  // It does not track the current encapsulated plugin.
	  instance[pluginUtils.kRegisteredPlugins] = Object.create(instance[pluginUtils.kRegisteredPlugins]);

	  // Track the plugin chain since the root instance.
	  // When an non-encapsulated plugin is added, the chain will be updated.
	  instance[kPluginNameChain] = [fnName];
	  instance[kErrorHandlerAlreadySet] = false;

	  if (instance[kLogSerializers] || opts.logSerializers) {
	    instance[kLogSerializers] = Object.assign(Object.create(instance[kLogSerializers]), opts.logSerializers);
	  }

	  if (opts.prefix) {
	    instance[kFourOhFour].arrange404(instance);
	  }

	  for (const hook of instance[kHooks].onRegister) hook.call(old, instance, opts);

	  return instance
	};

	function buildRoutePrefix (instancePrefix, pluginPrefix) {
	  if (!pluginPrefix) {
	    return instancePrefix
	  }

	  // Ensure that there is a '/' between the prefixes
	  if (instancePrefix.endsWith('/') && pluginPrefix[0] === '/') {
	    // Remove the extra '/' to avoid: '/first//second'
	    pluginPrefix = pluginPrefix.slice(1);
	  } else if (pluginPrefix[0] !== '/') {
	    pluginPrefix = '/' + pluginPrefix;
	  }

	  return instancePrefix + pluginPrefix
	}
	return pluginOverride;
}

var noopSet;
var hasRequiredNoopSet;

function requireNoopSet () {
	if (hasRequiredNoopSet) return noopSet;
	hasRequiredNoopSet = 1;

	noopSet = function noopSet () {
	  return {
	    [Symbol.iterator]: function * () {},
	    add () {},
	    delete () {},
	    has () { return true }
	  }
	};
	return noopSet;
}

var lightMyRequest = {exports: {}};

var request = {exports: {}};

var dist$1 = {};

var hasRequiredDist$1;

function requireDist$1 () {
	if (hasRequiredDist$1) return dist$1;
	hasRequiredDist$1 = 1;
	Object.defineProperty(dist$1, "__esModule", { value: true });
	dist$1.parse = parse;
	dist$1.serialize = serialize;
	/**
	 * RegExp to match cookie-name in RFC 6265 sec 4.1.1
	 * This refers out to the obsoleted definition of token in RFC 2616 sec 2.2
	 * which has been replaced by the token definition in RFC 7230 appendix B.
	 *
	 * cookie-name       = token
	 * token             = 1*tchar
	 * tchar             = "!" / "#" / "$" / "%" / "&" / "'" /
	 *                     "*" / "+" / "-" / "." / "^" / "_" /
	 *                     "`" / "|" / "~" / DIGIT / ALPHA
	 *
	 * Note: Allowing more characters - https://github.com/jshttp/cookie/issues/191
	 * Allow same range as cookie value, except `=`, which delimits end of name.
	 */
	const cookieNameRegExp = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/;
	/**
	 * RegExp to match cookie-value in RFC 6265 sec 4.1.1
	 *
	 * cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )
	 * cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E
	 *                     ; US-ASCII characters excluding CTLs,
	 *                     ; whitespace DQUOTE, comma, semicolon,
	 *                     ; and backslash
	 *
	 * Allowing more characters: https://github.com/jshttp/cookie/issues/191
	 * Comma, backslash, and DQUOTE are not part of the parsing algorithm.
	 */
	const cookieValueRegExp = /^[\u0021-\u003A\u003C-\u007E]*$/;
	/**
	 * RegExp to match domain-value in RFC 6265 sec 4.1.1
	 *
	 * domain-value      = <subdomain>
	 *                     ; defined in [RFC1034], Section 3.5, as
	 *                     ; enhanced by [RFC1123], Section 2.1
	 * <subdomain>       = <label> | <subdomain> "." <label>
	 * <label>           = <let-dig> [ [ <ldh-str> ] <let-dig> ]
	 *                     Labels must be 63 characters or less.
	 *                     'let-dig' not 'letter' in the first char, per RFC1123
	 * <ldh-str>         = <let-dig-hyp> | <let-dig-hyp> <ldh-str>
	 * <let-dig-hyp>     = <let-dig> | "-"
	 * <let-dig>         = <letter> | <digit>
	 * <letter>          = any one of the 52 alphabetic characters A through Z in
	 *                     upper case and a through z in lower case
	 * <digit>           = any one of the ten digits 0 through 9
	 *
	 * Keep support for leading dot: https://github.com/jshttp/cookie/issues/173
	 *
	 * > (Note that a leading %x2E ("."), if present, is ignored even though that
	 * character is not permitted, but a trailing %x2E ("."), if present, will
	 * cause the user agent to ignore the attribute.)
	 */
	const domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
	/**
	 * RegExp to match path-value in RFC 6265 sec 4.1.1
	 *
	 * path-value        = <any CHAR except CTLs or ";">
	 * CHAR              = %x01-7F
	 *                     ; defined in RFC 5234 appendix B.1
	 */
	const pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
	const __toString = Object.prototype.toString;
	const NullObject = /* @__PURE__ */ (() => {
	    const C = function () { };
	    C.prototype = Object.create(null);
	    return C;
	})();
	/**
	 * Parse a cookie header.
	 *
	 * Parse the given cookie header string into an object
	 * The object has the various cookies as keys(names) => values
	 */
	function parse(str, options) {
	    const obj = new NullObject();
	    const len = str.length;
	    // RFC 6265 sec 4.1.1, RFC 2616 2.2 defines a cookie name consists of one char minimum, plus '='.
	    if (len < 2)
	        return obj;
	    const dec = options?.decode || decode;
	    let index = 0;
	    do {
	        const eqIdx = str.indexOf("=", index);
	        if (eqIdx === -1)
	            break; // No more cookie pairs.
	        const colonIdx = str.indexOf(";", index);
	        const endIdx = colonIdx === -1 ? len : colonIdx;
	        if (eqIdx > endIdx) {
	            // backtrack on prior semicolon
	            index = str.lastIndexOf(";", eqIdx - 1) + 1;
	            continue;
	        }
	        const keyStartIdx = startIndex(str, index, eqIdx);
	        const keyEndIdx = endIndex(str, eqIdx, keyStartIdx);
	        const key = str.slice(keyStartIdx, keyEndIdx);
	        // only assign once
	        if (obj[key] === undefined) {
	            let valStartIdx = startIndex(str, eqIdx + 1, endIdx);
	            let valEndIdx = endIndex(str, endIdx, valStartIdx);
	            const value = dec(str.slice(valStartIdx, valEndIdx));
	            obj[key] = value;
	        }
	        index = endIdx + 1;
	    } while (index < len);
	    return obj;
	}
	function startIndex(str, index, max) {
	    do {
	        const code = str.charCodeAt(index);
	        if (code !== 0x20 /*   */ && code !== 0x09 /* \t */)
	            return index;
	    } while (++index < max);
	    return max;
	}
	function endIndex(str, index, min) {
	    while (index > min) {
	        const code = str.charCodeAt(--index);
	        if (code !== 0x20 /*   */ && code !== 0x09 /* \t */)
	            return index + 1;
	    }
	    return min;
	}
	/**
	 * Serialize data into a cookie header.
	 *
	 * Serialize a name value pair into a cookie string suitable for
	 * http headers. An optional options object specifies cookie parameters.
	 *
	 * serialize('foo', 'bar', { httpOnly: true })
	 *   => "foo=bar; httpOnly"
	 */
	function serialize(name, val, options) {
	    const enc = options?.encode || encodeURIComponent;
	    if (!cookieNameRegExp.test(name)) {
	        throw new TypeError(`argument name is invalid: ${name}`);
	    }
	    const value = enc(val);
	    if (!cookieValueRegExp.test(value)) {
	        throw new TypeError(`argument val is invalid: ${val}`);
	    }
	    let str = name + "=" + value;
	    if (!options)
	        return str;
	    if (options.maxAge !== undefined) {
	        if (!Number.isInteger(options.maxAge)) {
	            throw new TypeError(`option maxAge is invalid: ${options.maxAge}`);
	        }
	        str += "; Max-Age=" + options.maxAge;
	    }
	    if (options.domain) {
	        if (!domainValueRegExp.test(options.domain)) {
	            throw new TypeError(`option domain is invalid: ${options.domain}`);
	        }
	        str += "; Domain=" + options.domain;
	    }
	    if (options.path) {
	        if (!pathValueRegExp.test(options.path)) {
	            throw new TypeError(`option path is invalid: ${options.path}`);
	        }
	        str += "; Path=" + options.path;
	    }
	    if (options.expires) {
	        if (!isDate(options.expires) ||
	            !Number.isFinite(options.expires.valueOf())) {
	            throw new TypeError(`option expires is invalid: ${options.expires}`);
	        }
	        str += "; Expires=" + options.expires.toUTCString();
	    }
	    if (options.httpOnly) {
	        str += "; HttpOnly";
	    }
	    if (options.secure) {
	        str += "; Secure";
	    }
	    if (options.partitioned) {
	        str += "; Partitioned";
	    }
	    if (options.priority) {
	        const priority = typeof options.priority === "string"
	            ? options.priority.toLowerCase()
	            : undefined;
	        switch (priority) {
	            case "low":
	                str += "; Priority=Low";
	                break;
	            case "medium":
	                str += "; Priority=Medium";
	                break;
	            case "high":
	                str += "; Priority=High";
	                break;
	            default:
	                throw new TypeError(`option priority is invalid: ${options.priority}`);
	        }
	    }
	    if (options.sameSite) {
	        const sameSite = typeof options.sameSite === "string"
	            ? options.sameSite.toLowerCase()
	            : options.sameSite;
	        switch (sameSite) {
	            case true:
	            case "strict":
	                str += "; SameSite=Strict";
	                break;
	            case "lax":
	                str += "; SameSite=Lax";
	                break;
	            case "none":
	                str += "; SameSite=None";
	                break;
	            default:
	                throw new TypeError(`option sameSite is invalid: ${options.sameSite}`);
	        }
	    }
	    return str;
	}
	/**
	 * URL-decode string value. Optimized to skip native call when no %.
	 */
	function decode(str) {
	    if (str.indexOf("%") === -1)
	        return str;
	    try {
	        return decodeURIComponent(str);
	    }
	    catch (e) {
	        return str;
	    }
	}
	/**
	 * Determine if value is a Date.
	 */
	function isDate(val) {
	    return __toString.call(val) === "[object Date]";
	}
	
	return dist$1;
}

var processWarning = {exports: {}};

var hasRequiredProcessWarning;

function requireProcessWarning () {
	if (hasRequiredProcessWarning) return processWarning.exports;
	hasRequiredProcessWarning = 1;

	const { format } = require$$0$2;

	/**
	 * @namespace processWarning
	 */

	/**
	 * Represents a warning item with details.
	 * @typedef {Function} WarningItem
	 * @param {*} [a] Possible message interpolation value.
	 * @param {*} [b] Possible message interpolation value.
	 * @param {*} [c] Possible message interpolation value.
	 * @property {string} name - The name of the warning.
	 * @property {string} code - The code associated with the warning.
	 * @property {string} message - The warning message.
	 * @property {boolean} emitted - Indicates if the warning has been emitted.
	 * @property {function} format - Formats the warning message.
	 */

	/**
	 * Options for creating a process warning.
	 * @typedef {Object} ProcessWarningOptions
	 * @property {string} name - The name of the warning.
	 * @property {string} code - The code associated with the warning.
	 * @property {string} message - The warning message.
	 * @property {boolean} [unlimited=false] - If true, allows unlimited emissions of the warning.
	 */

	/**
	 * Represents the process warning functionality.
	 * @typedef {Object} ProcessWarning
	 * @property {function} createWarning - Creates a warning item.
	 * @property {function} createDeprecation - Creates a deprecation warning item.
	 */

	/**
	 * Creates a deprecation warning item.
	 * @function
	 * @memberof processWarning
	 * @param {ProcessWarningOptions} params - Options for creating the warning.
	 * @returns {WarningItem} The created deprecation warning item.
	 */
	function createDeprecation (params) {
	  return createWarning({ ...params, name: 'DeprecationWarning' })
	}

	/**
	 * Creates a warning item.
	 * @function
	 * @memberof processWarning
	 * @param {ProcessWarningOptions} params - Options for creating the warning.
	 * @returns {WarningItem} The created warning item.
	 * @throws {Error} Throws an error if name, code, or message is empty, or if opts.unlimited is not a boolean.
	 */
	function createWarning ({ name, code, message, unlimited = false } = {}) {
	  if (!name) throw new Error('Warning name must not be empty')
	  if (!code) throw new Error('Warning code must not be empty')
	  if (!message) throw new Error('Warning message must not be empty')
	  if (typeof unlimited !== 'boolean') throw new Error('Warning opts.unlimited must be a boolean')

	  code = code.toUpperCase();

	  let warningContainer = {
	    [name]: function (a, b, c) {
	      if (warning.emitted === true && warning.unlimited !== true) {
	        return
	      }
	      warning.emitted = true;
	      process.emitWarning(warning.format(a, b, c), warning.name, warning.code);
	    }
	  };
	  if (unlimited) {
	    warningContainer = {
	      [name]: function (a, b, c) {
	        warning.emitted = true;
	        process.emitWarning(warning.format(a, b, c), warning.name, warning.code);
	      }
	    };
	  }

	  const warning = warningContainer[name];

	  warning.emitted = false;
	  warning.message = message;
	  warning.unlimited = unlimited;
	  warning.code = code;

	  /**
	   * Formats the warning message.
	   * @param {*} [a] Possible message interpolation value.
	   * @param {*} [b] Possible message interpolation value.
	   * @param {*} [c] Possible message interpolation value.
	   * @returns {string} The formatted warning message.
	   */
	  warning.format = function (a, b, c) {
	    let formatted;
	    if (a && b && c) {
	      formatted = format(message, a, b, c);
	    } else if (a && b) {
	      formatted = format(message, a, b);
	    } else if (a) {
	      formatted = format(message, a);
	    } else {
	      formatted = message;
	    }
	    return formatted
	  };

	  return warning
	}

	/**
	 * Module exports containing the process warning functionality.
	 * @namespace
	 * @property {function} createWarning - Creates a warning item.
	 * @property {function} createDeprecation - Creates a deprecation warning item.
	 * @property {ProcessWarning} processWarning - Represents the process warning functionality.
	 */
	const out = { createWarning, createDeprecation };
	processWarning.exports = out;
	processWarning.exports.default = out;
	processWarning.exports.processWarning = out;
	return processWarning.exports;
}

var parseUrl;
var hasRequiredParseUrl;

function requireParseUrl () {
	if (hasRequiredParseUrl) return parseUrl;
	hasRequiredParseUrl = 1;

	const { URL } = require$$1$3;

	const BASE_URL = 'http://localhost';

	/**
	 * Parse URL
	 *
	 * @param {(Object|String)} url
	 * @param {Object} [query]
	 * @return {URL}
	 */
	parseUrl = function parseURL (url, query) {
	  if ((typeof url === 'string' || Object.prototype.toString.call(url) === '[object String]') && url.startsWith('//')) {
	    url = BASE_URL + url;
	  }
	  const result = typeof url === 'object'
	    ? Object.assign(new URL(BASE_URL), url)
	    : new URL(url, BASE_URL);

	  if (typeof query === 'string') {
	    query = new URLSearchParams(query);
	    for (const key of query.keys()) {
	      result.searchParams.delete(key);
	      for (const value of query.getAll(key)) {
	        result.searchParams.append(key, value);
	      }
	    }
	  } else {
	    const merged = Object.assign({}, url.query, query);
	    for (const key in merged) {
	      const value = merged[key];

	      if (Array.isArray(value)) {
	        result.searchParams.delete(key);
	        for (const param of value) {
	          result.searchParams.append(key, param);
	        }
	      } else {
	        result.searchParams.set(key, value);
	      }
	    }
	  }

	  return result
	};
	return parseUrl;
}

var formData = {};

var hasRequiredFormData;

function requireFormData () {
	if (hasRequiredFormData) return formData;
	hasRequiredFormData = 1;

	const { randomUUID } = require$$0$a;
	const { Readable } = require$$0$7;

	let textEncoder;

	function isFormDataLike (payload) {
	  return (
	    payload &&
	    typeof payload === 'object' &&
	    typeof payload.append === 'function' &&
	    typeof payload.delete === 'function' &&
	    typeof payload.get === 'function' &&
	    typeof payload.getAll === 'function' &&
	    typeof payload.has === 'function' &&
	    typeof payload.set === 'function' &&
	    payload[Symbol.toStringTag] === 'FormData'
	  )
	}

	/*
	  partial code extraction and refactoring of `undici`.
	  MIT License. https://github.com/nodejs/undici/blob/043d8f1a89f606b1db259fc71f4c9bc8eb2aa1e6/lib/web/fetch/LICENSE
	  Reference https://github.com/nodejs/undici/blob/043d8f1a89f606b1db259fc71f4c9bc8eb2aa1e6/lib/web/fetch/body.js#L102-L168
	*/
	function formDataToStream (formdata) {
	  // lazy creation of TextEncoder
	  textEncoder = textEncoder ?? new TextEncoder();

	  // we expect the function argument must be FormData
	  const boundary = `----formdata-${randomUUID()}`;
	  const prefix = `--${boundary}\r\nContent-Disposition: form-data`;

	  /*! formdata-polyfill. MIT License. Jimmy W√§rting <https://jimmy.warting.se/opensource> */
	  const escape = (str) =>
	    str.replace(/\n/g, '%0A').replace(/\r/g, '%0D').replace(/"/g, '%22');
	  const normalizeLinefeeds = (value) => value.replace(/\r?\n|\r/g, '\r\n');

	  const linebreak = new Uint8Array([13, 10]); // '\r\n'

	  async function * asyncIterator () {
	    for (const [name, value] of formdata) {
	      if (typeof value === 'string') {
	        // header
	        yield textEncoder.encode(`${prefix}; name="${escape(normalizeLinefeeds(name))}"\r\n\r\n`);
	        // body
	        yield textEncoder.encode(`${normalizeLinefeeds(value)}\r\n`);
	      } else {
	        let header = `${prefix}; name="${escape(normalizeLinefeeds(name))}"`;
	        value.name && (header += `; filename="${escape(value.name)}"`);
	        header += `\r\nContent-Type: ${value.type || 'application/octet-stream'}\r\n\r\n`;
	        // header
	        yield textEncoder.encode(header);
	        // body
	        if (value.stream) {
	          yield * value.stream();
	        } /* c8 ignore start */ else {
	          // shouldn't be here since Blob / File should provide .stream
	          // and FormData always convert to USVString
	          yield value;
	        } /* c8 ignore stop */
	        yield linebreak;
	      }
	    }
	    // end
	    yield textEncoder.encode(`--${boundary}--`);
	  }

	  const stream = Readable.from(asyncIterator());

	  return {
	    stream,
	    contentType: `multipart/form-data; boundary=${boundary}`
	  }
	}

	formData.isFormDataLike = isFormDataLike;
	formData.formDataToStream = formDataToStream;
	return formData;
}

var hasRequiredRequest;

function requireRequest () {
	if (hasRequiredRequest) return request.exports;
	hasRequiredRequest = 1;

	/* eslint no-prototype-builtins: 0 */

	const { Readable, addAbortSignal } = require$$0$7;
	const util = require$$0$2;
	const cookie = requireDist$1();
	const assert = require$$0$9;
	const { createDeprecation } = requireProcessWarning();

	const parseURL = requireParseUrl();
	const { isFormDataLike, formDataToStream } = requireFormData();
	const { EventEmitter } = require$$0$3;

	// request.connectin deprecation https://nodejs.org/api/http.html#http_request_connection
	const FST_LIGHTMYREQUEST_DEP01 = createDeprecation({
	  name: 'FastifyDeprecationLightMyRequest',
	  code: 'FST_LIGHTMYREQUEST_DEP01',
	  message: 'You are accessing "request.connection", use "request.socket" instead.'
	});

	/**
	 * Get hostname:port
	 *
	 * @param {URL} parsedURL
	 * @return {String}
	 */
	function hostHeaderFromURL (parsedURL) {
	  return parsedURL.port
	    ? parsedURL.host
	    : parsedURL.hostname + (parsedURL.protocol === 'https:' ? ':443' : ':80')
	}

	/**
	 * Mock socket object used to fake access to a socket for a request
	 *
	 * @constructor
	 * @param {String} remoteAddress the fake address to show consumers of the socket
	 */
	class MockSocket extends EventEmitter {
	  constructor (remoteAddress) {
	    super();
	    this.remoteAddress = remoteAddress;
	  }
	}

	/**
	 * CustomRequest
	 *
	 * @constructor
	 * @param {Object} options
	 * @param {(Object|String)} options.url || options.path
	 * @param {String} [options.method='GET']
	 * @param {String} [options.remoteAddress]
	 * @param {Object} [options.cookies]
	 * @param {Object} [options.headers]
	 * @param {Object} [options.query]
	 * @param {Object} [options.Request]
	 * @param {any} [options.payload]
	 */
	function CustomRequest (options) {
	  return new _CustomLMRRequest(this)

	  function _CustomLMRRequest (obj) {
	    Request.call(obj, {
	      ...options,
	      Request: undefined
	    });
	    Object.assign(this, obj);

	    for (const fn of Object.keys(Request.prototype)) {
	      this.constructor.prototype[fn] = Request.prototype[fn];
	    }

	    util.inherits(this.constructor, options.Request);
	    return this
	  }
	}

	/**
	 * Request
	 *
	 * @constructor
	 * @param {Object} options
	 * @param {(Object|String)} options.url || options.path
	 * @param {String} [options.method='GET']
	 * @param {String} [options.remoteAddress]
	 * @param {Object} [options.cookies]
	 * @param {Object} [options.headers]
	 * @param {Object} [options.query]
	 * @param {any} [options.payload]
	 */
	function Request (options) {
	  Readable.call(this, {
	    autoDestroy: false
	  });

	  const parsedURL = parseURL(options.url || options.path, options.query);

	  this.url = parsedURL.pathname + parsedURL.search;

	  this.aborted = false;
	  this.httpVersionMajor = 1;
	  this.httpVersionMinor = 1;
	  this.httpVersion = '1.1';
	  this.method = options.method ? options.method.toUpperCase() : 'GET';

	  this.headers = {};
	  this.rawHeaders = [];

	  const headers = options.headers || {};

	  for (const field in headers) {
	    const fieldLowerCase = field.toLowerCase();
	    if (
	      (
	        fieldLowerCase === 'user-agent' ||
	        fieldLowerCase === 'content-type'
	      ) && headers[field] === undefined
	    ) {
	      this.headers[fieldLowerCase] = undefined;
	      continue
	    }
	    const value = headers[field];
	    assert(value !== undefined, 'invalid value "undefined" for header ' + field);
	    this.headers[fieldLowerCase] = '' + value;
	  }

	  if (('user-agent' in this.headers) === false) {
	    this.headers['user-agent'] = 'lightMyRequest';
	  }
	  this.headers.host = this.headers.host || options.authority || hostHeaderFromURL(parsedURL);

	  if (options.cookies) {
	    const { cookies } = options;
	    const cookieValues = Object.keys(cookies).map(key => cookie.serialize(key, cookies[key]));
	    if (this.headers.cookie) {
	      cookieValues.unshift(this.headers.cookie);
	    }
	    this.headers.cookie = cookieValues.join('; ');
	  }

	  this.socket = new MockSocket(options.remoteAddress || '127.0.0.1');

	  Object.defineProperty(this, 'connection', {
	    get () {
	      FST_LIGHTMYREQUEST_DEP01();
	      return this.socket
	    },
	    configurable: true
	  });

	  // we keep both payload and body for compatibility reasons
	  let payload = options.payload || options.body || null;
	  let payloadResume = payload && typeof payload.resume === 'function';

	  if (isFormDataLike(payload)) {
	    const stream = formDataToStream(payload);
	    payload = stream.stream;
	    payloadResume = true;
	    // we override the content-type
	    this.headers['content-type'] = stream.contentType;
	    this.headers['transfer-encoding'] = 'chunked';
	  }

	  if (payload && typeof payload !== 'string' && !payloadResume && !Buffer.isBuffer(payload)) {
	    payload = JSON.stringify(payload);

	    if (('content-type' in this.headers) === false) {
	      this.headers['content-type'] = 'application/json';
	    }
	  }

	  // Set the content-length for the corresponding payload if none set
	  if (payload && !payloadResume && !Object.hasOwn(this.headers, 'content-length')) {
	    this.headers['content-length'] = (Buffer.isBuffer(payload) ? payload.length : Buffer.byteLength(payload)).toString();
	  }

	  for (const header of Object.keys(this.headers)) {
	    this.rawHeaders.push(header, this.headers[header]);
	  }

	  // Use _lightMyRequest namespace to avoid collision with Node
	  this._lightMyRequest = {
	    payload,
	    isDone: false,
	    simulate: options.simulate || {},
	    payloadAsStream: options.payloadAsStream,
	    signal: options.signal
	  };

	  const signal = options.signal;
	  /* c8 ignore next 3 */
	  if (signal) {
	    addAbortSignal(signal, this);
	  }

	  {
	    const payload = this._lightMyRequest.payload;
	    if (payload?._readableState) { // does quack like a modern stream
	      this._read = readStream;

	      payload.on('error', (err) => {
	        this.destroy(err);
	      });

	      payload.on('end', () => {
	        this.push(null);
	      });
	    } else {
	      // Stream v1 are handled in index.js synchronously
	      this._read = readEverythingElse;
	    }
	  }

	  return this
	}

	function readStream () {
	  const payload = this._lightMyRequest.payload;

	  let more = true;
	  let pushed = false;
	  let chunk;
	  while (more && (chunk = payload.read())) {
	    pushed = true;
	    more = this.push(chunk);
	  }

	  // We set up a recursive 'readable' event only if we didn't read anything.
	  // Otheriwse, the stream machinery will call _read() for us.
	  if (more && !pushed) {
	    this._lightMyRequest.payload.once('readable', this._read.bind(this));
	  }
	}

	function readEverythingElse () {
	  setImmediate(() => {
	    if (this._lightMyRequest.isDone) {
	      // 'end' defaults to true
	      if (this._lightMyRequest.simulate.end !== false) {
	        this.push(null);
	      }
	      return
	    }

	    this._lightMyRequest.isDone = true;

	    if (this._lightMyRequest.payload) {
	      if (this._lightMyRequest.simulate.split) {
	        this.push(this._lightMyRequest.payload.slice(0, 1));
	        this.push(this._lightMyRequest.payload.slice(1));
	      } else {
	        this.push(this._lightMyRequest.payload);
	      }
	    }

	    if (this._lightMyRequest.simulate.error) {
	      this.emit('error', new Error('Simulated'));
	    }

	    if (this._lightMyRequest.simulate.close) {
	      this.emit('close');
	    }

	    // 'end' defaults to true
	    if (this._lightMyRequest.simulate.end !== false) {
	      this.push(null);
	    }
	  });
	}

	util.inherits(Request, Readable);
	util.inherits(CustomRequest, Request);

	Request.prototype.destroy = function (error) {
	  if (this.destroyed || this._lightMyRequest.isDone) return
	  this.destroyed = true;

	  if (error) {
	    this._error = true;
	    process.nextTick(() => this.emit('error', error));
	  }

	  process.nextTick(() => this.emit('close'));
	};

	request.exports = Request;
	request.exports.Request = Request;
	request.exports.CustomRequest = CustomRequest;
	return request.exports;
}

var setCookie = {exports: {}};

var hasRequiredSetCookie;

function requireSetCookie () {
	if (hasRequiredSetCookie) return setCookie.exports;
	hasRequiredSetCookie = 1;

	var defaultParseOptions = {
	  decodeValues: true,
	  map: false,
	  silent: false,
	};

	function isNonEmptyString(str) {
	  return typeof str === "string" && !!str.trim();
	}

	function parseString(setCookieValue, options) {
	  var parts = setCookieValue.split(";").filter(isNonEmptyString);

	  var nameValuePairStr = parts.shift();
	  var parsed = parseNameValuePair(nameValuePairStr);
	  var name = parsed.name;
	  var value = parsed.value;

	  options = options
	    ? Object.assign({}, defaultParseOptions, options)
	    : defaultParseOptions;

	  try {
	    value = options.decodeValues ? decodeURIComponent(value) : value; // decode cookie value
	  } catch (e) {
	    console.error(
	      "set-cookie-parser encountered an error while decoding a cookie with value '" +
	        value +
	        "'. Set options.decodeValues to false to disable this feature.",
	      e
	    );
	  }

	  var cookie = {
	    name: name,
	    value: value,
	  };

	  parts.forEach(function (part) {
	    var sides = part.split("=");
	    var key = sides.shift().trimLeft().toLowerCase();
	    var value = sides.join("=");
	    if (key === "expires") {
	      cookie.expires = new Date(value);
	    } else if (key === "max-age") {
	      cookie.maxAge = parseInt(value, 10);
	    } else if (key === "secure") {
	      cookie.secure = true;
	    } else if (key === "httponly") {
	      cookie.httpOnly = true;
	    } else if (key === "samesite") {
	      cookie.sameSite = value;
	    } else if (key === "partitioned") {
	      cookie.partitioned = true;
	    } else {
	      cookie[key] = value;
	    }
	  });

	  return cookie;
	}

	function parseNameValuePair(nameValuePairStr) {
	  // Parses name-value-pair according to rfc6265bis draft

	  var name = "";
	  var value = "";
	  var nameValueArr = nameValuePairStr.split("=");
	  if (nameValueArr.length > 1) {
	    name = nameValueArr.shift();
	    value = nameValueArr.join("="); // everything after the first =, joined by a "=" if there was more than one part
	  } else {
	    value = nameValuePairStr;
	  }

	  return { name: name, value: value };
	}

	function parse(input, options) {
	  options = options
	    ? Object.assign({}, defaultParseOptions, options)
	    : defaultParseOptions;

	  if (!input) {
	    if (!options.map) {
	      return [];
	    } else {
	      return {};
	    }
	  }

	  if (input.headers) {
	    if (typeof input.headers.getSetCookie === "function") {
	      // for fetch responses - they combine headers of the same type in the headers array,
	      // but getSetCookie returns an uncombined array
	      input = input.headers.getSetCookie();
	    } else if (input.headers["set-cookie"]) {
	      // fast-path for node.js (which automatically normalizes header names to lower-case
	      input = input.headers["set-cookie"];
	    } else {
	      // slow-path for other environments - see #25
	      var sch =
	        input.headers[
	          Object.keys(input.headers).find(function (key) {
	            return key.toLowerCase() === "set-cookie";
	          })
	        ];
	      // warn if called on a request-like object with a cookie header rather than a set-cookie header - see #34, 36
	      if (!sch && input.headers.cookie && !options.silent) {
	        console.warn(
	          "Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning."
	        );
	      }
	      input = sch;
	    }
	  }
	  if (!Array.isArray(input)) {
	    input = [input];
	  }

	  if (!options.map) {
	    return input.filter(isNonEmptyString).map(function (str) {
	      return parseString(str, options);
	    });
	  } else {
	    var cookies = {};
	    return input.filter(isNonEmptyString).reduce(function (cookies, str) {
	      var cookie = parseString(str, options);
	      cookies[cookie.name] = cookie;
	      return cookies;
	    }, cookies);
	  }
	}

	/*
	  Set-Cookie header field-values are sometimes comma joined in one string. This splits them without choking on commas
	  that are within a single set-cookie field-value, such as in the Expires portion.

	  This is uncommon, but explicitly allowed - see https://tools.ietf.org/html/rfc2616#section-4.2
	  Node.js does this for every header *except* set-cookie - see https://github.com/nodejs/node/blob/d5e363b77ebaf1caf67cd7528224b651c86815c1/lib/_http_incoming.js#L128
	  React Native's fetch does this for *every* header, including set-cookie.

	  Based on: https://github.com/google/j2objc/commit/16820fdbc8f76ca0c33472810ce0cb03d20efe25
	  Credits to: https://github.com/tomball for original and https://github.com/chrusart for JavaScript implementation
	*/
	function splitCookiesString(cookiesString) {
	  if (Array.isArray(cookiesString)) {
	    return cookiesString;
	  }
	  if (typeof cookiesString !== "string") {
	    return [];
	  }

	  var cookiesStrings = [];
	  var pos = 0;
	  var start;
	  var ch;
	  var lastComma;
	  var nextStart;
	  var cookiesSeparatorFound;

	  function skipWhitespace() {
	    while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) {
	      pos += 1;
	    }
	    return pos < cookiesString.length;
	  }

	  function notSpecialChar() {
	    ch = cookiesString.charAt(pos);

	    return ch !== "=" && ch !== ";" && ch !== ",";
	  }

	  while (pos < cookiesString.length) {
	    start = pos;
	    cookiesSeparatorFound = false;

	    while (skipWhitespace()) {
	      ch = cookiesString.charAt(pos);
	      if (ch === ",") {
	        // ',' is a cookie separator if we have later first '=', not ';' or ','
	        lastComma = pos;
	        pos += 1;

	        skipWhitespace();
	        nextStart = pos;

	        while (pos < cookiesString.length && notSpecialChar()) {
	          pos += 1;
	        }

	        // currently special character
	        if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
	          // we found cookies separator
	          cookiesSeparatorFound = true;
	          // pos is inside the next cookie, so back up and return it.
	          pos = nextStart;
	          cookiesStrings.push(cookiesString.substring(start, lastComma));
	          start = pos;
	        } else {
	          // in param ',' or param separator ';',
	          // we continue from that comma
	          pos = lastComma + 1;
	        }
	      } else {
	        pos += 1;
	      }
	    }

	    if (!cookiesSeparatorFound || pos >= cookiesString.length) {
	      cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
	    }
	  }

	  return cookiesStrings;
	}

	setCookie.exports = parse;
	setCookie.exports.parse = parse;
	setCookie.exports.parseString = parseString;
	setCookie.exports.splitCookiesString = splitCookiesString;
	return setCookie.exports;
}

var response$1;
var hasRequiredResponse$1;

function requireResponse$1 () {
	if (hasRequiredResponse$1) return response$1;
	hasRequiredResponse$1 = 1;

	const http = require$$0$4;
	const { Writable, Readable, addAbortSignal } = require$$0$7;
	const util = require$$0$2;

	const setCookie = /*@__PURE__*/ requireSetCookie();

	function Response (req, onEnd, reject) {
	  http.ServerResponse.call(this, req);

	  if (req._lightMyRequest?.payloadAsStream) {
	    const read = this.emit.bind(this, 'drain');
	    this._lightMyRequest = { headers: null, trailers: {}, stream: new Readable({ read }) };
	    const signal = req._lightMyRequest.signal;

	    if (signal) {
	      addAbortSignal(signal, this._lightMyRequest.stream);
	    }
	  } else {
	    this._lightMyRequest = { headers: null, trailers: {}, payloadChunks: [] };
	  }
	  // This forces node@8 to always render the headers
	  this.setHeader('foo', 'bar'); this.removeHeader('foo');

	  this.assignSocket(getNullSocket());

	  this._promiseCallback = typeof reject === 'function';

	  let called = false;
	  const onEndSuccess = (payload) => {
	    if (called) return
	    called = true;
	    if (this._promiseCallback) {
	      return process.nextTick(() => onEnd(payload))
	    }
	    process.nextTick(() => onEnd(null, payload));
	  };
	  this._lightMyRequest.onEndSuccess = onEndSuccess;

	  let finished = false;
	  const onEndFailure = (err) => {
	    if (called) {
	      if (this._lightMyRequest.stream && !finished) {
	        if (!err) {
	          err = new Error('response destroyed before completion');
	          err.code = 'LIGHT_ECONNRESET';
	        }
	        this._lightMyRequest.stream.destroy(err);
	        this._lightMyRequest.stream.on('error', () => {});
	      }
	      return
	    }
	    called = true;
	    if (!err) {
	      err = new Error('response destroyed before completion');
	      err.code = 'LIGHT_ECONNRESET';
	    }
	    if (this._promiseCallback) {
	      return process.nextTick(() => reject(err))
	    }
	    process.nextTick(() => onEnd(err, null));
	  };

	  if (this._lightMyRequest.stream) {
	    this.once('finish', () => {
	      finished = true;
	      this._lightMyRequest.stream.push(null);
	    });
	  } else {
	    this.once('finish', () => {
	      const res = generatePayload(this);
	      res.raw.req = req;
	      onEndSuccess(res);
	    });
	  }

	  this.connection.once('error', onEndFailure);

	  this.once('error', onEndFailure);

	  this.once('close', onEndFailure);
	}

	util.inherits(Response, http.ServerResponse);

	Response.prototype.setTimeout = function (msecs, callback) {
	  this.timeoutHandle = setTimeout(() => {
	    this.emit('timeout');
	  }, msecs);
	  this.on('timeout', callback);
	  return this
	};

	Response.prototype.writeHead = function () {
	  const result = http.ServerResponse.prototype.writeHead.apply(this, arguments);

	  copyHeaders(this);

	  if (this._lightMyRequest.stream) {
	    this._lightMyRequest.onEndSuccess(generatePayload(this));
	  }

	  return result
	};

	Response.prototype.write = function (data, encoding, callback) {
	  if (this.timeoutHandle) {
	    clearTimeout(this.timeoutHandle);
	  }
	  http.ServerResponse.prototype.write.call(this, data, encoding, callback);
	  if (this._lightMyRequest.stream) {
	    return this._lightMyRequest.stream.push(Buffer.from(data, encoding))
	  } else {
	    this._lightMyRequest.payloadChunks.push(Buffer.from(data, encoding));
	    return true
	  }
	};

	Response.prototype.end = function (data, encoding, callback) {
	  if (data) {
	    this.write(data, encoding);
	  }

	  http.ServerResponse.prototype.end.call(this, callback);

	  this.emit('finish');

	  // We need to emit 'close' otherwise stream.finished() would
	  // not pick it up on Node v16

	  this.destroy();
	};

	Response.prototype.destroy = function (error) {
	  if (this.destroyed) return
	  this.destroyed = true;

	  if (error) {
	    process.nextTick(() => this.emit('error', error));
	  }

	  process.nextTick(() => this.emit('close'));
	};

	Response.prototype.addTrailers = function (trailers) {
	  for (const key in trailers) {
	    this._lightMyRequest.trailers[key.toLowerCase().trim()] = trailers[key].toString().trim();
	  }
	};

	function generatePayload (response) {
	  // This seems only to happen when using `fastify-express` - see https://github.com/fastify/fastify-express/issues/47
	  /* c8 ignore next 3  */
	  if (response._lightMyRequest.headers === null) {
	    copyHeaders(response);
	  }
	  serializeHeaders(response);
	  // Prepare response object
	  const res = {
	    raw: {
	      res: response
	    },
	    headers: response._lightMyRequest.headers,
	    statusCode: response.statusCode,
	    statusMessage: response.statusMessage,
	    trailers: {},
	    get cookies () {
	      return setCookie.parse(this)
	    }
	  };

	  res.trailers = response._lightMyRequest.trailers;

	  if (response._lightMyRequest.payloadChunks) {
	    // Prepare payload and trailers
	    const rawBuffer = Buffer.concat(response._lightMyRequest.payloadChunks);
	    res.rawPayload = rawBuffer;

	    // we keep both of them for compatibility reasons
	    res.payload = rawBuffer.toString();
	    res.body = res.payload;

	    // Prepare payload parsers
	    res.json = function parseJsonPayload () {
	      return JSON.parse(res.payload)
	    };
	  } else {
	    res.json = function () {
	      throw new Error('Response payload is not available with payloadAsStream: true')
	    };
	  }

	  // Provide stream Readable for advanced user
	  res.stream = function streamPayload () {
	    if (response._lightMyRequest.stream) {
	      return response._lightMyRequest.stream
	    }
	    return Readable.from(response._lightMyRequest.payloadChunks)
	  };

	  return res
	}

	// Throws away all written data to prevent response from buffering payload
	function getNullSocket () {
	  return new Writable({
	    write (_chunk, _encoding, callback) {
	      setImmediate(callback);
	    }
	  })
	}

	function serializeHeaders (response) {
	  const headers = response._lightMyRequest.headers;

	  for (const headerName of Object.keys(headers)) {
	    const headerValue = headers[headerName];
	    if (Array.isArray(headerValue)) {
	      headers[headerName] = headerValue.map(value => '' + value);
	    } else {
	      headers[headerName] = '' + headerValue;
	    }
	  }
	}

	function copyHeaders (response) {
	  response._lightMyRequest.headers = Object.assign({}, response.getHeaders())

	  // Add raw headers
	  ;['Date', 'Connection', 'Transfer-Encoding'].forEach((name) => {
	    const regex = new RegExp('\\r\\n' + name + ': ([^\\r]*)\\r\\n');
	    const field = response._header?.match(regex);
	    if (field) {
	      response._lightMyRequest.headers[name.toLowerCase()] = field[1];
	    }
	  });
	}

	response$1 = Response;
	return response$1;
}

var configValidator = {exports: {}};

var hasRequiredConfigValidator;

function requireConfigValidator () {
	if (hasRequiredConfigValidator) return configValidator.exports;
	hasRequiredConfigValidator = 1;
	configValidator.exports = validate10;
	configValidator.exports.default = validate10;
	const schema11 = {"properties":{"method":{"enum":["ACL","BIND","CHECKOUT","CONNECT","COPY","DELETE","GET","HEAD","LINK","LOCK","M-SEARCH","MERGE","MKACTIVITY","MKCALENDAR","MKCOL","MOVE","NOTIFY","OPTIONS","PATCH","POST","PROPFIND","PROPPATCH","PURGE","PUT","QUERY","REBIND","REPORT","SEARCH","SOURCE","SUBSCRIBE","TRACE","UNBIND","UNLINK","UNLOCK","UNSUBSCRIBE","acl","bind","checkout","connect","copy","delete","get","head","link","lock","m-search","merge","mkactivity","mkcalendar","mkcol","move","notify","options","patch","post","propfind","proppatch","purge","put","query","rebind","report","search","source","subscribe","trace","unbind","unlink","unlock","unsubscribe"]}}};

	function validate10(data, {instancePath="", parentData, parentDataProperty, rootData=data}={}){
	let vErrors = null;
	let errors = 0;
	const _errs1 = errors;
	let valid0 = false;
	let passing0 = null;
	const _errs2 = errors;
	if(data && typeof data == "object" && !Array.isArray(data)){
	let missing0;
	if((data.url === undefined) && (missing0 = "url")){
	const err0 = {instancePath,schemaPath:"#/oneOf/0/required",keyword:"required",params:{missingProperty: missing0},message:"must have required property '"+missing0+"'"};
	if(vErrors === null){
	vErrors = [err0];
	}
	else {
	vErrors.push(err0);
	}
	errors++;
	}
	}
	var _valid0 = _errs2 === errors;
	if(_valid0){
	valid0 = true;
	passing0 = 0;
	}
	const _errs3 = errors;
	if(data && typeof data == "object" && !Array.isArray(data)){
	let missing1;
	if((data.path === undefined) && (missing1 = "path")){
	const err1 = {instancePath,schemaPath:"#/oneOf/1/required",keyword:"required",params:{missingProperty: missing1},message:"must have required property '"+missing1+"'"};
	if(vErrors === null){
	vErrors = [err1];
	}
	else {
	vErrors.push(err1);
	}
	errors++;
	}
	}
	var _valid0 = _errs3 === errors;
	if(_valid0 && valid0){
	valid0 = false;
	passing0 = [passing0, 1];
	}
	else {
	if(_valid0){
	valid0 = true;
	passing0 = 1;
	}
	}
	if(!valid0){
	const err2 = {instancePath,schemaPath:"#/oneOf",keyword:"oneOf",params:{passingSchemas: passing0},message:"must match exactly one schema in oneOf"};
	if(vErrors === null){
	vErrors = [err2];
	}
	else {
	vErrors.push(err2);
	}
	errors++;
	validate10.errors = vErrors;
	return false;
	}
	else {
	errors = _errs1;
	if(vErrors !== null){
	if(_errs1){
	vErrors.length = _errs1;
	}
	else {
	vErrors = null;
	}
	}
	}
	if(errors === 0){
	if(data && typeof data == "object" && !Array.isArray(data)){
	if(data.url !== undefined){
	let data0 = data.url;
	const _errs5 = errors;
	const _errs6 = errors;
	let valid2 = false;
	let passing1 = null;
	const _errs7 = errors;
	if(typeof data0 !== "string"){
	let dataType0 = typeof data0;
	let coerced0 = undefined;
	if(!(coerced0 !== undefined)){
	if(dataType0 == "number" || dataType0 == "boolean"){
	coerced0 = "" + data0;
	}
	else if(data0 === null){
	coerced0 = "";
	}
	else {
	const err3 = {instancePath:instancePath+"/url",schemaPath:"#/properties/url/oneOf/0/type",keyword:"type",params:{type: "string"},message:"must be string"};
	if(vErrors === null){
	vErrors = [err3];
	}
	else {
	vErrors.push(err3);
	}
	errors++;
	}
	}
	if(coerced0 !== undefined){
	data0 = coerced0;
	if(data !== undefined){
	data["url"] = coerced0;
	}
	}
	}
	var _valid1 = _errs7 === errors;
	if(_valid1){
	valid2 = true;
	passing1 = 0;
	}
	const _errs9 = errors;
	if(errors === _errs9){
	if(data0 && typeof data0 == "object" && !Array.isArray(data0)){
	let missing2;
	if((data0.pathname === undefined) && (missing2 = "pathname")){
	const err4 = {instancePath:instancePath+"/url",schemaPath:"#/properties/url/oneOf/1/required",keyword:"required",params:{missingProperty: missing2},message:"must have required property '"+missing2+"'"};
	if(vErrors === null){
	vErrors = [err4];
	}
	else {
	vErrors.push(err4);
	}
	errors++;
	}
	else {
	if(data0.protocol !== undefined){
	let data1 = data0.protocol;
	const _errs12 = errors;
	if(typeof data1 !== "string"){
	let dataType1 = typeof data1;
	let coerced1 = undefined;
	if(!(coerced1 !== undefined)){
	if(dataType1 == "number" || dataType1 == "boolean"){
	coerced1 = "" + data1;
	}
	else if(data1 === null){
	coerced1 = "";
	}
	else {
	const err5 = {instancePath:instancePath+"/url/protocol",schemaPath:"#/properties/url/oneOf/1/properties/protocol/type",keyword:"type",params:{type: "string"},message:"must be string"};
	if(vErrors === null){
	vErrors = [err5];
	}
	else {
	vErrors.push(err5);
	}
	errors++;
	}
	}
	if(coerced1 !== undefined){
	data1 = coerced1;
	if(data0 !== undefined){
	data0["protocol"] = coerced1;
	}
	}
	}
	var valid3 = _errs12 === errors;
	}
	else {
	var valid3 = true;
	}
	if(valid3){
	if(data0.hostname !== undefined){
	let data2 = data0.hostname;
	const _errs14 = errors;
	if(typeof data2 !== "string"){
	let dataType2 = typeof data2;
	let coerced2 = undefined;
	if(!(coerced2 !== undefined)){
	if(dataType2 == "number" || dataType2 == "boolean"){
	coerced2 = "" + data2;
	}
	else if(data2 === null){
	coerced2 = "";
	}
	else {
	const err6 = {instancePath:instancePath+"/url/hostname",schemaPath:"#/properties/url/oneOf/1/properties/hostname/type",keyword:"type",params:{type: "string"},message:"must be string"};
	if(vErrors === null){
	vErrors = [err6];
	}
	else {
	vErrors.push(err6);
	}
	errors++;
	}
	}
	if(coerced2 !== undefined){
	data2 = coerced2;
	if(data0 !== undefined){
	data0["hostname"] = coerced2;
	}
	}
	}
	var valid3 = _errs14 === errors;
	}
	else {
	var valid3 = true;
	}
	if(valid3){
	if(data0.pathname !== undefined){
	let data3 = data0.pathname;
	const _errs16 = errors;
	if(typeof data3 !== "string"){
	let dataType3 = typeof data3;
	let coerced3 = undefined;
	if(!(coerced3 !== undefined)){
	if(dataType3 == "number" || dataType3 == "boolean"){
	coerced3 = "" + data3;
	}
	else if(data3 === null){
	coerced3 = "";
	}
	else {
	const err7 = {instancePath:instancePath+"/url/pathname",schemaPath:"#/properties/url/oneOf/1/properties/pathname/type",keyword:"type",params:{type: "string"},message:"must be string"};
	if(vErrors === null){
	vErrors = [err7];
	}
	else {
	vErrors.push(err7);
	}
	errors++;
	}
	}
	if(coerced3 !== undefined){
	data3 = coerced3;
	if(data0 !== undefined){
	data0["pathname"] = coerced3;
	}
	}
	}
	var valid3 = _errs16 === errors;
	}
	else {
	var valid3 = true;
	}
	}
	}
	}
	}
	else {
	const err8 = {instancePath:instancePath+"/url",schemaPath:"#/properties/url/oneOf/1/type",keyword:"type",params:{type: "object"},message:"must be object"};
	if(vErrors === null){
	vErrors = [err8];
	}
	else {
	vErrors.push(err8);
	}
	errors++;
	}
	}
	var _valid1 = _errs9 === errors;
	if(_valid1 && valid2){
	valid2 = false;
	passing1 = [passing1, 1];
	}
	else {
	if(_valid1){
	valid2 = true;
	passing1 = 1;
	}
	}
	if(!valid2){
	const err9 = {instancePath:instancePath+"/url",schemaPath:"#/properties/url/oneOf",keyword:"oneOf",params:{passingSchemas: passing1},message:"must match exactly one schema in oneOf"};
	if(vErrors === null){
	vErrors = [err9];
	}
	else {
	vErrors.push(err9);
	}
	errors++;
	validate10.errors = vErrors;
	return false;
	}
	else {
	errors = _errs6;
	if(vErrors !== null){
	if(_errs6){
	vErrors.length = _errs6;
	}
	else {
	vErrors = null;
	}
	}
	}
	var valid1 = _errs5 === errors;
	}
	else {
	var valid1 = true;
	}
	if(valid1){
	if(data.path !== undefined){
	let data4 = data.path;
	const _errs18 = errors;
	const _errs19 = errors;
	let valid4 = false;
	let passing2 = null;
	const _errs20 = errors;
	if(typeof data4 !== "string"){
	let dataType4 = typeof data4;
	let coerced4 = undefined;
	if(!(coerced4 !== undefined)){
	if(dataType4 == "number" || dataType4 == "boolean"){
	coerced4 = "" + data4;
	}
	else if(data4 === null){
	coerced4 = "";
	}
	else {
	const err10 = {instancePath:instancePath+"/path",schemaPath:"#/properties/path/oneOf/0/type",keyword:"type",params:{type: "string"},message:"must be string"};
	if(vErrors === null){
	vErrors = [err10];
	}
	else {
	vErrors.push(err10);
	}
	errors++;
	}
	}
	if(coerced4 !== undefined){
	data4 = coerced4;
	if(data !== undefined){
	data["path"] = coerced4;
	}
	}
	}
	var _valid2 = _errs20 === errors;
	if(_valid2){
	valid4 = true;
	passing2 = 0;
	}
	const _errs22 = errors;
	if(errors === _errs22){
	if(data4 && typeof data4 == "object" && !Array.isArray(data4)){
	let missing3;
	if((data4.pathname === undefined) && (missing3 = "pathname")){
	const err11 = {instancePath:instancePath+"/path",schemaPath:"#/properties/path/oneOf/1/required",keyword:"required",params:{missingProperty: missing3},message:"must have required property '"+missing3+"'"};
	if(vErrors === null){
	vErrors = [err11];
	}
	else {
	vErrors.push(err11);
	}
	errors++;
	}
	else {
	if(data4.protocol !== undefined){
	let data5 = data4.protocol;
	const _errs25 = errors;
	if(typeof data5 !== "string"){
	let dataType5 = typeof data5;
	let coerced5 = undefined;
	if(!(coerced5 !== undefined)){
	if(dataType5 == "number" || dataType5 == "boolean"){
	coerced5 = "" + data5;
	}
	else if(data5 === null){
	coerced5 = "";
	}
	else {
	const err12 = {instancePath:instancePath+"/path/protocol",schemaPath:"#/properties/path/oneOf/1/properties/protocol/type",keyword:"type",params:{type: "string"},message:"must be string"};
	if(vErrors === null){
	vErrors = [err12];
	}
	else {
	vErrors.push(err12);
	}
	errors++;
	}
	}
	if(coerced5 !== undefined){
	data5 = coerced5;
	if(data4 !== undefined){
	data4["protocol"] = coerced5;
	}
	}
	}
	var valid5 = _errs25 === errors;
	}
	else {
	var valid5 = true;
	}
	if(valid5){
	if(data4.hostname !== undefined){
	let data6 = data4.hostname;
	const _errs27 = errors;
	if(typeof data6 !== "string"){
	let dataType6 = typeof data6;
	let coerced6 = undefined;
	if(!(coerced6 !== undefined)){
	if(dataType6 == "number" || dataType6 == "boolean"){
	coerced6 = "" + data6;
	}
	else if(data6 === null){
	coerced6 = "";
	}
	else {
	const err13 = {instancePath:instancePath+"/path/hostname",schemaPath:"#/properties/path/oneOf/1/properties/hostname/type",keyword:"type",params:{type: "string"},message:"must be string"};
	if(vErrors === null){
	vErrors = [err13];
	}
	else {
	vErrors.push(err13);
	}
	errors++;
	}
	}
	if(coerced6 !== undefined){
	data6 = coerced6;
	if(data4 !== undefined){
	data4["hostname"] = coerced6;
	}
	}
	}
	var valid5 = _errs27 === errors;
	}
	else {
	var valid5 = true;
	}
	if(valid5){
	if(data4.pathname !== undefined){
	let data7 = data4.pathname;
	const _errs29 = errors;
	if(typeof data7 !== "string"){
	let dataType7 = typeof data7;
	let coerced7 = undefined;
	if(!(coerced7 !== undefined)){
	if(dataType7 == "number" || dataType7 == "boolean"){
	coerced7 = "" + data7;
	}
	else if(data7 === null){
	coerced7 = "";
	}
	else {
	const err14 = {instancePath:instancePath+"/path/pathname",schemaPath:"#/properties/path/oneOf/1/properties/pathname/type",keyword:"type",params:{type: "string"},message:"must be string"};
	if(vErrors === null){
	vErrors = [err14];
	}
	else {
	vErrors.push(err14);
	}
	errors++;
	}
	}
	if(coerced7 !== undefined){
	data7 = coerced7;
	if(data4 !== undefined){
	data4["pathname"] = coerced7;
	}
	}
	}
	var valid5 = _errs29 === errors;
	}
	else {
	var valid5 = true;
	}
	}
	}
	}
	}
	else {
	const err15 = {instancePath:instancePath+"/path",schemaPath:"#/properties/path/oneOf/1/type",keyword:"type",params:{type: "object"},message:"must be object"};
	if(vErrors === null){
	vErrors = [err15];
	}
	else {
	vErrors.push(err15);
	}
	errors++;
	}
	}
	var _valid2 = _errs22 === errors;
	if(_valid2 && valid4){
	valid4 = false;
	passing2 = [passing2, 1];
	}
	else {
	if(_valid2){
	valid4 = true;
	passing2 = 1;
	}
	}
	if(!valid4){
	const err16 = {instancePath:instancePath+"/path",schemaPath:"#/properties/path/oneOf",keyword:"oneOf",params:{passingSchemas: passing2},message:"must match exactly one schema in oneOf"};
	if(vErrors === null){
	vErrors = [err16];
	}
	else {
	vErrors.push(err16);
	}
	errors++;
	validate10.errors = vErrors;
	return false;
	}
	else {
	errors = _errs19;
	if(vErrors !== null){
	if(_errs19){
	vErrors.length = _errs19;
	}
	else {
	vErrors = null;
	}
	}
	}
	var valid1 = _errs18 === errors;
	}
	else {
	var valid1 = true;
	}
	if(valid1){
	if(data.cookies !== undefined){
	let data8 = data.cookies;
	const _errs31 = errors;
	if(errors === _errs31){
	if(!(data8 && typeof data8 == "object" && !Array.isArray(data8))){
	validate10.errors = [{instancePath:instancePath+"/cookies",schemaPath:"#/properties/cookies/type",keyword:"type",params:{type: "object"},message:"must be object"}];
	return false;
	}
	}
	var valid1 = _errs31 === errors;
	}
	else {
	var valid1 = true;
	}
	if(valid1){
	if(data.headers !== undefined){
	let data9 = data.headers;
	const _errs34 = errors;
	if(errors === _errs34){
	if(!(data9 && typeof data9 == "object" && !Array.isArray(data9))){
	validate10.errors = [{instancePath:instancePath+"/headers",schemaPath:"#/properties/headers/type",keyword:"type",params:{type: "object"},message:"must be object"}];
	return false;
	}
	}
	var valid1 = _errs34 === errors;
	}
	else {
	var valid1 = true;
	}
	if(valid1){
	if(data.query !== undefined){
	let data10 = data.query;
	const _errs37 = errors;
	const _errs38 = errors;
	let valid6 = false;
	const _errs39 = errors;
	if(errors === _errs39){
	if(!(data10 && typeof data10 == "object" && !Array.isArray(data10))){
	const err17 = {instancePath:instancePath+"/query",schemaPath:"#/properties/query/anyOf/0/type",keyword:"type",params:{type: "object"},message:"must be object"};
	if(vErrors === null){
	vErrors = [err17];
	}
	else {
	vErrors.push(err17);
	}
	errors++;
	}
	}
	var _valid3 = _errs39 === errors;
	valid6 = valid6 || _valid3;
	if(!valid6){
	const _errs42 = errors;
	if(typeof data10 !== "string"){
	let dataType8 = typeof data10;
	let coerced8 = undefined;
	if(!(coerced8 !== undefined)){
	if(dataType8 == "number" || dataType8 == "boolean"){
	coerced8 = "" + data10;
	}
	else if(data10 === null){
	coerced8 = "";
	}
	else {
	const err18 = {instancePath:instancePath+"/query",schemaPath:"#/properties/query/anyOf/1/type",keyword:"type",params:{type: "string"},message:"must be string"};
	if(vErrors === null){
	vErrors = [err18];
	}
	else {
	vErrors.push(err18);
	}
	errors++;
	}
	}
	if(coerced8 !== undefined){
	data10 = coerced8;
	if(data !== undefined){
	data["query"] = coerced8;
	}
	}
	}
	var _valid3 = _errs42 === errors;
	valid6 = valid6 || _valid3;
	}
	if(!valid6){
	const err19 = {instancePath:instancePath+"/query",schemaPath:"#/properties/query/anyOf",keyword:"anyOf",params:{},message:"must match a schema in anyOf"};
	if(vErrors === null){
	vErrors = [err19];
	}
	else {
	vErrors.push(err19);
	}
	errors++;
	validate10.errors = vErrors;
	return false;
	}
	else {
	errors = _errs38;
	if(vErrors !== null){
	if(_errs38){
	vErrors.length = _errs38;
	}
	else {
	vErrors = null;
	}
	}
	}
	var valid1 = _errs37 === errors;
	}
	else {
	var valid1 = true;
	}
	if(valid1){
	if(data.simulate !== undefined){
	let data11 = data.simulate;
	const _errs44 = errors;
	if(errors === _errs44){
	if(data11 && typeof data11 == "object" && !Array.isArray(data11)){
	if(data11.end !== undefined){
	let data12 = data11.end;
	const _errs46 = errors;
	if(typeof data12 !== "boolean"){
	let coerced9 = undefined;
	if(!(coerced9 !== undefined)){
	if(data12 === "false" || data12 === 0 || data12 === null){
	coerced9 = false;
	}
	else if(data12 === "true" || data12 === 1){
	coerced9 = true;
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/simulate/end",schemaPath:"#/properties/simulate/properties/end/type",keyword:"type",params:{type: "boolean"},message:"must be boolean"}];
	return false;
	}
	}
	if(coerced9 !== undefined){
	data12 = coerced9;
	if(data11 !== undefined){
	data11["end"] = coerced9;
	}
	}
	}
	var valid7 = _errs46 === errors;
	}
	else {
	var valid7 = true;
	}
	if(valid7){
	if(data11.split !== undefined){
	let data13 = data11.split;
	const _errs48 = errors;
	if(typeof data13 !== "boolean"){
	let coerced10 = undefined;
	if(!(coerced10 !== undefined)){
	if(data13 === "false" || data13 === 0 || data13 === null){
	coerced10 = false;
	}
	else if(data13 === "true" || data13 === 1){
	coerced10 = true;
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/simulate/split",schemaPath:"#/properties/simulate/properties/split/type",keyword:"type",params:{type: "boolean"},message:"must be boolean"}];
	return false;
	}
	}
	if(coerced10 !== undefined){
	data13 = coerced10;
	if(data11 !== undefined){
	data11["split"] = coerced10;
	}
	}
	}
	var valid7 = _errs48 === errors;
	}
	else {
	var valid7 = true;
	}
	if(valid7){
	if(data11.error !== undefined){
	let data14 = data11.error;
	const _errs50 = errors;
	if(typeof data14 !== "boolean"){
	let coerced11 = undefined;
	if(!(coerced11 !== undefined)){
	if(data14 === "false" || data14 === 0 || data14 === null){
	coerced11 = false;
	}
	else if(data14 === "true" || data14 === 1){
	coerced11 = true;
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/simulate/error",schemaPath:"#/properties/simulate/properties/error/type",keyword:"type",params:{type: "boolean"},message:"must be boolean"}];
	return false;
	}
	}
	if(coerced11 !== undefined){
	data14 = coerced11;
	if(data11 !== undefined){
	data11["error"] = coerced11;
	}
	}
	}
	var valid7 = _errs50 === errors;
	}
	else {
	var valid7 = true;
	}
	if(valid7){
	if(data11.close !== undefined){
	let data15 = data11.close;
	const _errs52 = errors;
	if(typeof data15 !== "boolean"){
	let coerced12 = undefined;
	if(!(coerced12 !== undefined)){
	if(data15 === "false" || data15 === 0 || data15 === null){
	coerced12 = false;
	}
	else if(data15 === "true" || data15 === 1){
	coerced12 = true;
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/simulate/close",schemaPath:"#/properties/simulate/properties/close/type",keyword:"type",params:{type: "boolean"},message:"must be boolean"}];
	return false;
	}
	}
	if(coerced12 !== undefined){
	data15 = coerced12;
	if(data11 !== undefined){
	data11["close"] = coerced12;
	}
	}
	}
	var valid7 = _errs52 === errors;
	}
	else {
	var valid7 = true;
	}
	}
	}
	}
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/simulate",schemaPath:"#/properties/simulate/type",keyword:"type",params:{type: "object"},message:"must be object"}];
	return false;
	}
	}
	var valid1 = _errs44 === errors;
	}
	else {
	var valid1 = true;
	}
	if(valid1){
	if(data.authority !== undefined){
	let data16 = data.authority;
	const _errs54 = errors;
	if(typeof data16 !== "string"){
	let dataType13 = typeof data16;
	let coerced13 = undefined;
	if(!(coerced13 !== undefined)){
	if(dataType13 == "number" || dataType13 == "boolean"){
	coerced13 = "" + data16;
	}
	else if(data16 === null){
	coerced13 = "";
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/authority",schemaPath:"#/properties/authority/type",keyword:"type",params:{type: "string"},message:"must be string"}];
	return false;
	}
	}
	if(coerced13 !== undefined){
	data16 = coerced13;
	if(data !== undefined){
	data["authority"] = coerced13;
	}
	}
	}
	var valid1 = _errs54 === errors;
	}
	else {
	var valid1 = true;
	}
	if(valid1){
	if(data.remoteAddress !== undefined){
	let data17 = data.remoteAddress;
	const _errs56 = errors;
	if(typeof data17 !== "string"){
	let dataType14 = typeof data17;
	let coerced14 = undefined;
	if(!(coerced14 !== undefined)){
	if(dataType14 == "number" || dataType14 == "boolean"){
	coerced14 = "" + data17;
	}
	else if(data17 === null){
	coerced14 = "";
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/remoteAddress",schemaPath:"#/properties/remoteAddress/type",keyword:"type",params:{type: "string"},message:"must be string"}];
	return false;
	}
	}
	if(coerced14 !== undefined){
	data17 = coerced14;
	if(data !== undefined){
	data["remoteAddress"] = coerced14;
	}
	}
	}
	var valid1 = _errs56 === errors;
	}
	else {
	var valid1 = true;
	}
	if(valid1){
	if(data.method !== undefined){
	let data18 = data.method;
	const _errs58 = errors;
	if(typeof data18 !== "string"){
	let dataType15 = typeof data18;
	let coerced15 = undefined;
	if(!(coerced15 !== undefined)){
	if(dataType15 == "number" || dataType15 == "boolean"){
	coerced15 = "" + data18;
	}
	else if(data18 === null){
	coerced15 = "";
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/method",schemaPath:"#/properties/method/type",keyword:"type",params:{type: "string"},message:"must be string"}];
	return false;
	}
	}
	if(coerced15 !== undefined){
	data18 = coerced15;
	if(data !== undefined){
	data["method"] = coerced15;
	}
	}
	}
	if(!((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((data18 === "ACL") || (data18 === "BIND")) || (data18 === "CHECKOUT")) || (data18 === "CONNECT")) || (data18 === "COPY")) || (data18 === "DELETE")) || (data18 === "GET")) || (data18 === "HEAD")) || (data18 === "LINK")) || (data18 === "LOCK")) || (data18 === "M-SEARCH")) || (data18 === "MERGE")) || (data18 === "MKACTIVITY")) || (data18 === "MKCALENDAR")) || (data18 === "MKCOL")) || (data18 === "MOVE")) || (data18 === "NOTIFY")) || (data18 === "OPTIONS")) || (data18 === "PATCH")) || (data18 === "POST")) || (data18 === "PROPFIND")) || (data18 === "PROPPATCH")) || (data18 === "PURGE")) || (data18 === "PUT")) || (data18 === "QUERY")) || (data18 === "REBIND")) || (data18 === "REPORT")) || (data18 === "SEARCH")) || (data18 === "SOURCE")) || (data18 === "SUBSCRIBE")) || (data18 === "TRACE")) || (data18 === "UNBIND")) || (data18 === "UNLINK")) || (data18 === "UNLOCK")) || (data18 === "UNSUBSCRIBE")) || (data18 === "acl")) || (data18 === "bind")) || (data18 === "checkout")) || (data18 === "connect")) || (data18 === "copy")) || (data18 === "delete")) || (data18 === "get")) || (data18 === "head")) || (data18 === "link")) || (data18 === "lock")) || (data18 === "m-search")) || (data18 === "merge")) || (data18 === "mkactivity")) || (data18 === "mkcalendar")) || (data18 === "mkcol")) || (data18 === "move")) || (data18 === "notify")) || (data18 === "options")) || (data18 === "patch")) || (data18 === "post")) || (data18 === "propfind")) || (data18 === "proppatch")) || (data18 === "purge")) || (data18 === "put")) || (data18 === "query")) || (data18 === "rebind")) || (data18 === "report")) || (data18 === "search")) || (data18 === "source")) || (data18 === "subscribe")) || (data18 === "trace")) || (data18 === "unbind")) || (data18 === "unlink")) || (data18 === "unlock")) || (data18 === "unsubscribe"))){
	validate10.errors = [{instancePath:instancePath+"/method",schemaPath:"#/properties/method/enum",keyword:"enum",params:{allowedValues: schema11.properties.method.enum},message:"must be equal to one of the allowed values"}];
	return false;
	}
	var valid1 = _errs58 === errors;
	}
	else {
	var valid1 = true;
	}
	if(valid1){
	if(data.validate !== undefined){
	let data19 = data.validate;
	const _errs60 = errors;
	if(typeof data19 !== "boolean"){
	let coerced16 = undefined;
	if(!(coerced16 !== undefined)){
	if(data19 === "false" || data19 === 0 || data19 === null){
	coerced16 = false;
	}
	else if(data19 === "true" || data19 === 1){
	coerced16 = true;
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/validate",schemaPath:"#/properties/validate/type",keyword:"type",params:{type: "boolean"},message:"must be boolean"}];
	return false;
	}
	}
	if(coerced16 !== undefined){
	data19 = coerced16;
	if(data !== undefined){
	data["validate"] = coerced16;
	}
	}
	}
	var valid1 = _errs60 === errors;
	}
	else {
	var valid1 = true;
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	else {
	validate10.errors = [{instancePath,schemaPath:"#/type",keyword:"type",params:{type: "object"},message:"must be object"}];
	return false;
	}
	}
	validate10.errors = vErrors;
	return errors === 0;
	}
	return configValidator.exports;
}

var hasRequiredLightMyRequest;

function requireLightMyRequest () {
	if (hasRequiredLightMyRequest) return lightMyRequest.exports;
	hasRequiredLightMyRequest = 1;

	const assert = require$$0$9;
	const Request = requireRequest();
	const Response = requireResponse$1();

	const errorMessage = 'The dispatch function has already been invoked';

	const optsValidator = requireConfigValidator();

	function inject (dispatchFunc, options, callback) {
	  if (callback === undefined) {
	    return new Chain(dispatchFunc, options)
	  } else {
	    return doInject(dispatchFunc, options, callback)
	  }
	}

	function supportStream1 (req, next) {
	  const payload = req._lightMyRequest.payload;
	  if (!payload || payload._readableState || typeof payload.resume !== 'function') { // does quack like a modern stream
	    return next()
	  }

	  // This is a non-compliant stream
	  const chunks = [];

	  // We are accumulating because Readable.wrap() does not really work as expected
	  // in this case.
	  payload.on('data', (chunk) => chunks.push(Buffer.from(chunk)));

	  payload.on('end', () => {
	    const payload = Buffer.concat(chunks);
	    req.headers['content-length'] = req.headers['content-length'] || ('' + payload.length);
	    delete req.headers['transfer-encoding'];
	    req._lightMyRequest.payload = payload;
	    return next()
	  });

	  // Force to resume the stream. Needed for Stream 1
	  payload.resume();
	}

	function makeRequest (dispatchFunc, server, req, res) {
	  req.once('error', function (err) {
	    if (this.destroyed) res.destroy(err);
	  });

	  req.once('close', function () {
	    if (this.destroyed && !this._error) {
	      res.destroy();
	    }
	  });

	  return supportStream1(req, () => dispatchFunc.call(server, req, res))
	}

	function doInject (dispatchFunc, options, callback) {
	  options = (typeof options === 'string' ? { url: options } : options);

	  if (options.validate !== false) {
	    assert(typeof dispatchFunc === 'function', 'dispatchFunc should be a function');
	    const isOptionValid = optsValidator(options);
	    if (!isOptionValid) {
	      throw new Error(optsValidator.errors.map(e => e.message))
	    }
	  }

	  const server = options.server || {};

	  const RequestConstructor = options.Request
	    ? Request.CustomRequest
	    : Request;

	  // Express.js detection
	  if (dispatchFunc.request && dispatchFunc.request.app === dispatchFunc) {
	    Object.setPrototypeOf(Object.getPrototypeOf(dispatchFunc.request), RequestConstructor.prototype);
	    Object.setPrototypeOf(Object.getPrototypeOf(dispatchFunc.response), Response.prototype);
	  }

	  if (typeof callback === 'function') {
	    const req = new RequestConstructor(options);
	    const res = new Response(req, callback);

	    return makeRequest(dispatchFunc, server, req, res)
	  } else {
	    return new Promise((resolve, reject) => {
	      const req = new RequestConstructor(options);
	      const res = new Response(req, resolve, reject);

	      makeRequest(dispatchFunc, server, req, res);
	    })
	  }
	}

	function Chain (dispatch, option) {
	  if (typeof option === 'string') {
	    this.option = { url: option };
	  } else {
	    this.option = Object.assign({}, option);
	  }

	  this.dispatch = dispatch;
	  this._hasInvoked = false;
	  this._promise = null;

	  if (this.option.autoStart !== false) {
	    process.nextTick(() => {
	      if (!this._hasInvoked) {
	        this.end();
	      }
	    });
	  }
	}

	const httpMethods = [
	  'delete',
	  'get',
	  'head',
	  'options',
	  'patch',
	  'post',
	  'put',
	  'trace'
	];

	httpMethods.forEach(method => {
	  Chain.prototype[method] = function (url) {
	    if (this._hasInvoked === true || this._promise) {
	      throw new Error(errorMessage)
	    }
	    this.option.url = url;
	    this.option.method = method.toUpperCase();
	    return this
	  };
	});

	const chainMethods = [
	  'body',
	  'cookies',
	  'headers',
	  'payload',
	  'query'
	];

	chainMethods.forEach(method => {
	  Chain.prototype[method] = function (value) {
	    if (this._hasInvoked === true || this._promise) {
	      throw new Error(errorMessage)
	    }
	    this.option[method] = value;
	    return this
	  };
	});

	Chain.prototype.end = function (callback) {
	  if (this._hasInvoked === true || this._promise) {
	    throw new Error(errorMessage)
	  }
	  this._hasInvoked = true;
	  if (typeof callback === 'function') {
	    doInject(this.dispatch, this.option, callback);
	  } else {
	    this._promise = doInject(this.dispatch, this.option);
	    return this._promise
	  }
	};

	Object.getOwnPropertyNames(Promise.prototype).forEach(method => {
	  if (method === 'constructor') return
	  Chain.prototype[method] = function (...args) {
	    if (!this._promise) {
	      if (this._hasInvoked === true) {
	        throw new Error(errorMessage)
	      }
	      this._hasInvoked = true;
	      this._promise = doInject(this.dispatch, this.option);
	    }
	    return this._promise[method](...args)
	  };
	});

	function isInjection (obj) {
	  return (
	    obj instanceof Request ||
	    obj instanceof Response ||
	    obj?.constructor?.name === '_CustomLMRRequest'
	  )
	}

	lightMyRequest.exports = inject;
	lightMyRequest.exports.default = inject;
	lightMyRequest.exports.inject = inject;
	lightMyRequest.exports.isInjection = isInjection;
	return lightMyRequest.exports;
}

var hasRequiredFastify;

function requireFastify () {
	if (hasRequiredFastify) return fastify.exports;
	hasRequiredFastify = 1;

	const VERSION = '5.4.0';

	const Avvio = requireBoot();
	const http = require$$0$4;
	const diagnostics = require$$1$1;
	let lightMyRequest;

	const {
	  kAvvioBoot,
	  kChildren,
	  kServerBindings,
	  kBodyLimit,
	  kSupportedHTTPMethods,
	  kRoutePrefix,
	  kLogLevel,
	  kLogSerializers,
	  kHooks,
	  kSchemaController,
	  kRequestAcceptVersion,
	  kReplySerializerDefault,
	  kContentTypeParser,
	  kReply,
	  kRequest,
	  kFourOhFour,
	  kState,
	  kOptions,
	  kPluginNameChain,
	  kSchemaErrorFormatter,
	  kErrorHandler,
	  kKeepAliveConnections,
	  kChildLoggerFactory,
	  kGenReqId,
	  kErrorHandlerAlreadySet
	} = requireSymbols$1();

	const { createServer } = requireServer();
	const Reply = requireReply();
	const Request = requireRequest$1();
	const Context = requireContext();
	const decorator = requireDecorate();
	const ContentTypeParser = requireContentTypeParser();
	const SchemaController = requireSchemaController();
	const { Hooks, hookRunnerApplication, supportedHooks } = requireHooks();
	const { createChildLogger, defaultChildLoggerFactory, createLogger } = requireLoggerFactory();
	const pluginUtils = requirePluginUtils();
	const { getGenReqId, reqIdGenFactory } = requireReqIdGenFactory();
	const { buildRouting, validateBodyLimitOption } = requireRoute();
	const build404 = requireFourOhFour();
	const getSecuredInitialConfig = requireInitialConfigValidation();
	const override = requirePluginOverride();
	const noopSet = requireNoopSet();
	const {
	  appendStackTrace,
	  AVVIO_ERRORS_MAP,
	  ...errorCodes
	} = requireErrors$2();

	const { defaultInitOptions } = getSecuredInitialConfig;

	const {
	  FST_ERR_ASYNC_CONSTRAINT,
	  FST_ERR_BAD_URL,
	  FST_ERR_FORCE_CLOSE_CONNECTIONS_IDLE_NOT_AVAILABLE,
	  FST_ERR_OPTIONS_NOT_OBJ,
	  FST_ERR_QSP_NOT_FN,
	  FST_ERR_SCHEMA_CONTROLLER_BUCKET_OPT_NOT_FN,
	  FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_OBJ,
	  FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_ARR,
	  FST_ERR_INSTANCE_ALREADY_LISTENING,
	  FST_ERR_REOPENED_CLOSE_SERVER,
	  FST_ERR_ROUTE_REWRITE_NOT_STR,
	  FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN,
	  FST_ERR_ERROR_HANDLER_NOT_FN,
	  FST_ERR_ERROR_HANDLER_ALREADY_SET,
	  FST_ERR_ROUTE_METHOD_INVALID
	} = errorCodes;

	const { buildErrorHandler } = requireErrorHandler();
	const { FSTWRN004 } = requireWarnings();

	const initChannel = diagnostics.channel('fastify.initialization');

	function defaultBuildPrettyMeta (route) {
	  // return a shallow copy of route's sanitized context

	  const cleanKeys = {};
	  const allowedProps = ['errorHandler', 'logLevel', 'logSerializers'];

	  allowedProps.concat(supportedHooks).forEach(k => {
	    cleanKeys[k] = route.store[k];
	  });

	  return Object.assign({}, cleanKeys)
	}

	/**
	 * @param {import('./fastify.js').FastifyServerOptions} options
	 */
	function fastify$1 (options) {
	  // Options validations
	  if (options && typeof options !== 'object') {
	    throw new FST_ERR_OPTIONS_NOT_OBJ()
	  } else {
	    // Shallow copy options object to prevent mutations outside of this function
	    options = Object.assign({}, options);
	  }

	  if (options.querystringParser && typeof options.querystringParser !== 'function') {
	    throw new FST_ERR_QSP_NOT_FN(typeof options.querystringParser)
	  }

	  if (options.schemaController && options.schemaController.bucket && typeof options.schemaController.bucket !== 'function') {
	    throw new FST_ERR_SCHEMA_CONTROLLER_BUCKET_OPT_NOT_FN(typeof options.schemaController.bucket)
	  }

	  validateBodyLimitOption(options.bodyLimit);

	  const requestIdHeader = typeof options.requestIdHeader === 'string' && options.requestIdHeader.length !== 0 ? options.requestIdHeader.toLowerCase() : (options.requestIdHeader === true && 'request-id');
	  const genReqId = reqIdGenFactory(requestIdHeader, options.genReqId);
	  const requestIdLogLabel = options.requestIdLogLabel || 'reqId';
	  const bodyLimit = options.bodyLimit || defaultInitOptions.bodyLimit;
	  const disableRequestLogging = options.disableRequestLogging || false;

	  const ajvOptions = Object.assign({
	    customOptions: {},
	    plugins: []
	  }, options.ajv);
	  const frameworkErrors = options.frameworkErrors;

	  // Ajv options
	  if (!ajvOptions.customOptions || Object.prototype.toString.call(ajvOptions.customOptions) !== '[object Object]') {
	    throw new FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_OBJ(typeof ajvOptions.customOptions)
	  }
	  if (!ajvOptions.plugins || !Array.isArray(ajvOptions.plugins)) {
	    throw new FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_ARR(typeof ajvOptions.plugins)
	  }

	  // Instance Fastify components

	  const { logger, hasLogger } = createLogger(options);

	  // Update the options with the fixed values
	  options.connectionTimeout = options.connectionTimeout || defaultInitOptions.connectionTimeout;
	  options.keepAliveTimeout = options.keepAliveTimeout || defaultInitOptions.keepAliveTimeout;
	  options.maxRequestsPerSocket = options.maxRequestsPerSocket || defaultInitOptions.maxRequestsPerSocket;
	  options.requestTimeout = options.requestTimeout || defaultInitOptions.requestTimeout;
	  options.logger = logger;
	  options.requestIdHeader = requestIdHeader;
	  options.requestIdLogLabel = requestIdLogLabel;
	  options.disableRequestLogging = disableRequestLogging;
	  options.ajv = ajvOptions;
	  options.clientErrorHandler = options.clientErrorHandler || defaultClientErrorHandler;
	  options.allowErrorHandlerOverride = options.allowErrorHandlerOverride ?? defaultInitOptions.allowErrorHandlerOverride;

	  const initialConfig = getSecuredInitialConfig(options);

	  // exposeHeadRoutes have its default set from the validator
	  options.exposeHeadRoutes = initialConfig.exposeHeadRoutes;

	  // Default router
	  const router = buildRouting({
	    config: {
	      defaultRoute,
	      onBadUrl,
	      constraints: options.constraints,
	      ignoreTrailingSlash: options.ignoreTrailingSlash || defaultInitOptions.ignoreTrailingSlash,
	      ignoreDuplicateSlashes: options.ignoreDuplicateSlashes || defaultInitOptions.ignoreDuplicateSlashes,
	      maxParamLength: options.maxParamLength || defaultInitOptions.maxParamLength,
	      caseSensitive: options.caseSensitive,
	      allowUnsafeRegex: options.allowUnsafeRegex || defaultInitOptions.allowUnsafeRegex,
	      buildPrettyMeta: defaultBuildPrettyMeta,
	      querystringParser: options.querystringParser,
	      useSemicolonDelimiter: options.useSemicolonDelimiter ?? defaultInitOptions.useSemicolonDelimiter
	    }
	  });

	  // 404 router, used for handling encapsulated 404 handlers
	  const fourOhFour = build404(options);

	  // HTTP server and its handler
	  const httpHandler = wrapRouting(router, options);

	  // we need to set this before calling createServer
	  options.http2SessionTimeout = initialConfig.http2SessionTimeout;
	  const { server, listen } = createServer(options, httpHandler);

	  const serverHasCloseAllConnections = typeof server.closeAllConnections === 'function';
	  const serverHasCloseIdleConnections = typeof server.closeIdleConnections === 'function';

	  let forceCloseConnections = options.forceCloseConnections;
	  if (forceCloseConnections === 'idle' && !serverHasCloseIdleConnections) {
	    throw new FST_ERR_FORCE_CLOSE_CONNECTIONS_IDLE_NOT_AVAILABLE()
	  } else if (typeof forceCloseConnections !== 'boolean') {
	    /* istanbul ignore next: only one branch can be valid in a given Node.js version */
	    forceCloseConnections = serverHasCloseIdleConnections ? 'idle' : false;
	  }

	  const keepAliveConnections = !serverHasCloseAllConnections && forceCloseConnections === true ? new Set() : noopSet();

	  const setupResponseListeners = Reply.setupResponseListeners;
	  const schemaController = SchemaController.buildSchemaController(null, options.schemaController);

	  // Public API
	  const fastify = {
	    // Fastify internals
	    [kState]: {
	      listening: false,
	      closing: false,
	      started: false,
	      ready: false,
	      booting: false,
	      readyPromise: null
	    },
	    [kKeepAliveConnections]: keepAliveConnections,
	    [kSupportedHTTPMethods]: {
	      bodyless: new Set([
	        // Standard
	        'GET',
	        'HEAD',
	        'TRACE'
	      ]),
	      bodywith: new Set([
	        // Standard
	        'DELETE',
	        'OPTIONS',
	        'PATCH',
	        'PUT',
	        'POST'
	      ])
	    },
	    [kOptions]: options,
	    [kChildren]: [],
	    [kServerBindings]: [],
	    [kBodyLimit]: bodyLimit,
	    [kRoutePrefix]: '',
	    [kLogLevel]: '',
	    [kLogSerializers]: null,
	    [kHooks]: new Hooks(),
	    [kSchemaController]: schemaController,
	    [kSchemaErrorFormatter]: null,
	    [kErrorHandler]: buildErrorHandler(),
	    [kErrorHandlerAlreadySet]: false,
	    [kChildLoggerFactory]: defaultChildLoggerFactory,
	    [kReplySerializerDefault]: null,
	    [kContentTypeParser]: new ContentTypeParser(
	      bodyLimit,
	      (options.onProtoPoisoning || defaultInitOptions.onProtoPoisoning),
	      (options.onConstructorPoisoning || defaultInitOptions.onConstructorPoisoning)
	    ),
	    [kReply]: Reply.buildReply(Reply),
	    [kRequest]: Request.buildRequest(Request, options.trustProxy),
	    [kFourOhFour]: fourOhFour,
	    [pluginUtils.kRegisteredPlugins]: [],
	    [kPluginNameChain]: ['fastify'],
	    [kAvvioBoot]: null,
	    [kGenReqId]: genReqId,
	    // routing method
	    routing: httpHandler,
	    // routes shorthand methods
	    delete: function _delete (url, options, handler) {
	      return router.prepareRoute.call(this, { method: 'DELETE', url, options, handler })
	    },
	    get: function _get (url, options, handler) {
	      return router.prepareRoute.call(this, { method: 'GET', url, options, handler })
	    },
	    head: function _head (url, options, handler) {
	      return router.prepareRoute.call(this, { method: 'HEAD', url, options, handler })
	    },
	    trace: function _trace (url, options, handler) {
	      return router.prepareRoute.call(this, { method: 'TRACE', url, options, handler })
	    },
	    patch: function _patch (url, options, handler) {
	      return router.prepareRoute.call(this, { method: 'PATCH', url, options, handler })
	    },
	    post: function _post (url, options, handler) {
	      return router.prepareRoute.call(this, { method: 'POST', url, options, handler })
	    },
	    put: function _put (url, options, handler) {
	      return router.prepareRoute.call(this, { method: 'PUT', url, options, handler })
	    },
	    options: function _options (url, options, handler) {
	      return router.prepareRoute.call(this, { method: 'OPTIONS', url, options, handler })
	    },
	    all: function _all (url, options, handler) {
	      return router.prepareRoute.call(this, { method: this.supportedMethods, url, options, handler })
	    },
	    // extended route
	    route: function _route (options) {
	      // we need the fastify object that we are producing so we apply a lazy loading of the function,
	      // otherwise we should bind it after the declaration
	      return router.route.call(this, { options })
	    },
	    hasRoute: function _route (options) {
	      return router.hasRoute.call(this, { options })
	    },
	    findRoute: function _findRoute (options) {
	      return router.findRoute(options)
	    },
	    // expose logger instance
	    log: logger,
	    // type provider
	    withTypeProvider,
	    // hooks
	    addHook,
	    // schemas
	    addSchema,
	    getSchema: schemaController.getSchema.bind(schemaController),
	    getSchemas: schemaController.getSchemas.bind(schemaController),
	    setValidatorCompiler,
	    setSerializerCompiler,
	    setSchemaController,
	    setReplySerializer,
	    setSchemaErrorFormatter,
	    // set generated request id
	    setGenReqId,
	    // custom parsers
	    addContentTypeParser: ContentTypeParser.helpers.addContentTypeParser,
	    hasContentTypeParser: ContentTypeParser.helpers.hasContentTypeParser,
	    getDefaultJsonParser: ContentTypeParser.defaultParsers.getDefaultJsonParser,
	    defaultTextParser: ContentTypeParser.defaultParsers.defaultTextParser,
	    removeContentTypeParser: ContentTypeParser.helpers.removeContentTypeParser,
	    removeAllContentTypeParsers: ContentTypeParser.helpers.removeAllContentTypeParsers,
	    // Fastify architecture methods (initialized by Avvio)
	    register: null,
	    after: null,
	    ready: null,
	    onClose: null,
	    close: null,
	    printPlugins: null,
	    hasPlugin: function (name) {
	      return this[pluginUtils.kRegisteredPlugins].includes(name) || this[kPluginNameChain].includes(name)
	    },
	    // http server
	    listen,
	    server,
	    addresses: function () {
	      /* istanbul ignore next */
	      const binded = this[kServerBindings].map(b => b.address());
	      binded.push(this.server.address());
	      return binded.filter(adr => adr)
	    },
	    // extend fastify objects
	    decorate: decorator.add,
	    hasDecorator: decorator.exist,
	    decorateReply: decorator.decorateReply,
	    decorateRequest: decorator.decorateRequest,
	    hasRequestDecorator: decorator.existRequest,
	    hasReplyDecorator: decorator.existReply,
	    getDecorator: decorator.getInstanceDecorator,
	    addHttpMethod,
	    // fake http injection
	    inject,
	    // pretty print of the registered routes
	    printRoutes,
	    // custom error handling
	    setNotFoundHandler,
	    setErrorHandler,
	    // child logger
	    setChildLoggerFactory,
	    // Set fastify initial configuration options read-only object
	    initialConfig,
	    // constraint strategies
	    addConstraintStrategy: router.addConstraintStrategy.bind(router),
	    hasConstraintStrategy: router.hasConstraintStrategy.bind(router)
	  };

	  Object.defineProperties(fastify, {
	    listeningOrigin: {
	      get () {
	        const address = this.addresses().slice(-1).pop();
	        /* ignore if windows: unix socket is not testable on Windows platform */
	        /* c8 ignore next 3 */
	        if (typeof address === 'string') {
	          return address
	        }
	        const host = address.family === 'IPv6' ? `[${address.address}]` : address.address;
	        return `${this[kOptions].https ? 'https' : 'http'}://${host}:${address.port}`
	      }
	    },
	    pluginName: {
	      configurable: true,
	      get () {
	        if (this[kPluginNameChain].length > 1) {
	          return this[kPluginNameChain].join(' -> ')
	        }
	        return this[kPluginNameChain][0]
	      }
	    },
	    prefix: {
	      configurable: true,
	      get () { return this[kRoutePrefix] }
	    },
	    validatorCompiler: {
	      configurable: true,
	      get () { return this[kSchemaController].getValidatorCompiler() }
	    },
	    serializerCompiler: {
	      configurable: true,
	      get () { return this[kSchemaController].getSerializerCompiler() }
	    },
	    childLoggerFactory: {
	      configurable: true,
	      get () { return this[kChildLoggerFactory] }
	    },
	    version: {
	      configurable: true,
	      get () { return VERSION }
	    },
	    errorHandler: {
	      configurable: true,
	      get () {
	        return this[kErrorHandler].func
	      }
	    },
	    genReqId: {
	      configurable: true,
	      get () { return this[kGenReqId] }
	    },
	    supportedMethods: {
	      configurable: false,
	      get () {
	        return [
	          ...this[kSupportedHTTPMethods].bodyless,
	          ...this[kSupportedHTTPMethods].bodywith
	        ]
	      }
	    }
	  });

	  if (options.schemaErrorFormatter) {
	    validateSchemaErrorFormatter(options.schemaErrorFormatter);
	    fastify[kSchemaErrorFormatter] = options.schemaErrorFormatter.bind(fastify);
	  }

	  // Install and configure Avvio
	  // Avvio will update the following Fastify methods:
	  // - register
	  // - after
	  // - ready
	  // - onClose
	  // - close

	  const avvioPluginTimeout = Number(options.pluginTimeout);
	  const avvio = Avvio(fastify, {
	    autostart: false,
	    timeout: isNaN(avvioPluginTimeout) === false ? avvioPluginTimeout : defaultInitOptions.pluginTimeout,
	    expose: {
	      use: 'register'
	    }
	  });
	  // Override to allow the plugin encapsulation
	  avvio.override = override;
	  avvio.on('start', () => (fastify[kState].started = true));
	  fastify[kAvvioBoot] = fastify.ready; // the avvio ready function
	  fastify.ready = ready; // overwrite the avvio ready function
	  fastify.printPlugins = avvio.prettyPrint.bind(avvio);

	  // cache the closing value, since we are checking it in an hot path
	  avvio.once('preReady', () => {
	    fastify.onClose((instance, done) => {
	      fastify[kState].closing = true;
	      router.closeRoutes();

	      hookRunnerApplication('preClose', fastify[kAvvioBoot], fastify, function () {
	        if (fastify[kState].listening) {
	          /* istanbul ignore next: Cannot test this without Node.js core support */
	          if (forceCloseConnections === 'idle') {
	            // Not needed in Node 19
	            instance.server.closeIdleConnections();
	            /* istanbul ignore next: Cannot test this without Node.js core support */
	          } else if (serverHasCloseAllConnections && forceCloseConnections) {
	            instance.server.closeAllConnections();
	          } else if (forceCloseConnections === true) {
	            for (const conn of fastify[kKeepAliveConnections]) {
	              // We must invoke the destroy method instead of merely unreffing
	              // the sockets. If we only unref, then the callback passed to
	              // `fastify.close` will never be invoked; nor will any of the
	              // registered `onClose` hooks.
	              conn.destroy();
	              fastify[kKeepAliveConnections].delete(conn);
	            }
	          }
	        }

	        // No new TCP connections are accepted.
	        // We must call close on the server even if we are not listening
	        // otherwise memory will be leaked.
	        // https://github.com/nodejs/node/issues/48604
	        if (!options.serverFactory || fastify[kState].listening) {
	          instance.server.close(function (err) {
	            /* c8 ignore next 6 */
	            if (err && err.code !== 'ERR_SERVER_NOT_RUNNING') {
	              done(null);
	            } else {
	              done();
	            }
	          });
	        } else {
	          process.nextTick(done, null);
	        }
	      });
	    });
	  });

	  // Create bad URL context
	  const onBadUrlContext = new Context({
	    server: fastify,
	    config: {}
	  });

	  // Set the default 404 handler
	  fastify.setNotFoundHandler();
	  fourOhFour.arrange404(fastify);

	  router.setup(options, {
	    avvio,
	    fourOhFour,
	    logger,
	    hasLogger,
	    setupResponseListeners,
	    throwIfAlreadyStarted,
	    keepAliveConnections
	  });

	  // Delay configuring clientError handler so that it can access fastify state.
	  server.on('clientError', options.clientErrorHandler.bind(fastify));

	  if (initChannel.hasSubscribers) {
	    initChannel.publish({ fastify });
	  }

	  // Older nodejs versions may not have asyncDispose
	  if ('asyncDispose' in Symbol) {
	    fastify[Symbol.asyncDispose] = function dispose () {
	      return fastify.close()
	    };
	  }

	  return fastify

	  function throwIfAlreadyStarted (msg) {
	    if (fastify[kState].started) throw new FST_ERR_INSTANCE_ALREADY_LISTENING(msg)
	  }

	  // HTTP injection handling
	  // If the server is not ready yet, this
	  // utility will automatically force it.
	  function inject (opts, cb) {
	    // lightMyRequest is dynamically loaded as it seems very expensive
	    // because of Ajv
	    if (lightMyRequest === undefined) {
	      lightMyRequest = requireLightMyRequest();
	    }

	    if (fastify[kState].started) {
	      if (fastify[kState].closing) {
	        // Force to return an error
	        const error = new FST_ERR_REOPENED_CLOSE_SERVER();
	        if (cb) {
	          cb(error);
	          return
	        } else {
	          return Promise.reject(error)
	        }
	      }
	      return lightMyRequest(httpHandler, opts, cb)
	    }

	    if (cb) {
	      this.ready(err => {
	        if (err) cb(err, null);
	        else lightMyRequest(httpHandler, opts, cb);
	      });
	    } else {
	      return lightMyRequest((req, res) => {
	        this.ready(function (err) {
	          if (err) {
	            res.emit('error', err);
	            return
	          }
	          httpHandler(req, res);
	        });
	      }, opts)
	    }
	  }

	  function ready (cb) {
	    if (this[kState].readyPromise !== null) {
	      if (cb != null) {
	        this[kState].readyPromise.then(() => cb(null, fastify), cb);
	        return
	      }

	      return this[kState].readyPromise
	    }

	    let resolveReady;
	    let rejectReady;

	    // run the hooks after returning the promise
	    process.nextTick(runHooks);

	    // Create a promise no matter what
	    // It will work as a barrier for all the .ready() calls (ensuring single hook execution)
	    // as well as a flow control mechanism to chain cbs and further
	    // promises
	    this[kState].readyPromise = new Promise(function (resolve, reject) {
	      resolveReady = resolve;
	      rejectReady = reject;
	    });

	    if (!cb) {
	      return this[kState].readyPromise
	    } else {
	      this[kState].readyPromise.then(() => cb(null, fastify), cb);
	    }

	    function runHooks () {
	      // start loading
	      fastify[kAvvioBoot]((err, done) => {
	        if (err || fastify[kState].started || fastify[kState].ready || fastify[kState].booting) {
	          manageErr(err);
	        } else {
	          fastify[kState].booting = true;
	          hookRunnerApplication('onReady', fastify[kAvvioBoot], fastify, manageErr);
	        }
	        done();
	      });
	    }

	    function manageErr (err) {
	      // If the error comes out of Avvio's Error codes
	      // We create a make and preserve the previous error
	      // as cause
	      err = err != null && AVVIO_ERRORS_MAP[err.code] != null
	        ? appendStackTrace(err, new AVVIO_ERRORS_MAP[err.code](err.message))
	        : err;

	      if (err) {
	        return rejectReady(err)
	      }

	      resolveReady(fastify);
	      fastify[kState].booting = false;
	      fastify[kState].ready = true;
	      fastify[kState].readyPromise = null;
	    }
	  }

	  // Used exclusively in TypeScript contexts to enable auto type inference from JSON schema.
	  function withTypeProvider () {
	    return this
	  }

	  // wrapper that we expose to the user for hooks handling
	  function addHook (name, fn) {
	    throwIfAlreadyStarted('Cannot call "addHook"!');

	    if (fn == null) {
	      throw new errorCodes.FST_ERR_HOOK_INVALID_HANDLER(name, fn)
	    }

	    if (name === 'onSend' || name === 'preSerialization' || name === 'onError' || name === 'preParsing') {
	      if (fn.constructor.name === 'AsyncFunction' && fn.length === 4) {
	        throw new errorCodes.FST_ERR_HOOK_INVALID_ASYNC_HANDLER()
	      }
	    } else if (name === 'onReady' || name === 'onListen') {
	      if (fn.constructor.name === 'AsyncFunction' && fn.length !== 0) {
	        throw new errorCodes.FST_ERR_HOOK_INVALID_ASYNC_HANDLER()
	      }
	    } else if (name === 'onRequestAbort') {
	      if (fn.constructor.name === 'AsyncFunction' && fn.length !== 1) {
	        throw new errorCodes.FST_ERR_HOOK_INVALID_ASYNC_HANDLER()
	      }
	    } else {
	      if (fn.constructor.name === 'AsyncFunction' && fn.length === 3) {
	        throw new errorCodes.FST_ERR_HOOK_INVALID_ASYNC_HANDLER()
	      }
	    }

	    if (name === 'onClose') {
	      this.onClose(fn.bind(this));
	    } else if (name === 'onReady' || name === 'onListen' || name === 'onRoute') {
	      this[kHooks].add(name, fn);
	    } else {
	      this.after((err, done) => {
	        try {
	          _addHook.call(this, name, fn);
	          done(err);
	        } catch (err) {
	          done(err);
	        }
	      });
	    }
	    return this

	    function _addHook (name, fn) {
	      this[kHooks].add(name, fn);
	      this[kChildren].forEach(child => _addHook.call(child, name, fn));
	    }
	  }

	  // wrapper that we expose to the user for schemas handling
	  function addSchema (schema) {
	    throwIfAlreadyStarted('Cannot call "addSchema"!');
	    this[kSchemaController].add(schema);
	    this[kChildren].forEach(child => child.addSchema(schema));
	    return this
	  }

	  function defaultClientErrorHandler (err, socket) {
	    // In case of a connection reset, the socket has been destroyed and there is nothing that needs to be done.
	    // https://nodejs.org/api/http.html#http_event_clienterror
	    if (err.code === 'ECONNRESET' || socket.destroyed) {
	      return
	    }

	    let body, errorCode, errorStatus, errorLabel;

	    if (err.code === 'ERR_HTTP_REQUEST_TIMEOUT') {
	      errorCode = '408';
	      errorStatus = http.STATUS_CODES[errorCode];
	      body = `{"error":"${errorStatus}","message":"Client Timeout","statusCode":408}`;
	      errorLabel = 'timeout';
	    } else if (err.code === 'HPE_HEADER_OVERFLOW') {
	      errorCode = '431';
	      errorStatus = http.STATUS_CODES[errorCode];
	      body = `{"error":"${errorStatus}","message":"Exceeded maximum allowed HTTP header size","statusCode":431}`;
	      errorLabel = 'header_overflow';
	    } else {
	      errorCode = '400';
	      errorStatus = http.STATUS_CODES[errorCode];
	      body = `{"error":"${errorStatus}","message":"Client Error","statusCode":400}`;
	      errorLabel = 'error';
	    }

	    // Most devs do not know what to do with this error.
	    // In the vast majority of cases, it's a network error and/or some
	    // config issue on the load balancer side.
	    this.log.trace({ err }, `client ${errorLabel}`);
	    // Copying standard node behavior
	    // https://github.com/nodejs/node/blob/6ca23d7846cb47e84fd344543e394e50938540be/lib/_http_server.js#L666

	    // If the socket is not writable, there is no reason to try to send data.
	    if (socket.writable) {
	      socket.write(`HTTP/1.1 ${errorCode} ${errorStatus}\r\nContent-Length: ${body.length}\r\nContent-Type: application/json\r\n\r\n${body}`);
	    }
	    socket.destroy(err);
	  }

	  // If the router does not match any route, every request will land here
	  // req and res are Node.js core objects
	  function defaultRoute (req, res) {
	    if (req.headers['accept-version'] !== undefined) {
	      // we remove the accept-version header for performance result
	      // because we do not want to go through the constraint checking
	      // the usage of symbol here to prevent any collision on custom header name
	      req.headers[kRequestAcceptVersion] = req.headers['accept-version'];
	      req.headers['accept-version'] = undefined;
	    }
	    fourOhFour.router.lookup(req, res);
	  }

	  function onBadUrl (path, req, res) {
	    if (frameworkErrors) {
	      const id = getGenReqId(onBadUrlContext.server, req);
	      const childLogger = createChildLogger(onBadUrlContext, logger, req, id);

	      const request = new Request(id, null, req, null, childLogger, onBadUrlContext);
	      const reply = new Reply(res, request, childLogger);

	      if (disableRequestLogging === false) {
	        childLogger.info({ req: request }, 'incoming request');
	      }

	      return frameworkErrors(new FST_ERR_BAD_URL(path), request, reply)
	    }
	    const body = `{"error":"Bad Request","code":"FST_ERR_BAD_URL","message":"'${path}' is not a valid url component","statusCode":400}`;
	    res.writeHead(400, {
	      'Content-Type': 'application/json',
	      'Content-Length': body.length
	    });
	    res.end(body);
	  }

	  function buildAsyncConstraintCallback (isAsync, req, res) {
	    if (isAsync === false) return undefined
	    return function onAsyncConstraintError (err) {
	      if (err) {
	        if (frameworkErrors) {
	          const id = getGenReqId(onBadUrlContext.server, req);
	          const childLogger = createChildLogger(onBadUrlContext, logger, req, id);

	          const request = new Request(id, null, req, null, childLogger, onBadUrlContext);
	          const reply = new Reply(res, request, childLogger);

	          if (disableRequestLogging === false) {
	            childLogger.info({ req: request }, 'incoming request');
	          }

	          return frameworkErrors(new FST_ERR_ASYNC_CONSTRAINT(), request, reply)
	        }
	        const body = '{"error":"Internal Server Error","message":"Unexpected error from async constraint","statusCode":500}';
	        res.writeHead(500, {
	          'Content-Type': 'application/json',
	          'Content-Length': body.length
	        });
	        res.end(body);
	      }
	    }
	  }

	  function setNotFoundHandler (opts, handler) {
	    throwIfAlreadyStarted('Cannot call "setNotFoundHandler"!');

	    fourOhFour.setNotFoundHandler.call(this, opts, handler, avvio, router.routeHandler);
	    return this
	  }

	  function setValidatorCompiler (validatorCompiler) {
	    throwIfAlreadyStarted('Cannot call "setValidatorCompiler"!');
	    this[kSchemaController].setValidatorCompiler(validatorCompiler);
	    return this
	  }

	  function setSchemaErrorFormatter (errorFormatter) {
	    throwIfAlreadyStarted('Cannot call "setSchemaErrorFormatter"!');
	    validateSchemaErrorFormatter(errorFormatter);
	    this[kSchemaErrorFormatter] = errorFormatter.bind(this);
	    return this
	  }

	  function setSerializerCompiler (serializerCompiler) {
	    throwIfAlreadyStarted('Cannot call "setSerializerCompiler"!');
	    this[kSchemaController].setSerializerCompiler(serializerCompiler);
	    return this
	  }

	  function setSchemaController (schemaControllerOpts) {
	    throwIfAlreadyStarted('Cannot call "setSchemaController"!');
	    const old = this[kSchemaController];
	    const schemaController = SchemaController.buildSchemaController(old, Object.assign({}, old.opts, schemaControllerOpts));
	    this[kSchemaController] = schemaController;
	    this.getSchema = schemaController.getSchema.bind(schemaController);
	    this.getSchemas = schemaController.getSchemas.bind(schemaController);
	    return this
	  }

	  function setReplySerializer (replySerializer) {
	    throwIfAlreadyStarted('Cannot call "setReplySerializer"!');

	    this[kReplySerializerDefault] = replySerializer;
	    return this
	  }

	  // wrapper that we expose to the user for configure the custom error handler
	  function setErrorHandler (func) {
	    throwIfAlreadyStarted('Cannot call "setErrorHandler"!');

	    if (typeof func !== 'function') {
	      throw new FST_ERR_ERROR_HANDLER_NOT_FN()
	    }

	    if (!options.allowErrorHandlerOverride && this[kErrorHandlerAlreadySet]) {
	      throw new FST_ERR_ERROR_HANDLER_ALREADY_SET()
	    } else if (this[kErrorHandlerAlreadySet]) {
	      FSTWRN004("To disable this behavior, set 'allowErrorHandlerOverride' to false or ignore this message. For more information, visit: https://fastify.dev/docs/latest/Reference/Server/#allowerrorhandleroverride");
	    }

	    this[kErrorHandlerAlreadySet] = true;
	    this[kErrorHandler] = buildErrorHandler(this[kErrorHandler], func.bind(this));
	    return this
	  }

	  function setChildLoggerFactory (factory) {
	    throwIfAlreadyStarted('Cannot call "setChildLoggerFactory"!');

	    this[kChildLoggerFactory] = factory;
	    return this
	  }

	  function printRoutes (opts = {}) {
	    // includeHooks:true - shortcut to include all supported hooks exported by fastify.Hooks
	    opts.includeMeta = opts.includeHooks ? opts.includeMeta ? supportedHooks.concat(opts.includeMeta) : supportedHooks : opts.includeMeta;
	    return router.printRoutes(opts)
	  }

	  function wrapRouting (router, { rewriteUrl, logger }) {
	    let isAsync;
	    return function preRouting (req, res) {
	      // only call isAsyncConstraint once
	      if (isAsync === undefined) isAsync = router.isAsyncConstraint();
	      if (rewriteUrl) {
	        req.originalUrl = req.url;
	        const url = rewriteUrl.call(fastify, req);
	        if (typeof url === 'string') {
	          req.url = url;
	        } else {
	          const err = new FST_ERR_ROUTE_REWRITE_NOT_STR(req.url, typeof url);
	          req.destroy(err);
	        }
	      }
	      router.routing(req, res, buildAsyncConstraintCallback(isAsync, req, res));
	    }
	  }

	  function setGenReqId (func) {
	    throwIfAlreadyStarted('Cannot call "setGenReqId"!');

	    this[kGenReqId] = reqIdGenFactory(this[kOptions].requestIdHeader, func);
	    return this
	  }

	  function addHttpMethod (method, { hasBody = false } = {}) {
	    if (typeof method !== 'string' || http.METHODS.indexOf(method) === -1) {
	      throw new FST_ERR_ROUTE_METHOD_INVALID()
	    }

	    if (hasBody === true) {
	      this[kSupportedHTTPMethods].bodywith.add(method);
	      this[kSupportedHTTPMethods].bodyless.delete(method);
	    } else {
	      this[kSupportedHTTPMethods].bodywith.delete(method);
	      this[kSupportedHTTPMethods].bodyless.add(method);
	    }

	    const _method = method.toLowerCase();
	    if (!this.hasDecorator(_method)) {
	      this.decorate(_method, function (url, options, handler) {
	        return router.prepareRoute.call(this, { method, url, options, handler })
	      });
	    }

	    return this
	  }
	}

	function validateSchemaErrorFormatter (schemaErrorFormatter) {
	  if (typeof schemaErrorFormatter !== 'function') {
	    throw new FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN(typeof schemaErrorFormatter)
	  } else if (schemaErrorFormatter.constructor.name === 'AsyncFunction') {
	    throw new FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN('AsyncFunction')
	  }
	}

	/**
	 * These export configurations enable JS and TS developers
	 * to consume fastify in whatever way best suits their needs.
	 * Some examples of supported import syntax includes:
	 * - `const fastify = require('fastify')`
	 * - `const { fastify } = require('fastify')`
	 * - `import * as Fastify from 'fastify'`
	 * - `import { fastify, TSC_definition } from 'fastify'`
	 * - `import fastify from 'fastify'`
	 * - `import fastify, { TSC_definition } from 'fastify'`
	 */
	fastify.exports = fastify$1;
	fastify.exports.errorCodes = errorCodes;
	fastify.exports.fastify = fastify$1;
	fastify.exports.default = fastify$1;
	return fastify.exports;
}

var fastifyExports = requireFastify();

var cors = {exports: {}};

var plugin = {exports: {}};

var getPluginName = {exports: {}};

var hasRequiredGetPluginName;

function requireGetPluginName () {
	if (hasRequiredGetPluginName) return getPluginName.exports;
	hasRequiredGetPluginName = 1;

	const fpStackTracePattern = /at\s{1}(?:.*\.)?plugin\s{1}.*\n\s*(.*)/;
	const fileNamePattern = /(\w*(\.\w*)*)\..*/;

	getPluginName.exports = function getPluginName (fn) {
	  if (fn.name.length > 0) return fn.name

	  const stackTraceLimit = Error.stackTraceLimit;
	  Error.stackTraceLimit = 10;
	  try {
	    throw new Error('anonymous function')
	  } catch (e) {
	    Error.stackTraceLimit = stackTraceLimit;
	    return extractPluginName(e.stack)
	  }
	};

	function extractPluginName (stack) {
	  const m = stack.match(fpStackTracePattern);

	  // get last section of path and match for filename
	  return m ? m[1].split(/[/\\]/).slice(-1)[0].match(fileNamePattern)[1] : 'anonymous'
	}
	getPluginName.exports.extractPluginName = extractPluginName;
	return getPluginName.exports;
}

var toCamelCase;
var hasRequiredToCamelCase;

function requireToCamelCase () {
	if (hasRequiredToCamelCase) return toCamelCase;
	hasRequiredToCamelCase = 1;

	toCamelCase = function toCamelCase (name) {
	  if (name[0] === '@') {
	    name = name.slice(1).replace('/', '-');
	  }
	  return name.replace(/-(.)/g, function (match, g1) {
	    return g1.toUpperCase()
	  })
	};
	return toCamelCase;
}

var hasRequiredPlugin;

function requirePlugin () {
	if (hasRequiredPlugin) return plugin.exports;
	hasRequiredPlugin = 1;

	const getPluginName = requireGetPluginName();
	const toCamelCase = requireToCamelCase();

	let count = 0;

	function plugin$1 (fn, options = {}) {
	  let autoName = false;

	  if (fn.default !== undefined) {
	    // Support for 'export default' behaviour in transpiled ECMAScript module
	    fn = fn.default;
	  }

	  if (typeof fn !== 'function') {
	    throw new TypeError(
	      `fastify-plugin expects a function, instead got a '${typeof fn}'`
	    )
	  }

	  if (typeof options === 'string') {
	    options = {
	      fastify: options
	    };
	  }

	  if (
	    typeof options !== 'object' ||
	    Array.isArray(options) ||
	    options === null
	  ) {
	    throw new TypeError('The options object should be an object')
	  }

	  if (options.fastify !== undefined && typeof options.fastify !== 'string') {
	    throw new TypeError(`fastify-plugin expects a version string, instead got '${typeof options.fastify}'`)
	  }

	  if (!options.name) {
	    autoName = true;
	    options.name = getPluginName(fn) + '-auto-' + count++;
	  }

	  fn[Symbol.for('skip-override')] = options.encapsulate !== true;
	  fn[Symbol.for('fastify.display-name')] = options.name;
	  fn[Symbol.for('plugin-meta')] = options;

	  // Faux modules support
	  if (!fn.default) {
	    fn.default = fn;
	  }

	  // TypeScript support for named imports
	  // See https://github.com/fastify/fastify/issues/2404 for more details
	  // The type definitions would have to be update to match this.
	  const camelCase = toCamelCase(options.name);
	  if (!autoName && !fn[camelCase]) {
	    fn[camelCase] = fn;
	  }

	  return fn
	}

	plugin.exports = plugin$1;
	plugin.exports.default = plugin$1;
	plugin.exports.fastifyPlugin = plugin$1;
	return plugin.exports;
}

var vary = {};

var hasRequiredVary;

function requireVary () {
	if (hasRequiredVary) return vary;
	hasRequiredVary = 1;

	const { FifoMap: FifoCache } = requireToadCache();

	/**
	 * Field Value Components
	 * Most HTTP header field values are defined using common syntax
	 * components (token, quoted-string, and comment) separated by
	 * whitespace or specific delimiting characters.  Delimiters are chosen
	 * from the set of US-ASCII visual characters not allowed in a token
	 * (DQUOTE and "(),/:;<=>?@[\]{}").
	 *
	 * field-name    = token
	 * token         = 1*tchar
	 * tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
	 *               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
	 *               / DIGIT / ALPHA
	 *               ; any VCHAR, except delimiters
	 *
	 * @see https://datatracker.ietf.org/doc/html/rfc7230#section-3.2.6
	 */

	const validFieldnameRE = /^[!#$%&'*+\-.^\w`|~]+$/u;
	function validateFieldname (fieldname) {
	  if (validFieldnameRE.test(fieldname) === false) {
	    throw new TypeError('Fieldname contains invalid characters.')
	  }
	}

	function parse (header) {
	  header = header.trim().toLowerCase();
	  const result = [];

	  if (header.length === 0) ; else if (header.indexOf(',') === -1) {
	    result.push(header);
	  } else {
	    const il = header.length;
	    let i = 0;
	    let pos = 0;
	    let char;

	    // tokenize the header
	    for (i; i < il; ++i) {
	      char = header[i];
	      // when we have whitespace set the pos to the next position
	      if (char === ' ') {
	        pos = i + 1;
	      // `,` is the separator of vary-values
	      } else if (char === ',') {
	        // if pos and current position are not the same we have a valid token
	        if (pos !== i) {
	          result.push(header.slice(pos, i));
	        }
	        // reset the positions
	        pos = i + 1;
	      }
	    }

	    if (pos !== i) {
	      result.push(header.slice(pos, i));
	    }
	  }

	  return result
	}

	function createAddFieldnameToVary (fieldname) {
	  const headerCache = new FifoCache(1000);

	  validateFieldname(fieldname);

	  return function (reply) {
	    let header = reply.getHeader('Vary');

	    if (!header) {
	      reply.header('Vary', fieldname);
	      return
	    }

	    if (header === '*') {
	      return
	    }

	    if (fieldname === '*') {
	      reply.header('Vary', '*');
	      return
	    }

	    if (Array.isArray(header)) {
	      header = header.join(', ');
	    }

	    if (headerCache.get(header) === undefined) {
	      const vals = parse(header);

	      if (vals.indexOf('*') !== -1) {
	        headerCache.set(header, '*');
	      } else if (vals.indexOf(fieldname.toLowerCase()) === -1) {
	        headerCache.set(header, header + ', ' + fieldname);
	      } else {
	        headerCache.set(header, null);
	      }
	    }
	    const cached = headerCache.get(header);
	    if (cached !== null) {
	      reply.header('Vary', cached);
	    }
	  }
	}

	vary.createAddFieldnameToVary = createAddFieldnameToVary;
	vary.addOriginToVaryHeader = createAddFieldnameToVary('Origin');
	vary.addAccessControlRequestHeadersToVaryHeader = createAddFieldnameToVary('Access-Control-Request-Headers');
	vary.parse = parse;
	return vary;
}

var hasRequiredCors;

function requireCors () {
	if (hasRequiredCors) return cors.exports;
	hasRequiredCors = 1;

	const fp = requirePlugin();
	const {
	  addAccessControlRequestHeadersToVaryHeader,
	  addOriginToVaryHeader
	} = requireVary();

	const defaultOptions = {
	  origin: '*',
	  methods: 'GET,HEAD,POST',
	  hook: 'onRequest',
	  preflightContinue: false,
	  optionsSuccessStatus: 204,
	  credentials: false,
	  exposedHeaders: null,
	  allowedHeaders: null,
	  maxAge: null,
	  preflight: true,
	  strictPreflight: true
	};

	const validHooks = [
	  'onRequest',
	  'preParsing',
	  'preValidation',
	  'preHandler',
	  'preSerialization',
	  'onSend'
	];

	const hookWithPayload = [
	  'preSerialization',
	  'preParsing',
	  'onSend'
	];

	function validateHook (value, next) {
	  if (validHooks.indexOf(value) !== -1) {
	    return
	  }
	  next(new TypeError('@fastify/cors: Invalid hook option provided.'));
	}

	function fastifyCors (fastify, opts, next) {
	  fastify.decorateRequest('corsPreflightEnabled', false);

	  let hideOptionsRoute = true;
	  if (typeof opts === 'function') {
	    handleCorsOptionsDelegator(opts, fastify, { hook: defaultOptions.hook }, next);
	  } else if (opts.delegator) {
	    const { delegator, ...options } = opts;
	    handleCorsOptionsDelegator(delegator, fastify, options, next);
	  } else {
	    if (opts.hideOptionsRoute !== undefined) hideOptionsRoute = opts.hideOptionsRoute;
	    const corsOptions = normalizeCorsOptions(opts);
	    validateHook(corsOptions.hook, next);
	    if (hookWithPayload.indexOf(corsOptions.hook) !== -1) {
	      fastify.addHook(corsOptions.hook, function handleCors (req, reply, _payload, next) {
	        addCorsHeadersHandler(fastify, corsOptions, req, reply, next);
	      });
	    } else {
	      fastify.addHook(corsOptions.hook, function handleCors (req, reply, next) {
	        addCorsHeadersHandler(fastify, corsOptions, req, reply, next);
	      });
	    }
	  }

	  // The preflight reply must occur in the hook. This allows fastify-cors to reply to
	  // preflight requests BEFORE possible authentication plugins. If the preflight reply
	  // occurred in this handler, other plugins may deny the request since the browser will
	  // remove most headers (such as the Authentication header).
	  //
	  // This route simply enables fastify to accept preflight requests.
	  fastify.options('*', { schema: { hide: hideOptionsRoute } }, (req, reply) => {
	    if (!req.corsPreflightEnabled) {
	      // Do not handle preflight requests if the origin option disabled CORS
	      reply.callNotFound();
	      return
	    }

	    reply.send();
	  });

	  next();
	}

	function handleCorsOptionsDelegator (optionsResolver, fastify, opts, next) {
	  const hook = opts?.hook || defaultOptions.hook;
	  validateHook(hook, next);
	  if (optionsResolver.length === 2) {
	    if (hookWithPayload.indexOf(hook) !== -1) {
	      fastify.addHook(hook, function handleCors (req, reply, _payload, next) {
	        handleCorsOptionsCallbackDelegator(optionsResolver, fastify, req, reply, next);
	      });
	    } else {
	      fastify.addHook(hook, function handleCors (req, reply, next) {
	        handleCorsOptionsCallbackDelegator(optionsResolver, fastify, req, reply, next);
	      });
	    }
	  } else {
	    if (hookWithPayload.indexOf(hook) !== -1) {
	      // handle delegator based on Promise
	      fastify.addHook(hook, function handleCors (req, reply, _payload, next) {
	        const ret = optionsResolver(req);
	        if (ret && typeof ret.then === 'function') {
	          ret.then(options => addCorsHeadersHandler(fastify, normalizeCorsOptions(options, true), req, reply, next)).catch(next);
	          return
	        }
	        next(new Error('Invalid CORS origin option'));
	      });
	    } else {
	      // handle delegator based on Promise
	      fastify.addHook(hook, function handleCors (req, reply, next) {
	        const ret = optionsResolver(req);
	        if (ret && typeof ret.then === 'function') {
	          ret.then(options => addCorsHeadersHandler(fastify, normalizeCorsOptions(options, true), req, reply, next)).catch(next);
	          return
	        }
	        next(new Error('Invalid CORS origin option'));
	      });
	    }
	  }
	}

	function handleCorsOptionsCallbackDelegator (optionsResolver, fastify, req, reply, next) {
	  optionsResolver(req, (err, options) => {
	    if (err) {
	      next(err);
	    } else {
	      addCorsHeadersHandler(fastify, normalizeCorsOptions(options, true), req, reply, next);
	    }
	  });
	}

	/**
	 * @param {import('./types').FastifyCorsOptions} opts
	 */
	function normalizeCorsOptions (opts, dynamic) {
	  const corsOptions = { ...defaultOptions, ...opts };
	  if (Array.isArray(opts.origin) && opts.origin.indexOf('*') !== -1) {
	    corsOptions.origin = '*';
	  }
	  if (Number.isInteger(corsOptions.cacheControl)) {
	    // integer numbers are formatted this way
	    corsOptions.cacheControl = `max-age=${corsOptions.cacheControl}`;
	  } else if (typeof corsOptions.cacheControl !== 'string') {
	    // strings are applied directly and any other value is ignored
	    corsOptions.cacheControl = null;
	  }
	  corsOptions.dynamic = dynamic || false;
	  return corsOptions
	}

	function addCorsHeadersHandler (fastify, options, req, reply, next) {
	  if ((typeof options.origin !== 'string' && options.origin !== false) || options.dynamic) {
	    // Always set Vary header for non-static origin option
	    // https://fetch.spec.whatwg.org/#cors-protocol-and-http-caches
	    addOriginToVaryHeader(reply);
	  }

	  const resolveOriginOption = typeof options.origin === 'function' ? resolveOriginWrapper(fastify, options.origin) : (_, cb) => cb(null, options.origin);

	  resolveOriginOption(req, (error, resolvedOriginOption) => {
	    if (error !== null) {
	      return next(error)
	    }

	    // Disable CORS and preflight if false
	    if (resolvedOriginOption === false) {
	      return next()
	    }

	    // Allow routes to disable CORS individually
	    if (req.routeOptions.config?.cors === false) {
	      return next()
	    }

	    // Falsy values are invalid
	    if (!resolvedOriginOption) {
	      return next(new Error('Invalid CORS origin option'))
	    }

	    addCorsHeaders(req, reply, resolvedOriginOption, options);

	    if (req.raw.method === 'OPTIONS' && options.preflight === true) {
	      // Strict mode enforces the required headers for preflight
	      if (options.strictPreflight === true && (!req.headers.origin || !req.headers['access-control-request-method'])) {
	        reply.status(400).type('text/plain').send('Invalid Preflight Request');
	        return
	      }

	      req.corsPreflightEnabled = true;

	      addPreflightHeaders(req, reply, options);

	      if (!options.preflightContinue) {
	        // Do not call the hook callback and terminate the request
	        // Safari (and potentially other browsers) need content-length 0,
	        // for 204 or they just hang waiting for a body
	        reply
	          .code(options.optionsSuccessStatus)
	          .header('Content-Length', '0')
	          .send();
	        return
	      }
	    }

	    return next()
	  });
	}

	function addCorsHeaders (req, reply, originOption, corsOptions) {
	  const origin = getAccessControlAllowOriginHeader(req.headers.origin, originOption);
	  // In the case of origin not allowed the header is not
	  // written in the response.
	  // https://github.com/fastify/fastify-cors/issues/127
	  if (origin) {
	    reply.header('Access-Control-Allow-Origin', origin);
	  }

	  if (corsOptions.credentials) {
	    reply.header('Access-Control-Allow-Credentials', 'true');
	  }

	  if (corsOptions.exposedHeaders !== null) {
	    reply.header(
	      'Access-Control-Expose-Headers',
	      Array.isArray(corsOptions.exposedHeaders) ? corsOptions.exposedHeaders.join(', ') : corsOptions.exposedHeaders
	    );
	  }
	}

	function addPreflightHeaders (req, reply, corsOptions) {
	  reply.header(
	    'Access-Control-Allow-Methods',
	    Array.isArray(corsOptions.methods) ? corsOptions.methods.join(', ') : corsOptions.methods
	  );

	  if (corsOptions.allowedHeaders === null) {
	    addAccessControlRequestHeadersToVaryHeader(reply);
	    const reqAllowedHeaders = req.headers['access-control-request-headers'];
	    if (reqAllowedHeaders !== undefined) {
	      reply.header('Access-Control-Allow-Headers', reqAllowedHeaders);
	    }
	  } else {
	    reply.header(
	      'Access-Control-Allow-Headers',
	      Array.isArray(corsOptions.allowedHeaders) ? corsOptions.allowedHeaders.join(', ') : corsOptions.allowedHeaders
	    );
	  }

	  if (corsOptions.maxAge !== null) {
	    reply.header('Access-Control-Max-Age', String(corsOptions.maxAge));
	  }

	  if (corsOptions.cacheControl) {
	    reply.header('Cache-Control', corsOptions.cacheControl);
	  }
	}

	function resolveOriginWrapper (fastify, origin) {
	  return function (req, cb) {
	    const result = origin.call(fastify, req.headers.origin, cb);

	    // Allow for promises
	    if (result && typeof result.then === 'function') {
	      result.then(res => cb(null, res), cb);
	    }
	  }
	}

	function getAccessControlAllowOriginHeader (reqOrigin, originOption) {
	  if (typeof originOption === 'string') {
	    // fixed or any origin ('*')
	    return originOption
	  }

	  // reflect origin
	  return isRequestOriginAllowed(reqOrigin, originOption) ? reqOrigin : false
	}

	function isRequestOriginAllowed (reqOrigin, allowedOrigin) {
	  if (Array.isArray(allowedOrigin)) {
	    for (let i = 0; i < allowedOrigin.length; ++i) {
	      if (isRequestOriginAllowed(reqOrigin, allowedOrigin[i])) {
	        return true
	      }
	    }
	    return false
	  } else if (typeof allowedOrigin === 'string') {
	    return reqOrigin === allowedOrigin
	  } else if (allowedOrigin instanceof RegExp) {
	    allowedOrigin.lastIndex = 0;
	    return allowedOrigin.test(reqOrigin)
	  } else {
	    return !!allowedOrigin
	  }
	}

	const _fastifyCors = fp(fastifyCors, {
	  fastify: '5.x',
	  name: '@fastify/cors'
	});

	/**
	 * These export configurations enable JS and TS developers
	 * to consumer fastify in whatever way best suits their needs.
	 */
	cors.exports = _fastifyCors;
	cors.exports.fastifyCors = _fastifyCors;
	cors.exports.default = _fastifyCors;
	return cors.exports;
}

var corsExports = requireCors();

var _static = {exports: {}};

var commonjs$6 = {};

var commonjs$5 = {};

var commonjs$4 = {};

var commonjs$3 = {};

var hasRequiredCommonjs$6;

function requireCommonjs$6 () {
	if (hasRequiredCommonjs$6) return commonjs$3;
	hasRequiredCommonjs$6 = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.range = exports.balanced = void 0;
		const balanced = (a, b, str) => {
		    const ma = a instanceof RegExp ? maybeMatch(a, str) : a;
		    const mb = b instanceof RegExp ? maybeMatch(b, str) : b;
		    const r = ma !== null && mb != null && (0, exports.range)(ma, mb, str);
		    return (r && {
		        start: r[0],
		        end: r[1],
		        pre: str.slice(0, r[0]),
		        body: str.slice(r[0] + ma.length, r[1]),
		        post: str.slice(r[1] + mb.length),
		    });
		};
		exports.balanced = balanced;
		const maybeMatch = (reg, str) => {
		    const m = str.match(reg);
		    return m ? m[0] : null;
		};
		const range = (a, b, str) => {
		    let begs, beg, left, right = undefined, result;
		    let ai = str.indexOf(a);
		    let bi = str.indexOf(b, ai + 1);
		    let i = ai;
		    if (ai >= 0 && bi > 0) {
		        if (a === b) {
		            return [ai, bi];
		        }
		        begs = [];
		        left = str.length;
		        while (i >= 0 && !result) {
		            if (i === ai) {
		                begs.push(i);
		                ai = str.indexOf(a, i + 1);
		            }
		            else if (begs.length === 1) {
		                const r = begs.pop();
		                if (r !== undefined)
		                    result = [r, bi];
		            }
		            else {
		                beg = begs.pop();
		                if (beg !== undefined && beg < left) {
		                    left = beg;
		                    right = bi;
		                }
		                bi = str.indexOf(b, i + 1);
		            }
		            i = ai < bi && ai >= 0 ? ai : bi;
		        }
		        if (begs.length && right !== undefined) {
		            result = [left, right];
		        }
		    }
		    return result;
		};
		exports.range = range;
		
	} (commonjs$3));
	return commonjs$3;
}

var hasRequiredCommonjs$5;

function requireCommonjs$5 () {
	if (hasRequiredCommonjs$5) return commonjs$4;
	hasRequiredCommonjs$5 = 1;
	Object.defineProperty(commonjs$4, "__esModule", { value: true });
	commonjs$4.expand = expand;
	const balanced_match_1 = requireCommonjs$6();
	const escSlash = '\0SLASH' + Math.random() + '\0';
	const escOpen = '\0OPEN' + Math.random() + '\0';
	const escClose = '\0CLOSE' + Math.random() + '\0';
	const escComma = '\0COMMA' + Math.random() + '\0';
	const escPeriod = '\0PERIOD' + Math.random() + '\0';
	const escSlashPattern = new RegExp(escSlash, 'g');
	const escOpenPattern = new RegExp(escOpen, 'g');
	const escClosePattern = new RegExp(escClose, 'g');
	const escCommaPattern = new RegExp(escComma, 'g');
	const escPeriodPattern = new RegExp(escPeriod, 'g');
	const slashPattern = /\\\\/g;
	const openPattern = /\\{/g;
	const closePattern = /\\}/g;
	const commaPattern = /\\,/g;
	const periodPattern = /\\./g;
	function numeric(str) {
	    return !isNaN(str) ? parseInt(str, 10) : str.charCodeAt(0);
	}
	function escapeBraces(str) {
	    return str
	        .replace(slashPattern, escSlash)
	        .replace(openPattern, escOpen)
	        .replace(closePattern, escClose)
	        .replace(commaPattern, escComma)
	        .replace(periodPattern, escPeriod);
	}
	function unescapeBraces(str) {
	    return str
	        .replace(escSlashPattern, '\\')
	        .replace(escOpenPattern, '{')
	        .replace(escClosePattern, '}')
	        .replace(escCommaPattern, ',')
	        .replace(escPeriodPattern, '.');
	}
	/**
	 * Basically just str.split(","), but handling cases
	 * where we have nested braced sections, which should be
	 * treated as individual members, like {a,{b,c},d}
	 */
	function parseCommaParts(str) {
	    if (!str) {
	        return [''];
	    }
	    const parts = [];
	    const m = (0, balanced_match_1.balanced)('{', '}', str);
	    if (!m) {
	        return str.split(',');
	    }
	    const { pre, body, post } = m;
	    const p = pre.split(',');
	    p[p.length - 1] += '{' + body + '}';
	    const postParts = parseCommaParts(post);
	    if (post.length) {
	        p[p.length - 1] += postParts.shift();
	        p.push.apply(p, postParts);
	    }
	    parts.push.apply(parts, p);
	    return parts;
	}
	function expand(str) {
	    if (!str) {
	        return [];
	    }
	    // I don't know why Bash 4.3 does this, but it does.
	    // Anything starting with {} will have the first two bytes preserved
	    // but *only* at the top level, so {},a}b will not expand to anything,
	    // but a{},b}c will be expanded to [a}c,abc].
	    // One could argue that this is a bug in Bash, but since the goal of
	    // this module is to match Bash's rules, we escape a leading {}
	    if (str.slice(0, 2) === '{}') {
	        str = '\\{\\}' + str.slice(2);
	    }
	    return expand_(escapeBraces(str), true).map(unescapeBraces);
	}
	function embrace(str) {
	    return '{' + str + '}';
	}
	function isPadded(el) {
	    return /^-?0\d/.test(el);
	}
	function lte(i, y) {
	    return i <= y;
	}
	function gte(i, y) {
	    return i >= y;
	}
	function expand_(str, isTop) {
	    /** @type {string[]} */
	    const expansions = [];
	    const m = (0, balanced_match_1.balanced)('{', '}', str);
	    if (!m)
	        return [str];
	    // no need to expand pre, since it is guaranteed to be free of brace-sets
	    const pre = m.pre;
	    const post = m.post.length ? expand_(m.post, false) : [''];
	    if (/\$$/.test(m.pre)) {
	        for (let k = 0; k < post.length; k++) {
	            const expansion = pre + '{' + m.body + '}' + post[k];
	            expansions.push(expansion);
	        }
	    }
	    else {
	        const isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
	        const isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
	        const isSequence = isNumericSequence || isAlphaSequence;
	        const isOptions = m.body.indexOf(',') >= 0;
	        if (!isSequence && !isOptions) {
	            // {a},b}
	            if (m.post.match(/,(?!,).*\}/)) {
	                str = m.pre + '{' + m.body + escClose + m.post;
	                return expand_(str);
	            }
	            return [str];
	        }
	        let n;
	        if (isSequence) {
	            n = m.body.split(/\.\./);
	        }
	        else {
	            n = parseCommaParts(m.body);
	            if (n.length === 1 && n[0] !== undefined) {
	                // x{{a,b}}y ==> x{a}y x{b}y
	                n = expand_(n[0], false).map(embrace);
	                //XXX is this necessary? Can't seem to hit it in tests.
	                /* c8 ignore start */
	                if (n.length === 1) {
	                    return post.map(p => m.pre + n[0] + p);
	                }
	                /* c8 ignore stop */
	            }
	        }
	        // at this point, n is the parts, and we know it's not a comma set
	        // with a single entry.
	        let N;
	        if (isSequence && n[0] !== undefined && n[1] !== undefined) {
	            const x = numeric(n[0]);
	            const y = numeric(n[1]);
	            const width = Math.max(n[0].length, n[1].length);
	            let incr = n.length === 3 && n[2] !== undefined ? Math.abs(numeric(n[2])) : 1;
	            let test = lte;
	            const reverse = y < x;
	            if (reverse) {
	                incr *= -1;
	                test = gte;
	            }
	            const pad = n.some(isPadded);
	            N = [];
	            for (let i = x; test(i, y); i += incr) {
	                let c;
	                if (isAlphaSequence) {
	                    c = String.fromCharCode(i);
	                    if (c === '\\') {
	                        c = '';
	                    }
	                }
	                else {
	                    c = String(i);
	                    if (pad) {
	                        const need = width - c.length;
	                        if (need > 0) {
	                            const z = new Array(need + 1).join('0');
	                            if (i < 0) {
	                                c = '-' + z + c.slice(1);
	                            }
	                            else {
	                                c = z + c;
	                            }
	                        }
	                    }
	                }
	                N.push(c);
	            }
	        }
	        else {
	            N = [];
	            for (let j = 0; j < n.length; j++) {
	                N.push.apply(N, expand_(n[j], false));
	            }
	        }
	        for (let j = 0; j < N.length; j++) {
	            for (let k = 0; k < post.length; k++) {
	                const expansion = pre + N[j] + post[k];
	                if (!isTop || isSequence || expansion) {
	                    expansions.push(expansion);
	                }
	            }
	        }
	    }
	    return expansions;
	}
	
	return commonjs$4;
}

var assertValidPattern = {};

var hasRequiredAssertValidPattern;

function requireAssertValidPattern () {
	if (hasRequiredAssertValidPattern) return assertValidPattern;
	hasRequiredAssertValidPattern = 1;
	Object.defineProperty(assertValidPattern, "__esModule", { value: true });
	assertValidPattern.assertValidPattern = void 0;
	const MAX_PATTERN_LENGTH = 1024 * 64;
	const assertValidPattern$1 = (pattern) => {
	    if (typeof pattern !== 'string') {
	        throw new TypeError('invalid pattern');
	    }
	    if (pattern.length > MAX_PATTERN_LENGTH) {
	        throw new TypeError('pattern is too long');
	    }
	};
	assertValidPattern.assertValidPattern = assertValidPattern$1;
	
	return assertValidPattern;
}

var ast = {};

var braceExpressions = {};

var hasRequiredBraceExpressions;

function requireBraceExpressions () {
	if (hasRequiredBraceExpressions) return braceExpressions;
	hasRequiredBraceExpressions = 1;
	// translate the various posix character classes into unicode properties
	// this works across all unicode locales
	Object.defineProperty(braceExpressions, "__esModule", { value: true });
	braceExpressions.parseClass = void 0;
	// { <posix class>: [<translation>, /u flag required, negated]
	const posixClasses = {
	    '[:alnum:]': ['\\p{L}\\p{Nl}\\p{Nd}', true],
	    '[:alpha:]': ['\\p{L}\\p{Nl}', true],
	    '[:ascii:]': ['\\x' + '00-\\x' + '7f', false],
	    '[:blank:]': ['\\p{Zs}\\t', true],
	    '[:cntrl:]': ['\\p{Cc}', true],
	    '[:digit:]': ['\\p{Nd}', true],
	    '[:graph:]': ['\\p{Z}\\p{C}', true, true],
	    '[:lower:]': ['\\p{Ll}', true],
	    '[:print:]': ['\\p{C}', true],
	    '[:punct:]': ['\\p{P}', true],
	    '[:space:]': ['\\p{Z}\\t\\r\\n\\v\\f', true],
	    '[:upper:]': ['\\p{Lu}', true],
	    '[:word:]': ['\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}', true],
	    '[:xdigit:]': ['A-Fa-f0-9', false],
	};
	// only need to escape a few things inside of brace expressions
	// escapes: [ \ ] -
	const braceEscape = (s) => s.replace(/[[\]\\-]/g, '\\$&');
	// escape all regexp magic characters
	const regexpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
	// everything has already been escaped, we just have to join
	const rangesToString = (ranges) => ranges.join('');
	// takes a glob string at a posix brace expression, and returns
	// an equivalent regular expression source, and boolean indicating
	// whether the /u flag needs to be applied, and the number of chars
	// consumed to parse the character class.
	// This also removes out of order ranges, and returns ($.) if the
	// entire class just no good.
	const parseClass = (glob, position) => {
	    const pos = position;
	    /* c8 ignore start */
	    if (glob.charAt(pos) !== '[') {
	        throw new Error('not in a brace expression');
	    }
	    /* c8 ignore stop */
	    const ranges = [];
	    const negs = [];
	    let i = pos + 1;
	    let sawStart = false;
	    let uflag = false;
	    let escaping = false;
	    let negate = false;
	    let endPos = pos;
	    let rangeStart = '';
	    WHILE: while (i < glob.length) {
	        const c = glob.charAt(i);
	        if ((c === '!' || c === '^') && i === pos + 1) {
	            negate = true;
	            i++;
	            continue;
	        }
	        if (c === ']' && sawStart && !escaping) {
	            endPos = i + 1;
	            break;
	        }
	        sawStart = true;
	        if (c === '\\') {
	            if (!escaping) {
	                escaping = true;
	                i++;
	                continue;
	            }
	            // escaped \ char, fall through and treat like normal char
	        }
	        if (c === '[' && !escaping) {
	            // either a posix class, a collation equivalent, or just a [
	            for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {
	                if (glob.startsWith(cls, i)) {
	                    // invalid, [a-[] is fine, but not [a-[:alpha]]
	                    if (rangeStart) {
	                        return ['$.', false, glob.length - pos, true];
	                    }
	                    i += cls.length;
	                    if (neg)
	                        negs.push(unip);
	                    else
	                        ranges.push(unip);
	                    uflag = uflag || u;
	                    continue WHILE;
	                }
	            }
	        }
	        // now it's just a normal character, effectively
	        escaping = false;
	        if (rangeStart) {
	            // throw this range away if it's not valid, but others
	            // can still match.
	            if (c > rangeStart) {
	                ranges.push(braceEscape(rangeStart) + '-' + braceEscape(c));
	            }
	            else if (c === rangeStart) {
	                ranges.push(braceEscape(c));
	            }
	            rangeStart = '';
	            i++;
	            continue;
	        }
	        // now might be the start of a range.
	        // can be either c-d or c-] or c<more...>] or c] at this point
	        if (glob.startsWith('-]', i + 1)) {
	            ranges.push(braceEscape(c + '-'));
	            i += 2;
	            continue;
	        }
	        if (glob.startsWith('-', i + 1)) {
	            rangeStart = c;
	            i += 2;
	            continue;
	        }
	        // not the start of a range, just a single character
	        ranges.push(braceEscape(c));
	        i++;
	    }
	    if (endPos < i) {
	        // didn't see the end of the class, not a valid class,
	        // but might still be valid as a literal match.
	        return ['', false, 0, false];
	    }
	    // if we got no ranges and no negates, then we have a range that
	    // cannot possibly match anything, and that poisons the whole glob
	    if (!ranges.length && !negs.length) {
	        return ['$.', false, glob.length - pos, true];
	    }
	    // if we got one positive range, and it's a single character, then that's
	    // not actually a magic pattern, it's just that one literal character.
	    // we should not treat that as "magic", we should just return the literal
	    // character. [_] is a perfectly valid way to escape glob magic chars.
	    if (negs.length === 0 &&
	        ranges.length === 1 &&
	        /^\\?.$/.test(ranges[0]) &&
	        !negate) {
	        const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
	        return [regexpEscape(r), false, endPos - pos, false];
	    }
	    const sranges = '[' + (negate ? '^' : '') + rangesToString(ranges) + ']';
	    const snegs = '[' + (negate ? '' : '^') + rangesToString(negs) + ']';
	    const comb = ranges.length && negs.length
	        ? '(' + sranges + '|' + snegs + ')'
	        : ranges.length
	            ? sranges
	            : snegs;
	    return [comb, uflag, endPos - pos, true];
	};
	braceExpressions.parseClass = parseClass;
	
	return braceExpressions;
}

var _unescape = {};

var hasRequired_unescape;

function require_unescape () {
	if (hasRequired_unescape) return _unescape;
	hasRequired_unescape = 1;
	Object.defineProperty(_unescape, "__esModule", { value: true });
	_unescape.unescape = void 0;
	/**
	 * Un-escape a string that has been escaped with {@link escape}.
	 *
	 * If the {@link windowsPathsNoEscape} option is used, then square-brace
	 * escapes are removed, but not backslash escapes.  For example, it will turn
	 * the string `'[*]'` into `*`, but it will not turn `'\\*'` into `'*'`,
	 * becuase `\` is a path separator in `windowsPathsNoEscape` mode.
	 *
	 * When `windowsPathsNoEscape` is not set, then both brace escapes and
	 * backslash escapes are removed.
	 *
	 * Slashes (and backslashes in `windowsPathsNoEscape` mode) cannot be escaped
	 * or unescaped.
	 */
	const unescape = (s, { windowsPathsNoEscape = false, } = {}) => {
	    return windowsPathsNoEscape
	        ? s.replace(/\[([^\/\\])\]/g, '$1')
	        : s.replace(/((?!\\).|^)\[([^\/\\])\]/g, '$1$2').replace(/\\([^\/])/g, '$1');
	};
	_unescape.unescape = unescape;
	
	return _unescape;
}

var hasRequiredAst;

function requireAst () {
	if (hasRequiredAst) return ast;
	hasRequiredAst = 1;
	// parse a single path portion
	Object.defineProperty(ast, "__esModule", { value: true });
	ast.AST = void 0;
	const brace_expressions_js_1 = requireBraceExpressions();
	const unescape_js_1 = require_unescape();
	const types = new Set(['!', '?', '+', '*', '@']);
	const isExtglobType = (c) => types.has(c);
	// Patterns that get prepended to bind to the start of either the
	// entire string, or just a single path portion, to prevent dots
	// and/or traversal patterns, when needed.
	// Exts don't need the ^ or / bit, because the root binds that already.
	const startNoTraversal = '(?!(?:^|/)\\.\\.?(?:$|/))';
	const startNoDot = '(?!\\.)';
	// characters that indicate a start of pattern needs the "no dots" bit,
	// because a dot *might* be matched. ( is not in the list, because in
	// the case of a child extglob, it will handle the prevention itself.
	const addPatternStart = new Set(['[', '.']);
	// cases where traversal is A-OK, no dot prevention needed
	const justDots = new Set(['..', '.']);
	const reSpecials = new Set('().*{}+?[]^$\\!');
	const regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
	// any single thing other than /
	const qmark = '[^/]';
	// * => any number of characters
	const star = qmark + '*?';
	// use + when we need to ensure that *something* matches, because the * is
	// the only thing in the path portion.
	const starNoEmpty = qmark + '+?';
	// remove the \ chars that we added if we end up doing a nonmagic compare
	// const deslash = (s: string) => s.replace(/\\(.)/g, '$1')
	class AST {
	    type;
	    #root;
	    #hasMagic;
	    #uflag = false;
	    #parts = [];
	    #parent;
	    #parentIndex;
	    #negs;
	    #filledNegs = false;
	    #options;
	    #toString;
	    // set to true if it's an extglob with no children
	    // (which really means one child of '')
	    #emptyExt = false;
	    constructor(type, parent, options = {}) {
	        this.type = type;
	        // extglobs are inherently magical
	        if (type)
	            this.#hasMagic = true;
	        this.#parent = parent;
	        this.#root = this.#parent ? this.#parent.#root : this;
	        this.#options = this.#root === this ? options : this.#root.#options;
	        this.#negs = this.#root === this ? [] : this.#root.#negs;
	        if (type === '!' && !this.#root.#filledNegs)
	            this.#negs.push(this);
	        this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;
	    }
	    get hasMagic() {
	        /* c8 ignore start */
	        if (this.#hasMagic !== undefined)
	            return this.#hasMagic;
	        /* c8 ignore stop */
	        for (const p of this.#parts) {
	            if (typeof p === 'string')
	                continue;
	            if (p.type || p.hasMagic)
	                return (this.#hasMagic = true);
	        }
	        // note: will be undefined until we generate the regexp src and find out
	        return this.#hasMagic;
	    }
	    // reconstructs the pattern
	    toString() {
	        if (this.#toString !== undefined)
	            return this.#toString;
	        if (!this.type) {
	            return (this.#toString = this.#parts.map(p => String(p)).join(''));
	        }
	        else {
	            return (this.#toString =
	                this.type + '(' + this.#parts.map(p => String(p)).join('|') + ')');
	        }
	    }
	    #fillNegs() {
	        /* c8 ignore start */
	        if (this !== this.#root)
	            throw new Error('should only call on root');
	        if (this.#filledNegs)
	            return this;
	        /* c8 ignore stop */
	        // call toString() once to fill this out
	        this.toString();
	        this.#filledNegs = true;
	        let n;
	        while ((n = this.#negs.pop())) {
	            if (n.type !== '!')
	                continue;
	            // walk up the tree, appending everthing that comes AFTER parentIndex
	            let p = n;
	            let pp = p.#parent;
	            while (pp) {
	                for (let i = p.#parentIndex + 1; !pp.type && i < pp.#parts.length; i++) {
	                    for (const part of n.#parts) {
	                        /* c8 ignore start */
	                        if (typeof part === 'string') {
	                            throw new Error('string part in extglob AST??');
	                        }
	                        /* c8 ignore stop */
	                        part.copyIn(pp.#parts[i]);
	                    }
	                }
	                p = pp;
	                pp = p.#parent;
	            }
	        }
	        return this;
	    }
	    push(...parts) {
	        for (const p of parts) {
	            if (p === '')
	                continue;
	            /* c8 ignore start */
	            if (typeof p !== 'string' && !(p instanceof AST && p.#parent === this)) {
	                throw new Error('invalid part: ' + p);
	            }
	            /* c8 ignore stop */
	            this.#parts.push(p);
	        }
	    }
	    toJSON() {
	        const ret = this.type === null
	            ? this.#parts.slice().map(p => (typeof p === 'string' ? p : p.toJSON()))
	            : [this.type, ...this.#parts.map(p => p.toJSON())];
	        if (this.isStart() && !this.type)
	            ret.unshift([]);
	        if (this.isEnd() &&
	            (this === this.#root ||
	                (this.#root.#filledNegs && this.#parent?.type === '!'))) {
	            ret.push({});
	        }
	        return ret;
	    }
	    isStart() {
	        if (this.#root === this)
	            return true;
	        // if (this.type) return !!this.#parent?.isStart()
	        if (!this.#parent?.isStart())
	            return false;
	        if (this.#parentIndex === 0)
	            return true;
	        // if everything AHEAD of this is a negation, then it's still the "start"
	        const p = this.#parent;
	        for (let i = 0; i < this.#parentIndex; i++) {
	            const pp = p.#parts[i];
	            if (!(pp instanceof AST && pp.type === '!')) {
	                return false;
	            }
	        }
	        return true;
	    }
	    isEnd() {
	        if (this.#root === this)
	            return true;
	        if (this.#parent?.type === '!')
	            return true;
	        if (!this.#parent?.isEnd())
	            return false;
	        if (!this.type)
	            return this.#parent?.isEnd();
	        // if not root, it'll always have a parent
	        /* c8 ignore start */
	        const pl = this.#parent ? this.#parent.#parts.length : 0;
	        /* c8 ignore stop */
	        return this.#parentIndex === pl - 1;
	    }
	    copyIn(part) {
	        if (typeof part === 'string')
	            this.push(part);
	        else
	            this.push(part.clone(this));
	    }
	    clone(parent) {
	        const c = new AST(this.type, parent);
	        for (const p of this.#parts) {
	            c.copyIn(p);
	        }
	        return c;
	    }
	    static #parseAST(str, ast, pos, opt) {
	        let escaping = false;
	        let inBrace = false;
	        let braceStart = -1;
	        let braceNeg = false;
	        if (ast.type === null) {
	            // outside of a extglob, append until we find a start
	            let i = pos;
	            let acc = '';
	            while (i < str.length) {
	                const c = str.charAt(i++);
	                // still accumulate escapes at this point, but we do ignore
	                // starts that are escaped
	                if (escaping || c === '\\') {
	                    escaping = !escaping;
	                    acc += c;
	                    continue;
	                }
	                if (inBrace) {
	                    if (i === braceStart + 1) {
	                        if (c === '^' || c === '!') {
	                            braceNeg = true;
	                        }
	                    }
	                    else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {
	                        inBrace = false;
	                    }
	                    acc += c;
	                    continue;
	                }
	                else if (c === '[') {
	                    inBrace = true;
	                    braceStart = i;
	                    braceNeg = false;
	                    acc += c;
	                    continue;
	                }
	                if (!opt.noext && isExtglobType(c) && str.charAt(i) === '(') {
	                    ast.push(acc);
	                    acc = '';
	                    const ext = new AST(c, ast);
	                    i = AST.#parseAST(str, ext, i, opt);
	                    ast.push(ext);
	                    continue;
	                }
	                acc += c;
	            }
	            ast.push(acc);
	            return i;
	        }
	        // some kind of extglob, pos is at the (
	        // find the next | or )
	        let i = pos + 1;
	        let part = new AST(null, ast);
	        const parts = [];
	        let acc = '';
	        while (i < str.length) {
	            const c = str.charAt(i++);
	            // still accumulate escapes at this point, but we do ignore
	            // starts that are escaped
	            if (escaping || c === '\\') {
	                escaping = !escaping;
	                acc += c;
	                continue;
	            }
	            if (inBrace) {
	                if (i === braceStart + 1) {
	                    if (c === '^' || c === '!') {
	                        braceNeg = true;
	                    }
	                }
	                else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {
	                    inBrace = false;
	                }
	                acc += c;
	                continue;
	            }
	            else if (c === '[') {
	                inBrace = true;
	                braceStart = i;
	                braceNeg = false;
	                acc += c;
	                continue;
	            }
	            if (isExtglobType(c) && str.charAt(i) === '(') {
	                part.push(acc);
	                acc = '';
	                const ext = new AST(c, part);
	                part.push(ext);
	                i = AST.#parseAST(str, ext, i, opt);
	                continue;
	            }
	            if (c === '|') {
	                part.push(acc);
	                acc = '';
	                parts.push(part);
	                part = new AST(null, ast);
	                continue;
	            }
	            if (c === ')') {
	                if (acc === '' && ast.#parts.length === 0) {
	                    ast.#emptyExt = true;
	                }
	                part.push(acc);
	                acc = '';
	                ast.push(...parts, part);
	                return i;
	            }
	            acc += c;
	        }
	        // unfinished extglob
	        // if we got here, it was a malformed extglob! not an extglob, but
	        // maybe something else in there.
	        ast.type = null;
	        ast.#hasMagic = undefined;
	        ast.#parts = [str.substring(pos - 1)];
	        return i;
	    }
	    static fromGlob(pattern, options = {}) {
	        const ast = new AST(null, undefined, options);
	        AST.#parseAST(pattern, ast, 0, options);
	        return ast;
	    }
	    // returns the regular expression if there's magic, or the unescaped
	    // string if not.
	    toMMPattern() {
	        // should only be called on root
	        /* c8 ignore start */
	        if (this !== this.#root)
	            return this.#root.toMMPattern();
	        /* c8 ignore stop */
	        const glob = this.toString();
	        const [re, body, hasMagic, uflag] = this.toRegExpSource();
	        // if we're in nocase mode, and not nocaseMagicOnly, then we do
	        // still need a regular expression if we have to case-insensitively
	        // match capital/lowercase characters.
	        const anyMagic = hasMagic ||
	            this.#hasMagic ||
	            (this.#options.nocase &&
	                !this.#options.nocaseMagicOnly &&
	                glob.toUpperCase() !== glob.toLowerCase());
	        if (!anyMagic) {
	            return body;
	        }
	        const flags = (this.#options.nocase ? 'i' : '') + (uflag ? 'u' : '');
	        return Object.assign(new RegExp(`^${re}$`, flags), {
	            _src: re,
	            _glob: glob,
	        });
	    }
	    get options() {
	        return this.#options;
	    }
	    // returns the string match, the regexp source, whether there's magic
	    // in the regexp (so a regular expression is required) and whether or
	    // not the uflag is needed for the regular expression (for posix classes)
	    // TODO: instead of injecting the start/end at this point, just return
	    // the BODY of the regexp, along with the start/end portions suitable
	    // for binding the start/end in either a joined full-path makeRe context
	    // (where we bind to (^|/), or a standalone matchPart context (where
	    // we bind to ^, and not /).  Otherwise slashes get duped!
	    //
	    // In part-matching mode, the start is:
	    // - if not isStart: nothing
	    // - if traversal possible, but not allowed: ^(?!\.\.?$)
	    // - if dots allowed or not possible: ^
	    // - if dots possible and not allowed: ^(?!\.)
	    // end is:
	    // - if not isEnd(): nothing
	    // - else: $
	    //
	    // In full-path matching mode, we put the slash at the START of the
	    // pattern, so start is:
	    // - if first pattern: same as part-matching mode
	    // - if not isStart(): nothing
	    // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
	    // - if dots allowed or not possible: /
	    // - if dots possible and not allowed: /(?!\.)
	    // end is:
	    // - if last pattern, same as part-matching mode
	    // - else nothing
	    //
	    // Always put the (?:$|/) on negated tails, though, because that has to be
	    // there to bind the end of the negated pattern portion, and it's easier to
	    // just stick it in now rather than try to inject it later in the middle of
	    // the pattern.
	    //
	    // We can just always return the same end, and leave it up to the caller
	    // to know whether it's going to be used joined or in parts.
	    // And, if the start is adjusted slightly, can do the same there:
	    // - if not isStart: nothing
	    // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
	    // - if dots allowed or not possible: (?:/|^)
	    // - if dots possible and not allowed: (?:/|^)(?!\.)
	    //
	    // But it's better to have a simpler binding without a conditional, for
	    // performance, so probably better to return both start options.
	    //
	    // Then the caller just ignores the end if it's not the first pattern,
	    // and the start always gets applied.
	    //
	    // But that's always going to be $ if it's the ending pattern, or nothing,
	    // so the caller can just attach $ at the end of the pattern when building.
	    //
	    // So the todo is:
	    // - better detect what kind of start is needed
	    // - return both flavors of starting pattern
	    // - attach $ at the end of the pattern when creating the actual RegExp
	    //
	    // Ah, but wait, no, that all only applies to the root when the first pattern
	    // is not an extglob. If the first pattern IS an extglob, then we need all
	    // that dot prevention biz to live in the extglob portions, because eg
	    // +(*|.x*) can match .xy but not .yx.
	    //
	    // So, return the two flavors if it's #root and the first child is not an
	    // AST, otherwise leave it to the child AST to handle it, and there,
	    // use the (?:^|/) style of start binding.
	    //
	    // Even simplified further:
	    // - Since the start for a join is eg /(?!\.) and the start for a part
	    // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
	    // or start or whatever) and prepend ^ or / at the Regexp construction.
	    toRegExpSource(allowDot) {
	        const dot = allowDot ?? !!this.#options.dot;
	        if (this.#root === this)
	            this.#fillNegs();
	        if (!this.type) {
	            const noEmpty = this.isStart() && this.isEnd();
	            const src = this.#parts
	                .map(p => {
	                const [re, _, hasMagic, uflag] = typeof p === 'string'
	                    ? AST.#parseGlob(p, this.#hasMagic, noEmpty)
	                    : p.toRegExpSource(allowDot);
	                this.#hasMagic = this.#hasMagic || hasMagic;
	                this.#uflag = this.#uflag || uflag;
	                return re;
	            })
	                .join('');
	            let start = '';
	            if (this.isStart()) {
	                if (typeof this.#parts[0] === 'string') {
	                    // this is the string that will match the start of the pattern,
	                    // so we need to protect against dots and such.
	                    // '.' and '..' cannot match unless the pattern is that exactly,
	                    // even if it starts with . or dot:true is set.
	                    const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);
	                    if (!dotTravAllowed) {
	                        const aps = addPatternStart;
	                        // check if we have a possibility of matching . or ..,
	                        // and prevent that.
	                        const needNoTrav = 
	                        // dots are allowed, and the pattern starts with [ or .
	                        (dot && aps.has(src.charAt(0))) ||
	                            // the pattern starts with \., and then [ or .
	                            (src.startsWith('\\.') && aps.has(src.charAt(2))) ||
	                            // the pattern starts with \.\., and then [ or .
	                            (src.startsWith('\\.\\.') && aps.has(src.charAt(4)));
	                        // no need to prevent dots if it can't match a dot, or if a
	                        // sub-pattern will be preventing it anyway.
	                        const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
	                        start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : '';
	                    }
	                }
	            }
	            // append the "end of path portion" pattern to negation tails
	            let end = '';
	            if (this.isEnd() &&
	                this.#root.#filledNegs &&
	                this.#parent?.type === '!') {
	                end = '(?:$|\\/)';
	            }
	            const final = start + src + end;
	            return [
	                final,
	                (0, unescape_js_1.unescape)(src),
	                (this.#hasMagic = !!this.#hasMagic),
	                this.#uflag,
	            ];
	        }
	        // We need to calculate the body *twice* if it's a repeat pattern
	        // at the start, once in nodot mode, then again in dot mode, so a
	        // pattern like *(?) can match 'x.y'
	        const repeated = this.type === '*' || this.type === '+';
	        // some kind of extglob
	        const start = this.type === '!' ? '(?:(?!(?:' : '(?:';
	        let body = this.#partsToRegExp(dot);
	        if (this.isStart() && this.isEnd() && !body && this.type !== '!') {
	            // invalid extglob, has to at least be *something* present, if it's
	            // the entire path portion.
	            const s = this.toString();
	            this.#parts = [s];
	            this.type = null;
	            this.#hasMagic = undefined;
	            return [s, (0, unescape_js_1.unescape)(this.toString()), false, false];
	        }
	        // XXX abstract out this map method
	        let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot
	            ? ''
	            : this.#partsToRegExp(true);
	        if (bodyDotAllowed === body) {
	            bodyDotAllowed = '';
	        }
	        if (bodyDotAllowed) {
	            body = `(?:${body})(?:${bodyDotAllowed})*?`;
	        }
	        // an empty !() is exactly equivalent to a starNoEmpty
	        let final = '';
	        if (this.type === '!' && this.#emptyExt) {
	            final = (this.isStart() && !dot ? startNoDot : '') + starNoEmpty;
	        }
	        else {
	            const close = this.type === '!'
	                ? // !() must match something,but !(x) can match ''
	                    '))' +
	                        (this.isStart() && !dot && !allowDot ? startNoDot : '') +
	                        star +
	                        ')'
	                : this.type === '@'
	                    ? ')'
	                    : this.type === '?'
	                        ? ')?'
	                        : this.type === '+' && bodyDotAllowed
	                            ? ')'
	                            : this.type === '*' && bodyDotAllowed
	                                ? `)?`
	                                : `)${this.type}`;
	            final = start + body + close;
	        }
	        return [
	            final,
	            (0, unescape_js_1.unescape)(body),
	            (this.#hasMagic = !!this.#hasMagic),
	            this.#uflag,
	        ];
	    }
	    #partsToRegExp(dot) {
	        return this.#parts
	            .map(p => {
	            // extglob ASTs should only contain parent ASTs
	            /* c8 ignore start */
	            if (typeof p === 'string') {
	                throw new Error('string type in extglob ast??');
	            }
	            /* c8 ignore stop */
	            // can ignore hasMagic, because extglobs are already always magic
	            const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);
	            this.#uflag = this.#uflag || uflag;
	            return re;
	        })
	            .filter(p => !(this.isStart() && this.isEnd()) || !!p)
	            .join('|');
	    }
	    static #parseGlob(glob, hasMagic, noEmpty = false) {
	        let escaping = false;
	        let re = '';
	        let uflag = false;
	        for (let i = 0; i < glob.length; i++) {
	            const c = glob.charAt(i);
	            if (escaping) {
	                escaping = false;
	                re += (reSpecials.has(c) ? '\\' : '') + c;
	                continue;
	            }
	            if (c === '\\') {
	                if (i === glob.length - 1) {
	                    re += '\\\\';
	                }
	                else {
	                    escaping = true;
	                }
	                continue;
	            }
	            if (c === '[') {
	                const [src, needUflag, consumed, magic] = (0, brace_expressions_js_1.parseClass)(glob, i);
	                if (consumed) {
	                    re += src;
	                    uflag = uflag || needUflag;
	                    i += consumed - 1;
	                    hasMagic = hasMagic || magic;
	                    continue;
	                }
	            }
	            if (c === '*') {
	                if (noEmpty && glob === '*')
	                    re += starNoEmpty;
	                else
	                    re += star;
	                hasMagic = true;
	                continue;
	            }
	            if (c === '?') {
	                re += qmark;
	                hasMagic = true;
	                continue;
	            }
	            re += regExpEscape(c);
	        }
	        return [re, (0, unescape_js_1.unescape)(glob), !!hasMagic, uflag];
	    }
	}
	ast.AST = AST;
	
	return ast;
}

var _escape = {};

var hasRequired_escape;

function require_escape () {
	if (hasRequired_escape) return _escape;
	hasRequired_escape = 1;
	Object.defineProperty(_escape, "__esModule", { value: true });
	_escape.escape = void 0;
	/**
	 * Escape all magic characters in a glob pattern.
	 *
	 * If the {@link windowsPathsNoEscape | GlobOptions.windowsPathsNoEscape}
	 * option is used, then characters are escaped by wrapping in `[]`, because
	 * a magic character wrapped in a character class can only be satisfied by
	 * that exact character.  In this mode, `\` is _not_ escaped, because it is
	 * not interpreted as a magic character, but instead as a path separator.
	 */
	const escape = (s, { windowsPathsNoEscape = false, } = {}) => {
	    // don't need to escape +@! because we escape the parens
	    // that make those magic, and escaping ! as [!] isn't valid,
	    // because [!]] is a valid glob class meaning not ']'.
	    return windowsPathsNoEscape
	        ? s.replace(/[?*()[\]]/g, '[$&]')
	        : s.replace(/[?*()[\]\\]/g, '\\$&');
	};
	_escape.escape = escape;
	
	return _escape;
}

var hasRequiredCommonjs$4;

function requireCommonjs$4 () {
	if (hasRequiredCommonjs$4) return commonjs$5;
	hasRequiredCommonjs$4 = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.unescape = exports.escape = exports.AST = exports.Minimatch = exports.match = exports.makeRe = exports.braceExpand = exports.defaults = exports.filter = exports.GLOBSTAR = exports.sep = exports.minimatch = void 0;
		const brace_expansion_1 = requireCommonjs$5();
		const assert_valid_pattern_js_1 = requireAssertValidPattern();
		const ast_js_1 = requireAst();
		const escape_js_1 = require_escape();
		const unescape_js_1 = require_unescape();
		const minimatch = (p, pattern, options = {}) => {
		    (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
		    // shortcut: comments match nothing.
		    if (!options.nocomment && pattern.charAt(0) === '#') {
		        return false;
		    }
		    return new Minimatch(pattern, options).match(p);
		};
		exports.minimatch = minimatch;
		// Optimized checking for the most common glob patterns.
		const starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
		const starDotExtTest = (ext) => (f) => !f.startsWith('.') && f.endsWith(ext);
		const starDotExtTestDot = (ext) => (f) => f.endsWith(ext);
		const starDotExtTestNocase = (ext) => {
		    ext = ext.toLowerCase();
		    return (f) => !f.startsWith('.') && f.toLowerCase().endsWith(ext);
		};
		const starDotExtTestNocaseDot = (ext) => {
		    ext = ext.toLowerCase();
		    return (f) => f.toLowerCase().endsWith(ext);
		};
		const starDotStarRE = /^\*+\.\*+$/;
		const starDotStarTest = (f) => !f.startsWith('.') && f.includes('.');
		const starDotStarTestDot = (f) => f !== '.' && f !== '..' && f.includes('.');
		const dotStarRE = /^\.\*+$/;
		const dotStarTest = (f) => f !== '.' && f !== '..' && f.startsWith('.');
		const starRE = /^\*+$/;
		const starTest = (f) => f.length !== 0 && !f.startsWith('.');
		const starTestDot = (f) => f.length !== 0 && f !== '.' && f !== '..';
		const qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
		const qmarksTestNocase = ([$0, ext = '']) => {
		    const noext = qmarksTestNoExt([$0]);
		    if (!ext)
		        return noext;
		    ext = ext.toLowerCase();
		    return (f) => noext(f) && f.toLowerCase().endsWith(ext);
		};
		const qmarksTestNocaseDot = ([$0, ext = '']) => {
		    const noext = qmarksTestNoExtDot([$0]);
		    if (!ext)
		        return noext;
		    ext = ext.toLowerCase();
		    return (f) => noext(f) && f.toLowerCase().endsWith(ext);
		};
		const qmarksTestDot = ([$0, ext = '']) => {
		    const noext = qmarksTestNoExtDot([$0]);
		    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);
		};
		const qmarksTest = ([$0, ext = '']) => {
		    const noext = qmarksTestNoExt([$0]);
		    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);
		};
		const qmarksTestNoExt = ([$0]) => {
		    const len = $0.length;
		    return (f) => f.length === len && !f.startsWith('.');
		};
		const qmarksTestNoExtDot = ([$0]) => {
		    const len = $0.length;
		    return (f) => f.length === len && f !== '.' && f !== '..';
		};
		/* c8 ignore start */
		const defaultPlatform = (typeof process === 'object' && process
		    ? (typeof process.env === 'object' &&
		        process.env &&
		        process.env.__MINIMATCH_TESTING_PLATFORM__) ||
		        process.platform
		    : 'posix');
		const path = {
		    win32: { sep: '\\' },
		    posix: { sep: '/' },
		};
		/* c8 ignore stop */
		exports.sep = defaultPlatform === 'win32' ? path.win32.sep : path.posix.sep;
		exports.minimatch.sep = exports.sep;
		exports.GLOBSTAR = Symbol('globstar **');
		exports.minimatch.GLOBSTAR = exports.GLOBSTAR;
		// any single thing other than /
		// don't need to escape / when using new RegExp()
		const qmark = '[^/]';
		// * => any number of characters
		const star = qmark + '*?';
		// ** when dots are allowed.  Anything goes, except .. and .
		// not (^ or / followed by one or two dots followed by $ or /),
		// followed by anything, any number of times.
		const twoStarDot = '(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?';
		// not a ^ or / followed by a dot,
		// followed by anything, any number of times.
		const twoStarNoDot = '(?:(?!(?:\\/|^)\\.).)*?';
		const filter = (pattern, options = {}) => (p) => (0, exports.minimatch)(p, pattern, options);
		exports.filter = filter;
		exports.minimatch.filter = exports.filter;
		const ext = (a, b = {}) => Object.assign({}, a, b);
		const defaults = (def) => {
		    if (!def || typeof def !== 'object' || !Object.keys(def).length) {
		        return exports.minimatch;
		    }
		    const orig = exports.minimatch;
		    const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));
		    return Object.assign(m, {
		        Minimatch: class Minimatch extends orig.Minimatch {
		            constructor(pattern, options = {}) {
		                super(pattern, ext(def, options));
		            }
		            static defaults(options) {
		                return orig.defaults(ext(def, options)).Minimatch;
		            }
		        },
		        AST: class AST extends orig.AST {
		            /* c8 ignore start */
		            constructor(type, parent, options = {}) {
		                super(type, parent, ext(def, options));
		            }
		            /* c8 ignore stop */
		            static fromGlob(pattern, options = {}) {
		                return orig.AST.fromGlob(pattern, ext(def, options));
		            }
		        },
		        unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),
		        escape: (s, options = {}) => orig.escape(s, ext(def, options)),
		        filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),
		        defaults: (options) => orig.defaults(ext(def, options)),
		        makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),
		        braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),
		        match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),
		        sep: orig.sep,
		        GLOBSTAR: exports.GLOBSTAR,
		    });
		};
		exports.defaults = defaults;
		exports.minimatch.defaults = exports.defaults;
		// Brace expansion:
		// a{b,c}d -> abd acd
		// a{b,}c -> abc ac
		// a{0..3}d -> a0d a1d a2d a3d
		// a{b,c{d,e}f}g -> abg acdfg acefg
		// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
		//
		// Invalid sets are not expanded.
		// a{2..}b -> a{2..}b
		// a{b}c -> a{b}c
		const braceExpand = (pattern, options = {}) => {
		    (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
		    // Thanks to Yeting Li <https://github.com/yetingli> for
		    // improving this regexp to avoid a ReDOS vulnerability.
		    if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
		        // shortcut. no need to expand.
		        return [pattern];
		    }
		    return (0, brace_expansion_1.expand)(pattern);
		};
		exports.braceExpand = braceExpand;
		exports.minimatch.braceExpand = exports.braceExpand;
		// parse a component of the expanded set.
		// At this point, no pattern may contain "/" in it
		// so we're going to return a 2d array, where each entry is the full
		// pattern, split on '/', and then turned into a regular expression.
		// A regexp is made at the end which joins each array with an
		// escaped /, and another full one which joins each regexp with |.
		//
		// Following the lead of Bash 4.1, note that "**" only has special meaning
		// when it is the *only* thing in a path portion.  Otherwise, any series
		// of * is equivalent to a single *.  Globstar behavior is enabled by
		// default, and can be disabled by setting options.noglobstar.
		const makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();
		exports.makeRe = makeRe;
		exports.minimatch.makeRe = exports.makeRe;
		const match = (list, pattern, options = {}) => {
		    const mm = new Minimatch(pattern, options);
		    list = list.filter(f => mm.match(f));
		    if (mm.options.nonull && !list.length) {
		        list.push(pattern);
		    }
		    return list;
		};
		exports.match = match;
		exports.minimatch.match = exports.match;
		// replace stuff like \* with *
		const globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
		const regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
		class Minimatch {
		    options;
		    set;
		    pattern;
		    windowsPathsNoEscape;
		    nonegate;
		    negate;
		    comment;
		    empty;
		    preserveMultipleSlashes;
		    partial;
		    globSet;
		    globParts;
		    nocase;
		    isWindows;
		    platform;
		    windowsNoMagicRoot;
		    regexp;
		    constructor(pattern, options = {}) {
		        (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
		        options = options || {};
		        this.options = options;
		        this.pattern = pattern;
		        this.platform = options.platform || defaultPlatform;
		        this.isWindows = this.platform === 'win32';
		        this.windowsPathsNoEscape =
		            !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
		        if (this.windowsPathsNoEscape) {
		            this.pattern = this.pattern.replace(/\\/g, '/');
		        }
		        this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
		        this.regexp = null;
		        this.negate = false;
		        this.nonegate = !!options.nonegate;
		        this.comment = false;
		        this.empty = false;
		        this.partial = !!options.partial;
		        this.nocase = !!this.options.nocase;
		        this.windowsNoMagicRoot =
		            options.windowsNoMagicRoot !== undefined
		                ? options.windowsNoMagicRoot
		                : !!(this.isWindows && this.nocase);
		        this.globSet = [];
		        this.globParts = [];
		        this.set = [];
		        // make the set of regexps etc.
		        this.make();
		    }
		    hasMagic() {
		        if (this.options.magicalBraces && this.set.length > 1) {
		            return true;
		        }
		        for (const pattern of this.set) {
		            for (const part of pattern) {
		                if (typeof part !== 'string')
		                    return true;
		            }
		        }
		        return false;
		    }
		    debug(..._) { }
		    make() {
		        const pattern = this.pattern;
		        const options = this.options;
		        // empty patterns and comments match nothing.
		        if (!options.nocomment && pattern.charAt(0) === '#') {
		            this.comment = true;
		            return;
		        }
		        if (!pattern) {
		            this.empty = true;
		            return;
		        }
		        // step 1: figure out negation, etc.
		        this.parseNegate();
		        // step 2: expand braces
		        this.globSet = [...new Set(this.braceExpand())];
		        if (options.debug) {
		            this.debug = (...args) => console.error(...args);
		        }
		        this.debug(this.pattern, this.globSet);
		        // step 3: now we have a set, so turn each one into a series of
		        // path-portion matching patterns.
		        // These will be regexps, except in the case of "**", which is
		        // set to the GLOBSTAR object for globstar behavior,
		        // and will not contain any / characters
		        //
		        // First, we preprocess to make the glob pattern sets a bit simpler
		        // and deduped.  There are some perf-killing patterns that can cause
		        // problems with a glob walk, but we can simplify them down a bit.
		        const rawGlobParts = this.globSet.map(s => this.slashSplit(s));
		        this.globParts = this.preprocess(rawGlobParts);
		        this.debug(this.pattern, this.globParts);
		        // glob --> regexps
		        let set = this.globParts.map((s, _, __) => {
		            if (this.isWindows && this.windowsNoMagicRoot) {
		                // check if it's a drive or unc path.
		                const isUNC = s[0] === '' &&
		                    s[1] === '' &&
		                    (s[2] === '?' || !globMagic.test(s[2])) &&
		                    !globMagic.test(s[3]);
		                const isDrive = /^[a-z]:/i.test(s[0]);
		                if (isUNC) {
		                    return [...s.slice(0, 4), ...s.slice(4).map(ss => this.parse(ss))];
		                }
		                else if (isDrive) {
		                    return [s[0], ...s.slice(1).map(ss => this.parse(ss))];
		                }
		            }
		            return s.map(ss => this.parse(ss));
		        });
		        this.debug(this.pattern, set);
		        // filter out everything that didn't compile properly.
		        this.set = set.filter(s => s.indexOf(false) === -1);
		        // do not treat the ? in UNC paths as magic
		        if (this.isWindows) {
		            for (let i = 0; i < this.set.length; i++) {
		                const p = this.set[i];
		                if (p[0] === '' &&
		                    p[1] === '' &&
		                    this.globParts[i][2] === '?' &&
		                    typeof p[3] === 'string' &&
		                    /^[a-z]:$/i.test(p[3])) {
		                    p[2] = '?';
		                }
		            }
		        }
		        this.debug(this.pattern, this.set);
		    }
		    // various transforms to equivalent pattern sets that are
		    // faster to process in a filesystem walk.  The goal is to
		    // eliminate what we can, and push all ** patterns as far
		    // to the right as possible, even if it increases the number
		    // of patterns that we have to process.
		    preprocess(globParts) {
		        // if we're not in globstar mode, then turn all ** into *
		        if (this.options.noglobstar) {
		            for (let i = 0; i < globParts.length; i++) {
		                for (let j = 0; j < globParts[i].length; j++) {
		                    if (globParts[i][j] === '**') {
		                        globParts[i][j] = '*';
		                    }
		                }
		            }
		        }
		        const { optimizationLevel = 1 } = this.options;
		        if (optimizationLevel >= 2) {
		            // aggressive optimization for the purpose of fs walking
		            globParts = this.firstPhasePreProcess(globParts);
		            globParts = this.secondPhasePreProcess(globParts);
		        }
		        else if (optimizationLevel >= 1) {
		            // just basic optimizations to remove some .. parts
		            globParts = this.levelOneOptimize(globParts);
		        }
		        else {
		            // just collapse multiple ** portions into one
		            globParts = this.adjascentGlobstarOptimize(globParts);
		        }
		        return globParts;
		    }
		    // just get rid of adjascent ** portions
		    adjascentGlobstarOptimize(globParts) {
		        return globParts.map(parts => {
		            let gs = -1;
		            while (-1 !== (gs = parts.indexOf('**', gs + 1))) {
		                let i = gs;
		                while (parts[i + 1] === '**') {
		                    i++;
		                }
		                if (i !== gs) {
		                    parts.splice(gs, i - gs);
		                }
		            }
		            return parts;
		        });
		    }
		    // get rid of adjascent ** and resolve .. portions
		    levelOneOptimize(globParts) {
		        return globParts.map(parts => {
		            parts = parts.reduce((set, part) => {
		                const prev = set[set.length - 1];
		                if (part === '**' && prev === '**') {
		                    return set;
		                }
		                if (part === '..') {
		                    if (prev && prev !== '..' && prev !== '.' && prev !== '**') {
		                        set.pop();
		                        return set;
		                    }
		                }
		                set.push(part);
		                return set;
		            }, []);
		            return parts.length === 0 ? [''] : parts;
		        });
		    }
		    levelTwoFileOptimize(parts) {
		        if (!Array.isArray(parts)) {
		            parts = this.slashSplit(parts);
		        }
		        let didSomething = false;
		        do {
		            didSomething = false;
		            // <pre>/<e>/<rest> -> <pre>/<rest>
		            if (!this.preserveMultipleSlashes) {
		                for (let i = 1; i < parts.length - 1; i++) {
		                    const p = parts[i];
		                    // don't squeeze out UNC patterns
		                    if (i === 1 && p === '' && parts[0] === '')
		                        continue;
		                    if (p === '.' || p === '') {
		                        didSomething = true;
		                        parts.splice(i, 1);
		                        i--;
		                    }
		                }
		                if (parts[0] === '.' &&
		                    parts.length === 2 &&
		                    (parts[1] === '.' || parts[1] === '')) {
		                    didSomething = true;
		                    parts.pop();
		                }
		            }
		            // <pre>/<p>/../<rest> -> <pre>/<rest>
		            let dd = 0;
		            while (-1 !== (dd = parts.indexOf('..', dd + 1))) {
		                const p = parts[dd - 1];
		                if (p && p !== '.' && p !== '..' && p !== '**') {
		                    didSomething = true;
		                    parts.splice(dd - 1, 2);
		                    dd -= 2;
		                }
		            }
		        } while (didSomething);
		        return parts.length === 0 ? [''] : parts;
		    }
		    // First phase: single-pattern processing
		    // <pre> is 1 or more portions
		    // <rest> is 1 or more portions
		    // <p> is any portion other than ., .., '', or **
		    // <e> is . or ''
		    //
		    // **/.. is *brutal* for filesystem walking performance, because
		    // it effectively resets the recursive walk each time it occurs,
		    // and ** cannot be reduced out by a .. pattern part like a regexp
		    // or most strings (other than .., ., and '') can be.
		    //
		    // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
		    // <pre>/<e>/<rest> -> <pre>/<rest>
		    // <pre>/<p>/../<rest> -> <pre>/<rest>
		    // **/**/<rest> -> **/<rest>
		    //
		    // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
		    // this WOULD be allowed if ** did follow symlinks, or * didn't
		    firstPhasePreProcess(globParts) {
		        let didSomething = false;
		        do {
		            didSomething = false;
		            // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
		            for (let parts of globParts) {
		                let gs = -1;
		                while (-1 !== (gs = parts.indexOf('**', gs + 1))) {
		                    let gss = gs;
		                    while (parts[gss + 1] === '**') {
		                        // <pre>/**/**/<rest> -> <pre>/**/<rest>
		                        gss++;
		                    }
		                    // eg, if gs is 2 and gss is 4, that means we have 3 **
		                    // parts, and can remove 2 of them.
		                    if (gss > gs) {
		                        parts.splice(gs + 1, gss - gs);
		                    }
		                    let next = parts[gs + 1];
		                    const p = parts[gs + 2];
		                    const p2 = parts[gs + 3];
		                    if (next !== '..')
		                        continue;
		                    if (!p ||
		                        p === '.' ||
		                        p === '..' ||
		                        !p2 ||
		                        p2 === '.' ||
		                        p2 === '..') {
		                        continue;
		                    }
		                    didSomething = true;
		                    // edit parts in place, and push the new one
		                    parts.splice(gs, 1);
		                    const other = parts.slice(0);
		                    other[gs] = '**';
		                    globParts.push(other);
		                    gs--;
		                }
		                // <pre>/<e>/<rest> -> <pre>/<rest>
		                if (!this.preserveMultipleSlashes) {
		                    for (let i = 1; i < parts.length - 1; i++) {
		                        const p = parts[i];
		                        // don't squeeze out UNC patterns
		                        if (i === 1 && p === '' && parts[0] === '')
		                            continue;
		                        if (p === '.' || p === '') {
		                            didSomething = true;
		                            parts.splice(i, 1);
		                            i--;
		                        }
		                    }
		                    if (parts[0] === '.' &&
		                        parts.length === 2 &&
		                        (parts[1] === '.' || parts[1] === '')) {
		                        didSomething = true;
		                        parts.pop();
		                    }
		                }
		                // <pre>/<p>/../<rest> -> <pre>/<rest>
		                let dd = 0;
		                while (-1 !== (dd = parts.indexOf('..', dd + 1))) {
		                    const p = parts[dd - 1];
		                    if (p && p !== '.' && p !== '..' && p !== '**') {
		                        didSomething = true;
		                        const needDot = dd === 1 && parts[dd + 1] === '**';
		                        const splin = needDot ? ['.'] : [];
		                        parts.splice(dd - 1, 2, ...splin);
		                        if (parts.length === 0)
		                            parts.push('');
		                        dd -= 2;
		                    }
		                }
		            }
		        } while (didSomething);
		        return globParts;
		    }
		    // second phase: multi-pattern dedupes
		    // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
		    // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
		    // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
		    //
		    // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
		    // ^-- not valid because ** doens't follow symlinks
		    secondPhasePreProcess(globParts) {
		        for (let i = 0; i < globParts.length - 1; i++) {
		            for (let j = i + 1; j < globParts.length; j++) {
		                const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);
		                if (matched) {
		                    globParts[i] = [];
		                    globParts[j] = matched;
		                    break;
		                }
		            }
		        }
		        return globParts.filter(gs => gs.length);
		    }
		    partsMatch(a, b, emptyGSMatch = false) {
		        let ai = 0;
		        let bi = 0;
		        let result = [];
		        let which = '';
		        while (ai < a.length && bi < b.length) {
		            if (a[ai] === b[bi]) {
		                result.push(which === 'b' ? b[bi] : a[ai]);
		                ai++;
		                bi++;
		            }
		            else if (emptyGSMatch && a[ai] === '**' && b[bi] === a[ai + 1]) {
		                result.push(a[ai]);
		                ai++;
		            }
		            else if (emptyGSMatch && b[bi] === '**' && a[ai] === b[bi + 1]) {
		                result.push(b[bi]);
		                bi++;
		            }
		            else if (a[ai] === '*' &&
		                b[bi] &&
		                (this.options.dot || !b[bi].startsWith('.')) &&
		                b[bi] !== '**') {
		                if (which === 'b')
		                    return false;
		                which = 'a';
		                result.push(a[ai]);
		                ai++;
		                bi++;
		            }
		            else if (b[bi] === '*' &&
		                a[ai] &&
		                (this.options.dot || !a[ai].startsWith('.')) &&
		                a[ai] !== '**') {
		                if (which === 'a')
		                    return false;
		                which = 'b';
		                result.push(b[bi]);
		                ai++;
		                bi++;
		            }
		            else {
		                return false;
		            }
		        }
		        // if we fall out of the loop, it means they two are identical
		        // as long as their lengths match
		        return a.length === b.length && result;
		    }
		    parseNegate() {
		        if (this.nonegate)
		            return;
		        const pattern = this.pattern;
		        let negate = false;
		        let negateOffset = 0;
		        for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {
		            negate = !negate;
		            negateOffset++;
		        }
		        if (negateOffset)
		            this.pattern = pattern.slice(negateOffset);
		        this.negate = negate;
		    }
		    // set partial to true to test if, for example,
		    // "/a/b" matches the start of "/*/b/*/d"
		    // Partial means, if you run out of file before you run
		    // out of pattern, then that's fine, as long as all
		    // the parts match.
		    matchOne(file, pattern, partial = false) {
		        const options = this.options;
		        // UNC paths like //?/X:/... can match X:/... and vice versa
		        // Drive letters in absolute drive or unc paths are always compared
		        // case-insensitively.
		        if (this.isWindows) {
		            const fileDrive = typeof file[0] === 'string' && /^[a-z]:$/i.test(file[0]);
		            const fileUNC = !fileDrive &&
		                file[0] === '' &&
		                file[1] === '' &&
		                file[2] === '?' &&
		                /^[a-z]:$/i.test(file[3]);
		            const patternDrive = typeof pattern[0] === 'string' && /^[a-z]:$/i.test(pattern[0]);
		            const patternUNC = !patternDrive &&
		                pattern[0] === '' &&
		                pattern[1] === '' &&
		                pattern[2] === '?' &&
		                typeof pattern[3] === 'string' &&
		                /^[a-z]:$/i.test(pattern[3]);
		            const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined;
		            const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined;
		            if (typeof fdi === 'number' && typeof pdi === 'number') {
		                const [fd, pd] = [file[fdi], pattern[pdi]];
		                if (fd.toLowerCase() === pd.toLowerCase()) {
		                    pattern[pdi] = fd;
		                    if (pdi > fdi) {
		                        pattern = pattern.slice(pdi);
		                    }
		                    else if (fdi > pdi) {
		                        file = file.slice(fdi);
		                    }
		                }
		            }
		        }
		        // resolve and reduce . and .. portions in the file as well.
		        // dont' need to do the second phase, because it's only one string[]
		        const { optimizationLevel = 1 } = this.options;
		        if (optimizationLevel >= 2) {
		            file = this.levelTwoFileOptimize(file);
		        }
		        this.debug('matchOne', this, { file, pattern });
		        this.debug('matchOne', file.length, pattern.length);
		        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
		            this.debug('matchOne loop');
		            var p = pattern[pi];
		            var f = file[fi];
		            this.debug(pattern, p, f);
		            // should be impossible.
		            // some invalid regexp stuff in the set.
		            /* c8 ignore start */
		            if (p === false) {
		                return false;
		            }
		            /* c8 ignore stop */
		            if (p === exports.GLOBSTAR) {
		                this.debug('GLOBSTAR', [pattern, p, f]);
		                // "**"
		                // a/**/b/**/c would match the following:
		                // a/b/x/y/z/c
		                // a/x/y/z/b/c
		                // a/b/x/b/x/c
		                // a/b/c
		                // To do this, take the rest of the pattern after
		                // the **, and see if it would match the file remainder.
		                // If so, return success.
		                // If not, the ** "swallows" a segment, and try again.
		                // This is recursively awful.
		                //
		                // a/**/b/**/c matching a/b/x/y/z/c
		                // - a matches a
		                // - doublestar
		                //   - matchOne(b/x/y/z/c, b/**/c)
		                //     - b matches b
		                //     - doublestar
		                //       - matchOne(x/y/z/c, c) -> no
		                //       - matchOne(y/z/c, c) -> no
		                //       - matchOne(z/c, c) -> no
		                //       - matchOne(c, c) yes, hit
		                var fr = fi;
		                var pr = pi + 1;
		                if (pr === pl) {
		                    this.debug('** at the end');
		                    // a ** at the end will just swallow the rest.
		                    // We have found a match.
		                    // however, it will not swallow /.x, unless
		                    // options.dot is set.
		                    // . and .. are *never* matched by **, for explosively
		                    // exponential reasons.
		                    for (; fi < fl; fi++) {
		                        if (file[fi] === '.' ||
		                            file[fi] === '..' ||
		                            (!options.dot && file[fi].charAt(0) === '.'))
		                            return false;
		                    }
		                    return true;
		                }
		                // ok, let's see if we can swallow whatever we can.
		                while (fr < fl) {
		                    var swallowee = file[fr];
		                    this.debug('\nglobstar while', file, fr, pattern, pr, swallowee);
		                    // XXX remove this slice.  Just pass the start index.
		                    if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
		                        this.debug('globstar found match!', fr, fl, swallowee);
		                        // found a match.
		                        return true;
		                    }
		                    else {
		                        // can't swallow "." or ".." ever.
		                        // can only swallow ".foo" when explicitly asked.
		                        if (swallowee === '.' ||
		                            swallowee === '..' ||
		                            (!options.dot && swallowee.charAt(0) === '.')) {
		                            this.debug('dot detected!', file, fr, pattern, pr);
		                            break;
		                        }
		                        // ** swallows a segment, and continue.
		                        this.debug('globstar swallow a segment, and continue');
		                        fr++;
		                    }
		                }
		                // no match was found.
		                // However, in partial mode, we can't say this is necessarily over.
		                /* c8 ignore start */
		                if (partial) {
		                    // ran out of file
		                    this.debug('\n>>> no match, partial?', file, fr, pattern, pr);
		                    if (fr === fl) {
		                        return true;
		                    }
		                }
		                /* c8 ignore stop */
		                return false;
		            }
		            // something other than **
		            // non-magic patterns just have to match exactly
		            // patterns with magic have been turned into regexps.
		            let hit;
		            if (typeof p === 'string') {
		                hit = f === p;
		                this.debug('string match', p, f, hit);
		            }
		            else {
		                hit = p.test(f);
		                this.debug('pattern match', p, f, hit);
		            }
		            if (!hit)
		                return false;
		        }
		        // Note: ending in / means that we'll get a final ""
		        // at the end of the pattern.  This can only match a
		        // corresponding "" at the end of the file.
		        // If the file ends in /, then it can only match a
		        // a pattern that ends in /, unless the pattern just
		        // doesn't have any more for it. But, a/b/ should *not*
		        // match "a/b/*", even though "" matches against the
		        // [^/]*? pattern, except in partial mode, where it might
		        // simply not be reached yet.
		        // However, a/b/ should still satisfy a/*
		        // now either we fell off the end of the pattern, or we're done.
		        if (fi === fl && pi === pl) {
		            // ran out of pattern and filename at the same time.
		            // an exact hit!
		            return true;
		        }
		        else if (fi === fl) {
		            // ran out of file, but still had pattern left.
		            // this is ok if we're doing the match as part of
		            // a glob fs traversal.
		            return partial;
		        }
		        else if (pi === pl) {
		            // ran out of pattern, still have file left.
		            // this is only acceptable if we're on the very last
		            // empty segment of a file with a trailing slash.
		            // a/* should match a/b/
		            return fi === fl - 1 && file[fi] === '';
		            /* c8 ignore start */
		        }
		        else {
		            // should be unreachable.
		            throw new Error('wtf?');
		        }
		        /* c8 ignore stop */
		    }
		    braceExpand() {
		        return (0, exports.braceExpand)(this.pattern, this.options);
		    }
		    parse(pattern) {
		        (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
		        const options = this.options;
		        // shortcuts
		        if (pattern === '**')
		            return exports.GLOBSTAR;
		        if (pattern === '')
		            return '';
		        // far and away, the most common glob pattern parts are
		        // *, *.*, and *.<ext>  Add a fast check method for those.
		        let m;
		        let fastTest = null;
		        if ((m = pattern.match(starRE))) {
		            fastTest = options.dot ? starTestDot : starTest;
		        }
		        else if ((m = pattern.match(starDotExtRE))) {
		            fastTest = (options.nocase
		                ? options.dot
		                    ? starDotExtTestNocaseDot
		                    : starDotExtTestNocase
		                : options.dot
		                    ? starDotExtTestDot
		                    : starDotExtTest)(m[1]);
		        }
		        else if ((m = pattern.match(qmarksRE))) {
		            fastTest = (options.nocase
		                ? options.dot
		                    ? qmarksTestNocaseDot
		                    : qmarksTestNocase
		                : options.dot
		                    ? qmarksTestDot
		                    : qmarksTest)(m);
		        }
		        else if ((m = pattern.match(starDotStarRE))) {
		            fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
		        }
		        else if ((m = pattern.match(dotStarRE))) {
		            fastTest = dotStarTest;
		        }
		        const re = ast_js_1.AST.fromGlob(pattern, this.options).toMMPattern();
		        if (fastTest && typeof re === 'object') {
		            // Avoids overriding in frozen environments
		            Reflect.defineProperty(re, 'test', { value: fastTest });
		        }
		        return re;
		    }
		    makeRe() {
		        if (this.regexp || this.regexp === false)
		            return this.regexp;
		        // at this point, this.set is a 2d array of partial
		        // pattern strings, or "**".
		        //
		        // It's better to use .match().  This function shouldn't
		        // be used, really, but it's pretty convenient sometimes,
		        // when you just want to work with a regex.
		        const set = this.set;
		        if (!set.length) {
		            this.regexp = false;
		            return this.regexp;
		        }
		        const options = this.options;
		        const twoStar = options.noglobstar
		            ? star
		            : options.dot
		                ? twoStarDot
		                : twoStarNoDot;
		        const flags = new Set(options.nocase ? ['i'] : []);
		        // regexpify non-globstar patterns
		        // if ** is only item, then we just do one twoStar
		        // if ** is first, and there are more, prepend (\/|twoStar\/)? to next
		        // if ** is last, append (\/twoStar|) to previous
		        // if ** is in the middle, append (\/|\/twoStar\/) to previous
		        // then filter out GLOBSTAR symbols
		        let re = set
		            .map(pattern => {
		            const pp = pattern.map(p => {
		                if (p instanceof RegExp) {
		                    for (const f of p.flags.split(''))
		                        flags.add(f);
		                }
		                return typeof p === 'string'
		                    ? regExpEscape(p)
		                    : p === exports.GLOBSTAR
		                        ? exports.GLOBSTAR
		                        : p._src;
		            });
		            pp.forEach((p, i) => {
		                const next = pp[i + 1];
		                const prev = pp[i - 1];
		                if (p !== exports.GLOBSTAR || prev === exports.GLOBSTAR) {
		                    return;
		                }
		                if (prev === undefined) {
		                    if (next !== undefined && next !== exports.GLOBSTAR) {
		                        pp[i + 1] = '(?:\\/|' + twoStar + '\\/)?' + next;
		                    }
		                    else {
		                        pp[i] = twoStar;
		                    }
		                }
		                else if (next === undefined) {
		                    pp[i - 1] = prev + '(?:\\/|' + twoStar + ')?';
		                }
		                else if (next !== exports.GLOBSTAR) {
		                    pp[i - 1] = prev + '(?:\\/|\\/' + twoStar + '\\/)' + next;
		                    pp[i + 1] = exports.GLOBSTAR;
		                }
		            });
		            return pp.filter(p => p !== exports.GLOBSTAR).join('/');
		        })
		            .join('|');
		        // need to wrap in parens if we had more than one thing with |,
		        // otherwise only the first will be anchored to ^ and the last to $
		        const [open, close] = set.length > 1 ? ['(?:', ')'] : ['', ''];
		        // must match entire pattern
		        // ending in a * or ** will make it less strict.
		        re = '^' + open + re + close + '$';
		        // can match anything, as long as it's not this.
		        if (this.negate)
		            re = '^(?!' + re + ').+$';
		        try {
		            this.regexp = new RegExp(re, [...flags].join(''));
		            /* c8 ignore start */
		        }
		        catch (ex) {
		            // should be impossible
		            this.regexp = false;
		        }
		        /* c8 ignore stop */
		        return this.regexp;
		    }
		    slashSplit(p) {
		        // if p starts with // on windows, we preserve that
		        // so that UNC paths aren't broken.  Otherwise, any number of
		        // / characters are coalesced into one, unless
		        // preserveMultipleSlashes is set to true.
		        if (this.preserveMultipleSlashes) {
		            return p.split('/');
		        }
		        else if (this.isWindows && /^\/\/[^\/]+/.test(p)) {
		            // add an extra '' for the one we lose
		            return ['', ...p.split(/\/+/)];
		        }
		        else {
		            return p.split(/\/+/);
		        }
		    }
		    match(f, partial = this.partial) {
		        this.debug('match', f, this.pattern);
		        // short-circuit in the case of busted things.
		        // comments, etc.
		        if (this.comment) {
		            return false;
		        }
		        if (this.empty) {
		            return f === '';
		        }
		        if (f === '/' && partial) {
		            return true;
		        }
		        const options = this.options;
		        // windows: need to use /, not \
		        if (this.isWindows) {
		            f = f.split('\\').join('/');
		        }
		        // treat the test path as a set of pathparts.
		        const ff = this.slashSplit(f);
		        this.debug(this.pattern, 'split', ff);
		        // just ONE of the pattern sets in this.set needs to match
		        // in order for it to be valid.  If negating, then just one
		        // match means that we have failed.
		        // Either way, return on the first hit.
		        const set = this.set;
		        this.debug(this.pattern, 'set', set);
		        // Find the basename of the path by looking for the last non-empty segment
		        let filename = ff[ff.length - 1];
		        if (!filename) {
		            for (let i = ff.length - 2; !filename && i >= 0; i--) {
		                filename = ff[i];
		            }
		        }
		        for (let i = 0; i < set.length; i++) {
		            const pattern = set[i];
		            let file = ff;
		            if (options.matchBase && pattern.length === 1) {
		                file = [filename];
		            }
		            const hit = this.matchOne(file, pattern, partial);
		            if (hit) {
		                if (options.flipNegate) {
		                    return true;
		                }
		                return !this.negate;
		            }
		        }
		        // didn't get any hits.  this is success if it's a negative
		        // pattern, failure otherwise.
		        if (options.flipNegate) {
		            return false;
		        }
		        return this.negate;
		    }
		    static defaults(def) {
		        return exports.minimatch.defaults(def).Minimatch;
		    }
		}
		exports.Minimatch = Minimatch;
		/* c8 ignore start */
		var ast_js_2 = requireAst();
		Object.defineProperty(exports, "AST", { enumerable: true, get: function () { return ast_js_2.AST; } });
		var escape_js_2 = require_escape();
		Object.defineProperty(exports, "escape", { enumerable: true, get: function () { return escape_js_2.escape; } });
		var unescape_js_2 = require_unescape();
		Object.defineProperty(exports, "unescape", { enumerable: true, get: function () { return unescape_js_2.unescape; } });
		/* c8 ignore stop */
		exports.minimatch.AST = ast_js_1.AST;
		exports.minimatch.Minimatch = Minimatch;
		exports.minimatch.escape = escape_js_1.escape;
		exports.minimatch.unescape = unescape_js_1.unescape;
		
	} (commonjs$5));
	return commonjs$5;
}

var glob = {};

var commonjs$2 = {};

var commonjs$1 = {};

var hasRequiredCommonjs$3;

function requireCommonjs$3 () {
	if (hasRequiredCommonjs$3) return commonjs$1;
	hasRequiredCommonjs$3 = 1;
	/**
	 * @module LRUCache
	 */
	Object.defineProperty(commonjs$1, "__esModule", { value: true });
	commonjs$1.LRUCache = void 0;
	const perf = typeof performance === 'object' &&
	    performance &&
	    typeof performance.now === 'function'
	    ? performance
	    : Date;
	const warned = new Set();
	/* c8 ignore start */
	const PROCESS = (typeof process === 'object' && !!process ? process : {});
	/* c8 ignore start */
	const emitWarning = (msg, type, code, fn) => {
	    typeof PROCESS.emitWarning === 'function'
	        ? PROCESS.emitWarning(msg, type, code, fn)
	        : console.error(`[${code}] ${type}: ${msg}`);
	};
	let AC = globalThis.AbortController;
	let AS = globalThis.AbortSignal;
	/* c8 ignore start */
	if (typeof AC === 'undefined') {
	    //@ts-ignore
	    AS = class AbortSignal {
	        onabort;
	        _onabort = [];
	        reason;
	        aborted = false;
	        addEventListener(_, fn) {
	            this._onabort.push(fn);
	        }
	    };
	    //@ts-ignore
	    AC = class AbortController {
	        constructor() {
	            warnACPolyfill();
	        }
	        signal = new AS();
	        abort(reason) {
	            if (this.signal.aborted)
	                return;
	            //@ts-ignore
	            this.signal.reason = reason;
	            //@ts-ignore
	            this.signal.aborted = true;
	            //@ts-ignore
	            for (const fn of this.signal._onabort) {
	                fn(reason);
	            }
	            this.signal.onabort?.(reason);
	        }
	    };
	    let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1';
	    const warnACPolyfill = () => {
	        if (!printACPolyfillWarning)
	            return;
	        printACPolyfillWarning = false;
	        emitWarning('AbortController is not defined. If using lru-cache in ' +
	            'node 14, load an AbortController polyfill from the ' +
	            '`node-abort-controller` package. A minimal polyfill is ' +
	            'provided for use by LRUCache.fetch(), but it should not be ' +
	            'relied upon in other contexts (eg, passing it to other APIs that ' +
	            'use AbortController/AbortSignal might have undesirable effects). ' +
	            'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.', 'NO_ABORT_CONTROLLER', 'ENOTSUP', warnACPolyfill);
	    };
	}
	/* c8 ignore stop */
	const shouldWarn = (code) => !warned.has(code);
	const isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
	/* c8 ignore start */
	// This is a little bit ridiculous, tbh.
	// The maximum array length is 2^32-1 or thereabouts on most JS impls.
	// And well before that point, you're caching the entire world, I mean,
	// that's ~32GB of just integers for the next/prev links, plus whatever
	// else to hold that many keys and values.  Just filling the memory with
	// zeroes at init time is brutal when you get that big.
	// But why not be complete?
	// Maybe in the future, these limits will have expanded.
	const getUintArray = (max) => !isPosInt(max)
	    ? null
	    : max <= Math.pow(2, 8)
	        ? Uint8Array
	        : max <= Math.pow(2, 16)
	            ? Uint16Array
	            : max <= Math.pow(2, 32)
	                ? Uint32Array
	                : max <= Number.MAX_SAFE_INTEGER
	                    ? ZeroArray
	                    : null;
	/* c8 ignore stop */
	class ZeroArray extends Array {
	    constructor(size) {
	        super(size);
	        this.fill(0);
	    }
	}
	class Stack {
	    heap;
	    length;
	    // private constructor
	    static #constructing = false;
	    static create(max) {
	        const HeapCls = getUintArray(max);
	        if (!HeapCls)
	            return [];
	        Stack.#constructing = true;
	        const s = new Stack(max, HeapCls);
	        Stack.#constructing = false;
	        return s;
	    }
	    constructor(max, HeapCls) {
	        /* c8 ignore start */
	        if (!Stack.#constructing) {
	            throw new TypeError('instantiate Stack using Stack.create(n)');
	        }
	        /* c8 ignore stop */
	        this.heap = new HeapCls(max);
	        this.length = 0;
	    }
	    push(n) {
	        this.heap[this.length++] = n;
	    }
	    pop() {
	        return this.heap[--this.length];
	    }
	}
	/**
	 * Default export, the thing you're using this module to get.
	 *
	 * The `K` and `V` types define the key and value types, respectively. The
	 * optional `FC` type defines the type of the `context` object passed to
	 * `cache.fetch()` and `cache.memo()`.
	 *
	 * Keys and values **must not** be `null` or `undefined`.
	 *
	 * All properties from the options object (with the exception of `max`,
	 * `maxSize`, `fetchMethod`, `memoMethod`, `dispose` and `disposeAfter`) are
	 * added as normal public members. (The listed options are read-only getters.)
	 *
	 * Changing any of these will alter the defaults for subsequent method calls.
	 */
	class LRUCache {
	    // options that cannot be changed without disaster
	    #max;
	    #maxSize;
	    #dispose;
	    #onInsert;
	    #disposeAfter;
	    #fetchMethod;
	    #memoMethod;
	    /**
	     * {@link LRUCache.OptionsBase.ttl}
	     */
	    ttl;
	    /**
	     * {@link LRUCache.OptionsBase.ttlResolution}
	     */
	    ttlResolution;
	    /**
	     * {@link LRUCache.OptionsBase.ttlAutopurge}
	     */
	    ttlAutopurge;
	    /**
	     * {@link LRUCache.OptionsBase.updateAgeOnGet}
	     */
	    updateAgeOnGet;
	    /**
	     * {@link LRUCache.OptionsBase.updateAgeOnHas}
	     */
	    updateAgeOnHas;
	    /**
	     * {@link LRUCache.OptionsBase.allowStale}
	     */
	    allowStale;
	    /**
	     * {@link LRUCache.OptionsBase.noDisposeOnSet}
	     */
	    noDisposeOnSet;
	    /**
	     * {@link LRUCache.OptionsBase.noUpdateTTL}
	     */
	    noUpdateTTL;
	    /**
	     * {@link LRUCache.OptionsBase.maxEntrySize}
	     */
	    maxEntrySize;
	    /**
	     * {@link LRUCache.OptionsBase.sizeCalculation}
	     */
	    sizeCalculation;
	    /**
	     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
	     */
	    noDeleteOnFetchRejection;
	    /**
	     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
	     */
	    noDeleteOnStaleGet;
	    /**
	     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
	     */
	    allowStaleOnFetchAbort;
	    /**
	     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
	     */
	    allowStaleOnFetchRejection;
	    /**
	     * {@link LRUCache.OptionsBase.ignoreFetchAbort}
	     */
	    ignoreFetchAbort;
	    // computed properties
	    #size;
	    #calculatedSize;
	    #keyMap;
	    #keyList;
	    #valList;
	    #next;
	    #prev;
	    #head;
	    #tail;
	    #free;
	    #disposed;
	    #sizes;
	    #starts;
	    #ttls;
	    #hasDispose;
	    #hasFetchMethod;
	    #hasDisposeAfter;
	    #hasOnInsert;
	    /**
	     * Do not call this method unless you need to inspect the
	     * inner workings of the cache.  If anything returned by this
	     * object is modified in any way, strange breakage may occur.
	     *
	     * These fields are private for a reason!
	     *
	     * @internal
	     */
	    static unsafeExposeInternals(c) {
	        return {
	            // properties
	            starts: c.#starts,
	            ttls: c.#ttls,
	            sizes: c.#sizes,
	            keyMap: c.#keyMap,
	            keyList: c.#keyList,
	            valList: c.#valList,
	            next: c.#next,
	            prev: c.#prev,
	            get head() {
	                return c.#head;
	            },
	            get tail() {
	                return c.#tail;
	            },
	            free: c.#free,
	            // methods
	            isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
	            backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),
	            moveToTail: (index) => c.#moveToTail(index),
	            indexes: (options) => c.#indexes(options),
	            rindexes: (options) => c.#rindexes(options),
	            isStale: (index) => c.#isStale(index),
	        };
	    }
	    // Protected read-only members
	    /**
	     * {@link LRUCache.OptionsBase.max} (read-only)
	     */
	    get max() {
	        return this.#max;
	    }
	    /**
	     * {@link LRUCache.OptionsBase.maxSize} (read-only)
	     */
	    get maxSize() {
	        return this.#maxSize;
	    }
	    /**
	     * The total computed size of items in the cache (read-only)
	     */
	    get calculatedSize() {
	        return this.#calculatedSize;
	    }
	    /**
	     * The number of items stored in the cache (read-only)
	     */
	    get size() {
	        return this.#size;
	    }
	    /**
	     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
	     */
	    get fetchMethod() {
	        return this.#fetchMethod;
	    }
	    get memoMethod() {
	        return this.#memoMethod;
	    }
	    /**
	     * {@link LRUCache.OptionsBase.dispose} (read-only)
	     */
	    get dispose() {
	        return this.#dispose;
	    }
	    /**
	     * {@link LRUCache.OptionsBase.onInsert} (read-only)
	     */
	    get onInsert() {
	        return this.#onInsert;
	    }
	    /**
	     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
	     */
	    get disposeAfter() {
	        return this.#disposeAfter;
	    }
	    constructor(options) {
	        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, onInsert, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort, } = options;
	        if (max !== 0 && !isPosInt(max)) {
	            throw new TypeError('max option must be a nonnegative integer');
	        }
	        const UintArray = max ? getUintArray(max) : Array;
	        if (!UintArray) {
	            throw new Error('invalid max value: ' + max);
	        }
	        this.#max = max;
	        this.#maxSize = maxSize;
	        this.maxEntrySize = maxEntrySize || this.#maxSize;
	        this.sizeCalculation = sizeCalculation;
	        if (this.sizeCalculation) {
	            if (!this.#maxSize && !this.maxEntrySize) {
	                throw new TypeError('cannot set sizeCalculation without setting maxSize or maxEntrySize');
	            }
	            if (typeof this.sizeCalculation !== 'function') {
	                throw new TypeError('sizeCalculation set to non-function');
	            }
	        }
	        if (memoMethod !== undefined &&
	            typeof memoMethod !== 'function') {
	            throw new TypeError('memoMethod must be a function if defined');
	        }
	        this.#memoMethod = memoMethod;
	        if (fetchMethod !== undefined &&
	            typeof fetchMethod !== 'function') {
	            throw new TypeError('fetchMethod must be a function if specified');
	        }
	        this.#fetchMethod = fetchMethod;
	        this.#hasFetchMethod = !!fetchMethod;
	        this.#keyMap = new Map();
	        this.#keyList = new Array(max).fill(undefined);
	        this.#valList = new Array(max).fill(undefined);
	        this.#next = new UintArray(max);
	        this.#prev = new UintArray(max);
	        this.#head = 0;
	        this.#tail = 0;
	        this.#free = Stack.create(max);
	        this.#size = 0;
	        this.#calculatedSize = 0;
	        if (typeof dispose === 'function') {
	            this.#dispose = dispose;
	        }
	        if (typeof onInsert === 'function') {
	            this.#onInsert = onInsert;
	        }
	        if (typeof disposeAfter === 'function') {
	            this.#disposeAfter = disposeAfter;
	            this.#disposed = [];
	        }
	        else {
	            this.#disposeAfter = undefined;
	            this.#disposed = undefined;
	        }
	        this.#hasDispose = !!this.#dispose;
	        this.#hasOnInsert = !!this.#onInsert;
	        this.#hasDisposeAfter = !!this.#disposeAfter;
	        this.noDisposeOnSet = !!noDisposeOnSet;
	        this.noUpdateTTL = !!noUpdateTTL;
	        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
	        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
	        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
	        this.ignoreFetchAbort = !!ignoreFetchAbort;
	        // NB: maxEntrySize is set to maxSize if it's set
	        if (this.maxEntrySize !== 0) {
	            if (this.#maxSize !== 0) {
	                if (!isPosInt(this.#maxSize)) {
	                    throw new TypeError('maxSize must be a positive integer if specified');
	                }
	            }
	            if (!isPosInt(this.maxEntrySize)) {
	                throw new TypeError('maxEntrySize must be a positive integer if specified');
	            }
	            this.#initializeSizeTracking();
	        }
	        this.allowStale = !!allowStale;
	        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
	        this.updateAgeOnGet = !!updateAgeOnGet;
	        this.updateAgeOnHas = !!updateAgeOnHas;
	        this.ttlResolution =
	            isPosInt(ttlResolution) || ttlResolution === 0
	                ? ttlResolution
	                : 1;
	        this.ttlAutopurge = !!ttlAutopurge;
	        this.ttl = ttl || 0;
	        if (this.ttl) {
	            if (!isPosInt(this.ttl)) {
	                throw new TypeError('ttl must be a positive integer if specified');
	            }
	            this.#initializeTTLTracking();
	        }
	        // do not allow completely unbounded caches
	        if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
	            throw new TypeError('At least one of max, maxSize, or ttl is required');
	        }
	        if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
	            const code = 'LRU_CACHE_UNBOUNDED';
	            if (shouldWarn(code)) {
	                warned.add(code);
	                const msg = 'TTL caching without ttlAutopurge, max, or maxSize can ' +
	                    'result in unbounded memory consumption.';
	                emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache);
	            }
	        }
	    }
	    /**
	     * Return the number of ms left in the item's TTL. If item is not in cache,
	     * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
	     */
	    getRemainingTTL(key) {
	        return this.#keyMap.has(key) ? Infinity : 0;
	    }
	    #initializeTTLTracking() {
	        const ttls = new ZeroArray(this.#max);
	        const starts = new ZeroArray(this.#max);
	        this.#ttls = ttls;
	        this.#starts = starts;
	        this.#setItemTTL = (index, ttl, start = perf.now()) => {
	            starts[index] = ttl !== 0 ? start : 0;
	            ttls[index] = ttl;
	            if (ttl !== 0 && this.ttlAutopurge) {
	                const t = setTimeout(() => {
	                    if (this.#isStale(index)) {
	                        this.#delete(this.#keyList[index], 'expire');
	                    }
	                }, ttl + 1);
	                // unref() not supported on all platforms
	                /* c8 ignore start */
	                if (t.unref) {
	                    t.unref();
	                }
	                /* c8 ignore stop */
	            }
	        };
	        this.#updateItemAge = index => {
	            starts[index] = ttls[index] !== 0 ? perf.now() : 0;
	        };
	        this.#statusTTL = (status, index) => {
	            if (ttls[index]) {
	                const ttl = ttls[index];
	                const start = starts[index];
	                /* c8 ignore next */
	                if (!ttl || !start)
	                    return;
	                status.ttl = ttl;
	                status.start = start;
	                status.now = cachedNow || getNow();
	                const age = status.now - start;
	                status.remainingTTL = ttl - age;
	            }
	        };
	        // debounce calls to perf.now() to 1s so we're not hitting
	        // that costly call repeatedly.
	        let cachedNow = 0;
	        const getNow = () => {
	            const n = perf.now();
	            if (this.ttlResolution > 0) {
	                cachedNow = n;
	                const t = setTimeout(() => (cachedNow = 0), this.ttlResolution);
	                // not available on all platforms
	                /* c8 ignore start */
	                if (t.unref) {
	                    t.unref();
	                }
	                /* c8 ignore stop */
	            }
	            return n;
	        };
	        this.getRemainingTTL = key => {
	            const index = this.#keyMap.get(key);
	            if (index === undefined) {
	                return 0;
	            }
	            const ttl = ttls[index];
	            const start = starts[index];
	            if (!ttl || !start) {
	                return Infinity;
	            }
	            const age = (cachedNow || getNow()) - start;
	            return ttl - age;
	        };
	        this.#isStale = index => {
	            const s = starts[index];
	            const t = ttls[index];
	            return !!t && !!s && (cachedNow || getNow()) - s > t;
	        };
	    }
	    // conditionally set private methods related to TTL
	    #updateItemAge = () => { };
	    #statusTTL = () => { };
	    #setItemTTL = () => { };
	    /* c8 ignore stop */
	    #isStale = () => false;
	    #initializeSizeTracking() {
	        const sizes = new ZeroArray(this.#max);
	        this.#calculatedSize = 0;
	        this.#sizes = sizes;
	        this.#removeItemSize = index => {
	            this.#calculatedSize -= sizes[index];
	            sizes[index] = 0;
	        };
	        this.#requireSize = (k, v, size, sizeCalculation) => {
	            // provisionally accept background fetches.
	            // actual value size will be checked when they return.
	            if (this.#isBackgroundFetch(v)) {
	                return 0;
	            }
	            if (!isPosInt(size)) {
	                if (sizeCalculation) {
	                    if (typeof sizeCalculation !== 'function') {
	                        throw new TypeError('sizeCalculation must be a function');
	                    }
	                    size = sizeCalculation(v, k);
	                    if (!isPosInt(size)) {
	                        throw new TypeError('sizeCalculation return invalid (expect positive integer)');
	                    }
	                }
	                else {
	                    throw new TypeError('invalid size value (must be positive integer). ' +
	                        'When maxSize or maxEntrySize is used, sizeCalculation ' +
	                        'or size must be set.');
	                }
	            }
	            return size;
	        };
	        this.#addItemSize = (index, size, status) => {
	            sizes[index] = size;
	            if (this.#maxSize) {
	                const maxSize = this.#maxSize - sizes[index];
	                while (this.#calculatedSize > maxSize) {
	                    this.#evict(true);
	                }
	            }
	            this.#calculatedSize += sizes[index];
	            if (status) {
	                status.entrySize = size;
	                status.totalCalculatedSize = this.#calculatedSize;
	            }
	        };
	    }
	    #removeItemSize = _i => { };
	    #addItemSize = (_i, _s, _st) => { };
	    #requireSize = (_k, _v, size, sizeCalculation) => {
	        if (size || sizeCalculation) {
	            throw new TypeError('cannot set size without setting maxSize or maxEntrySize on cache');
	        }
	        return 0;
	    };
	    *#indexes({ allowStale = this.allowStale } = {}) {
	        if (this.#size) {
	            for (let i = this.#tail; true;) {
	                if (!this.#isValidIndex(i)) {
	                    break;
	                }
	                if (allowStale || !this.#isStale(i)) {
	                    yield i;
	                }
	                if (i === this.#head) {
	                    break;
	                }
	                else {
	                    i = this.#prev[i];
	                }
	            }
	        }
	    }
	    *#rindexes({ allowStale = this.allowStale } = {}) {
	        if (this.#size) {
	            for (let i = this.#head; true;) {
	                if (!this.#isValidIndex(i)) {
	                    break;
	                }
	                if (allowStale || !this.#isStale(i)) {
	                    yield i;
	                }
	                if (i === this.#tail) {
	                    break;
	                }
	                else {
	                    i = this.#next[i];
	                }
	            }
	        }
	    }
	    #isValidIndex(index) {
	        return (index !== undefined &&
	            this.#keyMap.get(this.#keyList[index]) === index);
	    }
	    /**
	     * Return a generator yielding `[key, value]` pairs,
	     * in order from most recently used to least recently used.
	     */
	    *entries() {
	        for (const i of this.#indexes()) {
	            if (this.#valList[i] !== undefined &&
	                this.#keyList[i] !== undefined &&
	                !this.#isBackgroundFetch(this.#valList[i])) {
	                yield [this.#keyList[i], this.#valList[i]];
	            }
	        }
	    }
	    /**
	     * Inverse order version of {@link LRUCache.entries}
	     *
	     * Return a generator yielding `[key, value]` pairs,
	     * in order from least recently used to most recently used.
	     */
	    *rentries() {
	        for (const i of this.#rindexes()) {
	            if (this.#valList[i] !== undefined &&
	                this.#keyList[i] !== undefined &&
	                !this.#isBackgroundFetch(this.#valList[i])) {
	                yield [this.#keyList[i], this.#valList[i]];
	            }
	        }
	    }
	    /**
	     * Return a generator yielding the keys in the cache,
	     * in order from most recently used to least recently used.
	     */
	    *keys() {
	        for (const i of this.#indexes()) {
	            const k = this.#keyList[i];
	            if (k !== undefined &&
	                !this.#isBackgroundFetch(this.#valList[i])) {
	                yield k;
	            }
	        }
	    }
	    /**
	     * Inverse order version of {@link LRUCache.keys}
	     *
	     * Return a generator yielding the keys in the cache,
	     * in order from least recently used to most recently used.
	     */
	    *rkeys() {
	        for (const i of this.#rindexes()) {
	            const k = this.#keyList[i];
	            if (k !== undefined &&
	                !this.#isBackgroundFetch(this.#valList[i])) {
	                yield k;
	            }
	        }
	    }
	    /**
	     * Return a generator yielding the values in the cache,
	     * in order from most recently used to least recently used.
	     */
	    *values() {
	        for (const i of this.#indexes()) {
	            const v = this.#valList[i];
	            if (v !== undefined &&
	                !this.#isBackgroundFetch(this.#valList[i])) {
	                yield this.#valList[i];
	            }
	        }
	    }
	    /**
	     * Inverse order version of {@link LRUCache.values}
	     *
	     * Return a generator yielding the values in the cache,
	     * in order from least recently used to most recently used.
	     */
	    *rvalues() {
	        for (const i of this.#rindexes()) {
	            const v = this.#valList[i];
	            if (v !== undefined &&
	                !this.#isBackgroundFetch(this.#valList[i])) {
	                yield this.#valList[i];
	            }
	        }
	    }
	    /**
	     * Iterating over the cache itself yields the same results as
	     * {@link LRUCache.entries}
	     */
	    [Symbol.iterator]() {
	        return this.entries();
	    }
	    /**
	     * A String value that is used in the creation of the default string
	     * description of an object. Called by the built-in method
	     * `Object.prototype.toString`.
	     */
	    [Symbol.toStringTag] = 'LRUCache';
	    /**
	     * Find a value for which the supplied fn method returns a truthy value,
	     * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
	     */
	    find(fn, getOptions = {}) {
	        for (const i of this.#indexes()) {
	            const v = this.#valList[i];
	            const value = this.#isBackgroundFetch(v)
	                ? v.__staleWhileFetching
	                : v;
	            if (value === undefined)
	                continue;
	            if (fn(value, this.#keyList[i], this)) {
	                return this.get(this.#keyList[i], getOptions);
	            }
	        }
	    }
	    /**
	     * Call the supplied function on each item in the cache, in order from most
	     * recently used to least recently used.
	     *
	     * `fn` is called as `fn(value, key, cache)`.
	     *
	     * If `thisp` is provided, function will be called in the `this`-context of
	     * the provided object, or the cache if no `thisp` object is provided.
	     *
	     * Does not update age or recenty of use, or iterate over stale values.
	     */
	    forEach(fn, thisp = this) {
	        for (const i of this.#indexes()) {
	            const v = this.#valList[i];
	            const value = this.#isBackgroundFetch(v)
	                ? v.__staleWhileFetching
	                : v;
	            if (value === undefined)
	                continue;
	            fn.call(thisp, value, this.#keyList[i], this);
	        }
	    }
	    /**
	     * The same as {@link LRUCache.forEach} but items are iterated over in
	     * reverse order.  (ie, less recently used items are iterated over first.)
	     */
	    rforEach(fn, thisp = this) {
	        for (const i of this.#rindexes()) {
	            const v = this.#valList[i];
	            const value = this.#isBackgroundFetch(v)
	                ? v.__staleWhileFetching
	                : v;
	            if (value === undefined)
	                continue;
	            fn.call(thisp, value, this.#keyList[i], this);
	        }
	    }
	    /**
	     * Delete any stale entries. Returns true if anything was removed,
	     * false otherwise.
	     */
	    purgeStale() {
	        let deleted = false;
	        for (const i of this.#rindexes({ allowStale: true })) {
	            if (this.#isStale(i)) {
	                this.#delete(this.#keyList[i], 'expire');
	                deleted = true;
	            }
	        }
	        return deleted;
	    }
	    /**
	     * Get the extended info about a given entry, to get its value, size, and
	     * TTL info simultaneously. Returns `undefined` if the key is not present.
	     *
	     * Unlike {@link LRUCache#dump}, which is designed to be portable and survive
	     * serialization, the `start` value is always the current timestamp, and the
	     * `ttl` is a calculated remaining time to live (negative if expired).
	     *
	     * Always returns stale values, if their info is found in the cache, so be
	     * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
	     * if relevant.
	     */
	    info(key) {
	        const i = this.#keyMap.get(key);
	        if (i === undefined)
	            return undefined;
	        const v = this.#valList[i];
	        const value = this.#isBackgroundFetch(v)
	            ? v.__staleWhileFetching
	            : v;
	        if (value === undefined)
	            return undefined;
	        const entry = { value };
	        if (this.#ttls && this.#starts) {
	            const ttl = this.#ttls[i];
	            const start = this.#starts[i];
	            if (ttl && start) {
	                const remain = ttl - (perf.now() - start);
	                entry.ttl = remain;
	                entry.start = Date.now();
	            }
	        }
	        if (this.#sizes) {
	            entry.size = this.#sizes[i];
	        }
	        return entry;
	    }
	    /**
	     * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
	     * passed to {@link LRUCache#load}.
	     *
	     * The `start` fields are calculated relative to a portable `Date.now()`
	     * timestamp, even if `performance.now()` is available.
	     *
	     * Stale entries are always included in the `dump`, even if
	     * {@link LRUCache.OptionsBase.allowStale} is false.
	     *
	     * Note: this returns an actual array, not a generator, so it can be more
	     * easily passed around.
	     */
	    dump() {
	        const arr = [];
	        for (const i of this.#indexes({ allowStale: true })) {
	            const key = this.#keyList[i];
	            const v = this.#valList[i];
	            const value = this.#isBackgroundFetch(v)
	                ? v.__staleWhileFetching
	                : v;
	            if (value === undefined || key === undefined)
	                continue;
	            const entry = { value };
	            if (this.#ttls && this.#starts) {
	                entry.ttl = this.#ttls[i];
	                // always dump the start relative to a portable timestamp
	                // it's ok for this to be a bit slow, it's a rare operation.
	                const age = perf.now() - this.#starts[i];
	                entry.start = Math.floor(Date.now() - age);
	            }
	            if (this.#sizes) {
	                entry.size = this.#sizes[i];
	            }
	            arr.unshift([key, entry]);
	        }
	        return arr;
	    }
	    /**
	     * Reset the cache and load in the items in entries in the order listed.
	     *
	     * The shape of the resulting cache may be different if the same options are
	     * not used in both caches.
	     *
	     * The `start` fields are assumed to be calculated relative to a portable
	     * `Date.now()` timestamp, even if `performance.now()` is available.
	     */
	    load(arr) {
	        this.clear();
	        for (const [key, entry] of arr) {
	            if (entry.start) {
	                // entry.start is a portable timestamp, but we may be using
	                // node's performance.now(), so calculate the offset, so that
	                // we get the intended remaining TTL, no matter how long it's
	                // been on ice.
	                //
	                // it's ok for this to be a bit slow, it's a rare operation.
	                const age = Date.now() - entry.start;
	                entry.start = perf.now() - age;
	            }
	            this.set(key, entry.value, entry);
	        }
	    }
	    /**
	     * Add a value to the cache.
	     *
	     * Note: if `undefined` is specified as a value, this is an alias for
	     * {@link LRUCache#delete}
	     *
	     * Fields on the {@link LRUCache.SetOptions} options param will override
	     * their corresponding values in the constructor options for the scope
	     * of this single `set()` operation.
	     *
	     * If `start` is provided, then that will set the effective start
	     * time for the TTL calculation. Note that this must be a previous
	     * value of `performance.now()` if supported, or a previous value of
	     * `Date.now()` if not.
	     *
	     * Options object may also include `size`, which will prevent
	     * calling the `sizeCalculation` function and just use the specified
	     * number if it is a positive integer, and `noDisposeOnSet` which
	     * will prevent calling a `dispose` function in the case of
	     * overwrites.
	     *
	     * If the `size` (or return value of `sizeCalculation`) for a given
	     * entry is greater than `maxEntrySize`, then the item will not be
	     * added to the cache.
	     *
	     * Will update the recency of the entry.
	     *
	     * If the value is `undefined`, then this is an alias for
	     * `cache.delete(key)`. `undefined` is never stored in the cache.
	     */
	    set(k, v, setOptions = {}) {
	        if (v === undefined) {
	            this.delete(k);
	            return this;
	        }
	        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status, } = setOptions;
	        let { noUpdateTTL = this.noUpdateTTL } = setOptions;
	        const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
	        // if the item doesn't fit, don't do anything
	        // NB: maxEntrySize set to maxSize by default
	        if (this.maxEntrySize && size > this.maxEntrySize) {
	            if (status) {
	                status.set = 'miss';
	                status.maxEntrySizeExceeded = true;
	            }
	            // have to delete, in case something is there already.
	            this.#delete(k, 'set');
	            return this;
	        }
	        let index = this.#size === 0 ? undefined : this.#keyMap.get(k);
	        if (index === undefined) {
	            // addition
	            index = (this.#size === 0
	                ? this.#tail
	                : this.#free.length !== 0
	                    ? this.#free.pop()
	                    : this.#size === this.#max
	                        ? this.#evict(false)
	                        : this.#size);
	            this.#keyList[index] = k;
	            this.#valList[index] = v;
	            this.#keyMap.set(k, index);
	            this.#next[this.#tail] = index;
	            this.#prev[index] = this.#tail;
	            this.#tail = index;
	            this.#size++;
	            this.#addItemSize(index, size, status);
	            if (status)
	                status.set = 'add';
	            noUpdateTTL = false;
	            if (this.#hasOnInsert) {
	                this.#onInsert?.(v, k, 'add');
	            }
	        }
	        else {
	            // update
	            this.#moveToTail(index);
	            const oldVal = this.#valList[index];
	            if (v !== oldVal) {
	                if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
	                    oldVal.__abortController.abort(new Error('replaced'));
	                    const { __staleWhileFetching: s } = oldVal;
	                    if (s !== undefined && !noDisposeOnSet) {
	                        if (this.#hasDispose) {
	                            this.#dispose?.(s, k, 'set');
	                        }
	                        if (this.#hasDisposeAfter) {
	                            this.#disposed?.push([s, k, 'set']);
	                        }
	                    }
	                }
	                else if (!noDisposeOnSet) {
	                    if (this.#hasDispose) {
	                        this.#dispose?.(oldVal, k, 'set');
	                    }
	                    if (this.#hasDisposeAfter) {
	                        this.#disposed?.push([oldVal, k, 'set']);
	                    }
	                }
	                this.#removeItemSize(index);
	                this.#addItemSize(index, size, status);
	                this.#valList[index] = v;
	                if (status) {
	                    status.set = 'replace';
	                    const oldValue = oldVal && this.#isBackgroundFetch(oldVal)
	                        ? oldVal.__staleWhileFetching
	                        : oldVal;
	                    if (oldValue !== undefined)
	                        status.oldValue = oldValue;
	                }
	            }
	            else if (status) {
	                status.set = 'update';
	            }
	            if (this.#hasOnInsert) {
	                this.onInsert?.(v, k, v === oldVal ? 'update' : 'replace');
	            }
	        }
	        if (ttl !== 0 && !this.#ttls) {
	            this.#initializeTTLTracking();
	        }
	        if (this.#ttls) {
	            if (!noUpdateTTL) {
	                this.#setItemTTL(index, ttl, start);
	            }
	            if (status)
	                this.#statusTTL(status, index);
	        }
	        if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
	            const dt = this.#disposed;
	            let task;
	            while ((task = dt?.shift())) {
	                this.#disposeAfter?.(...task);
	            }
	        }
	        return this;
	    }
	    /**
	     * Evict the least recently used item, returning its value or
	     * `undefined` if cache is empty.
	     */
	    pop() {
	        try {
	            while (this.#size) {
	                const val = this.#valList[this.#head];
	                this.#evict(true);
	                if (this.#isBackgroundFetch(val)) {
	                    if (val.__staleWhileFetching) {
	                        return val.__staleWhileFetching;
	                    }
	                }
	                else if (val !== undefined) {
	                    return val;
	                }
	            }
	        }
	        finally {
	            if (this.#hasDisposeAfter && this.#disposed) {
	                const dt = this.#disposed;
	                let task;
	                while ((task = dt?.shift())) {
	                    this.#disposeAfter?.(...task);
	                }
	            }
	        }
	    }
	    #evict(free) {
	        const head = this.#head;
	        const k = this.#keyList[head];
	        const v = this.#valList[head];
	        if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
	            v.__abortController.abort(new Error('evicted'));
	        }
	        else if (this.#hasDispose || this.#hasDisposeAfter) {
	            if (this.#hasDispose) {
	                this.#dispose?.(v, k, 'evict');
	            }
	            if (this.#hasDisposeAfter) {
	                this.#disposed?.push([v, k, 'evict']);
	            }
	        }
	        this.#removeItemSize(head);
	        // if we aren't about to use the index, then null these out
	        if (free) {
	            this.#keyList[head] = undefined;
	            this.#valList[head] = undefined;
	            this.#free.push(head);
	        }
	        if (this.#size === 1) {
	            this.#head = this.#tail = 0;
	            this.#free.length = 0;
	        }
	        else {
	            this.#head = this.#next[head];
	        }
	        this.#keyMap.delete(k);
	        this.#size--;
	        return head;
	    }
	    /**
	     * Check if a key is in the cache, without updating the recency of use.
	     * Will return false if the item is stale, even though it is technically
	     * in the cache.
	     *
	     * Check if a key is in the cache, without updating the recency of
	     * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
	     * to `true` in either the options or the constructor.
	     *
	     * Will return `false` if the item is stale, even though it is technically in
	     * the cache. The difference can be determined (if it matters) by using a
	     * `status` argument, and inspecting the `has` field.
	     *
	     * Will not update item age unless
	     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
	     */
	    has(k, hasOptions = {}) {
	        const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
	        const index = this.#keyMap.get(k);
	        if (index !== undefined) {
	            const v = this.#valList[index];
	            if (this.#isBackgroundFetch(v) &&
	                v.__staleWhileFetching === undefined) {
	                return false;
	            }
	            if (!this.#isStale(index)) {
	                if (updateAgeOnHas) {
	                    this.#updateItemAge(index);
	                }
	                if (status) {
	                    status.has = 'hit';
	                    this.#statusTTL(status, index);
	                }
	                return true;
	            }
	            else if (status) {
	                status.has = 'stale';
	                this.#statusTTL(status, index);
	            }
	        }
	        else if (status) {
	            status.has = 'miss';
	        }
	        return false;
	    }
	    /**
	     * Like {@link LRUCache#get} but doesn't update recency or delete stale
	     * items.
	     *
	     * Returns `undefined` if the item is stale, unless
	     * {@link LRUCache.OptionsBase.allowStale} is set.
	     */
	    peek(k, peekOptions = {}) {
	        const { allowStale = this.allowStale } = peekOptions;
	        const index = this.#keyMap.get(k);
	        if (index === undefined ||
	            (!allowStale && this.#isStale(index))) {
	            return;
	        }
	        const v = this.#valList[index];
	        // either stale and allowed, or forcing a refresh of non-stale value
	        return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
	    }
	    #backgroundFetch(k, index, options, context) {
	        const v = index === undefined ? undefined : this.#valList[index];
	        if (this.#isBackgroundFetch(v)) {
	            return v;
	        }
	        const ac = new AC();
	        const { signal } = options;
	        // when/if our AC signals, then stop listening to theirs.
	        signal?.addEventListener('abort', () => ac.abort(signal.reason), {
	            signal: ac.signal,
	        });
	        const fetchOpts = {
	            signal: ac.signal,
	            options,
	            context,
	        };
	        const cb = (v, updateCache = false) => {
	            const { aborted } = ac.signal;
	            const ignoreAbort = options.ignoreFetchAbort && v !== undefined;
	            if (options.status) {
	                if (aborted && !updateCache) {
	                    options.status.fetchAborted = true;
	                    options.status.fetchError = ac.signal.reason;
	                    if (ignoreAbort)
	                        options.status.fetchAbortIgnored = true;
	                }
	                else {
	                    options.status.fetchResolved = true;
	                }
	            }
	            if (aborted && !ignoreAbort && !updateCache) {
	                return fetchFail(ac.signal.reason);
	            }
	            // either we didn't abort, and are still here, or we did, and ignored
	            const bf = p;
	            if (this.#valList[index] === p) {
	                if (v === undefined) {
	                    if (bf.__staleWhileFetching) {
	                        this.#valList[index] = bf.__staleWhileFetching;
	                    }
	                    else {
	                        this.#delete(k, 'fetch');
	                    }
	                }
	                else {
	                    if (options.status)
	                        options.status.fetchUpdated = true;
	                    this.set(k, v, fetchOpts.options);
	                }
	            }
	            return v;
	        };
	        const eb = (er) => {
	            if (options.status) {
	                options.status.fetchRejected = true;
	                options.status.fetchError = er;
	            }
	            return fetchFail(er);
	        };
	        const fetchFail = (er) => {
	            const { aborted } = ac.signal;
	            const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
	            const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
	            const noDelete = allowStale || options.noDeleteOnFetchRejection;
	            const bf = p;
	            if (this.#valList[index] === p) {
	                // if we allow stale on fetch rejections, then we need to ensure that
	                // the stale value is not removed from the cache when the fetch fails.
	                const del = !noDelete || bf.__staleWhileFetching === undefined;
	                if (del) {
	                    this.#delete(k, 'fetch');
	                }
	                else if (!allowStaleAborted) {
	                    // still replace the *promise* with the stale value,
	                    // since we are done with the promise at this point.
	                    // leave it untouched if we're still waiting for an
	                    // aborted background fetch that hasn't yet returned.
	                    this.#valList[index] = bf.__staleWhileFetching;
	                }
	            }
	            if (allowStale) {
	                if (options.status && bf.__staleWhileFetching !== undefined) {
	                    options.status.returnedStale = true;
	                }
	                return bf.__staleWhileFetching;
	            }
	            else if (bf.__returned === bf) {
	                throw er;
	            }
	        };
	        const pcall = (res, rej) => {
	            const fmp = this.#fetchMethod?.(k, v, fetchOpts);
	            if (fmp && fmp instanceof Promise) {
	                fmp.then(v => res(v === undefined ? undefined : v), rej);
	            }
	            // ignored, we go until we finish, regardless.
	            // defer check until we are actually aborting,
	            // so fetchMethod can override.
	            ac.signal.addEventListener('abort', () => {
	                if (!options.ignoreFetchAbort ||
	                    options.allowStaleOnFetchAbort) {
	                    res(undefined);
	                    // when it eventually resolves, update the cache.
	                    if (options.allowStaleOnFetchAbort) {
	                        res = v => cb(v, true);
	                    }
	                }
	            });
	        };
	        if (options.status)
	            options.status.fetchDispatched = true;
	        const p = new Promise(pcall).then(cb, eb);
	        const bf = Object.assign(p, {
	            __abortController: ac,
	            __staleWhileFetching: v,
	            __returned: undefined,
	        });
	        if (index === undefined) {
	            // internal, don't expose status.
	            this.set(k, bf, { ...fetchOpts.options, status: undefined });
	            index = this.#keyMap.get(k);
	        }
	        else {
	            this.#valList[index] = bf;
	        }
	        return bf;
	    }
	    #isBackgroundFetch(p) {
	        if (!this.#hasFetchMethod)
	            return false;
	        const b = p;
	        return (!!b &&
	            b instanceof Promise &&
	            b.hasOwnProperty('__staleWhileFetching') &&
	            b.__abortController instanceof AC);
	    }
	    async fetch(k, fetchOptions = {}) {
	        const { 
	        // get options
	        allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, 
	        // set options
	        ttl = this.ttl, noDisposeOnSet = this.noDisposeOnSet, size = 0, sizeCalculation = this.sizeCalculation, noUpdateTTL = this.noUpdateTTL, 
	        // fetch exclusive options
	        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection = this.allowStaleOnFetchRejection, ignoreFetchAbort = this.ignoreFetchAbort, allowStaleOnFetchAbort = this.allowStaleOnFetchAbort, context, forceRefresh = false, status, signal, } = fetchOptions;
	        if (!this.#hasFetchMethod) {
	            if (status)
	                status.fetch = 'get';
	            return this.get(k, {
	                allowStale,
	                updateAgeOnGet,
	                noDeleteOnStaleGet,
	                status,
	            });
	        }
	        const options = {
	            allowStale,
	            updateAgeOnGet,
	            noDeleteOnStaleGet,
	            ttl,
	            noDisposeOnSet,
	            size,
	            sizeCalculation,
	            noUpdateTTL,
	            noDeleteOnFetchRejection,
	            allowStaleOnFetchRejection,
	            allowStaleOnFetchAbort,
	            ignoreFetchAbort,
	            status,
	            signal,
	        };
	        let index = this.#keyMap.get(k);
	        if (index === undefined) {
	            if (status)
	                status.fetch = 'miss';
	            const p = this.#backgroundFetch(k, index, options, context);
	            return (p.__returned = p);
	        }
	        else {
	            // in cache, maybe already fetching
	            const v = this.#valList[index];
	            if (this.#isBackgroundFetch(v)) {
	                const stale = allowStale && v.__staleWhileFetching !== undefined;
	                if (status) {
	                    status.fetch = 'inflight';
	                    if (stale)
	                        status.returnedStale = true;
	                }
	                return stale ? v.__staleWhileFetching : (v.__returned = v);
	            }
	            // if we force a refresh, that means do NOT serve the cached value,
	            // unless we are already in the process of refreshing the cache.
	            const isStale = this.#isStale(index);
	            if (!forceRefresh && !isStale) {
	                if (status)
	                    status.fetch = 'hit';
	                this.#moveToTail(index);
	                if (updateAgeOnGet) {
	                    this.#updateItemAge(index);
	                }
	                if (status)
	                    this.#statusTTL(status, index);
	                return v;
	            }
	            // ok, it is stale or a forced refresh, and not already fetching.
	            // refresh the cache.
	            const p = this.#backgroundFetch(k, index, options, context);
	            const hasStale = p.__staleWhileFetching !== undefined;
	            const staleVal = hasStale && allowStale;
	            if (status) {
	                status.fetch = isStale ? 'stale' : 'refresh';
	                if (staleVal && isStale)
	                    status.returnedStale = true;
	            }
	            return staleVal ? p.__staleWhileFetching : (p.__returned = p);
	        }
	    }
	    async forceFetch(k, fetchOptions = {}) {
	        const v = await this.fetch(k, fetchOptions);
	        if (v === undefined)
	            throw new Error('fetch() returned undefined');
	        return v;
	    }
	    memo(k, memoOptions = {}) {
	        const memoMethod = this.#memoMethod;
	        if (!memoMethod) {
	            throw new Error('no memoMethod provided to constructor');
	        }
	        const { context, forceRefresh, ...options } = memoOptions;
	        const v = this.get(k, options);
	        if (!forceRefresh && v !== undefined)
	            return v;
	        const vv = memoMethod(k, v, {
	            options,
	            context,
	        });
	        this.set(k, vv, options);
	        return vv;
	    }
	    /**
	     * Return a value from the cache. Will update the recency of the cache
	     * entry found.
	     *
	     * If the key is not found, get() will return `undefined`.
	     */
	    get(k, getOptions = {}) {
	        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status, } = getOptions;
	        const index = this.#keyMap.get(k);
	        if (index !== undefined) {
	            const value = this.#valList[index];
	            const fetching = this.#isBackgroundFetch(value);
	            if (status)
	                this.#statusTTL(status, index);
	            if (this.#isStale(index)) {
	                if (status)
	                    status.get = 'stale';
	                // delete only if not an in-flight background fetch
	                if (!fetching) {
	                    if (!noDeleteOnStaleGet) {
	                        this.#delete(k, 'expire');
	                    }
	                    if (status && allowStale)
	                        status.returnedStale = true;
	                    return allowStale ? value : undefined;
	                }
	                else {
	                    if (status &&
	                        allowStale &&
	                        value.__staleWhileFetching !== undefined) {
	                        status.returnedStale = true;
	                    }
	                    return allowStale ? value.__staleWhileFetching : undefined;
	                }
	            }
	            else {
	                if (status)
	                    status.get = 'hit';
	                // if we're currently fetching it, we don't actually have it yet
	                // it's not stale, which means this isn't a staleWhileRefetching.
	                // If it's not stale, and fetching, AND has a __staleWhileFetching
	                // value, then that means the user fetched with {forceRefresh:true},
	                // so it's safe to return that value.
	                if (fetching) {
	                    return value.__staleWhileFetching;
	                }
	                this.#moveToTail(index);
	                if (updateAgeOnGet) {
	                    this.#updateItemAge(index);
	                }
	                return value;
	            }
	        }
	        else if (status) {
	            status.get = 'miss';
	        }
	    }
	    #connect(p, n) {
	        this.#prev[n] = p;
	        this.#next[p] = n;
	    }
	    #moveToTail(index) {
	        // if tail already, nothing to do
	        // if head, move head to next[index]
	        // else
	        //   move next[prev[index]] to next[index] (head has no prev)
	        //   move prev[next[index]] to prev[index]
	        // prev[index] = tail
	        // next[tail] = index
	        // tail = index
	        if (index !== this.#tail) {
	            if (index === this.#head) {
	                this.#head = this.#next[index];
	            }
	            else {
	                this.#connect(this.#prev[index], this.#next[index]);
	            }
	            this.#connect(this.#tail, index);
	            this.#tail = index;
	        }
	    }
	    /**
	     * Deletes a key out of the cache.
	     *
	     * Returns true if the key was deleted, false otherwise.
	     */
	    delete(k) {
	        return this.#delete(k, 'delete');
	    }
	    #delete(k, reason) {
	        let deleted = false;
	        if (this.#size !== 0) {
	            const index = this.#keyMap.get(k);
	            if (index !== undefined) {
	                deleted = true;
	                if (this.#size === 1) {
	                    this.#clear(reason);
	                }
	                else {
	                    this.#removeItemSize(index);
	                    const v = this.#valList[index];
	                    if (this.#isBackgroundFetch(v)) {
	                        v.__abortController.abort(new Error('deleted'));
	                    }
	                    else if (this.#hasDispose || this.#hasDisposeAfter) {
	                        if (this.#hasDispose) {
	                            this.#dispose?.(v, k, reason);
	                        }
	                        if (this.#hasDisposeAfter) {
	                            this.#disposed?.push([v, k, reason]);
	                        }
	                    }
	                    this.#keyMap.delete(k);
	                    this.#keyList[index] = undefined;
	                    this.#valList[index] = undefined;
	                    if (index === this.#tail) {
	                        this.#tail = this.#prev[index];
	                    }
	                    else if (index === this.#head) {
	                        this.#head = this.#next[index];
	                    }
	                    else {
	                        const pi = this.#prev[index];
	                        this.#next[pi] = this.#next[index];
	                        const ni = this.#next[index];
	                        this.#prev[ni] = this.#prev[index];
	                    }
	                    this.#size--;
	                    this.#free.push(index);
	                }
	            }
	        }
	        if (this.#hasDisposeAfter && this.#disposed?.length) {
	            const dt = this.#disposed;
	            let task;
	            while ((task = dt?.shift())) {
	                this.#disposeAfter?.(...task);
	            }
	        }
	        return deleted;
	    }
	    /**
	     * Clear the cache entirely, throwing away all values.
	     */
	    clear() {
	        return this.#clear('delete');
	    }
	    #clear(reason) {
	        for (const index of this.#rindexes({ allowStale: true })) {
	            const v = this.#valList[index];
	            if (this.#isBackgroundFetch(v)) {
	                v.__abortController.abort(new Error('deleted'));
	            }
	            else {
	                const k = this.#keyList[index];
	                if (this.#hasDispose) {
	                    this.#dispose?.(v, k, reason);
	                }
	                if (this.#hasDisposeAfter) {
	                    this.#disposed?.push([v, k, reason]);
	                }
	            }
	        }
	        this.#keyMap.clear();
	        this.#valList.fill(undefined);
	        this.#keyList.fill(undefined);
	        if (this.#ttls && this.#starts) {
	            this.#ttls.fill(0);
	            this.#starts.fill(0);
	        }
	        if (this.#sizes) {
	            this.#sizes.fill(0);
	        }
	        this.#head = 0;
	        this.#tail = 0;
	        this.#free.length = 0;
	        this.#calculatedSize = 0;
	        this.#size = 0;
	        if (this.#hasDisposeAfter && this.#disposed) {
	            const dt = this.#disposed;
	            let task;
	            while ((task = dt?.shift())) {
	                this.#disposeAfter?.(...task);
	            }
	        }
	    }
	}
	commonjs$1.LRUCache = LRUCache;
	
	return commonjs$1;
}

var commonjs = {};

var hasRequiredCommonjs$2;

function requireCommonjs$2 () {
	if (hasRequiredCommonjs$2) return commonjs;
	hasRequiredCommonjs$2 = 1;
	(function (exports) {
		var __importDefault = (commonjs && commonjs.__importDefault) || function (mod) {
		    return (mod && mod.__esModule) ? mod : { "default": mod };
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.Minipass = exports.isWritable = exports.isReadable = exports.isStream = void 0;
		const proc = typeof process === 'object' && process
		    ? process
		    : {
		        stdout: null,
		        stderr: null,
		    };
		const node_events_1 = require$$0$3;
		const node_stream_1 = __importDefault(require$$0$7);
		const node_string_decoder_1 = require$$2$4;
		/**
		 * Return true if the argument is a Minipass stream, Node stream, or something
		 * else that Minipass can interact with.
		 */
		const isStream = (s) => !!s &&
		    typeof s === 'object' &&
		    (s instanceof Minipass ||
		        s instanceof node_stream_1.default ||
		        (0, exports.isReadable)(s) ||
		        (0, exports.isWritable)(s));
		exports.isStream = isStream;
		/**
		 * Return true if the argument is a valid {@link Minipass.Readable}
		 */
		const isReadable = (s) => !!s &&
		    typeof s === 'object' &&
		    s instanceof node_events_1.EventEmitter &&
		    typeof s.pipe === 'function' &&
		    // node core Writable streams have a pipe() method, but it throws
		    s.pipe !== node_stream_1.default.Writable.prototype.pipe;
		exports.isReadable = isReadable;
		/**
		 * Return true if the argument is a valid {@link Minipass.Writable}
		 */
		const isWritable = (s) => !!s &&
		    typeof s === 'object' &&
		    s instanceof node_events_1.EventEmitter &&
		    typeof s.write === 'function' &&
		    typeof s.end === 'function';
		exports.isWritable = isWritable;
		const EOF = Symbol('EOF');
		const MAYBE_EMIT_END = Symbol('maybeEmitEnd');
		const EMITTED_END = Symbol('emittedEnd');
		const EMITTING_END = Symbol('emittingEnd');
		const EMITTED_ERROR = Symbol('emittedError');
		const CLOSED = Symbol('closed');
		const READ = Symbol('read');
		const FLUSH = Symbol('flush');
		const FLUSHCHUNK = Symbol('flushChunk');
		const ENCODING = Symbol('encoding');
		const DECODER = Symbol('decoder');
		const FLOWING = Symbol('flowing');
		const PAUSED = Symbol('paused');
		const RESUME = Symbol('resume');
		const BUFFER = Symbol('buffer');
		const PIPES = Symbol('pipes');
		const BUFFERLENGTH = Symbol('bufferLength');
		const BUFFERPUSH = Symbol('bufferPush');
		const BUFFERSHIFT = Symbol('bufferShift');
		const OBJECTMODE = Symbol('objectMode');
		// internal event when stream is destroyed
		const DESTROYED = Symbol('destroyed');
		// internal event when stream has an error
		const ERROR = Symbol('error');
		const EMITDATA = Symbol('emitData');
		const EMITEND = Symbol('emitEnd');
		const EMITEND2 = Symbol('emitEnd2');
		const ASYNC = Symbol('async');
		const ABORT = Symbol('abort');
		const ABORTED = Symbol('aborted');
		const SIGNAL = Symbol('signal');
		const DATALISTENERS = Symbol('dataListeners');
		const DISCARDED = Symbol('discarded');
		const defer = (fn) => Promise.resolve().then(fn);
		const nodefer = (fn) => fn();
		const isEndish = (ev) => ev === 'end' || ev === 'finish' || ev === 'prefinish';
		const isArrayBufferLike = (b) => b instanceof ArrayBuffer ||
		    (!!b &&
		        typeof b === 'object' &&
		        b.constructor &&
		        b.constructor.name === 'ArrayBuffer' &&
		        b.byteLength >= 0);
		const isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
		/**
		 * Internal class representing a pipe to a destination stream.
		 *
		 * @internal
		 */
		class Pipe {
		    src;
		    dest;
		    opts;
		    ondrain;
		    constructor(src, dest, opts) {
		        this.src = src;
		        this.dest = dest;
		        this.opts = opts;
		        this.ondrain = () => src[RESUME]();
		        this.dest.on('drain', this.ondrain);
		    }
		    unpipe() {
		        this.dest.removeListener('drain', this.ondrain);
		    }
		    // only here for the prototype
		    /* c8 ignore start */
		    proxyErrors(_er) { }
		    /* c8 ignore stop */
		    end() {
		        this.unpipe();
		        if (this.opts.end)
		            this.dest.end();
		    }
		}
		/**
		 * Internal class representing a pipe to a destination stream where
		 * errors are proxied.
		 *
		 * @internal
		 */
		class PipeProxyErrors extends Pipe {
		    unpipe() {
		        this.src.removeListener('error', this.proxyErrors);
		        super.unpipe();
		    }
		    constructor(src, dest, opts) {
		        super(src, dest, opts);
		        this.proxyErrors = er => dest.emit('error', er);
		        src.on('error', this.proxyErrors);
		    }
		}
		const isObjectModeOptions = (o) => !!o.objectMode;
		const isEncodingOptions = (o) => !o.objectMode && !!o.encoding && o.encoding !== 'buffer';
		/**
		 * Main export, the Minipass class
		 *
		 * `RType` is the type of data emitted, defaults to Buffer
		 *
		 * `WType` is the type of data to be written, if RType is buffer or string,
		 * then any {@link Minipass.ContiguousData} is allowed.
		 *
		 * `Events` is the set of event handler signatures that this object
		 * will emit, see {@link Minipass.Events}
		 */
		class Minipass extends node_events_1.EventEmitter {
		    [FLOWING] = false;
		    [PAUSED] = false;
		    [PIPES] = [];
		    [BUFFER] = [];
		    [OBJECTMODE];
		    [ENCODING];
		    [ASYNC];
		    [DECODER];
		    [EOF] = false;
		    [EMITTED_END] = false;
		    [EMITTING_END] = false;
		    [CLOSED] = false;
		    [EMITTED_ERROR] = null;
		    [BUFFERLENGTH] = 0;
		    [DESTROYED] = false;
		    [SIGNAL];
		    [ABORTED] = false;
		    [DATALISTENERS] = 0;
		    [DISCARDED] = false;
		    /**
		     * true if the stream can be written
		     */
		    writable = true;
		    /**
		     * true if the stream can be read
		     */
		    readable = true;
		    /**
		     * If `RType` is Buffer, then options do not need to be provided.
		     * Otherwise, an options object must be provided to specify either
		     * {@link Minipass.SharedOptions.objectMode} or
		     * {@link Minipass.SharedOptions.encoding}, as appropriate.
		     */
		    constructor(...args) {
		        const options = (args[0] ||
		            {});
		        super();
		        if (options.objectMode && typeof options.encoding === 'string') {
		            throw new TypeError('Encoding and objectMode may not be used together');
		        }
		        if (isObjectModeOptions(options)) {
		            this[OBJECTMODE] = true;
		            this[ENCODING] = null;
		        }
		        else if (isEncodingOptions(options)) {
		            this[ENCODING] = options.encoding;
		            this[OBJECTMODE] = false;
		        }
		        else {
		            this[OBJECTMODE] = false;
		            this[ENCODING] = null;
		        }
		        this[ASYNC] = !!options.async;
		        this[DECODER] = this[ENCODING]
		            ? new node_string_decoder_1.StringDecoder(this[ENCODING])
		            : null;
		        //@ts-ignore - private option for debugging and testing
		        if (options && options.debugExposeBuffer === true) {
		            Object.defineProperty(this, 'buffer', { get: () => this[BUFFER] });
		        }
		        //@ts-ignore - private option for debugging and testing
		        if (options && options.debugExposePipes === true) {
		            Object.defineProperty(this, 'pipes', { get: () => this[PIPES] });
		        }
		        const { signal } = options;
		        if (signal) {
		            this[SIGNAL] = signal;
		            if (signal.aborted) {
		                this[ABORT]();
		            }
		            else {
		                signal.addEventListener('abort', () => this[ABORT]());
		            }
		        }
		    }
		    /**
		     * The amount of data stored in the buffer waiting to be read.
		     *
		     * For Buffer strings, this will be the total byte length.
		     * For string encoding streams, this will be the string character length,
		     * according to JavaScript's `string.length` logic.
		     * For objectMode streams, this is a count of the items waiting to be
		     * emitted.
		     */
		    get bufferLength() {
		        return this[BUFFERLENGTH];
		    }
		    /**
		     * The `BufferEncoding` currently in use, or `null`
		     */
		    get encoding() {
		        return this[ENCODING];
		    }
		    /**
		     * @deprecated - This is a read only property
		     */
		    set encoding(_enc) {
		        throw new Error('Encoding must be set at instantiation time');
		    }
		    /**
		     * @deprecated - Encoding may only be set at instantiation time
		     */
		    setEncoding(_enc) {
		        throw new Error('Encoding must be set at instantiation time');
		    }
		    /**
		     * True if this is an objectMode stream
		     */
		    get objectMode() {
		        return this[OBJECTMODE];
		    }
		    /**
		     * @deprecated - This is a read-only property
		     */
		    set objectMode(_om) {
		        throw new Error('objectMode must be set at instantiation time');
		    }
		    /**
		     * true if this is an async stream
		     */
		    get ['async']() {
		        return this[ASYNC];
		    }
		    /**
		     * Set to true to make this stream async.
		     *
		     * Once set, it cannot be unset, as this would potentially cause incorrect
		     * behavior.  Ie, a sync stream can be made async, but an async stream
		     * cannot be safely made sync.
		     */
		    set ['async'](a) {
		        this[ASYNC] = this[ASYNC] || !!a;
		    }
		    // drop everything and get out of the flow completely
		    [ABORT]() {
		        this[ABORTED] = true;
		        this.emit('abort', this[SIGNAL]?.reason);
		        this.destroy(this[SIGNAL]?.reason);
		    }
		    /**
		     * True if the stream has been aborted.
		     */
		    get aborted() {
		        return this[ABORTED];
		    }
		    /**
		     * No-op setter. Stream aborted status is set via the AbortSignal provided
		     * in the constructor options.
		     */
		    set aborted(_) { }
		    write(chunk, encoding, cb) {
		        if (this[ABORTED])
		            return false;
		        if (this[EOF])
		            throw new Error('write after end');
		        if (this[DESTROYED]) {
		            this.emit('error', Object.assign(new Error('Cannot call write after a stream was destroyed'), { code: 'ERR_STREAM_DESTROYED' }));
		            return true;
		        }
		        if (typeof encoding === 'function') {
		            cb = encoding;
		            encoding = 'utf8';
		        }
		        if (!encoding)
		            encoding = 'utf8';
		        const fn = this[ASYNC] ? defer : nodefer;
		        // convert array buffers and typed array views into buffers
		        // at some point in the future, we may want to do the opposite!
		        // leave strings and buffers as-is
		        // anything is only allowed if in object mode, so throw
		        if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
		            if (isArrayBufferView(chunk)) {
		                //@ts-ignore - sinful unsafe type changing
		                chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
		            }
		            else if (isArrayBufferLike(chunk)) {
		                //@ts-ignore - sinful unsafe type changing
		                chunk = Buffer.from(chunk);
		            }
		            else if (typeof chunk !== 'string') {
		                throw new Error('Non-contiguous data written to non-objectMode stream');
		            }
		        }
		        // handle object mode up front, since it's simpler
		        // this yields better performance, fewer checks later.
		        if (this[OBJECTMODE]) {
		            // maybe impossible?
		            /* c8 ignore start */
		            if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
		                this[FLUSH](true);
		            /* c8 ignore stop */
		            if (this[FLOWING])
		                this.emit('data', chunk);
		            else
		                this[BUFFERPUSH](chunk);
		            if (this[BUFFERLENGTH] !== 0)
		                this.emit('readable');
		            if (cb)
		                fn(cb);
		            return this[FLOWING];
		        }
		        // at this point the chunk is a buffer or string
		        // don't buffer it up or send it to the decoder
		        if (!chunk.length) {
		            if (this[BUFFERLENGTH] !== 0)
		                this.emit('readable');
		            if (cb)
		                fn(cb);
		            return this[FLOWING];
		        }
		        // fast-path writing strings of same encoding to a stream with
		        // an empty buffer, skipping the buffer/decoder dance
		        if (typeof chunk === 'string' &&
		            // unless it is a string already ready for us to use
		            !(encoding === this[ENCODING] && !this[DECODER]?.lastNeed)) {
		            //@ts-ignore - sinful unsafe type change
		            chunk = Buffer.from(chunk, encoding);
		        }
		        if (Buffer.isBuffer(chunk) && this[ENCODING]) {
		            //@ts-ignore - sinful unsafe type change
		            chunk = this[DECODER].write(chunk);
		        }
		        // Note: flushing CAN potentially switch us into not-flowing mode
		        if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
		            this[FLUSH](true);
		        if (this[FLOWING])
		            this.emit('data', chunk);
		        else
		            this[BUFFERPUSH](chunk);
		        if (this[BUFFERLENGTH] !== 0)
		            this.emit('readable');
		        if (cb)
		            fn(cb);
		        return this[FLOWING];
		    }
		    /**
		     * Low-level explicit read method.
		     *
		     * In objectMode, the argument is ignored, and one item is returned if
		     * available.
		     *
		     * `n` is the number of bytes (or in the case of encoding streams,
		     * characters) to consume. If `n` is not provided, then the entire buffer
		     * is returned, or `null` is returned if no data is available.
		     *
		     * If `n` is greater that the amount of data in the internal buffer,
		     * then `null` is returned.
		     */
		    read(n) {
		        if (this[DESTROYED])
		            return null;
		        this[DISCARDED] = false;
		        if (this[BUFFERLENGTH] === 0 ||
		            n === 0 ||
		            (n && n > this[BUFFERLENGTH])) {
		            this[MAYBE_EMIT_END]();
		            return null;
		        }
		        if (this[OBJECTMODE])
		            n = null;
		        if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {
		            // not object mode, so if we have an encoding, then RType is string
		            // otherwise, must be Buffer
		            this[BUFFER] = [
		                (this[ENCODING]
		                    ? this[BUFFER].join('')
		                    : Buffer.concat(this[BUFFER], this[BUFFERLENGTH])),
		            ];
		        }
		        const ret = this[READ](n || null, this[BUFFER][0]);
		        this[MAYBE_EMIT_END]();
		        return ret;
		    }
		    [READ](n, chunk) {
		        if (this[OBJECTMODE])
		            this[BUFFERSHIFT]();
		        else {
		            const c = chunk;
		            if (n === c.length || n === null)
		                this[BUFFERSHIFT]();
		            else if (typeof c === 'string') {
		                this[BUFFER][0] = c.slice(n);
		                chunk = c.slice(0, n);
		                this[BUFFERLENGTH] -= n;
		            }
		            else {
		                this[BUFFER][0] = c.subarray(n);
		                chunk = c.subarray(0, n);
		                this[BUFFERLENGTH] -= n;
		            }
		        }
		        this.emit('data', chunk);
		        if (!this[BUFFER].length && !this[EOF])
		            this.emit('drain');
		        return chunk;
		    }
		    end(chunk, encoding, cb) {
		        if (typeof chunk === 'function') {
		            cb = chunk;
		            chunk = undefined;
		        }
		        if (typeof encoding === 'function') {
		            cb = encoding;
		            encoding = 'utf8';
		        }
		        if (chunk !== undefined)
		            this.write(chunk, encoding);
		        if (cb)
		            this.once('end', cb);
		        this[EOF] = true;
		        this.writable = false;
		        // if we haven't written anything, then go ahead and emit,
		        // even if we're not reading.
		        // we'll re-emit if a new 'end' listener is added anyway.
		        // This makes MP more suitable to write-only use cases.
		        if (this[FLOWING] || !this[PAUSED])
		            this[MAYBE_EMIT_END]();
		        return this;
		    }
		    // don't let the internal resume be overwritten
		    [RESUME]() {
		        if (this[DESTROYED])
		            return;
		        if (!this[DATALISTENERS] && !this[PIPES].length) {
		            this[DISCARDED] = true;
		        }
		        this[PAUSED] = false;
		        this[FLOWING] = true;
		        this.emit('resume');
		        if (this[BUFFER].length)
		            this[FLUSH]();
		        else if (this[EOF])
		            this[MAYBE_EMIT_END]();
		        else
		            this.emit('drain');
		    }
		    /**
		     * Resume the stream if it is currently in a paused state
		     *
		     * If called when there are no pipe destinations or `data` event listeners,
		     * this will place the stream in a "discarded" state, where all data will
		     * be thrown away. The discarded state is removed if a pipe destination or
		     * data handler is added, if pause() is called, or if any synchronous or
		     * asynchronous iteration is started.
		     */
		    resume() {
		        return this[RESUME]();
		    }
		    /**
		     * Pause the stream
		     */
		    pause() {
		        this[FLOWING] = false;
		        this[PAUSED] = true;
		        this[DISCARDED] = false;
		    }
		    /**
		     * true if the stream has been forcibly destroyed
		     */
		    get destroyed() {
		        return this[DESTROYED];
		    }
		    /**
		     * true if the stream is currently in a flowing state, meaning that
		     * any writes will be immediately emitted.
		     */
		    get flowing() {
		        return this[FLOWING];
		    }
		    /**
		     * true if the stream is currently in a paused state
		     */
		    get paused() {
		        return this[PAUSED];
		    }
		    [BUFFERPUSH](chunk) {
		        if (this[OBJECTMODE])
		            this[BUFFERLENGTH] += 1;
		        else
		            this[BUFFERLENGTH] += chunk.length;
		        this[BUFFER].push(chunk);
		    }
		    [BUFFERSHIFT]() {
		        if (this[OBJECTMODE])
		            this[BUFFERLENGTH] -= 1;
		        else
		            this[BUFFERLENGTH] -= this[BUFFER][0].length;
		        return this[BUFFER].shift();
		    }
		    [FLUSH](noDrain = false) {
		        do { } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) &&
		            this[BUFFER].length);
		        if (!noDrain && !this[BUFFER].length && !this[EOF])
		            this.emit('drain');
		    }
		    [FLUSHCHUNK](chunk) {
		        this.emit('data', chunk);
		        return this[FLOWING];
		    }
		    /**
		     * Pipe all data emitted by this stream into the destination provided.
		     *
		     * Triggers the flow of data.
		     */
		    pipe(dest, opts) {
		        if (this[DESTROYED])
		            return dest;
		        this[DISCARDED] = false;
		        const ended = this[EMITTED_END];
		        opts = opts || {};
		        if (dest === proc.stdout || dest === proc.stderr)
		            opts.end = false;
		        else
		            opts.end = opts.end !== false;
		        opts.proxyErrors = !!opts.proxyErrors;
		        // piping an ended stream ends immediately
		        if (ended) {
		            if (opts.end)
		                dest.end();
		        }
		        else {
		            // "as" here just ignores the WType, which pipes don't care about,
		            // since they're only consuming from us, and writing to the dest
		            this[PIPES].push(!opts.proxyErrors
		                ? new Pipe(this, dest, opts)
		                : new PipeProxyErrors(this, dest, opts));
		            if (this[ASYNC])
		                defer(() => this[RESUME]());
		            else
		                this[RESUME]();
		        }
		        return dest;
		    }
		    /**
		     * Fully unhook a piped destination stream.
		     *
		     * If the destination stream was the only consumer of this stream (ie,
		     * there are no other piped destinations or `'data'` event listeners)
		     * then the flow of data will stop until there is another consumer or
		     * {@link Minipass#resume} is explicitly called.
		     */
		    unpipe(dest) {
		        const p = this[PIPES].find(p => p.dest === dest);
		        if (p) {
		            if (this[PIPES].length === 1) {
		                if (this[FLOWING] && this[DATALISTENERS] === 0) {
		                    this[FLOWING] = false;
		                }
		                this[PIPES] = [];
		            }
		            else
		                this[PIPES].splice(this[PIPES].indexOf(p), 1);
		            p.unpipe();
		        }
		    }
		    /**
		     * Alias for {@link Minipass#on}
		     */
		    addListener(ev, handler) {
		        return this.on(ev, handler);
		    }
		    /**
		     * Mostly identical to `EventEmitter.on`, with the following
		     * behavior differences to prevent data loss and unnecessary hangs:
		     *
		     * - Adding a 'data' event handler will trigger the flow of data
		     *
		     * - Adding a 'readable' event handler when there is data waiting to be read
		     *   will cause 'readable' to be emitted immediately.
		     *
		     * - Adding an 'endish' event handler ('end', 'finish', etc.) which has
		     *   already passed will cause the event to be emitted immediately and all
		     *   handlers removed.
		     *
		     * - Adding an 'error' event handler after an error has been emitted will
		     *   cause the event to be re-emitted immediately with the error previously
		     *   raised.
		     */
		    on(ev, handler) {
		        const ret = super.on(ev, handler);
		        if (ev === 'data') {
		            this[DISCARDED] = false;
		            this[DATALISTENERS]++;
		            if (!this[PIPES].length && !this[FLOWING]) {
		                this[RESUME]();
		            }
		        }
		        else if (ev === 'readable' && this[BUFFERLENGTH] !== 0) {
		            super.emit('readable');
		        }
		        else if (isEndish(ev) && this[EMITTED_END]) {
		            super.emit(ev);
		            this.removeAllListeners(ev);
		        }
		        else if (ev === 'error' && this[EMITTED_ERROR]) {
		            const h = handler;
		            if (this[ASYNC])
		                defer(() => h.call(this, this[EMITTED_ERROR]));
		            else
		                h.call(this, this[EMITTED_ERROR]);
		        }
		        return ret;
		    }
		    /**
		     * Alias for {@link Minipass#off}
		     */
		    removeListener(ev, handler) {
		        return this.off(ev, handler);
		    }
		    /**
		     * Mostly identical to `EventEmitter.off`
		     *
		     * If a 'data' event handler is removed, and it was the last consumer
		     * (ie, there are no pipe destinations or other 'data' event listeners),
		     * then the flow of data will stop until there is another consumer or
		     * {@link Minipass#resume} is explicitly called.
		     */
		    off(ev, handler) {
		        const ret = super.off(ev, handler);
		        // if we previously had listeners, and now we don't, and we don't
		        // have any pipes, then stop the flow, unless it's been explicitly
		        // put in a discarded flowing state via stream.resume().
		        if (ev === 'data') {
		            this[DATALISTENERS] = this.listeners('data').length;
		            if (this[DATALISTENERS] === 0 &&
		                !this[DISCARDED] &&
		                !this[PIPES].length) {
		                this[FLOWING] = false;
		            }
		        }
		        return ret;
		    }
		    /**
		     * Mostly identical to `EventEmitter.removeAllListeners`
		     *
		     * If all 'data' event handlers are removed, and they were the last consumer
		     * (ie, there are no pipe destinations), then the flow of data will stop
		     * until there is another consumer or {@link Minipass#resume} is explicitly
		     * called.
		     */
		    removeAllListeners(ev) {
		        const ret = super.removeAllListeners(ev);
		        if (ev === 'data' || ev === undefined) {
		            this[DATALISTENERS] = 0;
		            if (!this[DISCARDED] && !this[PIPES].length) {
		                this[FLOWING] = false;
		            }
		        }
		        return ret;
		    }
		    /**
		     * true if the 'end' event has been emitted
		     */
		    get emittedEnd() {
		        return this[EMITTED_END];
		    }
		    [MAYBE_EMIT_END]() {
		        if (!this[EMITTING_END] &&
		            !this[EMITTED_END] &&
		            !this[DESTROYED] &&
		            this[BUFFER].length === 0 &&
		            this[EOF]) {
		            this[EMITTING_END] = true;
		            this.emit('end');
		            this.emit('prefinish');
		            this.emit('finish');
		            if (this[CLOSED])
		                this.emit('close');
		            this[EMITTING_END] = false;
		        }
		    }
		    /**
		     * Mostly identical to `EventEmitter.emit`, with the following
		     * behavior differences to prevent data loss and unnecessary hangs:
		     *
		     * If the stream has been destroyed, and the event is something other
		     * than 'close' or 'error', then `false` is returned and no handlers
		     * are called.
		     *
		     * If the event is 'end', and has already been emitted, then the event
		     * is ignored. If the stream is in a paused or non-flowing state, then
		     * the event will be deferred until data flow resumes. If the stream is
		     * async, then handlers will be called on the next tick rather than
		     * immediately.
		     *
		     * If the event is 'close', and 'end' has not yet been emitted, then
		     * the event will be deferred until after 'end' is emitted.
		     *
		     * If the event is 'error', and an AbortSignal was provided for the stream,
		     * and there are no listeners, then the event is ignored, matching the
		     * behavior of node core streams in the presense of an AbortSignal.
		     *
		     * If the event is 'finish' or 'prefinish', then all listeners will be
		     * removed after emitting the event, to prevent double-firing.
		     */
		    emit(ev, ...args) {
		        const data = args[0];
		        // error and close are only events allowed after calling destroy()
		        if (ev !== 'error' &&
		            ev !== 'close' &&
		            ev !== DESTROYED &&
		            this[DESTROYED]) {
		            return false;
		        }
		        else if (ev === 'data') {
		            return !this[OBJECTMODE] && !data
		                ? false
		                : this[ASYNC]
		                    ? (defer(() => this[EMITDATA](data)), true)
		                    : this[EMITDATA](data);
		        }
		        else if (ev === 'end') {
		            return this[EMITEND]();
		        }
		        else if (ev === 'close') {
		            this[CLOSED] = true;
		            // don't emit close before 'end' and 'finish'
		            if (!this[EMITTED_END] && !this[DESTROYED])
		                return false;
		            const ret = super.emit('close');
		            this.removeAllListeners('close');
		            return ret;
		        }
		        else if (ev === 'error') {
		            this[EMITTED_ERROR] = data;
		            super.emit(ERROR, data);
		            const ret = !this[SIGNAL] || this.listeners('error').length
		                ? super.emit('error', data)
		                : false;
		            this[MAYBE_EMIT_END]();
		            return ret;
		        }
		        else if (ev === 'resume') {
		            const ret = super.emit('resume');
		            this[MAYBE_EMIT_END]();
		            return ret;
		        }
		        else if (ev === 'finish' || ev === 'prefinish') {
		            const ret = super.emit(ev);
		            this.removeAllListeners(ev);
		            return ret;
		        }
		        // Some other unknown event
		        const ret = super.emit(ev, ...args);
		        this[MAYBE_EMIT_END]();
		        return ret;
		    }
		    [EMITDATA](data) {
		        for (const p of this[PIPES]) {
		            if (p.dest.write(data) === false)
		                this.pause();
		        }
		        const ret = this[DISCARDED] ? false : super.emit('data', data);
		        this[MAYBE_EMIT_END]();
		        return ret;
		    }
		    [EMITEND]() {
		        if (this[EMITTED_END])
		            return false;
		        this[EMITTED_END] = true;
		        this.readable = false;
		        return this[ASYNC]
		            ? (defer(() => this[EMITEND2]()), true)
		            : this[EMITEND2]();
		    }
		    [EMITEND2]() {
		        if (this[DECODER]) {
		            const data = this[DECODER].end();
		            if (data) {
		                for (const p of this[PIPES]) {
		                    p.dest.write(data);
		                }
		                if (!this[DISCARDED])
		                    super.emit('data', data);
		            }
		        }
		        for (const p of this[PIPES]) {
		            p.end();
		        }
		        const ret = super.emit('end');
		        this.removeAllListeners('end');
		        return ret;
		    }
		    /**
		     * Return a Promise that resolves to an array of all emitted data once
		     * the stream ends.
		     */
		    async collect() {
		        const buf = Object.assign([], {
		            dataLength: 0,
		        });
		        if (!this[OBJECTMODE])
		            buf.dataLength = 0;
		        // set the promise first, in case an error is raised
		        // by triggering the flow here.
		        const p = this.promise();
		        this.on('data', c => {
		            buf.push(c);
		            if (!this[OBJECTMODE])
		                buf.dataLength += c.length;
		        });
		        await p;
		        return buf;
		    }
		    /**
		     * Return a Promise that resolves to the concatenation of all emitted data
		     * once the stream ends.
		     *
		     * Not allowed on objectMode streams.
		     */
		    async concat() {
		        if (this[OBJECTMODE]) {
		            throw new Error('cannot concat in objectMode');
		        }
		        const buf = await this.collect();
		        return (this[ENCODING]
		            ? buf.join('')
		            : Buffer.concat(buf, buf.dataLength));
		    }
		    /**
		     * Return a void Promise that resolves once the stream ends.
		     */
		    async promise() {
		        return new Promise((resolve, reject) => {
		            this.on(DESTROYED, () => reject(new Error('stream destroyed')));
		            this.on('error', er => reject(er));
		            this.on('end', () => resolve());
		        });
		    }
		    /**
		     * Asynchronous `for await of` iteration.
		     *
		     * This will continue emitting all chunks until the stream terminates.
		     */
		    [Symbol.asyncIterator]() {
		        // set this up front, in case the consumer doesn't call next()
		        // right away.
		        this[DISCARDED] = false;
		        let stopped = false;
		        const stop = async () => {
		            this.pause();
		            stopped = true;
		            return { value: undefined, done: true };
		        };
		        const next = () => {
		            if (stopped)
		                return stop();
		            const res = this.read();
		            if (res !== null)
		                return Promise.resolve({ done: false, value: res });
		            if (this[EOF])
		                return stop();
		            let resolve;
		            let reject;
		            const onerr = (er) => {
		                this.off('data', ondata);
		                this.off('end', onend);
		                this.off(DESTROYED, ondestroy);
		                stop();
		                reject(er);
		            };
		            const ondata = (value) => {
		                this.off('error', onerr);
		                this.off('end', onend);
		                this.off(DESTROYED, ondestroy);
		                this.pause();
		                resolve({ value, done: !!this[EOF] });
		            };
		            const onend = () => {
		                this.off('error', onerr);
		                this.off('data', ondata);
		                this.off(DESTROYED, ondestroy);
		                stop();
		                resolve({ done: true, value: undefined });
		            };
		            const ondestroy = () => onerr(new Error('stream destroyed'));
		            return new Promise((res, rej) => {
		                reject = rej;
		                resolve = res;
		                this.once(DESTROYED, ondestroy);
		                this.once('error', onerr);
		                this.once('end', onend);
		                this.once('data', ondata);
		            });
		        };
		        return {
		            next,
		            throw: stop,
		            return: stop,
		            [Symbol.asyncIterator]() {
		                return this;
		            },
		        };
		    }
		    /**
		     * Synchronous `for of` iteration.
		     *
		     * The iteration will terminate when the internal buffer runs out, even
		     * if the stream has not yet terminated.
		     */
		    [Symbol.iterator]() {
		        // set this up front, in case the consumer doesn't call next()
		        // right away.
		        this[DISCARDED] = false;
		        let stopped = false;
		        const stop = () => {
		            this.pause();
		            this.off(ERROR, stop);
		            this.off(DESTROYED, stop);
		            this.off('end', stop);
		            stopped = true;
		            return { done: true, value: undefined };
		        };
		        const next = () => {
		            if (stopped)
		                return stop();
		            const value = this.read();
		            return value === null ? stop() : { done: false, value };
		        };
		        this.once('end', stop);
		        this.once(ERROR, stop);
		        this.once(DESTROYED, stop);
		        return {
		            next,
		            throw: stop,
		            return: stop,
		            [Symbol.iterator]() {
		                return this;
		            },
		        };
		    }
		    /**
		     * Destroy a stream, preventing it from being used for any further purpose.
		     *
		     * If the stream has a `close()` method, then it will be called on
		     * destruction.
		     *
		     * After destruction, any attempt to write data, read data, or emit most
		     * events will be ignored.
		     *
		     * If an error argument is provided, then it will be emitted in an
		     * 'error' event.
		     */
		    destroy(er) {
		        if (this[DESTROYED]) {
		            if (er)
		                this.emit('error', er);
		            else
		                this.emit(DESTROYED);
		            return this;
		        }
		        this[DESTROYED] = true;
		        this[DISCARDED] = true;
		        // throw away all buffered data, it's never coming out
		        this[BUFFER].length = 0;
		        this[BUFFERLENGTH] = 0;
		        const wc = this;
		        if (typeof wc.close === 'function' && !this[CLOSED])
		            wc.close();
		        if (er)
		            this.emit('error', er);
		        // if no error to emit, still reject pending promises
		        else
		            this.emit(DESTROYED);
		        return this;
		    }
		    /**
		     * Alias for {@link isStream}
		     *
		     * Former export location, maintained for backwards compatibility.
		     *
		     * @deprecated
		     */
		    static get isStream() {
		        return exports.isStream;
		    }
		}
		exports.Minipass = Minipass;
		
	} (commonjs));
	return commonjs;
}

var hasRequiredCommonjs$1;

function requireCommonjs$1 () {
	if (hasRequiredCommonjs$1) return commonjs$2;
	hasRequiredCommonjs$1 = 1;
	var __createBinding = (commonjs$2 && commonjs$2.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjs$2 && commonjs$2.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjs$2 && commonjs$2.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(commonjs$2, "__esModule", { value: true });
	commonjs$2.PathScurry = commonjs$2.Path = commonjs$2.PathScurryDarwin = commonjs$2.PathScurryPosix = commonjs$2.PathScurryWin32 = commonjs$2.PathScurryBase = commonjs$2.PathPosix = commonjs$2.PathWin32 = commonjs$2.PathBase = commonjs$2.ChildrenCache = commonjs$2.ResolveCache = void 0;
	const lru_cache_1 = /*@__PURE__*/ requireCommonjs$3();
	const node_path_1 = path$1;
	const node_url_1 = require$$1$3;
	const fs_1 = fs;
	const actualFS = __importStar(fs$1);
	const realpathSync = fs_1.realpathSync.native;
	// TODO: test perf of fs/promises realpath vs realpathCB,
	// since the promises one uses realpath.native
	const promises_1 = require$$5;
	const minipass_1 = requireCommonjs$2();
	const defaultFS = {
	    lstatSync: fs_1.lstatSync,
	    readdir: fs_1.readdir,
	    readdirSync: fs_1.readdirSync,
	    readlinkSync: fs_1.readlinkSync,
	    realpathSync,
	    promises: {
	        lstat: promises_1.lstat,
	        readdir: promises_1.readdir,
	        readlink: promises_1.readlink,
	        realpath: promises_1.realpath,
	    },
	};
	// if they just gave us require('fs') then use our default
	const fsFromOption = (fsOption) => !fsOption || fsOption === defaultFS || fsOption === actualFS ?
	    defaultFS
	    : {
	        ...defaultFS,
	        ...fsOption,
	        promises: {
	            ...defaultFS.promises,
	            ...(fsOption.promises || {}),
	        },
	    };
	// turn something like //?/c:/ into c:\
	const uncDriveRegexp = /^\\\\\?\\([a-z]:)\\?$/i;
	const uncToDrive = (rootPath) => rootPath.replace(/\//g, '\\').replace(uncDriveRegexp, '$1\\');
	// windows paths are separated by either / or \
	const eitherSep = /[\\\/]/;
	const UNKNOWN = 0; // may not even exist, for all we know
	const IFIFO = 0b0001;
	const IFCHR = 0b0010;
	const IFDIR = 0b0100;
	const IFBLK = 0b0110;
	const IFREG = 0b1000;
	const IFLNK = 0b1010;
	const IFSOCK = 0b1100;
	const IFMT = 0b1111;
	// mask to unset low 4 bits
	const IFMT_UNKNOWN = ~IFMT;
	// set after successfully calling readdir() and getting entries.
	const READDIR_CALLED = 0b0000_0001_0000;
	// set after a successful lstat()
	const LSTAT_CALLED = 0b0000_0010_0000;
	// set if an entry (or one of its parents) is definitely not a dir
	const ENOTDIR = 0b0000_0100_0000;
	// set if an entry (or one of its parents) does not exist
	// (can also be set on lstat errors like EACCES or ENAMETOOLONG)
	const ENOENT = 0b0000_1000_0000;
	// cannot have child entries -- also verify &IFMT is either IFDIR or IFLNK
	// set if we fail to readlink
	const ENOREADLINK = 0b0001_0000_0000;
	// set if we know realpath() will fail
	const ENOREALPATH = 0b0010_0000_0000;
	const ENOCHILD = ENOTDIR | ENOENT | ENOREALPATH;
	const TYPEMASK = 0b0011_1111_1111;
	const entToType = (s) => s.isFile() ? IFREG
	    : s.isDirectory() ? IFDIR
	        : s.isSymbolicLink() ? IFLNK
	            : s.isCharacterDevice() ? IFCHR
	                : s.isBlockDevice() ? IFBLK
	                    : s.isSocket() ? IFSOCK
	                        : s.isFIFO() ? IFIFO
	                            : UNKNOWN;
	// normalize unicode path names
	const normalizeCache = new Map();
	const normalize = (s) => {
	    const c = normalizeCache.get(s);
	    if (c)
	        return c;
	    const n = s.normalize('NFKD');
	    normalizeCache.set(s, n);
	    return n;
	};
	const normalizeNocaseCache = new Map();
	const normalizeNocase = (s) => {
	    const c = normalizeNocaseCache.get(s);
	    if (c)
	        return c;
	    const n = normalize(s.toLowerCase());
	    normalizeNocaseCache.set(s, n);
	    return n;
	};
	/**
	 * An LRUCache for storing resolved path strings or Path objects.
	 * @internal
	 */
	class ResolveCache extends lru_cache_1.LRUCache {
	    constructor() {
	        super({ max: 256 });
	    }
	}
	commonjs$2.ResolveCache = ResolveCache;
	// In order to prevent blowing out the js heap by allocating hundreds of
	// thousands of Path entries when walking extremely large trees, the "children"
	// in this tree are represented by storing an array of Path entries in an
	// LRUCache, indexed by the parent.  At any time, Path.children() may return an
	// empty array, indicating that it doesn't know about any of its children, and
	// thus has to rebuild that cache.  This is fine, it just means that we don't
	// benefit as much from having the cached entries, but huge directory walks
	// don't blow out the stack, and smaller ones are still as fast as possible.
	//
	//It does impose some complexity when building up the readdir data, because we
	//need to pass a reference to the children array that we started with.
	/**
	 * an LRUCache for storing child entries.
	 * @internal
	 */
	class ChildrenCache extends lru_cache_1.LRUCache {
	    constructor(maxSize = 16 * 1024) {
	        super({
	            maxSize,
	            // parent + children
	            sizeCalculation: a => a.length + 1,
	        });
	    }
	}
	commonjs$2.ChildrenCache = ChildrenCache;
	const setAsCwd = Symbol('PathScurry setAsCwd');
	/**
	 * Path objects are sort of like a super-powered
	 * {@link https://nodejs.org/docs/latest/api/fs.html#class-fsdirent fs.Dirent}
	 *
	 * Each one represents a single filesystem entry on disk, which may or may not
	 * exist. It includes methods for reading various types of information via
	 * lstat, readlink, and readdir, and caches all information to the greatest
	 * degree possible.
	 *
	 * Note that fs operations that would normally throw will instead return an
	 * "empty" value. This is in order to prevent excessive overhead from error
	 * stack traces.
	 */
	class PathBase {
	    /**
	     * the basename of this path
	     *
	     * **Important**: *always* test the path name against any test string
	     * usingthe {@link isNamed} method, and not by directly comparing this
	     * string. Otherwise, unicode path strings that the system sees as identical
	     * will not be properly treated as the same path, leading to incorrect
	     * behavior and possible security issues.
	     */
	    name;
	    /**
	     * the Path entry corresponding to the path root.
	     *
	     * @internal
	     */
	    root;
	    /**
	     * All roots found within the current PathScurry family
	     *
	     * @internal
	     */
	    roots;
	    /**
	     * a reference to the parent path, or undefined in the case of root entries
	     *
	     * @internal
	     */
	    parent;
	    /**
	     * boolean indicating whether paths are compared case-insensitively
	     * @internal
	     */
	    nocase;
	    /**
	     * boolean indicating that this path is the current working directory
	     * of the PathScurry collection that contains it.
	     */
	    isCWD = false;
	    // potential default fs override
	    #fs;
	    // Stats fields
	    #dev;
	    get dev() {
	        return this.#dev;
	    }
	    #mode;
	    get mode() {
	        return this.#mode;
	    }
	    #nlink;
	    get nlink() {
	        return this.#nlink;
	    }
	    #uid;
	    get uid() {
	        return this.#uid;
	    }
	    #gid;
	    get gid() {
	        return this.#gid;
	    }
	    #rdev;
	    get rdev() {
	        return this.#rdev;
	    }
	    #blksize;
	    get blksize() {
	        return this.#blksize;
	    }
	    #ino;
	    get ino() {
	        return this.#ino;
	    }
	    #size;
	    get size() {
	        return this.#size;
	    }
	    #blocks;
	    get blocks() {
	        return this.#blocks;
	    }
	    #atimeMs;
	    get atimeMs() {
	        return this.#atimeMs;
	    }
	    #mtimeMs;
	    get mtimeMs() {
	        return this.#mtimeMs;
	    }
	    #ctimeMs;
	    get ctimeMs() {
	        return this.#ctimeMs;
	    }
	    #birthtimeMs;
	    get birthtimeMs() {
	        return this.#birthtimeMs;
	    }
	    #atime;
	    get atime() {
	        return this.#atime;
	    }
	    #mtime;
	    get mtime() {
	        return this.#mtime;
	    }
	    #ctime;
	    get ctime() {
	        return this.#ctime;
	    }
	    #birthtime;
	    get birthtime() {
	        return this.#birthtime;
	    }
	    #matchName;
	    #depth;
	    #fullpath;
	    #fullpathPosix;
	    #relative;
	    #relativePosix;
	    #type;
	    #children;
	    #linkTarget;
	    #realpath;
	    /**
	     * This property is for compatibility with the Dirent class as of
	     * Node v20, where Dirent['parentPath'] refers to the path of the
	     * directory that was passed to readdir. For root entries, it's the path
	     * to the entry itself.
	     */
	    get parentPath() {
	        return (this.parent || this).fullpath();
	    }
	    /**
	     * Deprecated alias for Dirent['parentPath'] Somewhat counterintuitively,
	     * this property refers to the *parent* path, not the path object itself.
	     *
	     * @deprecated
	     */
	    get path() {
	        return this.parentPath;
	    }
	    /**
	     * Do not create new Path objects directly.  They should always be accessed
	     * via the PathScurry class or other methods on the Path class.
	     *
	     * @internal
	     */
	    constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
	        this.name = name;
	        this.#matchName = nocase ? normalizeNocase(name) : normalize(name);
	        this.#type = type & TYPEMASK;
	        this.nocase = nocase;
	        this.roots = roots;
	        this.root = root || this;
	        this.#children = children;
	        this.#fullpath = opts.fullpath;
	        this.#relative = opts.relative;
	        this.#relativePosix = opts.relativePosix;
	        this.parent = opts.parent;
	        if (this.parent) {
	            this.#fs = this.parent.#fs;
	        }
	        else {
	            this.#fs = fsFromOption(opts.fs);
	        }
	    }
	    /**
	     * Returns the depth of the Path object from its root.
	     *
	     * For example, a path at `/foo/bar` would have a depth of 2.
	     */
	    depth() {
	        if (this.#depth !== undefined)
	            return this.#depth;
	        if (!this.parent)
	            return (this.#depth = 0);
	        return (this.#depth = this.parent.depth() + 1);
	    }
	    /**
	     * @internal
	     */
	    childrenCache() {
	        return this.#children;
	    }
	    /**
	     * Get the Path object referenced by the string path, resolved from this Path
	     */
	    resolve(path) {
	        if (!path) {
	            return this;
	        }
	        const rootPath = this.getRootString(path);
	        const dir = path.substring(rootPath.length);
	        const dirParts = dir.split(this.splitSep);
	        const result = rootPath ?
	            this.getRoot(rootPath).#resolveParts(dirParts)
	            : this.#resolveParts(dirParts);
	        return result;
	    }
	    #resolveParts(dirParts) {
	        let p = this;
	        for (const part of dirParts) {
	            p = p.child(part);
	        }
	        return p;
	    }
	    /**
	     * Returns the cached children Path objects, if still available.  If they
	     * have fallen out of the cache, then returns an empty array, and resets the
	     * READDIR_CALLED bit, so that future calls to readdir() will require an fs
	     * lookup.
	     *
	     * @internal
	     */
	    children() {
	        const cached = this.#children.get(this);
	        if (cached) {
	            return cached;
	        }
	        const children = Object.assign([], { provisional: 0 });
	        this.#children.set(this, children);
	        this.#type &= ~READDIR_CALLED;
	        return children;
	    }
	    /**
	     * Resolves a path portion and returns or creates the child Path.
	     *
	     * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is
	     * `'..'`.
	     *
	     * This should not be called directly.  If `pathPart` contains any path
	     * separators, it will lead to unsafe undefined behavior.
	     *
	     * Use `Path.resolve()` instead.
	     *
	     * @internal
	     */
	    child(pathPart, opts) {
	        if (pathPart === '' || pathPart === '.') {
	            return this;
	        }
	        if (pathPart === '..') {
	            return this.parent || this;
	        }
	        // find the child
	        const children = this.children();
	        const name = this.nocase ? normalizeNocase(pathPart) : normalize(pathPart);
	        for (const p of children) {
	            if (p.#matchName === name) {
	                return p;
	            }
	        }
	        // didn't find it, create provisional child, since it might not
	        // actually exist.  If we know the parent isn't a dir, then
	        // in fact it CAN'T exist.
	        const s = this.parent ? this.sep : '';
	        const fullpath = this.#fullpath ? this.#fullpath + s + pathPart : undefined;
	        const pchild = this.newChild(pathPart, UNKNOWN, {
	            ...opts,
	            parent: this,
	            fullpath,
	        });
	        if (!this.canReaddir()) {
	            pchild.#type |= ENOENT;
	        }
	        // don't have to update provisional, because if we have real children,
	        // then provisional is set to children.length, otherwise a lower number
	        children.push(pchild);
	        return pchild;
	    }
	    /**
	     * The relative path from the cwd. If it does not share an ancestor with
	     * the cwd, then this ends up being equivalent to the fullpath()
	     */
	    relative() {
	        if (this.isCWD)
	            return '';
	        if (this.#relative !== undefined) {
	            return this.#relative;
	        }
	        const name = this.name;
	        const p = this.parent;
	        if (!p) {
	            return (this.#relative = this.name);
	        }
	        const pv = p.relative();
	        return pv + (!pv || !p.parent ? '' : this.sep) + name;
	    }
	    /**
	     * The relative path from the cwd, using / as the path separator.
	     * If it does not share an ancestor with
	     * the cwd, then this ends up being equivalent to the fullpathPosix()
	     * On posix systems, this is identical to relative().
	     */
	    relativePosix() {
	        if (this.sep === '/')
	            return this.relative();
	        if (this.isCWD)
	            return '';
	        if (this.#relativePosix !== undefined)
	            return this.#relativePosix;
	        const name = this.name;
	        const p = this.parent;
	        if (!p) {
	            return (this.#relativePosix = this.fullpathPosix());
	        }
	        const pv = p.relativePosix();
	        return pv + (!pv || !p.parent ? '' : '/') + name;
	    }
	    /**
	     * The fully resolved path string for this Path entry
	     */
	    fullpath() {
	        if (this.#fullpath !== undefined) {
	            return this.#fullpath;
	        }
	        const name = this.name;
	        const p = this.parent;
	        if (!p) {
	            return (this.#fullpath = this.name);
	        }
	        const pv = p.fullpath();
	        const fp = pv + (!p.parent ? '' : this.sep) + name;
	        return (this.#fullpath = fp);
	    }
	    /**
	     * On platforms other than windows, this is identical to fullpath.
	     *
	     * On windows, this is overridden to return the forward-slash form of the
	     * full UNC path.
	     */
	    fullpathPosix() {
	        if (this.#fullpathPosix !== undefined)
	            return this.#fullpathPosix;
	        if (this.sep === '/')
	            return (this.#fullpathPosix = this.fullpath());
	        if (!this.parent) {
	            const p = this.fullpath().replace(/\\/g, '/');
	            if (/^[a-z]:\//i.test(p)) {
	                return (this.#fullpathPosix = `//?/${p}`);
	            }
	            else {
	                return (this.#fullpathPosix = p);
	            }
	        }
	        const p = this.parent;
	        const pfpp = p.fullpathPosix();
	        const fpp = pfpp + (!pfpp || !p.parent ? '' : '/') + this.name;
	        return (this.#fullpathPosix = fpp);
	    }
	    /**
	     * Is the Path of an unknown type?
	     *
	     * Note that we might know *something* about it if there has been a previous
	     * filesystem operation, for example that it does not exist, or is not a
	     * link, or whether it has child entries.
	     */
	    isUnknown() {
	        return (this.#type & IFMT) === UNKNOWN;
	    }
	    isType(type) {
	        return this[`is${type}`]();
	    }
	    getType() {
	        return (this.isUnknown() ? 'Unknown'
	            : this.isDirectory() ? 'Directory'
	                : this.isFile() ? 'File'
	                    : this.isSymbolicLink() ? 'SymbolicLink'
	                        : this.isFIFO() ? 'FIFO'
	                            : this.isCharacterDevice() ? 'CharacterDevice'
	                                : this.isBlockDevice() ? 'BlockDevice'
	                                    : /* c8 ignore start */ this.isSocket() ? 'Socket'
	                                        : 'Unknown');
	        /* c8 ignore stop */
	    }
	    /**
	     * Is the Path a regular file?
	     */
	    isFile() {
	        return (this.#type & IFMT) === IFREG;
	    }
	    /**
	     * Is the Path a directory?
	     */
	    isDirectory() {
	        return (this.#type & IFMT) === IFDIR;
	    }
	    /**
	     * Is the path a character device?
	     */
	    isCharacterDevice() {
	        return (this.#type & IFMT) === IFCHR;
	    }
	    /**
	     * Is the path a block device?
	     */
	    isBlockDevice() {
	        return (this.#type & IFMT) === IFBLK;
	    }
	    /**
	     * Is the path a FIFO pipe?
	     */
	    isFIFO() {
	        return (this.#type & IFMT) === IFIFO;
	    }
	    /**
	     * Is the path a socket?
	     */
	    isSocket() {
	        return (this.#type & IFMT) === IFSOCK;
	    }
	    /**
	     * Is the path a symbolic link?
	     */
	    isSymbolicLink() {
	        return (this.#type & IFLNK) === IFLNK;
	    }
	    /**
	     * Return the entry if it has been subject of a successful lstat, or
	     * undefined otherwise.
	     *
	     * Does not read the filesystem, so an undefined result *could* simply
	     * mean that we haven't called lstat on it.
	     */
	    lstatCached() {
	        return this.#type & LSTAT_CALLED ? this : undefined;
	    }
	    /**
	     * Return the cached link target if the entry has been the subject of a
	     * successful readlink, or undefined otherwise.
	     *
	     * Does not read the filesystem, so an undefined result *could* just mean we
	     * don't have any cached data. Only use it if you are very sure that a
	     * readlink() has been called at some point.
	     */
	    readlinkCached() {
	        return this.#linkTarget;
	    }
	    /**
	     * Returns the cached realpath target if the entry has been the subject
	     * of a successful realpath, or undefined otherwise.
	     *
	     * Does not read the filesystem, so an undefined result *could* just mean we
	     * don't have any cached data. Only use it if you are very sure that a
	     * realpath() has been called at some point.
	     */
	    realpathCached() {
	        return this.#realpath;
	    }
	    /**
	     * Returns the cached child Path entries array if the entry has been the
	     * subject of a successful readdir(), or [] otherwise.
	     *
	     * Does not read the filesystem, so an empty array *could* just mean we
	     * don't have any cached data. Only use it if you are very sure that a
	     * readdir() has been called recently enough to still be valid.
	     */
	    readdirCached() {
	        const children = this.children();
	        return children.slice(0, children.provisional);
	    }
	    /**
	     * Return true if it's worth trying to readlink.  Ie, we don't (yet) have
	     * any indication that readlink will definitely fail.
	     *
	     * Returns false if the path is known to not be a symlink, if a previous
	     * readlink failed, or if the entry does not exist.
	     */
	    canReadlink() {
	        if (this.#linkTarget)
	            return true;
	        if (!this.parent)
	            return false;
	        // cases where it cannot possibly succeed
	        const ifmt = this.#type & IFMT;
	        return !((ifmt !== UNKNOWN && ifmt !== IFLNK) ||
	            this.#type & ENOREADLINK ||
	            this.#type & ENOENT);
	    }
	    /**
	     * Return true if readdir has previously been successfully called on this
	     * path, indicating that cachedReaddir() is likely valid.
	     */
	    calledReaddir() {
	        return !!(this.#type & READDIR_CALLED);
	    }
	    /**
	     * Returns true if the path is known to not exist. That is, a previous lstat
	     * or readdir failed to verify its existence when that would have been
	     * expected, or a parent entry was marked either enoent or enotdir.
	     */
	    isENOENT() {
	        return !!(this.#type & ENOENT);
	    }
	    /**
	     * Return true if the path is a match for the given path name.  This handles
	     * case sensitivity and unicode normalization.
	     *
	     * Note: even on case-sensitive systems, it is **not** safe to test the
	     * equality of the `.name` property to determine whether a given pathname
	     * matches, due to unicode normalization mismatches.
	     *
	     * Always use this method instead of testing the `path.name` property
	     * directly.
	     */
	    isNamed(n) {
	        return !this.nocase ?
	            this.#matchName === normalize(n)
	            : this.#matchName === normalizeNocase(n);
	    }
	    /**
	     * Return the Path object corresponding to the target of a symbolic link.
	     *
	     * If the Path is not a symbolic link, or if the readlink call fails for any
	     * reason, `undefined` is returned.
	     *
	     * Result is cached, and thus may be outdated if the filesystem is mutated.
	     */
	    async readlink() {
	        const target = this.#linkTarget;
	        if (target) {
	            return target;
	        }
	        if (!this.canReadlink()) {
	            return undefined;
	        }
	        /* c8 ignore start */
	        // already covered by the canReadlink test, here for ts grumples
	        if (!this.parent) {
	            return undefined;
	        }
	        /* c8 ignore stop */
	        try {
	            const read = await this.#fs.promises.readlink(this.fullpath());
	            const linkTarget = (await this.parent.realpath())?.resolve(read);
	            if (linkTarget) {
	                return (this.#linkTarget = linkTarget);
	            }
	        }
	        catch (er) {
	            this.#readlinkFail(er.code);
	            return undefined;
	        }
	    }
	    /**
	     * Synchronous {@link PathBase.readlink}
	     */
	    readlinkSync() {
	        const target = this.#linkTarget;
	        if (target) {
	            return target;
	        }
	        if (!this.canReadlink()) {
	            return undefined;
	        }
	        /* c8 ignore start */
	        // already covered by the canReadlink test, here for ts grumples
	        if (!this.parent) {
	            return undefined;
	        }
	        /* c8 ignore stop */
	        try {
	            const read = this.#fs.readlinkSync(this.fullpath());
	            const linkTarget = this.parent.realpathSync()?.resolve(read);
	            if (linkTarget) {
	                return (this.#linkTarget = linkTarget);
	            }
	        }
	        catch (er) {
	            this.#readlinkFail(er.code);
	            return undefined;
	        }
	    }
	    #readdirSuccess(children) {
	        // succeeded, mark readdir called bit
	        this.#type |= READDIR_CALLED;
	        // mark all remaining provisional children as ENOENT
	        for (let p = children.provisional; p < children.length; p++) {
	            const c = children[p];
	            if (c)
	                c.#markENOENT();
	        }
	    }
	    #markENOENT() {
	        // mark as UNKNOWN and ENOENT
	        if (this.#type & ENOENT)
	            return;
	        this.#type = (this.#type | ENOENT) & IFMT_UNKNOWN;
	        this.#markChildrenENOENT();
	    }
	    #markChildrenENOENT() {
	        // all children are provisional and do not exist
	        const children = this.children();
	        children.provisional = 0;
	        for (const p of children) {
	            p.#markENOENT();
	        }
	    }
	    #markENOREALPATH() {
	        this.#type |= ENOREALPATH;
	        this.#markENOTDIR();
	    }
	    // save the information when we know the entry is not a dir
	    #markENOTDIR() {
	        // entry is not a directory, so any children can't exist.
	        // this *should* be impossible, since any children created
	        // after it's been marked ENOTDIR should be marked ENOENT,
	        // so it won't even get to this point.
	        /* c8 ignore start */
	        if (this.#type & ENOTDIR)
	            return;
	        /* c8 ignore stop */
	        let t = this.#type;
	        // this could happen if we stat a dir, then delete it,
	        // then try to read it or one of its children.
	        if ((t & IFMT) === IFDIR)
	            t &= IFMT_UNKNOWN;
	        this.#type = t | ENOTDIR;
	        this.#markChildrenENOENT();
	    }
	    #readdirFail(code = '') {
	        // markENOTDIR and markENOENT also set provisional=0
	        if (code === 'ENOTDIR' || code === 'EPERM') {
	            this.#markENOTDIR();
	        }
	        else if (code === 'ENOENT') {
	            this.#markENOENT();
	        }
	        else {
	            this.children().provisional = 0;
	        }
	    }
	    #lstatFail(code = '') {
	        // Windows just raises ENOENT in this case, disable for win CI
	        /* c8 ignore start */
	        if (code === 'ENOTDIR') {
	            // already know it has a parent by this point
	            const p = this.parent;
	            p.#markENOTDIR();
	        }
	        else if (code === 'ENOENT') {
	            /* c8 ignore stop */
	            this.#markENOENT();
	        }
	    }
	    #readlinkFail(code = '') {
	        let ter = this.#type;
	        ter |= ENOREADLINK;
	        if (code === 'ENOENT')
	            ter |= ENOENT;
	        // windows gets a weird error when you try to readlink a file
	        if (code === 'EINVAL' || code === 'UNKNOWN') {
	            // exists, but not a symlink, we don't know WHAT it is, so remove
	            // all IFMT bits.
	            ter &= IFMT_UNKNOWN;
	        }
	        this.#type = ter;
	        // windows just gets ENOENT in this case.  We do cover the case,
	        // just disabled because it's impossible on Windows CI
	        /* c8 ignore start */
	        if (code === 'ENOTDIR' && this.parent) {
	            this.parent.#markENOTDIR();
	        }
	        /* c8 ignore stop */
	    }
	    #readdirAddChild(e, c) {
	        return (this.#readdirMaybePromoteChild(e, c) ||
	            this.#readdirAddNewChild(e, c));
	    }
	    #readdirAddNewChild(e, c) {
	        // alloc new entry at head, so it's never provisional
	        const type = entToType(e);
	        const child = this.newChild(e.name, type, { parent: this });
	        const ifmt = child.#type & IFMT;
	        if (ifmt !== IFDIR && ifmt !== IFLNK && ifmt !== UNKNOWN) {
	            child.#type |= ENOTDIR;
	        }
	        c.unshift(child);
	        c.provisional++;
	        return child;
	    }
	    #readdirMaybePromoteChild(e, c) {
	        for (let p = c.provisional; p < c.length; p++) {
	            const pchild = c[p];
	            const name = this.nocase ? normalizeNocase(e.name) : normalize(e.name);
	            if (name !== pchild.#matchName) {
	                continue;
	            }
	            return this.#readdirPromoteChild(e, pchild, p, c);
	        }
	    }
	    #readdirPromoteChild(e, p, index, c) {
	        const v = p.name;
	        // retain any other flags, but set ifmt from dirent
	        p.#type = (p.#type & IFMT_UNKNOWN) | entToType(e);
	        // case sensitivity fixing when we learn the true name.
	        if (v !== e.name)
	            p.name = e.name;
	        // just advance provisional index (potentially off the list),
	        // otherwise we have to splice/pop it out and re-insert at head
	        if (index !== c.provisional) {
	            if (index === c.length - 1)
	                c.pop();
	            else
	                c.splice(index, 1);
	            c.unshift(p);
	        }
	        c.provisional++;
	        return p;
	    }
	    /**
	     * Call lstat() on this Path, and update all known information that can be
	     * determined.
	     *
	     * Note that unlike `fs.lstat()`, the returned value does not contain some
	     * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
	     * information is required, you will need to call `fs.lstat` yourself.
	     *
	     * If the Path refers to a nonexistent file, or if the lstat call fails for
	     * any reason, `undefined` is returned.  Otherwise the updated Path object is
	     * returned.
	     *
	     * Results are cached, and thus may be out of date if the filesystem is
	     * mutated.
	     */
	    async lstat() {
	        if ((this.#type & ENOENT) === 0) {
	            try {
	                this.#applyStat(await this.#fs.promises.lstat(this.fullpath()));
	                return this;
	            }
	            catch (er) {
	                this.#lstatFail(er.code);
	            }
	        }
	    }
	    /**
	     * synchronous {@link PathBase.lstat}
	     */
	    lstatSync() {
	        if ((this.#type & ENOENT) === 0) {
	            try {
	                this.#applyStat(this.#fs.lstatSync(this.fullpath()));
	                return this;
	            }
	            catch (er) {
	                this.#lstatFail(er.code);
	            }
	        }
	    }
	    #applyStat(st) {
	        const { atime, atimeMs, birthtime, birthtimeMs, blksize, blocks, ctime, ctimeMs, dev, gid, ino, mode, mtime, mtimeMs, nlink, rdev, size, uid, } = st;
	        this.#atime = atime;
	        this.#atimeMs = atimeMs;
	        this.#birthtime = birthtime;
	        this.#birthtimeMs = birthtimeMs;
	        this.#blksize = blksize;
	        this.#blocks = blocks;
	        this.#ctime = ctime;
	        this.#ctimeMs = ctimeMs;
	        this.#dev = dev;
	        this.#gid = gid;
	        this.#ino = ino;
	        this.#mode = mode;
	        this.#mtime = mtime;
	        this.#mtimeMs = mtimeMs;
	        this.#nlink = nlink;
	        this.#rdev = rdev;
	        this.#size = size;
	        this.#uid = uid;
	        const ifmt = entToType(st);
	        // retain any other flags, but set the ifmt
	        this.#type = (this.#type & IFMT_UNKNOWN) | ifmt | LSTAT_CALLED;
	        if (ifmt !== UNKNOWN && ifmt !== IFDIR && ifmt !== IFLNK) {
	            this.#type |= ENOTDIR;
	        }
	    }
	    #onReaddirCB = [];
	    #readdirCBInFlight = false;
	    #callOnReaddirCB(children) {
	        this.#readdirCBInFlight = false;
	        const cbs = this.#onReaddirCB.slice();
	        this.#onReaddirCB.length = 0;
	        cbs.forEach(cb => cb(null, children));
	    }
	    /**
	     * Standard node-style callback interface to get list of directory entries.
	     *
	     * If the Path cannot or does not contain any children, then an empty array
	     * is returned.
	     *
	     * Results are cached, and thus may be out of date if the filesystem is
	     * mutated.
	     *
	     * @param cb The callback called with (er, entries).  Note that the `er`
	     * param is somewhat extraneous, as all readdir() errors are handled and
	     * simply result in an empty set of entries being returned.
	     * @param allowZalgo Boolean indicating that immediately known results should
	     * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release
	     * zalgo at your peril, the dark pony lord is devious and unforgiving.
	     */
	    readdirCB(cb, allowZalgo = false) {
	        if (!this.canReaddir()) {
	            if (allowZalgo)
	                cb(null, []);
	            else
	                queueMicrotask(() => cb(null, []));
	            return;
	        }
	        const children = this.children();
	        if (this.calledReaddir()) {
	            const c = children.slice(0, children.provisional);
	            if (allowZalgo)
	                cb(null, c);
	            else
	                queueMicrotask(() => cb(null, c));
	            return;
	        }
	        // don't have to worry about zalgo at this point.
	        this.#onReaddirCB.push(cb);
	        if (this.#readdirCBInFlight) {
	            return;
	        }
	        this.#readdirCBInFlight = true;
	        // else read the directory, fill up children
	        // de-provisionalize any provisional children.
	        const fullpath = this.fullpath();
	        this.#fs.readdir(fullpath, { withFileTypes: true }, (er, entries) => {
	            if (er) {
	                this.#readdirFail(er.code);
	                children.provisional = 0;
	            }
	            else {
	                // if we didn't get an error, we always get entries.
	                //@ts-ignore
	                for (const e of entries) {
	                    this.#readdirAddChild(e, children);
	                }
	                this.#readdirSuccess(children);
	            }
	            this.#callOnReaddirCB(children.slice(0, children.provisional));
	            return;
	        });
	    }
	    #asyncReaddirInFlight;
	    /**
	     * Return an array of known child entries.
	     *
	     * If the Path cannot or does not contain any children, then an empty array
	     * is returned.
	     *
	     * Results are cached, and thus may be out of date if the filesystem is
	     * mutated.
	     */
	    async readdir() {
	        if (!this.canReaddir()) {
	            return [];
	        }
	        const children = this.children();
	        if (this.calledReaddir()) {
	            return children.slice(0, children.provisional);
	        }
	        // else read the directory, fill up children
	        // de-provisionalize any provisional children.
	        const fullpath = this.fullpath();
	        if (this.#asyncReaddirInFlight) {
	            await this.#asyncReaddirInFlight;
	        }
	        else {
	            /* c8 ignore start */
	            let resolve = () => { };
	            /* c8 ignore stop */
	            this.#asyncReaddirInFlight = new Promise(res => (resolve = res));
	            try {
	                for (const e of await this.#fs.promises.readdir(fullpath, {
	                    withFileTypes: true,
	                })) {
	                    this.#readdirAddChild(e, children);
	                }
	                this.#readdirSuccess(children);
	            }
	            catch (er) {
	                this.#readdirFail(er.code);
	                children.provisional = 0;
	            }
	            this.#asyncReaddirInFlight = undefined;
	            resolve();
	        }
	        return children.slice(0, children.provisional);
	    }
	    /**
	     * synchronous {@link PathBase.readdir}
	     */
	    readdirSync() {
	        if (!this.canReaddir()) {
	            return [];
	        }
	        const children = this.children();
	        if (this.calledReaddir()) {
	            return children.slice(0, children.provisional);
	        }
	        // else read the directory, fill up children
	        // de-provisionalize any provisional children.
	        const fullpath = this.fullpath();
	        try {
	            for (const e of this.#fs.readdirSync(fullpath, {
	                withFileTypes: true,
	            })) {
	                this.#readdirAddChild(e, children);
	            }
	            this.#readdirSuccess(children);
	        }
	        catch (er) {
	            this.#readdirFail(er.code);
	            children.provisional = 0;
	        }
	        return children.slice(0, children.provisional);
	    }
	    canReaddir() {
	        if (this.#type & ENOCHILD)
	            return false;
	        const ifmt = IFMT & this.#type;
	        // we always set ENOTDIR when setting IFMT, so should be impossible
	        /* c8 ignore start */
	        if (!(ifmt === UNKNOWN || ifmt === IFDIR || ifmt === IFLNK)) {
	            return false;
	        }
	        /* c8 ignore stop */
	        return true;
	    }
	    shouldWalk(dirs, walkFilter) {
	        return ((this.#type & IFDIR) === IFDIR &&
	            !(this.#type & ENOCHILD) &&
	            !dirs.has(this) &&
	            (!walkFilter || walkFilter(this)));
	    }
	    /**
	     * Return the Path object corresponding to path as resolved
	     * by realpath(3).
	     *
	     * If the realpath call fails for any reason, `undefined` is returned.
	     *
	     * Result is cached, and thus may be outdated if the filesystem is mutated.
	     * On success, returns a Path object.
	     */
	    async realpath() {
	        if (this.#realpath)
	            return this.#realpath;
	        if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
	            return undefined;
	        try {
	            const rp = await this.#fs.promises.realpath(this.fullpath());
	            return (this.#realpath = this.resolve(rp));
	        }
	        catch (_) {
	            this.#markENOREALPATH();
	        }
	    }
	    /**
	     * Synchronous {@link realpath}
	     */
	    realpathSync() {
	        if (this.#realpath)
	            return this.#realpath;
	        if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
	            return undefined;
	        try {
	            const rp = this.#fs.realpathSync(this.fullpath());
	            return (this.#realpath = this.resolve(rp));
	        }
	        catch (_) {
	            this.#markENOREALPATH();
	        }
	    }
	    /**
	     * Internal method to mark this Path object as the scurry cwd,
	     * called by {@link PathScurry#chdir}
	     *
	     * @internal
	     */
	    [setAsCwd](oldCwd) {
	        if (oldCwd === this)
	            return;
	        oldCwd.isCWD = false;
	        this.isCWD = true;
	        const changed = new Set([]);
	        let rp = [];
	        let p = this;
	        while (p && p.parent) {
	            changed.add(p);
	            p.#relative = rp.join(this.sep);
	            p.#relativePosix = rp.join('/');
	            p = p.parent;
	            rp.push('..');
	        }
	        // now un-memoize parents of old cwd
	        p = oldCwd;
	        while (p && p.parent && !changed.has(p)) {
	            p.#relative = undefined;
	            p.#relativePosix = undefined;
	            p = p.parent;
	        }
	    }
	}
	commonjs$2.PathBase = PathBase;
	/**
	 * Path class used on win32 systems
	 *
	 * Uses `'\\'` as the path separator for returned paths, either `'\\'` or `'/'`
	 * as the path separator for parsing paths.
	 */
	class PathWin32 extends PathBase {
	    /**
	     * Separator for generating path strings.
	     */
	    sep = '\\';
	    /**
	     * Separator for parsing path strings.
	     */
	    splitSep = eitherSep;
	    /**
	     * Do not create new Path objects directly.  They should always be accessed
	     * via the PathScurry class or other methods on the Path class.
	     *
	     * @internal
	     */
	    constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
	        super(name, type, root, roots, nocase, children, opts);
	    }
	    /**
	     * @internal
	     */
	    newChild(name, type = UNKNOWN, opts = {}) {
	        return new PathWin32(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
	    }
	    /**
	     * @internal
	     */
	    getRootString(path) {
	        return node_path_1.win32.parse(path).root;
	    }
	    /**
	     * @internal
	     */
	    getRoot(rootPath) {
	        rootPath = uncToDrive(rootPath.toUpperCase());
	        if (rootPath === this.root.name) {
	            return this.root;
	        }
	        // ok, not that one, check if it matches another we know about
	        for (const [compare, root] of Object.entries(this.roots)) {
	            if (this.sameRoot(rootPath, compare)) {
	                return (this.roots[rootPath] = root);
	            }
	        }
	        // otherwise, have to create a new one.
	        return (this.roots[rootPath] = new PathScurryWin32(rootPath, this).root);
	    }
	    /**
	     * @internal
	     */
	    sameRoot(rootPath, compare = this.root.name) {
	        // windows can (rarely) have case-sensitive filesystem, but
	        // UNC and drive letters are always case-insensitive, and canonically
	        // represented uppercase.
	        rootPath = rootPath
	            .toUpperCase()
	            .replace(/\//g, '\\')
	            .replace(uncDriveRegexp, '$1\\');
	        return rootPath === compare;
	    }
	}
	commonjs$2.PathWin32 = PathWin32;
	/**
	 * Path class used on all posix systems.
	 *
	 * Uses `'/'` as the path separator.
	 */
	class PathPosix extends PathBase {
	    /**
	     * separator for parsing path strings
	     */
	    splitSep = '/';
	    /**
	     * separator for generating path strings
	     */
	    sep = '/';
	    /**
	     * Do not create new Path objects directly.  They should always be accessed
	     * via the PathScurry class or other methods on the Path class.
	     *
	     * @internal
	     */
	    constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
	        super(name, type, root, roots, nocase, children, opts);
	    }
	    /**
	     * @internal
	     */
	    getRootString(path) {
	        return path.startsWith('/') ? '/' : '';
	    }
	    /**
	     * @internal
	     */
	    getRoot(_rootPath) {
	        return this.root;
	    }
	    /**
	     * @internal
	     */
	    newChild(name, type = UNKNOWN, opts = {}) {
	        return new PathPosix(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
	    }
	}
	commonjs$2.PathPosix = PathPosix;
	/**
	 * The base class for all PathScurry classes, providing the interface for path
	 * resolution and filesystem operations.
	 *
	 * Typically, you should *not* instantiate this class directly, but rather one
	 * of the platform-specific classes, or the exported {@link PathScurry} which
	 * defaults to the current platform.
	 */
	class PathScurryBase {
	    /**
	     * The root Path entry for the current working directory of this Scurry
	     */
	    root;
	    /**
	     * The string path for the root of this Scurry's current working directory
	     */
	    rootPath;
	    /**
	     * A collection of all roots encountered, referenced by rootPath
	     */
	    roots;
	    /**
	     * The Path entry corresponding to this PathScurry's current working directory.
	     */
	    cwd;
	    #resolveCache;
	    #resolvePosixCache;
	    #children;
	    /**
	     * Perform path comparisons case-insensitively.
	     *
	     * Defaults true on Darwin and Windows systems, false elsewhere.
	     */
	    nocase;
	    #fs;
	    /**
	     * This class should not be instantiated directly.
	     *
	     * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry
	     *
	     * @internal
	     */
	    constructor(cwd = process.cwd(), pathImpl, sep, { nocase, childrenCacheSize = 16 * 1024, fs = defaultFS, } = {}) {
	        this.#fs = fsFromOption(fs);
	        if (cwd instanceof URL || cwd.startsWith('file://')) {
	            cwd = (0, node_url_1.fileURLToPath)(cwd);
	        }
	        // resolve and split root, and then add to the store.
	        // this is the only time we call path.resolve()
	        const cwdPath = pathImpl.resolve(cwd);
	        this.roots = Object.create(null);
	        this.rootPath = this.parseRootPath(cwdPath);
	        this.#resolveCache = new ResolveCache();
	        this.#resolvePosixCache = new ResolveCache();
	        this.#children = new ChildrenCache(childrenCacheSize);
	        const split = cwdPath.substring(this.rootPath.length).split(sep);
	        // resolve('/') leaves '', splits to [''], we don't want that.
	        if (split.length === 1 && !split[0]) {
	            split.pop();
	        }
	        /* c8 ignore start */
	        if (nocase === undefined) {
	            throw new TypeError('must provide nocase setting to PathScurryBase ctor');
	        }
	        /* c8 ignore stop */
	        this.nocase = nocase;
	        this.root = this.newRoot(this.#fs);
	        this.roots[this.rootPath] = this.root;
	        let prev = this.root;
	        let len = split.length - 1;
	        const joinSep = pathImpl.sep;
	        let abs = this.rootPath;
	        let sawFirst = false;
	        for (const part of split) {
	            const l = len--;
	            prev = prev.child(part, {
	                relative: new Array(l).fill('..').join(joinSep),
	                relativePosix: new Array(l).fill('..').join('/'),
	                fullpath: (abs += (sawFirst ? '' : joinSep) + part),
	            });
	            sawFirst = true;
	        }
	        this.cwd = prev;
	    }
	    /**
	     * Get the depth of a provided path, string, or the cwd
	     */
	    depth(path = this.cwd) {
	        if (typeof path === 'string') {
	            path = this.cwd.resolve(path);
	        }
	        return path.depth();
	    }
	    /**
	     * Return the cache of child entries.  Exposed so subclasses can create
	     * child Path objects in a platform-specific way.
	     *
	     * @internal
	     */
	    childrenCache() {
	        return this.#children;
	    }
	    /**
	     * Resolve one or more path strings to a resolved string
	     *
	     * Same interface as require('path').resolve.
	     *
	     * Much faster than path.resolve() when called multiple times for the same
	     * path, because the resolved Path objects are cached.  Much slower
	     * otherwise.
	     */
	    resolve(...paths) {
	        // first figure out the minimum number of paths we have to test
	        // we always start at cwd, but any absolutes will bump the start
	        let r = '';
	        for (let i = paths.length - 1; i >= 0; i--) {
	            const p = paths[i];
	            if (!p || p === '.')
	                continue;
	            r = r ? `${p}/${r}` : p;
	            if (this.isAbsolute(p)) {
	                break;
	            }
	        }
	        const cached = this.#resolveCache.get(r);
	        if (cached !== undefined) {
	            return cached;
	        }
	        const result = this.cwd.resolve(r).fullpath();
	        this.#resolveCache.set(r, result);
	        return result;
	    }
	    /**
	     * Resolve one or more path strings to a resolved string, returning
	     * the posix path.  Identical to .resolve() on posix systems, but on
	     * windows will return a forward-slash separated UNC path.
	     *
	     * Same interface as require('path').resolve.
	     *
	     * Much faster than path.resolve() when called multiple times for the same
	     * path, because the resolved Path objects are cached.  Much slower
	     * otherwise.
	     */
	    resolvePosix(...paths) {
	        // first figure out the minimum number of paths we have to test
	        // we always start at cwd, but any absolutes will bump the start
	        let r = '';
	        for (let i = paths.length - 1; i >= 0; i--) {
	            const p = paths[i];
	            if (!p || p === '.')
	                continue;
	            r = r ? `${p}/${r}` : p;
	            if (this.isAbsolute(p)) {
	                break;
	            }
	        }
	        const cached = this.#resolvePosixCache.get(r);
	        if (cached !== undefined) {
	            return cached;
	        }
	        const result = this.cwd.resolve(r).fullpathPosix();
	        this.#resolvePosixCache.set(r, result);
	        return result;
	    }
	    /**
	     * find the relative path from the cwd to the supplied path string or entry
	     */
	    relative(entry = this.cwd) {
	        if (typeof entry === 'string') {
	            entry = this.cwd.resolve(entry);
	        }
	        return entry.relative();
	    }
	    /**
	     * find the relative path from the cwd to the supplied path string or
	     * entry, using / as the path delimiter, even on Windows.
	     */
	    relativePosix(entry = this.cwd) {
	        if (typeof entry === 'string') {
	            entry = this.cwd.resolve(entry);
	        }
	        return entry.relativePosix();
	    }
	    /**
	     * Return the basename for the provided string or Path object
	     */
	    basename(entry = this.cwd) {
	        if (typeof entry === 'string') {
	            entry = this.cwd.resolve(entry);
	        }
	        return entry.name;
	    }
	    /**
	     * Return the dirname for the provided string or Path object
	     */
	    dirname(entry = this.cwd) {
	        if (typeof entry === 'string') {
	            entry = this.cwd.resolve(entry);
	        }
	        return (entry.parent || entry).fullpath();
	    }
	    async readdir(entry = this.cwd, opts = {
	        withFileTypes: true,
	    }) {
	        if (typeof entry === 'string') {
	            entry = this.cwd.resolve(entry);
	        }
	        else if (!(entry instanceof PathBase)) {
	            opts = entry;
	            entry = this.cwd;
	        }
	        const { withFileTypes } = opts;
	        if (!entry.canReaddir()) {
	            return [];
	        }
	        else {
	            const p = await entry.readdir();
	            return withFileTypes ? p : p.map(e => e.name);
	        }
	    }
	    readdirSync(entry = this.cwd, opts = {
	        withFileTypes: true,
	    }) {
	        if (typeof entry === 'string') {
	            entry = this.cwd.resolve(entry);
	        }
	        else if (!(entry instanceof PathBase)) {
	            opts = entry;
	            entry = this.cwd;
	        }
	        const { withFileTypes = true } = opts;
	        if (!entry.canReaddir()) {
	            return [];
	        }
	        else if (withFileTypes) {
	            return entry.readdirSync();
	        }
	        else {
	            return entry.readdirSync().map(e => e.name);
	        }
	    }
	    /**
	     * Call lstat() on the string or Path object, and update all known
	     * information that can be determined.
	     *
	     * Note that unlike `fs.lstat()`, the returned value does not contain some
	     * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
	     * information is required, you will need to call `fs.lstat` yourself.
	     *
	     * If the Path refers to a nonexistent file, or if the lstat call fails for
	     * any reason, `undefined` is returned.  Otherwise the updated Path object is
	     * returned.
	     *
	     * Results are cached, and thus may be out of date if the filesystem is
	     * mutated.
	     */
	    async lstat(entry = this.cwd) {
	        if (typeof entry === 'string') {
	            entry = this.cwd.resolve(entry);
	        }
	        return entry.lstat();
	    }
	    /**
	     * synchronous {@link PathScurryBase.lstat}
	     */
	    lstatSync(entry = this.cwd) {
	        if (typeof entry === 'string') {
	            entry = this.cwd.resolve(entry);
	        }
	        return entry.lstatSync();
	    }
	    async readlink(entry = this.cwd, { withFileTypes } = {
	        withFileTypes: false,
	    }) {
	        if (typeof entry === 'string') {
	            entry = this.cwd.resolve(entry);
	        }
	        else if (!(entry instanceof PathBase)) {
	            withFileTypes = entry.withFileTypes;
	            entry = this.cwd;
	        }
	        const e = await entry.readlink();
	        return withFileTypes ? e : e?.fullpath();
	    }
	    readlinkSync(entry = this.cwd, { withFileTypes } = {
	        withFileTypes: false,
	    }) {
	        if (typeof entry === 'string') {
	            entry = this.cwd.resolve(entry);
	        }
	        else if (!(entry instanceof PathBase)) {
	            withFileTypes = entry.withFileTypes;
	            entry = this.cwd;
	        }
	        const e = entry.readlinkSync();
	        return withFileTypes ? e : e?.fullpath();
	    }
	    async realpath(entry = this.cwd, { withFileTypes } = {
	        withFileTypes: false,
	    }) {
	        if (typeof entry === 'string') {
	            entry = this.cwd.resolve(entry);
	        }
	        else if (!(entry instanceof PathBase)) {
	            withFileTypes = entry.withFileTypes;
	            entry = this.cwd;
	        }
	        const e = await entry.realpath();
	        return withFileTypes ? e : e?.fullpath();
	    }
	    realpathSync(entry = this.cwd, { withFileTypes } = {
	        withFileTypes: false,
	    }) {
	        if (typeof entry === 'string') {
	            entry = this.cwd.resolve(entry);
	        }
	        else if (!(entry instanceof PathBase)) {
	            withFileTypes = entry.withFileTypes;
	            entry = this.cwd;
	        }
	        const e = entry.realpathSync();
	        return withFileTypes ? e : e?.fullpath();
	    }
	    async walk(entry = this.cwd, opts = {}) {
	        if (typeof entry === 'string') {
	            entry = this.cwd.resolve(entry);
	        }
	        else if (!(entry instanceof PathBase)) {
	            opts = entry;
	            entry = this.cwd;
	        }
	        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;
	        const results = [];
	        if (!filter || filter(entry)) {
	            results.push(withFileTypes ? entry : entry.fullpath());
	        }
	        const dirs = new Set();
	        const walk = (dir, cb) => {
	            dirs.add(dir);
	            dir.readdirCB((er, entries) => {
	                /* c8 ignore start */
	                if (er) {
	                    return cb(er);
	                }
	                /* c8 ignore stop */
	                let len = entries.length;
	                if (!len)
	                    return cb();
	                const next = () => {
	                    if (--len === 0) {
	                        cb();
	                    }
	                };
	                for (const e of entries) {
	                    if (!filter || filter(e)) {
	                        results.push(withFileTypes ? e : e.fullpath());
	                    }
	                    if (follow && e.isSymbolicLink()) {
	                        e.realpath()
	                            .then(r => (r?.isUnknown() ? r.lstat() : r))
	                            .then(r => r?.shouldWalk(dirs, walkFilter) ? walk(r, next) : next());
	                    }
	                    else {
	                        if (e.shouldWalk(dirs, walkFilter)) {
	                            walk(e, next);
	                        }
	                        else {
	                            next();
	                        }
	                    }
	                }
	            }, true); // zalgooooooo
	        };
	        const start = entry;
	        return new Promise((res, rej) => {
	            walk(start, er => {
	                /* c8 ignore start */
	                if (er)
	                    return rej(er);
	                /* c8 ignore stop */
	                res(results);
	            });
	        });
	    }
	    walkSync(entry = this.cwd, opts = {}) {
	        if (typeof entry === 'string') {
	            entry = this.cwd.resolve(entry);
	        }
	        else if (!(entry instanceof PathBase)) {
	            opts = entry;
	            entry = this.cwd;
	        }
	        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;
	        const results = [];
	        if (!filter || filter(entry)) {
	            results.push(withFileTypes ? entry : entry.fullpath());
	        }
	        const dirs = new Set([entry]);
	        for (const dir of dirs) {
	            const entries = dir.readdirSync();
	            for (const e of entries) {
	                if (!filter || filter(e)) {
	                    results.push(withFileTypes ? e : e.fullpath());
	                }
	                let r = e;
	                if (e.isSymbolicLink()) {
	                    if (!(follow && (r = e.realpathSync())))
	                        continue;
	                    if (r.isUnknown())
	                        r.lstatSync();
	                }
	                if (r.shouldWalk(dirs, walkFilter)) {
	                    dirs.add(r);
	                }
	            }
	        }
	        return results;
	    }
	    /**
	     * Support for `for await`
	     *
	     * Alias for {@link PathScurryBase.iterate}
	     *
	     * Note: As of Node 19, this is very slow, compared to other methods of
	     * walking.  Consider using {@link PathScurryBase.stream} if memory overhead
	     * and backpressure are concerns, or {@link PathScurryBase.walk} if not.
	     */
	    [Symbol.asyncIterator]() {
	        return this.iterate();
	    }
	    iterate(entry = this.cwd, options = {}) {
	        // iterating async over the stream is significantly more performant,
	        // especially in the warm-cache scenario, because it buffers up directory
	        // entries in the background instead of waiting for a yield for each one.
	        if (typeof entry === 'string') {
	            entry = this.cwd.resolve(entry);
	        }
	        else if (!(entry instanceof PathBase)) {
	            options = entry;
	            entry = this.cwd;
	        }
	        return this.stream(entry, options)[Symbol.asyncIterator]();
	    }
	    /**
	     * Iterating over a PathScurry performs a synchronous walk.
	     *
	     * Alias for {@link PathScurryBase.iterateSync}
	     */
	    [Symbol.iterator]() {
	        return this.iterateSync();
	    }
	    *iterateSync(entry = this.cwd, opts = {}) {
	        if (typeof entry === 'string') {
	            entry = this.cwd.resolve(entry);
	        }
	        else if (!(entry instanceof PathBase)) {
	            opts = entry;
	            entry = this.cwd;
	        }
	        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;
	        if (!filter || filter(entry)) {
	            yield withFileTypes ? entry : entry.fullpath();
	        }
	        const dirs = new Set([entry]);
	        for (const dir of dirs) {
	            const entries = dir.readdirSync();
	            for (const e of entries) {
	                if (!filter || filter(e)) {
	                    yield withFileTypes ? e : e.fullpath();
	                }
	                let r = e;
	                if (e.isSymbolicLink()) {
	                    if (!(follow && (r = e.realpathSync())))
	                        continue;
	                    if (r.isUnknown())
	                        r.lstatSync();
	                }
	                if (r.shouldWalk(dirs, walkFilter)) {
	                    dirs.add(r);
	                }
	            }
	        }
	    }
	    stream(entry = this.cwd, opts = {}) {
	        if (typeof entry === 'string') {
	            entry = this.cwd.resolve(entry);
	        }
	        else if (!(entry instanceof PathBase)) {
	            opts = entry;
	            entry = this.cwd;
	        }
	        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;
	        const results = new minipass_1.Minipass({ objectMode: true });
	        if (!filter || filter(entry)) {
	            results.write(withFileTypes ? entry : entry.fullpath());
	        }
	        const dirs = new Set();
	        const queue = [entry];
	        let processing = 0;
	        const process = () => {
	            let paused = false;
	            while (!paused) {
	                const dir = queue.shift();
	                if (!dir) {
	                    if (processing === 0)
	                        results.end();
	                    return;
	                }
	                processing++;
	                dirs.add(dir);
	                const onReaddir = (er, entries, didRealpaths = false) => {
	                    /* c8 ignore start */
	                    if (er)
	                        return results.emit('error', er);
	                    /* c8 ignore stop */
	                    if (follow && !didRealpaths) {
	                        const promises = [];
	                        for (const e of entries) {
	                            if (e.isSymbolicLink()) {
	                                promises.push(e
	                                    .realpath()
	                                    .then((r) => r?.isUnknown() ? r.lstat() : r));
	                            }
	                        }
	                        if (promises.length) {
	                            Promise.all(promises).then(() => onReaddir(null, entries, true));
	                            return;
	                        }
	                    }
	                    for (const e of entries) {
	                        if (e && (!filter || filter(e))) {
	                            if (!results.write(withFileTypes ? e : e.fullpath())) {
	                                paused = true;
	                            }
	                        }
	                    }
	                    processing--;
	                    for (const e of entries) {
	                        const r = e.realpathCached() || e;
	                        if (r.shouldWalk(dirs, walkFilter)) {
	                            queue.push(r);
	                        }
	                    }
	                    if (paused && !results.flowing) {
	                        results.once('drain', process);
	                    }
	                    else if (!sync) {
	                        process();
	                    }
	                };
	                // zalgo containment
	                let sync = true;
	                dir.readdirCB(onReaddir, true);
	                sync = false;
	            }
	        };
	        process();
	        return results;
	    }
	    streamSync(entry = this.cwd, opts = {}) {
	        if (typeof entry === 'string') {
	            entry = this.cwd.resolve(entry);
	        }
	        else if (!(entry instanceof PathBase)) {
	            opts = entry;
	            entry = this.cwd;
	        }
	        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;
	        const results = new minipass_1.Minipass({ objectMode: true });
	        const dirs = new Set();
	        if (!filter || filter(entry)) {
	            results.write(withFileTypes ? entry : entry.fullpath());
	        }
	        const queue = [entry];
	        let processing = 0;
	        const process = () => {
	            let paused = false;
	            while (!paused) {
	                const dir = queue.shift();
	                if (!dir) {
	                    if (processing === 0)
	                        results.end();
	                    return;
	                }
	                processing++;
	                dirs.add(dir);
	                const entries = dir.readdirSync();
	                for (const e of entries) {
	                    if (!filter || filter(e)) {
	                        if (!results.write(withFileTypes ? e : e.fullpath())) {
	                            paused = true;
	                        }
	                    }
	                }
	                processing--;
	                for (const e of entries) {
	                    let r = e;
	                    if (e.isSymbolicLink()) {
	                        if (!(follow && (r = e.realpathSync())))
	                            continue;
	                        if (r.isUnknown())
	                            r.lstatSync();
	                    }
	                    if (r.shouldWalk(dirs, walkFilter)) {
	                        queue.push(r);
	                    }
	                }
	            }
	            if (paused && !results.flowing)
	                results.once('drain', process);
	        };
	        process();
	        return results;
	    }
	    chdir(path = this.cwd) {
	        const oldCwd = this.cwd;
	        this.cwd = typeof path === 'string' ? this.cwd.resolve(path) : path;
	        this.cwd[setAsCwd](oldCwd);
	    }
	}
	commonjs$2.PathScurryBase = PathScurryBase;
	/**
	 * Windows implementation of {@link PathScurryBase}
	 *
	 * Defaults to case insensitve, uses `'\\'` to generate path strings.  Uses
	 * {@link PathWin32} for Path objects.
	 */
	class PathScurryWin32 extends PathScurryBase {
	    /**
	     * separator for generating path strings
	     */
	    sep = '\\';
	    constructor(cwd = process.cwd(), opts = {}) {
	        const { nocase = true } = opts;
	        super(cwd, node_path_1.win32, '\\', { ...opts, nocase });
	        this.nocase = nocase;
	        for (let p = this.cwd; p; p = p.parent) {
	            p.nocase = this.nocase;
	        }
	    }
	    /**
	     * @internal
	     */
	    parseRootPath(dir) {
	        // if the path starts with a single separator, it's not a UNC, and we'll
	        // just get separator as the root, and driveFromUNC will return \
	        // In that case, mount \ on the root from the cwd.
	        return node_path_1.win32.parse(dir).root.toUpperCase();
	    }
	    /**
	     * @internal
	     */
	    newRoot(fs) {
	        return new PathWin32(this.rootPath, IFDIR, undefined, this.roots, this.nocase, this.childrenCache(), { fs });
	    }
	    /**
	     * Return true if the provided path string is an absolute path
	     */
	    isAbsolute(p) {
	        return (p.startsWith('/') || p.startsWith('\\') || /^[a-z]:(\/|\\)/i.test(p));
	    }
	}
	commonjs$2.PathScurryWin32 = PathScurryWin32;
	/**
	 * {@link PathScurryBase} implementation for all posix systems other than Darwin.
	 *
	 * Defaults to case-sensitive matching, uses `'/'` to generate path strings.
	 *
	 * Uses {@link PathPosix} for Path objects.
	 */
	class PathScurryPosix extends PathScurryBase {
	    /**
	     * separator for generating path strings
	     */
	    sep = '/';
	    constructor(cwd = process.cwd(), opts = {}) {
	        const { nocase = false } = opts;
	        super(cwd, node_path_1.posix, '/', { ...opts, nocase });
	        this.nocase = nocase;
	    }
	    /**
	     * @internal
	     */
	    parseRootPath(_dir) {
	        return '/';
	    }
	    /**
	     * @internal
	     */
	    newRoot(fs) {
	        return new PathPosix(this.rootPath, IFDIR, undefined, this.roots, this.nocase, this.childrenCache(), { fs });
	    }
	    /**
	     * Return true if the provided path string is an absolute path
	     */
	    isAbsolute(p) {
	        return p.startsWith('/');
	    }
	}
	commonjs$2.PathScurryPosix = PathScurryPosix;
	/**
	 * {@link PathScurryBase} implementation for Darwin (macOS) systems.
	 *
	 * Defaults to case-insensitive matching, uses `'/'` for generating path
	 * strings.
	 *
	 * Uses {@link PathPosix} for Path objects.
	 */
	class PathScurryDarwin extends PathScurryPosix {
	    constructor(cwd = process.cwd(), opts = {}) {
	        const { nocase = true } = opts;
	        super(cwd, { ...opts, nocase });
	    }
	}
	commonjs$2.PathScurryDarwin = PathScurryDarwin;
	/**
	 * Default {@link PathBase} implementation for the current platform.
	 *
	 * {@link PathWin32} on Windows systems, {@link PathPosix} on all others.
	 */
	commonjs$2.Path = process.platform === 'win32' ? PathWin32 : PathPosix;
	/**
	 * Default {@link PathScurryBase} implementation for the current platform.
	 *
	 * {@link PathScurryWin32} on Windows systems, {@link PathScurryDarwin} on
	 * Darwin (macOS) systems, {@link PathScurryPosix} on all others.
	 */
	commonjs$2.PathScurry = process.platform === 'win32' ? PathScurryWin32
	    : process.platform === 'darwin' ? PathScurryDarwin
	        : PathScurryPosix;
	
	return commonjs$2;
}

var pattern = {};

var hasRequiredPattern;

function requirePattern () {
	if (hasRequiredPattern) return pattern;
	hasRequiredPattern = 1;
	// this is just a very light wrapper around 2 arrays with an offset index
	Object.defineProperty(pattern, "__esModule", { value: true });
	pattern.Pattern = void 0;
	const minimatch_1 = requireCommonjs$4();
	const isPatternList = (pl) => pl.length >= 1;
	const isGlobList = (gl) => gl.length >= 1;
	/**
	 * An immutable-ish view on an array of glob parts and their parsed
	 * results
	 */
	class Pattern {
	    #patternList;
	    #globList;
	    #index;
	    length;
	    #platform;
	    #rest;
	    #globString;
	    #isDrive;
	    #isUNC;
	    #isAbsolute;
	    #followGlobstar = true;
	    constructor(patternList, globList, index, platform) {
	        if (!isPatternList(patternList)) {
	            throw new TypeError('empty pattern list');
	        }
	        if (!isGlobList(globList)) {
	            throw new TypeError('empty glob list');
	        }
	        if (globList.length !== patternList.length) {
	            throw new TypeError('mismatched pattern list and glob list lengths');
	        }
	        this.length = patternList.length;
	        if (index < 0 || index >= this.length) {
	            throw new TypeError('index out of range');
	        }
	        this.#patternList = patternList;
	        this.#globList = globList;
	        this.#index = index;
	        this.#platform = platform;
	        // normalize root entries of absolute patterns on initial creation.
	        if (this.#index === 0) {
	            // c: => ['c:/']
	            // C:/ => ['C:/']
	            // C:/x => ['C:/', 'x']
	            // //host/share => ['//host/share/']
	            // //host/share/ => ['//host/share/']
	            // //host/share/x => ['//host/share/', 'x']
	            // /etc => ['/', 'etc']
	            // / => ['/']
	            if (this.isUNC()) {
	                // '' / '' / 'host' / 'share'
	                const [p0, p1, p2, p3, ...prest] = this.#patternList;
	                const [g0, g1, g2, g3, ...grest] = this.#globList;
	                if (prest[0] === '') {
	                    // ends in /
	                    prest.shift();
	                    grest.shift();
	                }
	                const p = [p0, p1, p2, p3, ''].join('/');
	                const g = [g0, g1, g2, g3, ''].join('/');
	                this.#patternList = [p, ...prest];
	                this.#globList = [g, ...grest];
	                this.length = this.#patternList.length;
	            }
	            else if (this.isDrive() || this.isAbsolute()) {
	                const [p1, ...prest] = this.#patternList;
	                const [g1, ...grest] = this.#globList;
	                if (prest[0] === '') {
	                    // ends in /
	                    prest.shift();
	                    grest.shift();
	                }
	                const p = p1 + '/';
	                const g = g1 + '/';
	                this.#patternList = [p, ...prest];
	                this.#globList = [g, ...grest];
	                this.length = this.#patternList.length;
	            }
	        }
	    }
	    /**
	     * The first entry in the parsed list of patterns
	     */
	    pattern() {
	        return this.#patternList[this.#index];
	    }
	    /**
	     * true of if pattern() returns a string
	     */
	    isString() {
	        return typeof this.#patternList[this.#index] === 'string';
	    }
	    /**
	     * true of if pattern() returns GLOBSTAR
	     */
	    isGlobstar() {
	        return this.#patternList[this.#index] === minimatch_1.GLOBSTAR;
	    }
	    /**
	     * true if pattern() returns a regexp
	     */
	    isRegExp() {
	        return this.#patternList[this.#index] instanceof RegExp;
	    }
	    /**
	     * The /-joined set of glob parts that make up this pattern
	     */
	    globString() {
	        return (this.#globString =
	            this.#globString ||
	                (this.#index === 0 ?
	                    this.isAbsolute() ?
	                        this.#globList[0] + this.#globList.slice(1).join('/')
	                        : this.#globList.join('/')
	                    : this.#globList.slice(this.#index).join('/')));
	    }
	    /**
	     * true if there are more pattern parts after this one
	     */
	    hasMore() {
	        return this.length > this.#index + 1;
	    }
	    /**
	     * The rest of the pattern after this part, or null if this is the end
	     */
	    rest() {
	        if (this.#rest !== undefined)
	            return this.#rest;
	        if (!this.hasMore())
	            return (this.#rest = null);
	        this.#rest = new Pattern(this.#patternList, this.#globList, this.#index + 1, this.#platform);
	        this.#rest.#isAbsolute = this.#isAbsolute;
	        this.#rest.#isUNC = this.#isUNC;
	        this.#rest.#isDrive = this.#isDrive;
	        return this.#rest;
	    }
	    /**
	     * true if the pattern represents a //unc/path/ on windows
	     */
	    isUNC() {
	        const pl = this.#patternList;
	        return this.#isUNC !== undefined ?
	            this.#isUNC
	            : (this.#isUNC =
	                this.#platform === 'win32' &&
	                    this.#index === 0 &&
	                    pl[0] === '' &&
	                    pl[1] === '' &&
	                    typeof pl[2] === 'string' &&
	                    !!pl[2] &&
	                    typeof pl[3] === 'string' &&
	                    !!pl[3]);
	    }
	    // pattern like C:/...
	    // split = ['C:', ...]
	    // XXX: would be nice to handle patterns like `c:*` to test the cwd
	    // in c: for *, but I don't know of a way to even figure out what that
	    // cwd is without actually chdir'ing into it?
	    /**
	     * True if the pattern starts with a drive letter on Windows
	     */
	    isDrive() {
	        const pl = this.#patternList;
	        return this.#isDrive !== undefined ?
	            this.#isDrive
	            : (this.#isDrive =
	                this.#platform === 'win32' &&
	                    this.#index === 0 &&
	                    this.length > 1 &&
	                    typeof pl[0] === 'string' &&
	                    /^[a-z]:$/i.test(pl[0]));
	    }
	    // pattern = '/' or '/...' or '/x/...'
	    // split = ['', ''] or ['', ...] or ['', 'x', ...]
	    // Drive and UNC both considered absolute on windows
	    /**
	     * True if the pattern is rooted on an absolute path
	     */
	    isAbsolute() {
	        const pl = this.#patternList;
	        return this.#isAbsolute !== undefined ?
	            this.#isAbsolute
	            : (this.#isAbsolute =
	                (pl[0] === '' && pl.length > 1) ||
	                    this.isDrive() ||
	                    this.isUNC());
	    }
	    /**
	     * consume the root of the pattern, and return it
	     */
	    root() {
	        const p = this.#patternList[0];
	        return (typeof p === 'string' && this.isAbsolute() && this.#index === 0) ?
	            p
	            : '';
	    }
	    /**
	     * Check to see if the current globstar pattern is allowed to follow
	     * a symbolic link.
	     */
	    checkFollowGlobstar() {
	        return !(this.#index === 0 ||
	            !this.isGlobstar() ||
	            !this.#followGlobstar);
	    }
	    /**
	     * Mark that the current globstar pattern is following a symbolic link
	     */
	    markFollowGlobstar() {
	        if (this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar)
	            return false;
	        this.#followGlobstar = false;
	        return true;
	    }
	}
	pattern.Pattern = Pattern;
	
	return pattern;
}

var walker$1 = {};

var ignore = {};

var hasRequiredIgnore;

function requireIgnore () {
	if (hasRequiredIgnore) return ignore;
	hasRequiredIgnore = 1;
	// give it a pattern, and it'll be able to tell you if
	// a given path should be ignored.
	// Ignoring a path ignores its children if the pattern ends in /**
	// Ignores are always parsed in dot:true mode
	Object.defineProperty(ignore, "__esModule", { value: true });
	ignore.Ignore = void 0;
	const minimatch_1 = requireCommonjs$4();
	const pattern_js_1 = requirePattern();
	const defaultPlatform = (typeof process === 'object' &&
	    process &&
	    typeof process.platform === 'string') ?
	    process.platform
	    : 'linux';
	/**
	 * Class used to process ignored patterns
	 */
	class Ignore {
	    relative;
	    relativeChildren;
	    absolute;
	    absoluteChildren;
	    platform;
	    mmopts;
	    constructor(ignored, { nobrace, nocase, noext, noglobstar, platform = defaultPlatform, }) {
	        this.relative = [];
	        this.absolute = [];
	        this.relativeChildren = [];
	        this.absoluteChildren = [];
	        this.platform = platform;
	        this.mmopts = {
	            dot: true,
	            nobrace,
	            nocase,
	            noext,
	            noglobstar,
	            optimizationLevel: 2,
	            platform,
	            nocomment: true,
	            nonegate: true,
	        };
	        for (const ign of ignored)
	            this.add(ign);
	    }
	    add(ign) {
	        // this is a little weird, but it gives us a clean set of optimized
	        // minimatch matchers, without getting tripped up if one of them
	        // ends in /** inside a brace section, and it's only inefficient at
	        // the start of the walk, not along it.
	        // It'd be nice if the Pattern class just had a .test() method, but
	        // handling globstars is a bit of a pita, and that code already lives
	        // in minimatch anyway.
	        // Another way would be if maybe Minimatch could take its set/globParts
	        // as an option, and then we could at least just use Pattern to test
	        // for absolute-ness.
	        // Yet another way, Minimatch could take an array of glob strings, and
	        // a cwd option, and do the right thing.
	        const mm = new minimatch_1.Minimatch(ign, this.mmopts);
	        for (let i = 0; i < mm.set.length; i++) {
	            const parsed = mm.set[i];
	            const globParts = mm.globParts[i];
	            /* c8 ignore start */
	            if (!parsed || !globParts) {
	                throw new Error('invalid pattern object');
	            }
	            // strip off leading ./ portions
	            // https://github.com/isaacs/node-glob/issues/570
	            while (parsed[0] === '.' && globParts[0] === '.') {
	                parsed.shift();
	                globParts.shift();
	            }
	            /* c8 ignore stop */
	            const p = new pattern_js_1.Pattern(parsed, globParts, 0, this.platform);
	            const m = new minimatch_1.Minimatch(p.globString(), this.mmopts);
	            const children = globParts[globParts.length - 1] === '**';
	            const absolute = p.isAbsolute();
	            if (absolute)
	                this.absolute.push(m);
	            else
	                this.relative.push(m);
	            if (children) {
	                if (absolute)
	                    this.absoluteChildren.push(m);
	                else
	                    this.relativeChildren.push(m);
	            }
	        }
	    }
	    ignored(p) {
	        const fullpath = p.fullpath();
	        const fullpaths = `${fullpath}/`;
	        const relative = p.relative() || '.';
	        const relatives = `${relative}/`;
	        for (const m of this.relative) {
	            if (m.match(relative) || m.match(relatives))
	                return true;
	        }
	        for (const m of this.absolute) {
	            if (m.match(fullpath) || m.match(fullpaths))
	                return true;
	        }
	        return false;
	    }
	    childrenIgnored(p) {
	        const fullpath = p.fullpath() + '/';
	        const relative = (p.relative() || '.') + '/';
	        for (const m of this.relativeChildren) {
	            if (m.match(relative))
	                return true;
	        }
	        for (const m of this.absoluteChildren) {
	            if (m.match(fullpath))
	                return true;
	        }
	        return false;
	    }
	}
	ignore.Ignore = Ignore;
	
	return ignore;
}

var processor = {};

var hasRequiredProcessor;

function requireProcessor () {
	if (hasRequiredProcessor) return processor;
	hasRequiredProcessor = 1;
	// synchronous utility for filtering entries and calculating subwalks
	Object.defineProperty(processor, "__esModule", { value: true });
	processor.Processor = processor.SubWalks = processor.MatchRecord = processor.HasWalkedCache = void 0;
	const minimatch_1 = requireCommonjs$4();
	/**
	 * A cache of which patterns have been processed for a given Path
	 */
	class HasWalkedCache {
	    store;
	    constructor(store = new Map()) {
	        this.store = store;
	    }
	    copy() {
	        return new HasWalkedCache(new Map(this.store));
	    }
	    hasWalked(target, pattern) {
	        return this.store.get(target.fullpath())?.has(pattern.globString());
	    }
	    storeWalked(target, pattern) {
	        const fullpath = target.fullpath();
	        const cached = this.store.get(fullpath);
	        if (cached)
	            cached.add(pattern.globString());
	        else
	            this.store.set(fullpath, new Set([pattern.globString()]));
	    }
	}
	processor.HasWalkedCache = HasWalkedCache;
	/**
	 * A record of which paths have been matched in a given walk step,
	 * and whether they only are considered a match if they are a directory,
	 * and whether their absolute or relative path should be returned.
	 */
	class MatchRecord {
	    store = new Map();
	    add(target, absolute, ifDir) {
	        const n = (absolute ? 2 : 0) | (ifDir ? 1 : 0);
	        const current = this.store.get(target);
	        this.store.set(target, current === undefined ? n : n & current);
	    }
	    // match, absolute, ifdir
	    entries() {
	        return [...this.store.entries()].map(([path, n]) => [
	            path,
	            !!(n & 2),
	            !!(n & 1),
	        ]);
	    }
	}
	processor.MatchRecord = MatchRecord;
	/**
	 * A collection of patterns that must be processed in a subsequent step
	 * for a given path.
	 */
	class SubWalks {
	    store = new Map();
	    add(target, pattern) {
	        if (!target.canReaddir()) {
	            return;
	        }
	        const subs = this.store.get(target);
	        if (subs) {
	            if (!subs.find(p => p.globString() === pattern.globString())) {
	                subs.push(pattern);
	            }
	        }
	        else
	            this.store.set(target, [pattern]);
	    }
	    get(target) {
	        const subs = this.store.get(target);
	        /* c8 ignore start */
	        if (!subs) {
	            throw new Error('attempting to walk unknown path');
	        }
	        /* c8 ignore stop */
	        return subs;
	    }
	    entries() {
	        return this.keys().map(k => [k, this.store.get(k)]);
	    }
	    keys() {
	        return [...this.store.keys()].filter(t => t.canReaddir());
	    }
	}
	processor.SubWalks = SubWalks;
	/**
	 * The class that processes patterns for a given path.
	 *
	 * Handles child entry filtering, and determining whether a path's
	 * directory contents must be read.
	 */
	class Processor {
	    hasWalkedCache;
	    matches = new MatchRecord();
	    subwalks = new SubWalks();
	    patterns;
	    follow;
	    dot;
	    opts;
	    constructor(opts, hasWalkedCache) {
	        this.opts = opts;
	        this.follow = !!opts.follow;
	        this.dot = !!opts.dot;
	        this.hasWalkedCache =
	            hasWalkedCache ? hasWalkedCache.copy() : new HasWalkedCache();
	    }
	    processPatterns(target, patterns) {
	        this.patterns = patterns;
	        const processingSet = patterns.map(p => [target, p]);
	        // map of paths to the magic-starting subwalks they need to walk
	        // first item in patterns is the filter
	        for (let [t, pattern] of processingSet) {
	            this.hasWalkedCache.storeWalked(t, pattern);
	            const root = pattern.root();
	            const absolute = pattern.isAbsolute() && this.opts.absolute !== false;
	            // start absolute patterns at root
	            if (root) {
	                t = t.resolve(root === '/' && this.opts.root !== undefined ?
	                    this.opts.root
	                    : root);
	                const rest = pattern.rest();
	                if (!rest) {
	                    this.matches.add(t, true, false);
	                    continue;
	                }
	                else {
	                    pattern = rest;
	                }
	            }
	            if (t.isENOENT())
	                continue;
	            let p;
	            let rest;
	            let changed = false;
	            while (typeof (p = pattern.pattern()) === 'string' &&
	                (rest = pattern.rest())) {
	                const c = t.resolve(p);
	                t = c;
	                pattern = rest;
	                changed = true;
	            }
	            p = pattern.pattern();
	            rest = pattern.rest();
	            if (changed) {
	                if (this.hasWalkedCache.hasWalked(t, pattern))
	                    continue;
	                this.hasWalkedCache.storeWalked(t, pattern);
	            }
	            // now we have either a final string for a known entry,
	            // more strings for an unknown entry,
	            // or a pattern starting with magic, mounted on t.
	            if (typeof p === 'string') {
	                // must not be final entry, otherwise we would have
	                // concatenated it earlier.
	                const ifDir = p === '..' || p === '' || p === '.';
	                this.matches.add(t.resolve(p), absolute, ifDir);
	                continue;
	            }
	            else if (p === minimatch_1.GLOBSTAR) {
	                // if no rest, match and subwalk pattern
	                // if rest, process rest and subwalk pattern
	                // if it's a symlink, but we didn't get here by way of a
	                // globstar match (meaning it's the first time THIS globstar
	                // has traversed a symlink), then we follow it. Otherwise, stop.
	                if (!t.isSymbolicLink() ||
	                    this.follow ||
	                    pattern.checkFollowGlobstar()) {
	                    this.subwalks.add(t, pattern);
	                }
	                const rp = rest?.pattern();
	                const rrest = rest?.rest();
	                if (!rest || ((rp === '' || rp === '.') && !rrest)) {
	                    // only HAS to be a dir if it ends in **/ or **/.
	                    // but ending in ** will match files as well.
	                    this.matches.add(t, absolute, rp === '' || rp === '.');
	                }
	                else {
	                    if (rp === '..') {
	                        // this would mean you're matching **/.. at the fs root,
	                        // and no thanks, I'm not gonna test that specific case.
	                        /* c8 ignore start */
	                        const tp = t.parent || t;
	                        /* c8 ignore stop */
	                        if (!rrest)
	                            this.matches.add(tp, absolute, true);
	                        else if (!this.hasWalkedCache.hasWalked(tp, rrest)) {
	                            this.subwalks.add(tp, rrest);
	                        }
	                    }
	                }
	            }
	            else if (p instanceof RegExp) {
	                this.subwalks.add(t, pattern);
	            }
	        }
	        return this;
	    }
	    subwalkTargets() {
	        return this.subwalks.keys();
	    }
	    child() {
	        return new Processor(this.opts, this.hasWalkedCache);
	    }
	    // return a new Processor containing the subwalks for each
	    // child entry, and a set of matches, and
	    // a hasWalkedCache that's a copy of this one
	    // then we're going to call
	    filterEntries(parent, entries) {
	        const patterns = this.subwalks.get(parent);
	        // put matches and entry walks into the results processor
	        const results = this.child();
	        for (const e of entries) {
	            for (const pattern of patterns) {
	                const absolute = pattern.isAbsolute();
	                const p = pattern.pattern();
	                const rest = pattern.rest();
	                if (p === minimatch_1.GLOBSTAR) {
	                    results.testGlobstar(e, pattern, rest, absolute);
	                }
	                else if (p instanceof RegExp) {
	                    results.testRegExp(e, p, rest, absolute);
	                }
	                else {
	                    results.testString(e, p, rest, absolute);
	                }
	            }
	        }
	        return results;
	    }
	    testGlobstar(e, pattern, rest, absolute) {
	        if (this.dot || !e.name.startsWith('.')) {
	            if (!pattern.hasMore()) {
	                this.matches.add(e, absolute, false);
	            }
	            if (e.canReaddir()) {
	                // if we're in follow mode or it's not a symlink, just keep
	                // testing the same pattern. If there's more after the globstar,
	                // then this symlink consumes the globstar. If not, then we can
	                // follow at most ONE symlink along the way, so we mark it, which
	                // also checks to ensure that it wasn't already marked.
	                if (this.follow || !e.isSymbolicLink()) {
	                    this.subwalks.add(e, pattern);
	                }
	                else if (e.isSymbolicLink()) {
	                    if (rest && pattern.checkFollowGlobstar()) {
	                        this.subwalks.add(e, rest);
	                    }
	                    else if (pattern.markFollowGlobstar()) {
	                        this.subwalks.add(e, pattern);
	                    }
	                }
	            }
	        }
	        // if the NEXT thing matches this entry, then also add
	        // the rest.
	        if (rest) {
	            const rp = rest.pattern();
	            if (typeof rp === 'string' &&
	                // dots and empty were handled already
	                rp !== '..' &&
	                rp !== '' &&
	                rp !== '.') {
	                this.testString(e, rp, rest.rest(), absolute);
	            }
	            else if (rp === '..') {
	                /* c8 ignore start */
	                const ep = e.parent || e;
	                /* c8 ignore stop */
	                this.subwalks.add(ep, rest);
	            }
	            else if (rp instanceof RegExp) {
	                this.testRegExp(e, rp, rest.rest(), absolute);
	            }
	        }
	    }
	    testRegExp(e, p, rest, absolute) {
	        if (!p.test(e.name))
	            return;
	        if (!rest) {
	            this.matches.add(e, absolute, false);
	        }
	        else {
	            this.subwalks.add(e, rest);
	        }
	    }
	    testString(e, p, rest, absolute) {
	        // should never happen?
	        if (!e.isNamed(p))
	            return;
	        if (!rest) {
	            this.matches.add(e, absolute, false);
	        }
	        else {
	            this.subwalks.add(e, rest);
	        }
	    }
	}
	processor.Processor = Processor;
	
	return processor;
}

var hasRequiredWalker$1;

function requireWalker$1 () {
	if (hasRequiredWalker$1) return walker$1;
	hasRequiredWalker$1 = 1;
	Object.defineProperty(walker$1, "__esModule", { value: true });
	walker$1.GlobStream = walker$1.GlobWalker = walker$1.GlobUtil = void 0;
	/**
	 * Single-use utility classes to provide functionality to the {@link Glob}
	 * methods.
	 *
	 * @module
	 */
	const minipass_1 = requireCommonjs$2();
	const ignore_js_1 = requireIgnore();
	const processor_js_1 = requireProcessor();
	const makeIgnore = (ignore, opts) => typeof ignore === 'string' ? new ignore_js_1.Ignore([ignore], opts)
	    : Array.isArray(ignore) ? new ignore_js_1.Ignore(ignore, opts)
	        : ignore;
	/**
	 * basic walking utilities that all the glob walker types use
	 */
	class GlobUtil {
	    path;
	    patterns;
	    opts;
	    seen = new Set();
	    paused = false;
	    aborted = false;
	    #onResume = [];
	    #ignore;
	    #sep;
	    signal;
	    maxDepth;
	    includeChildMatches;
	    constructor(patterns, path, opts) {
	        this.patterns = patterns;
	        this.path = path;
	        this.opts = opts;
	        this.#sep = !opts.posix && opts.platform === 'win32' ? '\\' : '/';
	        this.includeChildMatches = opts.includeChildMatches !== false;
	        if (opts.ignore || !this.includeChildMatches) {
	            this.#ignore = makeIgnore(opts.ignore ?? [], opts);
	            if (!this.includeChildMatches &&
	                typeof this.#ignore.add !== 'function') {
	                const m = 'cannot ignore child matches, ignore lacks add() method.';
	                throw new Error(m);
	            }
	        }
	        // ignore, always set with maxDepth, but it's optional on the
	        // GlobOptions type
	        /* c8 ignore start */
	        this.maxDepth = opts.maxDepth || Infinity;
	        /* c8 ignore stop */
	        if (opts.signal) {
	            this.signal = opts.signal;
	            this.signal.addEventListener('abort', () => {
	                this.#onResume.length = 0;
	            });
	        }
	    }
	    #ignored(path) {
	        return this.seen.has(path) || !!this.#ignore?.ignored?.(path);
	    }
	    #childrenIgnored(path) {
	        return !!this.#ignore?.childrenIgnored?.(path);
	    }
	    // backpressure mechanism
	    pause() {
	        this.paused = true;
	    }
	    resume() {
	        /* c8 ignore start */
	        if (this.signal?.aborted)
	            return;
	        /* c8 ignore stop */
	        this.paused = false;
	        let fn = undefined;
	        while (!this.paused && (fn = this.#onResume.shift())) {
	            fn();
	        }
	    }
	    onResume(fn) {
	        if (this.signal?.aborted)
	            return;
	        /* c8 ignore start */
	        if (!this.paused) {
	            fn();
	        }
	        else {
	            /* c8 ignore stop */
	            this.#onResume.push(fn);
	        }
	    }
	    // do the requisite realpath/stat checking, and return the path
	    // to add or undefined to filter it out.
	    async matchCheck(e, ifDir) {
	        if (ifDir && this.opts.nodir)
	            return undefined;
	        let rpc;
	        if (this.opts.realpath) {
	            rpc = e.realpathCached() || (await e.realpath());
	            if (!rpc)
	                return undefined;
	            e = rpc;
	        }
	        const needStat = e.isUnknown() || this.opts.stat;
	        const s = needStat ? await e.lstat() : e;
	        if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
	            const target = await s.realpath();
	            /* c8 ignore start */
	            if (target && (target.isUnknown() || this.opts.stat)) {
	                await target.lstat();
	            }
	            /* c8 ignore stop */
	        }
	        return this.matchCheckTest(s, ifDir);
	    }
	    matchCheckTest(e, ifDir) {
	        return (e &&
	            (this.maxDepth === Infinity || e.depth() <= this.maxDepth) &&
	            (!ifDir || e.canReaddir()) &&
	            (!this.opts.nodir || !e.isDirectory()) &&
	            (!this.opts.nodir ||
	                !this.opts.follow ||
	                !e.isSymbolicLink() ||
	                !e.realpathCached()?.isDirectory()) &&
	            !this.#ignored(e)) ?
	            e
	            : undefined;
	    }
	    matchCheckSync(e, ifDir) {
	        if (ifDir && this.opts.nodir)
	            return undefined;
	        let rpc;
	        if (this.opts.realpath) {
	            rpc = e.realpathCached() || e.realpathSync();
	            if (!rpc)
	                return undefined;
	            e = rpc;
	        }
	        const needStat = e.isUnknown() || this.opts.stat;
	        const s = needStat ? e.lstatSync() : e;
	        if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
	            const target = s.realpathSync();
	            if (target && (target?.isUnknown() || this.opts.stat)) {
	                target.lstatSync();
	            }
	        }
	        return this.matchCheckTest(s, ifDir);
	    }
	    matchFinish(e, absolute) {
	        if (this.#ignored(e))
	            return;
	        // we know we have an ignore if this is false, but TS doesn't
	        if (!this.includeChildMatches && this.#ignore?.add) {
	            const ign = `${e.relativePosix()}/**`;
	            this.#ignore.add(ign);
	        }
	        const abs = this.opts.absolute === undefined ? absolute : this.opts.absolute;
	        this.seen.add(e);
	        const mark = this.opts.mark && e.isDirectory() ? this.#sep : '';
	        // ok, we have what we need!
	        if (this.opts.withFileTypes) {
	            this.matchEmit(e);
	        }
	        else if (abs) {
	            const abs = this.opts.posix ? e.fullpathPosix() : e.fullpath();
	            this.matchEmit(abs + mark);
	        }
	        else {
	            const rel = this.opts.posix ? e.relativePosix() : e.relative();
	            const pre = this.opts.dotRelative && !rel.startsWith('..' + this.#sep) ?
	                '.' + this.#sep
	                : '';
	            this.matchEmit(!rel ? '.' + mark : pre + rel + mark);
	        }
	    }
	    async match(e, absolute, ifDir) {
	        const p = await this.matchCheck(e, ifDir);
	        if (p)
	            this.matchFinish(p, absolute);
	    }
	    matchSync(e, absolute, ifDir) {
	        const p = this.matchCheckSync(e, ifDir);
	        if (p)
	            this.matchFinish(p, absolute);
	    }
	    walkCB(target, patterns, cb) {
	        /* c8 ignore start */
	        if (this.signal?.aborted)
	            cb();
	        /* c8 ignore stop */
	        this.walkCB2(target, patterns, new processor_js_1.Processor(this.opts), cb);
	    }
	    walkCB2(target, patterns, processor, cb) {
	        if (this.#childrenIgnored(target))
	            return cb();
	        if (this.signal?.aborted)
	            cb();
	        if (this.paused) {
	            this.onResume(() => this.walkCB2(target, patterns, processor, cb));
	            return;
	        }
	        processor.processPatterns(target, patterns);
	        // done processing.  all of the above is sync, can be abstracted out.
	        // subwalks is a map of paths to the entry filters they need
	        // matches is a map of paths to [absolute, ifDir] tuples.
	        let tasks = 1;
	        const next = () => {
	            if (--tasks === 0)
	                cb();
	        };
	        for (const [m, absolute, ifDir] of processor.matches.entries()) {
	            if (this.#ignored(m))
	                continue;
	            tasks++;
	            this.match(m, absolute, ifDir).then(() => next());
	        }
	        for (const t of processor.subwalkTargets()) {
	            if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
	                continue;
	            }
	            tasks++;
	            const childrenCached = t.readdirCached();
	            if (t.calledReaddir())
	                this.walkCB3(t, childrenCached, processor, next);
	            else {
	                t.readdirCB((_, entries) => this.walkCB3(t, entries, processor, next), true);
	            }
	        }
	        next();
	    }
	    walkCB3(target, entries, processor, cb) {
	        processor = processor.filterEntries(target, entries);
	        let tasks = 1;
	        const next = () => {
	            if (--tasks === 0)
	                cb();
	        };
	        for (const [m, absolute, ifDir] of processor.matches.entries()) {
	            if (this.#ignored(m))
	                continue;
	            tasks++;
	            this.match(m, absolute, ifDir).then(() => next());
	        }
	        for (const [target, patterns] of processor.subwalks.entries()) {
	            tasks++;
	            this.walkCB2(target, patterns, processor.child(), next);
	        }
	        next();
	    }
	    walkCBSync(target, patterns, cb) {
	        /* c8 ignore start */
	        if (this.signal?.aborted)
	            cb();
	        /* c8 ignore stop */
	        this.walkCB2Sync(target, patterns, new processor_js_1.Processor(this.opts), cb);
	    }
	    walkCB2Sync(target, patterns, processor, cb) {
	        if (this.#childrenIgnored(target))
	            return cb();
	        if (this.signal?.aborted)
	            cb();
	        if (this.paused) {
	            this.onResume(() => this.walkCB2Sync(target, patterns, processor, cb));
	            return;
	        }
	        processor.processPatterns(target, patterns);
	        // done processing.  all of the above is sync, can be abstracted out.
	        // subwalks is a map of paths to the entry filters they need
	        // matches is a map of paths to [absolute, ifDir] tuples.
	        let tasks = 1;
	        const next = () => {
	            if (--tasks === 0)
	                cb();
	        };
	        for (const [m, absolute, ifDir] of processor.matches.entries()) {
	            if (this.#ignored(m))
	                continue;
	            this.matchSync(m, absolute, ifDir);
	        }
	        for (const t of processor.subwalkTargets()) {
	            if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
	                continue;
	            }
	            tasks++;
	            const children = t.readdirSync();
	            this.walkCB3Sync(t, children, processor, next);
	        }
	        next();
	    }
	    walkCB3Sync(target, entries, processor, cb) {
	        processor = processor.filterEntries(target, entries);
	        let tasks = 1;
	        const next = () => {
	            if (--tasks === 0)
	                cb();
	        };
	        for (const [m, absolute, ifDir] of processor.matches.entries()) {
	            if (this.#ignored(m))
	                continue;
	            this.matchSync(m, absolute, ifDir);
	        }
	        for (const [target, patterns] of processor.subwalks.entries()) {
	            tasks++;
	            this.walkCB2Sync(target, patterns, processor.child(), next);
	        }
	        next();
	    }
	}
	walker$1.GlobUtil = GlobUtil;
	class GlobWalker extends GlobUtil {
	    matches = new Set();
	    constructor(patterns, path, opts) {
	        super(patterns, path, opts);
	    }
	    matchEmit(e) {
	        this.matches.add(e);
	    }
	    async walk() {
	        if (this.signal?.aborted)
	            throw this.signal.reason;
	        if (this.path.isUnknown()) {
	            await this.path.lstat();
	        }
	        await new Promise((res, rej) => {
	            this.walkCB(this.path, this.patterns, () => {
	                if (this.signal?.aborted) {
	                    rej(this.signal.reason);
	                }
	                else {
	                    res(this.matches);
	                }
	            });
	        });
	        return this.matches;
	    }
	    walkSync() {
	        if (this.signal?.aborted)
	            throw this.signal.reason;
	        if (this.path.isUnknown()) {
	            this.path.lstatSync();
	        }
	        // nothing for the callback to do, because this never pauses
	        this.walkCBSync(this.path, this.patterns, () => {
	            if (this.signal?.aborted)
	                throw this.signal.reason;
	        });
	        return this.matches;
	    }
	}
	walker$1.GlobWalker = GlobWalker;
	class GlobStream extends GlobUtil {
	    results;
	    constructor(patterns, path, opts) {
	        super(patterns, path, opts);
	        this.results = new minipass_1.Minipass({
	            signal: this.signal,
	            objectMode: true,
	        });
	        this.results.on('drain', () => this.resume());
	        this.results.on('resume', () => this.resume());
	    }
	    matchEmit(e) {
	        this.results.write(e);
	        if (!this.results.flowing)
	            this.pause();
	    }
	    stream() {
	        const target = this.path;
	        if (target.isUnknown()) {
	            target.lstat().then(() => {
	                this.walkCB(target, this.patterns, () => this.results.end());
	            });
	        }
	        else {
	            this.walkCB(target, this.patterns, () => this.results.end());
	        }
	        return this.results;
	    }
	    streamSync() {
	        if (this.path.isUnknown()) {
	            this.path.lstatSync();
	        }
	        this.walkCBSync(this.path, this.patterns, () => this.results.end());
	        return this.results;
	    }
	}
	walker$1.GlobStream = GlobStream;
	
	return walker$1;
}

var hasRequiredGlob;

function requireGlob () {
	if (hasRequiredGlob) return glob;
	hasRequiredGlob = 1;
	Object.defineProperty(glob, "__esModule", { value: true });
	glob.Glob = void 0;
	const minimatch_1 = requireCommonjs$4();
	const node_url_1 = require$$1$3;
	const path_scurry_1 = requireCommonjs$1();
	const pattern_js_1 = requirePattern();
	const walker_js_1 = requireWalker$1();
	// if no process global, just call it linux.
	// so we default to case-sensitive, / separators
	const defaultPlatform = (typeof process === 'object' &&
	    process &&
	    typeof process.platform === 'string') ?
	    process.platform
	    : 'linux';
	/**
	 * An object that can perform glob pattern traversals.
	 */
	class Glob {
	    absolute;
	    cwd;
	    root;
	    dot;
	    dotRelative;
	    follow;
	    ignore;
	    magicalBraces;
	    mark;
	    matchBase;
	    maxDepth;
	    nobrace;
	    nocase;
	    nodir;
	    noext;
	    noglobstar;
	    pattern;
	    platform;
	    realpath;
	    scurry;
	    stat;
	    signal;
	    windowsPathsNoEscape;
	    withFileTypes;
	    includeChildMatches;
	    /**
	     * The options provided to the constructor.
	     */
	    opts;
	    /**
	     * An array of parsed immutable {@link Pattern} objects.
	     */
	    patterns;
	    /**
	     * All options are stored as properties on the `Glob` object.
	     *
	     * See {@link GlobOptions} for full options descriptions.
	     *
	     * Note that a previous `Glob` object can be passed as the
	     * `GlobOptions` to another `Glob` instantiation to re-use settings
	     * and caches with a new pattern.
	     *
	     * Traversal functions can be called multiple times to run the walk
	     * again.
	     */
	    constructor(pattern, opts) {
	        /* c8 ignore start */
	        if (!opts)
	            throw new TypeError('glob options required');
	        /* c8 ignore stop */
	        this.withFileTypes = !!opts.withFileTypes;
	        this.signal = opts.signal;
	        this.follow = !!opts.follow;
	        this.dot = !!opts.dot;
	        this.dotRelative = !!opts.dotRelative;
	        this.nodir = !!opts.nodir;
	        this.mark = !!opts.mark;
	        if (!opts.cwd) {
	            this.cwd = '';
	        }
	        else if (opts.cwd instanceof URL || opts.cwd.startsWith('file://')) {
	            opts.cwd = (0, node_url_1.fileURLToPath)(opts.cwd);
	        }
	        this.cwd = opts.cwd || '';
	        this.root = opts.root;
	        this.magicalBraces = !!opts.magicalBraces;
	        this.nobrace = !!opts.nobrace;
	        this.noext = !!opts.noext;
	        this.realpath = !!opts.realpath;
	        this.absolute = opts.absolute;
	        this.includeChildMatches = opts.includeChildMatches !== false;
	        this.noglobstar = !!opts.noglobstar;
	        this.matchBase = !!opts.matchBase;
	        this.maxDepth =
	            typeof opts.maxDepth === 'number' ? opts.maxDepth : Infinity;
	        this.stat = !!opts.stat;
	        this.ignore = opts.ignore;
	        if (this.withFileTypes && this.absolute !== undefined) {
	            throw new Error('cannot set absolute and withFileTypes:true');
	        }
	        if (typeof pattern === 'string') {
	            pattern = [pattern];
	        }
	        this.windowsPathsNoEscape =
	            !!opts.windowsPathsNoEscape ||
	                opts.allowWindowsEscape ===
	                    false;
	        if (this.windowsPathsNoEscape) {
	            pattern = pattern.map(p => p.replace(/\\/g, '/'));
	        }
	        if (this.matchBase) {
	            if (opts.noglobstar) {
	                throw new TypeError('base matching requires globstar');
	            }
	            pattern = pattern.map(p => (p.includes('/') ? p : `./**/${p}`));
	        }
	        this.pattern = pattern;
	        this.platform = opts.platform || defaultPlatform;
	        this.opts = { ...opts, platform: this.platform };
	        if (opts.scurry) {
	            this.scurry = opts.scurry;
	            if (opts.nocase !== undefined &&
	                opts.nocase !== opts.scurry.nocase) {
	                throw new Error('nocase option contradicts provided scurry option');
	            }
	        }
	        else {
	            const Scurry = opts.platform === 'win32' ? path_scurry_1.PathScurryWin32
	                : opts.platform === 'darwin' ? path_scurry_1.PathScurryDarwin
	                    : opts.platform ? path_scurry_1.PathScurryPosix
	                        : path_scurry_1.PathScurry;
	            this.scurry = new Scurry(this.cwd, {
	                nocase: opts.nocase,
	                fs: opts.fs,
	            });
	        }
	        this.nocase = this.scurry.nocase;
	        // If you do nocase:true on a case-sensitive file system, then
	        // we need to use regexps instead of strings for non-magic
	        // path portions, because statting `aBc` won't return results
	        // for the file `AbC` for example.
	        const nocaseMagicOnly = this.platform === 'darwin' || this.platform === 'win32';
	        const mmo = {
	            // default nocase based on platform
	            ...opts,
	            dot: this.dot,
	            matchBase: this.matchBase,
	            nobrace: this.nobrace,
	            nocase: this.nocase,
	            nocaseMagicOnly,
	            nocomment: true,
	            noext: this.noext,
	            nonegate: true,
	            optimizationLevel: 2,
	            platform: this.platform,
	            windowsPathsNoEscape: this.windowsPathsNoEscape,
	            debug: !!this.opts.debug,
	        };
	        const mms = this.pattern.map(p => new minimatch_1.Minimatch(p, mmo));
	        const [matchSet, globParts] = mms.reduce((set, m) => {
	            set[0].push(...m.set);
	            set[1].push(...m.globParts);
	            return set;
	        }, [[], []]);
	        this.patterns = matchSet.map((set, i) => {
	            const g = globParts[i];
	            /* c8 ignore start */
	            if (!g)
	                throw new Error('invalid pattern object');
	            /* c8 ignore stop */
	            return new pattern_js_1.Pattern(set, g, 0, this.platform);
	        });
	    }
	    async walk() {
	        // Walkers always return array of Path objects, so we just have to
	        // coerce them into the right shape.  It will have already called
	        // realpath() if the option was set to do so, so we know that's cached.
	        // start out knowing the cwd, at least
	        return [
	            ...(await new walker_js_1.GlobWalker(this.patterns, this.scurry.cwd, {
	                ...this.opts,
	                maxDepth: this.maxDepth !== Infinity ?
	                    this.maxDepth + this.scurry.cwd.depth()
	                    : Infinity,
	                platform: this.platform,
	                nocase: this.nocase,
	                includeChildMatches: this.includeChildMatches,
	            }).walk()),
	        ];
	    }
	    walkSync() {
	        return [
	            ...new walker_js_1.GlobWalker(this.patterns, this.scurry.cwd, {
	                ...this.opts,
	                maxDepth: this.maxDepth !== Infinity ?
	                    this.maxDepth + this.scurry.cwd.depth()
	                    : Infinity,
	                platform: this.platform,
	                nocase: this.nocase,
	                includeChildMatches: this.includeChildMatches,
	            }).walkSync(),
	        ];
	    }
	    stream() {
	        return new walker_js_1.GlobStream(this.patterns, this.scurry.cwd, {
	            ...this.opts,
	            maxDepth: this.maxDepth !== Infinity ?
	                this.maxDepth + this.scurry.cwd.depth()
	                : Infinity,
	            platform: this.platform,
	            nocase: this.nocase,
	            includeChildMatches: this.includeChildMatches,
	        }).stream();
	    }
	    streamSync() {
	        return new walker_js_1.GlobStream(this.patterns, this.scurry.cwd, {
	            ...this.opts,
	            maxDepth: this.maxDepth !== Infinity ?
	                this.maxDepth + this.scurry.cwd.depth()
	                : Infinity,
	            platform: this.platform,
	            nocase: this.nocase,
	            includeChildMatches: this.includeChildMatches,
	        }).streamSync();
	    }
	    /**
	     * Default sync iteration function. Returns a Generator that
	     * iterates over the results.
	     */
	    iterateSync() {
	        return this.streamSync()[Symbol.iterator]();
	    }
	    [Symbol.iterator]() {
	        return this.iterateSync();
	    }
	    /**
	     * Default async iteration function. Returns an AsyncGenerator that
	     * iterates over the results.
	     */
	    iterate() {
	        return this.stream()[Symbol.asyncIterator]();
	    }
	    [Symbol.asyncIterator]() {
	        return this.iterate();
	    }
	}
	glob.Glob = Glob;
	
	return glob;
}

var hasMagic = {};

var hasRequiredHasMagic;

function requireHasMagic () {
	if (hasRequiredHasMagic) return hasMagic;
	hasRequiredHasMagic = 1;
	Object.defineProperty(hasMagic, "__esModule", { value: true });
	hasMagic.hasMagic = void 0;
	const minimatch_1 = requireCommonjs$4();
	/**
	 * Return true if the patterns provided contain any magic glob characters,
	 * given the options provided.
	 *
	 * Brace expansion is not considered "magic" unless the `magicalBraces` option
	 * is set, as brace expansion just turns one string into an array of strings.
	 * So a pattern like `'x{a,b}y'` would return `false`, because `'xay'` and
	 * `'xby'` both do not contain any magic glob characters, and it's treated the
	 * same as if you had called it on `['xay', 'xby']`. When `magicalBraces:true`
	 * is in the options, brace expansion _is_ treated as a pattern having magic.
	 */
	const hasMagic$1 = (pattern, options = {}) => {
	    if (!Array.isArray(pattern)) {
	        pattern = [pattern];
	    }
	    for (const p of pattern) {
	        if (new minimatch_1.Minimatch(p, options).hasMagic())
	            return true;
	    }
	    return false;
	};
	hasMagic.hasMagic = hasMagic$1;
	
	return hasMagic;
}

var hasRequiredCommonjs;

function requireCommonjs () {
	if (hasRequiredCommonjs) return commonjs$6;
	hasRequiredCommonjs = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.glob = exports.sync = exports.iterate = exports.iterateSync = exports.stream = exports.streamSync = exports.Ignore = exports.hasMagic = exports.Glob = exports.unescape = exports.escape = void 0;
		exports.globStreamSync = globStreamSync;
		exports.globStream = globStream;
		exports.globSync = globSync;
		exports.globIterateSync = globIterateSync;
		exports.globIterate = globIterate;
		const minimatch_1 = requireCommonjs$4();
		const glob_js_1 = requireGlob();
		const has_magic_js_1 = requireHasMagic();
		var minimatch_2 = requireCommonjs$4();
		Object.defineProperty(exports, "escape", { enumerable: true, get: function () { return minimatch_2.escape; } });
		Object.defineProperty(exports, "unescape", { enumerable: true, get: function () { return minimatch_2.unescape; } });
		var glob_js_2 = requireGlob();
		Object.defineProperty(exports, "Glob", { enumerable: true, get: function () { return glob_js_2.Glob; } });
		var has_magic_js_2 = requireHasMagic();
		Object.defineProperty(exports, "hasMagic", { enumerable: true, get: function () { return has_magic_js_2.hasMagic; } });
		var ignore_js_1 = requireIgnore();
		Object.defineProperty(exports, "Ignore", { enumerable: true, get: function () { return ignore_js_1.Ignore; } });
		function globStreamSync(pattern, options = {}) {
		    return new glob_js_1.Glob(pattern, options).streamSync();
		}
		function globStream(pattern, options = {}) {
		    return new glob_js_1.Glob(pattern, options).stream();
		}
		function globSync(pattern, options = {}) {
		    return new glob_js_1.Glob(pattern, options).walkSync();
		}
		async function glob_(pattern, options = {}) {
		    return new glob_js_1.Glob(pattern, options).walk();
		}
		function globIterateSync(pattern, options = {}) {
		    return new glob_js_1.Glob(pattern, options).iterateSync();
		}
		function globIterate(pattern, options = {}) {
		    return new glob_js_1.Glob(pattern, options).iterate();
		}
		// aliases: glob.sync.stream() glob.stream.sync() glob.sync() etc
		exports.streamSync = globStreamSync;
		exports.stream = Object.assign(globStream, { sync: globStreamSync });
		exports.iterateSync = globIterateSync;
		exports.iterate = Object.assign(globIterate, {
		    sync: globIterateSync,
		});
		exports.sync = Object.assign(globSync, {
		    stream: globStreamSync,
		    iterate: globIterateSync,
		});
		exports.glob = Object.assign(glob_, {
		    glob: glob_,
		    globSync,
		    sync: exports.sync,
		    globStream,
		    stream: exports.stream,
		    globStreamSync,
		    streamSync: exports.streamSync,
		    globIterate,
		    iterate: exports.iterate,
		    globIterateSync,
		    iterateSync: exports.iterateSync,
		    Glob: glob_js_1.Glob,
		    hasMagic: has_magic_js_1.hasMagic,
		    escape: minimatch_1.escape,
		    unescape: minimatch_1.unescape,
		});
		exports.glob.glob = exports.glob;
		
	} (commonjs$6));
	return commonjs$6;
}

var send$1 = {exports: {}};

var isUtf8MimeType = {};

var hasRequiredIsUtf8MimeType;

function requireIsUtf8MimeType () {
	if (hasRequiredIsUtf8MimeType) return isUtf8MimeType;
	hasRequiredIsUtf8MimeType = 1;

	function isUtf8MimeType$1 (value) {
	  const len = value.length;
	  return (
	    (len > 21 && value.indexOf('application/javascript') === 0) ||
	    (len > 14 && value.indexOf('application/json') === 0) ||
	    (len > 5 && value.indexOf('text/') === 0)
	  )
	}

	isUtf8MimeType.isUtf8MimeType = isUtf8MimeType$1;
	return isUtf8MimeType;
}

var Mime_1;
var hasRequiredMime$1;

function requireMime$1 () {
	if (hasRequiredMime$1) return Mime_1;
	hasRequiredMime$1 = 1;

	/**
	 * @param typeMap [Object] Map of MIME type -> Array[extensions]
	 * @param ...
	 */
	function Mime() {
	  this._types = Object.create(null);
	  this._extensions = Object.create(null);

	  for (let i = 0; i < arguments.length; i++) {
	    this.define(arguments[i]);
	  }

	  this.define = this.define.bind(this);
	  this.getType = this.getType.bind(this);
	  this.getExtension = this.getExtension.bind(this);
	}

	/**
	 * Define mimetype -> extension mappings.  Each key is a mime-type that maps
	 * to an array of extensions associated with the type.  The first extension is
	 * used as the default extension for the type.
	 *
	 * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});
	 *
	 * If a type declares an extension that has already been defined, an error will
	 * be thrown.  To suppress this error and force the extension to be associated
	 * with the new type, pass `force`=true.  Alternatively, you may prefix the
	 * extension with "*" to map the type to extension, without mapping the
	 * extension to the type.
	 *
	 * e.g. mime.define({'audio/wav', ['wav']}, {'audio/x-wav', ['*wav']});
	 *
	 *
	 * @param map (Object) type definitions
	 * @param force (Boolean) if true, force overriding of existing definitions
	 */
	Mime.prototype.define = function(typeMap, force) {
	  for (let type in typeMap) {
	    let extensions = typeMap[type].map(function(t) {
	      return t.toLowerCase();
	    });
	    type = type.toLowerCase();

	    for (let i = 0; i < extensions.length; i++) {
	      const ext = extensions[i];

	      // '*' prefix = not the preferred type for this extension.  So fixup the
	      // extension, and skip it.
	      if (ext[0] === '*') {
	        continue;
	      }

	      if (!force && (ext in this._types)) {
	        throw new Error(
	          'Attempt to change mapping for "' + ext +
	          '" extension from "' + this._types[ext] + '" to "' + type +
	          '". Pass `force=true` to allow this, otherwise remove "' + ext +
	          '" from the list of extensions for "' + type + '".'
	        );
	      }

	      this._types[ext] = type;
	    }

	    // Use first extension as default
	    if (force || !this._extensions[type]) {
	      const ext = extensions[0];
	      this._extensions[type] = (ext[0] !== '*') ? ext : ext.substr(1);
	    }
	  }
	};

	/**
	 * Lookup a mime type based on extension
	 */
	Mime.prototype.getType = function(path) {
	  path = String(path);
	  let last = path.replace(/^.*[/\\]/, '').toLowerCase();
	  let ext = last.replace(/^.*\./, '').toLowerCase();

	  let hasPath = last.length < path.length;
	  let hasDot = ext.length < last.length - 1;

	  return (hasDot || !hasPath) && this._types[ext] || null;
	};

	/**
	 * Return file extension associated with a mime type
	 */
	Mime.prototype.getExtension = function(type) {
	  type = /^\s*([^;\s]*)/.test(type) && RegExp.$1;
	  return type && this._extensions[type.toLowerCase()] || null;
	};

	Mime_1 = Mime;
	return Mime_1;
}

var standard;
var hasRequiredStandard;

function requireStandard () {
	if (hasRequiredStandard) return standard;
	hasRequiredStandard = 1;
	standard = {"application/andrew-inset":["ez"],"application/applixware":["aw"],"application/atom+xml":["atom"],"application/atomcat+xml":["atomcat"],"application/atomdeleted+xml":["atomdeleted"],"application/atomsvc+xml":["atomsvc"],"application/atsc-dwd+xml":["dwd"],"application/atsc-held+xml":["held"],"application/atsc-rsat+xml":["rsat"],"application/bdoc":["bdoc"],"application/calendar+xml":["xcs"],"application/ccxml+xml":["ccxml"],"application/cdfx+xml":["cdfx"],"application/cdmi-capability":["cdmia"],"application/cdmi-container":["cdmic"],"application/cdmi-domain":["cdmid"],"application/cdmi-object":["cdmio"],"application/cdmi-queue":["cdmiq"],"application/cu-seeme":["cu"],"application/dash+xml":["mpd"],"application/davmount+xml":["davmount"],"application/docbook+xml":["dbk"],"application/dssc+der":["dssc"],"application/dssc+xml":["xdssc"],"application/ecmascript":["es","ecma"],"application/emma+xml":["emma"],"application/emotionml+xml":["emotionml"],"application/epub+zip":["epub"],"application/exi":["exi"],"application/express":["exp"],"application/fdt+xml":["fdt"],"application/font-tdpfr":["pfr"],"application/geo+json":["geojson"],"application/gml+xml":["gml"],"application/gpx+xml":["gpx"],"application/gxf":["gxf"],"application/gzip":["gz"],"application/hjson":["hjson"],"application/hyperstudio":["stk"],"application/inkml+xml":["ink","inkml"],"application/ipfix":["ipfix"],"application/its+xml":["its"],"application/java-archive":["jar","war","ear"],"application/java-serialized-object":["ser"],"application/java-vm":["class"],"application/javascript":["js","mjs"],"application/json":["json","map"],"application/json5":["json5"],"application/jsonml+json":["jsonml"],"application/ld+json":["jsonld"],"application/lgr+xml":["lgr"],"application/lost+xml":["lostxml"],"application/mac-binhex40":["hqx"],"application/mac-compactpro":["cpt"],"application/mads+xml":["mads"],"application/manifest+json":["webmanifest"],"application/marc":["mrc"],"application/marcxml+xml":["mrcx"],"application/mathematica":["ma","nb","mb"],"application/mathml+xml":["mathml"],"application/mbox":["mbox"],"application/mediaservercontrol+xml":["mscml"],"application/metalink+xml":["metalink"],"application/metalink4+xml":["meta4"],"application/mets+xml":["mets"],"application/mmt-aei+xml":["maei"],"application/mmt-usd+xml":["musd"],"application/mods+xml":["mods"],"application/mp21":["m21","mp21"],"application/mp4":["mp4s","m4p"],"application/msword":["doc","dot"],"application/mxf":["mxf"],"application/n-quads":["nq"],"application/n-triples":["nt"],"application/node":["cjs"],"application/octet-stream":["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"],"application/oda":["oda"],"application/oebps-package+xml":["opf"],"application/ogg":["ogx"],"application/omdoc+xml":["omdoc"],"application/onenote":["onetoc","onetoc2","onetmp","onepkg"],"application/oxps":["oxps"],"application/p2p-overlay+xml":["relo"],"application/patch-ops-error+xml":["xer"],"application/pdf":["pdf"],"application/pgp-encrypted":["pgp"],"application/pgp-signature":["asc","sig"],"application/pics-rules":["prf"],"application/pkcs10":["p10"],"application/pkcs7-mime":["p7m","p7c"],"application/pkcs7-signature":["p7s"],"application/pkcs8":["p8"],"application/pkix-attr-cert":["ac"],"application/pkix-cert":["cer"],"application/pkix-crl":["crl"],"application/pkix-pkipath":["pkipath"],"application/pkixcmp":["pki"],"application/pls+xml":["pls"],"application/postscript":["ai","eps","ps"],"application/provenance+xml":["provx"],"application/pskc+xml":["pskcxml"],"application/raml+yaml":["raml"],"application/rdf+xml":["rdf","owl"],"application/reginfo+xml":["rif"],"application/relax-ng-compact-syntax":["rnc"],"application/resource-lists+xml":["rl"],"application/resource-lists-diff+xml":["rld"],"application/rls-services+xml":["rs"],"application/route-apd+xml":["rapd"],"application/route-s-tsid+xml":["sls"],"application/route-usd+xml":["rusd"],"application/rpki-ghostbusters":["gbr"],"application/rpki-manifest":["mft"],"application/rpki-roa":["roa"],"application/rsd+xml":["rsd"],"application/rss+xml":["rss"],"application/rtf":["rtf"],"application/sbml+xml":["sbml"],"application/scvp-cv-request":["scq"],"application/scvp-cv-response":["scs"],"application/scvp-vp-request":["spq"],"application/scvp-vp-response":["spp"],"application/sdp":["sdp"],"application/senml+xml":["senmlx"],"application/sensml+xml":["sensmlx"],"application/set-payment-initiation":["setpay"],"application/set-registration-initiation":["setreg"],"application/shf+xml":["shf"],"application/sieve":["siv","sieve"],"application/smil+xml":["smi","smil"],"application/sparql-query":["rq"],"application/sparql-results+xml":["srx"],"application/srgs":["gram"],"application/srgs+xml":["grxml"],"application/sru+xml":["sru"],"application/ssdl+xml":["ssdl"],"application/ssml+xml":["ssml"],"application/swid+xml":["swidtag"],"application/tei+xml":["tei","teicorpus"],"application/thraud+xml":["tfi"],"application/timestamped-data":["tsd"],"application/toml":["toml"],"application/trig":["trig"],"application/ttml+xml":["ttml"],"application/ubjson":["ubj"],"application/urc-ressheet+xml":["rsheet"],"application/urc-targetdesc+xml":["td"],"application/voicexml+xml":["vxml"],"application/wasm":["wasm"],"application/widget":["wgt"],"application/winhlp":["hlp"],"application/wsdl+xml":["wsdl"],"application/wspolicy+xml":["wspolicy"],"application/xaml+xml":["xaml"],"application/xcap-att+xml":["xav"],"application/xcap-caps+xml":["xca"],"application/xcap-diff+xml":["xdf"],"application/xcap-el+xml":["xel"],"application/xcap-ns+xml":["xns"],"application/xenc+xml":["xenc"],"application/xhtml+xml":["xhtml","xht"],"application/xliff+xml":["xlf"],"application/xml":["xml","xsl","xsd","rng"],"application/xml-dtd":["dtd"],"application/xop+xml":["xop"],"application/xproc+xml":["xpl"],"application/xslt+xml":["*xsl","xslt"],"application/xspf+xml":["xspf"],"application/xv+xml":["mxml","xhvml","xvml","xvm"],"application/yang":["yang"],"application/yin+xml":["yin"],"application/zip":["zip"],"audio/3gpp":["*3gpp"],"audio/adpcm":["adp"],"audio/amr":["amr"],"audio/basic":["au","snd"],"audio/midi":["mid","midi","kar","rmi"],"audio/mobile-xmf":["mxmf"],"audio/mp3":["*mp3"],"audio/mp4":["m4a","mp4a"],"audio/mpeg":["mpga","mp2","mp2a","mp3","m2a","m3a"],"audio/ogg":["oga","ogg","spx","opus"],"audio/s3m":["s3m"],"audio/silk":["sil"],"audio/wav":["wav"],"audio/wave":["*wav"],"audio/webm":["weba"],"audio/xm":["xm"],"font/collection":["ttc"],"font/otf":["otf"],"font/ttf":["ttf"],"font/woff":["woff"],"font/woff2":["woff2"],"image/aces":["exr"],"image/apng":["apng"],"image/avif":["avif"],"image/bmp":["bmp"],"image/cgm":["cgm"],"image/dicom-rle":["drle"],"image/emf":["emf"],"image/fits":["fits"],"image/g3fax":["g3"],"image/gif":["gif"],"image/heic":["heic"],"image/heic-sequence":["heics"],"image/heif":["heif"],"image/heif-sequence":["heifs"],"image/hej2k":["hej2"],"image/hsj2":["hsj2"],"image/ief":["ief"],"image/jls":["jls"],"image/jp2":["jp2","jpg2"],"image/jpeg":["jpeg","jpg","jpe"],"image/jph":["jph"],"image/jphc":["jhc"],"image/jpm":["jpm"],"image/jpx":["jpx","jpf"],"image/jxr":["jxr"],"image/jxra":["jxra"],"image/jxrs":["jxrs"],"image/jxs":["jxs"],"image/jxsc":["jxsc"],"image/jxsi":["jxsi"],"image/jxss":["jxss"],"image/ktx":["ktx"],"image/ktx2":["ktx2"],"image/png":["png"],"image/sgi":["sgi"],"image/svg+xml":["svg","svgz"],"image/t38":["t38"],"image/tiff":["tif","tiff"],"image/tiff-fx":["tfx"],"image/webp":["webp"],"image/wmf":["wmf"],"message/disposition-notification":["disposition-notification"],"message/global":["u8msg"],"message/global-delivery-status":["u8dsn"],"message/global-disposition-notification":["u8mdn"],"message/global-headers":["u8hdr"],"message/rfc822":["eml","mime"],"model/3mf":["3mf"],"model/gltf+json":["gltf"],"model/gltf-binary":["glb"],"model/iges":["igs","iges"],"model/mesh":["msh","mesh","silo"],"model/mtl":["mtl"],"model/obj":["obj"],"model/step+xml":["stpx"],"model/step+zip":["stpz"],"model/step-xml+zip":["stpxz"],"model/stl":["stl"],"model/vrml":["wrl","vrml"],"model/x3d+binary":["*x3db","x3dbz"],"model/x3d+fastinfoset":["x3db"],"model/x3d+vrml":["*x3dv","x3dvz"],"model/x3d+xml":["x3d","x3dz"],"model/x3d-vrml":["x3dv"],"text/cache-manifest":["appcache","manifest"],"text/calendar":["ics","ifb"],"text/coffeescript":["coffee","litcoffee"],"text/css":["css"],"text/csv":["csv"],"text/html":["html","htm","shtml"],"text/jade":["jade"],"text/jsx":["jsx"],"text/less":["less"],"text/markdown":["markdown","md"],"text/mathml":["mml"],"text/mdx":["mdx"],"text/n3":["n3"],"text/plain":["txt","text","conf","def","list","log","in","ini"],"text/richtext":["rtx"],"text/rtf":["*rtf"],"text/sgml":["sgml","sgm"],"text/shex":["shex"],"text/slim":["slim","slm"],"text/spdx":["spdx"],"text/stylus":["stylus","styl"],"text/tab-separated-values":["tsv"],"text/troff":["t","tr","roff","man","me","ms"],"text/turtle":["ttl"],"text/uri-list":["uri","uris","urls"],"text/vcard":["vcard"],"text/vtt":["vtt"],"text/xml":["*xml"],"text/yaml":["yaml","yml"],"video/3gpp":["3gp","3gpp"],"video/3gpp2":["3g2"],"video/h261":["h261"],"video/h263":["h263"],"video/h264":["h264"],"video/iso.segment":["m4s"],"video/jpeg":["jpgv"],"video/jpm":["*jpm","jpgm"],"video/mj2":["mj2","mjp2"],"video/mp2t":["ts"],"video/mp4":["mp4","mp4v","mpg4"],"video/mpeg":["mpeg","mpg","mpe","m1v","m2v"],"video/ogg":["ogv"],"video/quicktime":["qt","mov"],"video/webm":["webm"]};
	return standard;
}

var other;
var hasRequiredOther;

function requireOther () {
	if (hasRequiredOther) return other;
	hasRequiredOther = 1;
	other = {"application/prs.cww":["cww"],"application/vnd.1000minds.decision-model+xml":["1km"],"application/vnd.3gpp.pic-bw-large":["plb"],"application/vnd.3gpp.pic-bw-small":["psb"],"application/vnd.3gpp.pic-bw-var":["pvb"],"application/vnd.3gpp2.tcap":["tcap"],"application/vnd.3m.post-it-notes":["pwn"],"application/vnd.accpac.simply.aso":["aso"],"application/vnd.accpac.simply.imp":["imp"],"application/vnd.acucobol":["acu"],"application/vnd.acucorp":["atc","acutc"],"application/vnd.adobe.air-application-installer-package+zip":["air"],"application/vnd.adobe.formscentral.fcdt":["fcdt"],"application/vnd.adobe.fxp":["fxp","fxpl"],"application/vnd.adobe.xdp+xml":["xdp"],"application/vnd.adobe.xfdf":["xfdf"],"application/vnd.ahead.space":["ahead"],"application/vnd.airzip.filesecure.azf":["azf"],"application/vnd.airzip.filesecure.azs":["azs"],"application/vnd.amazon.ebook":["azw"],"application/vnd.americandynamics.acc":["acc"],"application/vnd.amiga.ami":["ami"],"application/vnd.android.package-archive":["apk"],"application/vnd.anser-web-certificate-issue-initiation":["cii"],"application/vnd.anser-web-funds-transfer-initiation":["fti"],"application/vnd.antix.game-component":["atx"],"application/vnd.apple.installer+xml":["mpkg"],"application/vnd.apple.keynote":["key"],"application/vnd.apple.mpegurl":["m3u8"],"application/vnd.apple.numbers":["numbers"],"application/vnd.apple.pages":["pages"],"application/vnd.apple.pkpass":["pkpass"],"application/vnd.aristanetworks.swi":["swi"],"application/vnd.astraea-software.iota":["iota"],"application/vnd.audiograph":["aep"],"application/vnd.balsamiq.bmml+xml":["bmml"],"application/vnd.blueice.multipass":["mpm"],"application/vnd.bmi":["bmi"],"application/vnd.businessobjects":["rep"],"application/vnd.chemdraw+xml":["cdxml"],"application/vnd.chipnuts.karaoke-mmd":["mmd"],"application/vnd.cinderella":["cdy"],"application/vnd.citationstyles.style+xml":["csl"],"application/vnd.claymore":["cla"],"application/vnd.cloanto.rp9":["rp9"],"application/vnd.clonk.c4group":["c4g","c4d","c4f","c4p","c4u"],"application/vnd.cluetrust.cartomobile-config":["c11amc"],"application/vnd.cluetrust.cartomobile-config-pkg":["c11amz"],"application/vnd.commonspace":["csp"],"application/vnd.contact.cmsg":["cdbcmsg"],"application/vnd.cosmocaller":["cmc"],"application/vnd.crick.clicker":["clkx"],"application/vnd.crick.clicker.keyboard":["clkk"],"application/vnd.crick.clicker.palette":["clkp"],"application/vnd.crick.clicker.template":["clkt"],"application/vnd.crick.clicker.wordbank":["clkw"],"application/vnd.criticaltools.wbs+xml":["wbs"],"application/vnd.ctc-posml":["pml"],"application/vnd.cups-ppd":["ppd"],"application/vnd.curl.car":["car"],"application/vnd.curl.pcurl":["pcurl"],"application/vnd.dart":["dart"],"application/vnd.data-vision.rdz":["rdz"],"application/vnd.dbf":["dbf"],"application/vnd.dece.data":["uvf","uvvf","uvd","uvvd"],"application/vnd.dece.ttml+xml":["uvt","uvvt"],"application/vnd.dece.unspecified":["uvx","uvvx"],"application/vnd.dece.zip":["uvz","uvvz"],"application/vnd.denovo.fcselayout-link":["fe_launch"],"application/vnd.dna":["dna"],"application/vnd.dolby.mlp":["mlp"],"application/vnd.dpgraph":["dpg"],"application/vnd.dreamfactory":["dfac"],"application/vnd.ds-keypoint":["kpxx"],"application/vnd.dvb.ait":["ait"],"application/vnd.dvb.service":["svc"],"application/vnd.dynageo":["geo"],"application/vnd.ecowin.chart":["mag"],"application/vnd.enliven":["nml"],"application/vnd.epson.esf":["esf"],"application/vnd.epson.msf":["msf"],"application/vnd.epson.quickanime":["qam"],"application/vnd.epson.salt":["slt"],"application/vnd.epson.ssf":["ssf"],"application/vnd.eszigno3+xml":["es3","et3"],"application/vnd.ezpix-album":["ez2"],"application/vnd.ezpix-package":["ez3"],"application/vnd.fdf":["fdf"],"application/vnd.fdsn.mseed":["mseed"],"application/vnd.fdsn.seed":["seed","dataless"],"application/vnd.flographit":["gph"],"application/vnd.fluxtime.clip":["ftc"],"application/vnd.framemaker":["fm","frame","maker","book"],"application/vnd.frogans.fnc":["fnc"],"application/vnd.frogans.ltf":["ltf"],"application/vnd.fsc.weblaunch":["fsc"],"application/vnd.fujitsu.oasys":["oas"],"application/vnd.fujitsu.oasys2":["oa2"],"application/vnd.fujitsu.oasys3":["oa3"],"application/vnd.fujitsu.oasysgp":["fg5"],"application/vnd.fujitsu.oasysprs":["bh2"],"application/vnd.fujixerox.ddd":["ddd"],"application/vnd.fujixerox.docuworks":["xdw"],"application/vnd.fujixerox.docuworks.binder":["xbd"],"application/vnd.fuzzysheet":["fzs"],"application/vnd.genomatix.tuxedo":["txd"],"application/vnd.geogebra.file":["ggb"],"application/vnd.geogebra.tool":["ggt"],"application/vnd.geometry-explorer":["gex","gre"],"application/vnd.geonext":["gxt"],"application/vnd.geoplan":["g2w"],"application/vnd.geospace":["g3w"],"application/vnd.gmx":["gmx"],"application/vnd.google-apps.document":["gdoc"],"application/vnd.google-apps.presentation":["gslides"],"application/vnd.google-apps.spreadsheet":["gsheet"],"application/vnd.google-earth.kml+xml":["kml"],"application/vnd.google-earth.kmz":["kmz"],"application/vnd.grafeq":["gqf","gqs"],"application/vnd.groove-account":["gac"],"application/vnd.groove-help":["ghf"],"application/vnd.groove-identity-message":["gim"],"application/vnd.groove-injector":["grv"],"application/vnd.groove-tool-message":["gtm"],"application/vnd.groove-tool-template":["tpl"],"application/vnd.groove-vcard":["vcg"],"application/vnd.hal+xml":["hal"],"application/vnd.handheld-entertainment+xml":["zmm"],"application/vnd.hbci":["hbci"],"application/vnd.hhe.lesson-player":["les"],"application/vnd.hp-hpgl":["hpgl"],"application/vnd.hp-hpid":["hpid"],"application/vnd.hp-hps":["hps"],"application/vnd.hp-jlyt":["jlt"],"application/vnd.hp-pcl":["pcl"],"application/vnd.hp-pclxl":["pclxl"],"application/vnd.hydrostatix.sof-data":["sfd-hdstx"],"application/vnd.ibm.minipay":["mpy"],"application/vnd.ibm.modcap":["afp","listafp","list3820"],"application/vnd.ibm.rights-management":["irm"],"application/vnd.ibm.secure-container":["sc"],"application/vnd.iccprofile":["icc","icm"],"application/vnd.igloader":["igl"],"application/vnd.immervision-ivp":["ivp"],"application/vnd.immervision-ivu":["ivu"],"application/vnd.insors.igm":["igm"],"application/vnd.intercon.formnet":["xpw","xpx"],"application/vnd.intergeo":["i2g"],"application/vnd.intu.qbo":["qbo"],"application/vnd.intu.qfx":["qfx"],"application/vnd.ipunplugged.rcprofile":["rcprofile"],"application/vnd.irepository.package+xml":["irp"],"application/vnd.is-xpr":["xpr"],"application/vnd.isac.fcs":["fcs"],"application/vnd.jam":["jam"],"application/vnd.jcp.javame.midlet-rms":["rms"],"application/vnd.jisp":["jisp"],"application/vnd.joost.joda-archive":["joda"],"application/vnd.kahootz":["ktz","ktr"],"application/vnd.kde.karbon":["karbon"],"application/vnd.kde.kchart":["chrt"],"application/vnd.kde.kformula":["kfo"],"application/vnd.kde.kivio":["flw"],"application/vnd.kde.kontour":["kon"],"application/vnd.kde.kpresenter":["kpr","kpt"],"application/vnd.kde.kspread":["ksp"],"application/vnd.kde.kword":["kwd","kwt"],"application/vnd.kenameaapp":["htke"],"application/vnd.kidspiration":["kia"],"application/vnd.kinar":["kne","knp"],"application/vnd.koan":["skp","skd","skt","skm"],"application/vnd.kodak-descriptor":["sse"],"application/vnd.las.las+xml":["lasxml"],"application/vnd.llamagraphics.life-balance.desktop":["lbd"],"application/vnd.llamagraphics.life-balance.exchange+xml":["lbe"],"application/vnd.lotus-1-2-3":["123"],"application/vnd.lotus-approach":["apr"],"application/vnd.lotus-freelance":["pre"],"application/vnd.lotus-notes":["nsf"],"application/vnd.lotus-organizer":["org"],"application/vnd.lotus-screencam":["scm"],"application/vnd.lotus-wordpro":["lwp"],"application/vnd.macports.portpkg":["portpkg"],"application/vnd.mapbox-vector-tile":["mvt"],"application/vnd.mcd":["mcd"],"application/vnd.medcalcdata":["mc1"],"application/vnd.mediastation.cdkey":["cdkey"],"application/vnd.mfer":["mwf"],"application/vnd.mfmp":["mfm"],"application/vnd.micrografx.flo":["flo"],"application/vnd.micrografx.igx":["igx"],"application/vnd.mif":["mif"],"application/vnd.mobius.daf":["daf"],"application/vnd.mobius.dis":["dis"],"application/vnd.mobius.mbk":["mbk"],"application/vnd.mobius.mqy":["mqy"],"application/vnd.mobius.msl":["msl"],"application/vnd.mobius.plc":["plc"],"application/vnd.mobius.txf":["txf"],"application/vnd.mophun.application":["mpn"],"application/vnd.mophun.certificate":["mpc"],"application/vnd.mozilla.xul+xml":["xul"],"application/vnd.ms-artgalry":["cil"],"application/vnd.ms-cab-compressed":["cab"],"application/vnd.ms-excel":["xls","xlm","xla","xlc","xlt","xlw"],"application/vnd.ms-excel.addin.macroenabled.12":["xlam"],"application/vnd.ms-excel.sheet.binary.macroenabled.12":["xlsb"],"application/vnd.ms-excel.sheet.macroenabled.12":["xlsm"],"application/vnd.ms-excel.template.macroenabled.12":["xltm"],"application/vnd.ms-fontobject":["eot"],"application/vnd.ms-htmlhelp":["chm"],"application/vnd.ms-ims":["ims"],"application/vnd.ms-lrm":["lrm"],"application/vnd.ms-officetheme":["thmx"],"application/vnd.ms-outlook":["msg"],"application/vnd.ms-pki.seccat":["cat"],"application/vnd.ms-pki.stl":["*stl"],"application/vnd.ms-powerpoint":["ppt","pps","pot"],"application/vnd.ms-powerpoint.addin.macroenabled.12":["ppam"],"application/vnd.ms-powerpoint.presentation.macroenabled.12":["pptm"],"application/vnd.ms-powerpoint.slide.macroenabled.12":["sldm"],"application/vnd.ms-powerpoint.slideshow.macroenabled.12":["ppsm"],"application/vnd.ms-powerpoint.template.macroenabled.12":["potm"],"application/vnd.ms-project":["mpp","mpt"],"application/vnd.ms-word.document.macroenabled.12":["docm"],"application/vnd.ms-word.template.macroenabled.12":["dotm"],"application/vnd.ms-works":["wps","wks","wcm","wdb"],"application/vnd.ms-wpl":["wpl"],"application/vnd.ms-xpsdocument":["xps"],"application/vnd.mseq":["mseq"],"application/vnd.musician":["mus"],"application/vnd.muvee.style":["msty"],"application/vnd.mynfc":["taglet"],"application/vnd.neurolanguage.nlu":["nlu"],"application/vnd.nitf":["ntf","nitf"],"application/vnd.noblenet-directory":["nnd"],"application/vnd.noblenet-sealer":["nns"],"application/vnd.noblenet-web":["nnw"],"application/vnd.nokia.n-gage.ac+xml":["*ac"],"application/vnd.nokia.n-gage.data":["ngdat"],"application/vnd.nokia.n-gage.symbian.install":["n-gage"],"application/vnd.nokia.radio-preset":["rpst"],"application/vnd.nokia.radio-presets":["rpss"],"application/vnd.novadigm.edm":["edm"],"application/vnd.novadigm.edx":["edx"],"application/vnd.novadigm.ext":["ext"],"application/vnd.oasis.opendocument.chart":["odc"],"application/vnd.oasis.opendocument.chart-template":["otc"],"application/vnd.oasis.opendocument.database":["odb"],"application/vnd.oasis.opendocument.formula":["odf"],"application/vnd.oasis.opendocument.formula-template":["odft"],"application/vnd.oasis.opendocument.graphics":["odg"],"application/vnd.oasis.opendocument.graphics-template":["otg"],"application/vnd.oasis.opendocument.image":["odi"],"application/vnd.oasis.opendocument.image-template":["oti"],"application/vnd.oasis.opendocument.presentation":["odp"],"application/vnd.oasis.opendocument.presentation-template":["otp"],"application/vnd.oasis.opendocument.spreadsheet":["ods"],"application/vnd.oasis.opendocument.spreadsheet-template":["ots"],"application/vnd.oasis.opendocument.text":["odt"],"application/vnd.oasis.opendocument.text-master":["odm"],"application/vnd.oasis.opendocument.text-template":["ott"],"application/vnd.oasis.opendocument.text-web":["oth"],"application/vnd.olpc-sugar":["xo"],"application/vnd.oma.dd2+xml":["dd2"],"application/vnd.openblox.game+xml":["obgx"],"application/vnd.openofficeorg.extension":["oxt"],"application/vnd.openstreetmap.data+xml":["osm"],"application/vnd.openxmlformats-officedocument.presentationml.presentation":["pptx"],"application/vnd.openxmlformats-officedocument.presentationml.slide":["sldx"],"application/vnd.openxmlformats-officedocument.presentationml.slideshow":["ppsx"],"application/vnd.openxmlformats-officedocument.presentationml.template":["potx"],"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":["xlsx"],"application/vnd.openxmlformats-officedocument.spreadsheetml.template":["xltx"],"application/vnd.openxmlformats-officedocument.wordprocessingml.document":["docx"],"application/vnd.openxmlformats-officedocument.wordprocessingml.template":["dotx"],"application/vnd.osgeo.mapguide.package":["mgp"],"application/vnd.osgi.dp":["dp"],"application/vnd.osgi.subsystem":["esa"],"application/vnd.palm":["pdb","pqa","oprc"],"application/vnd.pawaafile":["paw"],"application/vnd.pg.format":["str"],"application/vnd.pg.osasli":["ei6"],"application/vnd.picsel":["efif"],"application/vnd.pmi.widget":["wg"],"application/vnd.pocketlearn":["plf"],"application/vnd.powerbuilder6":["pbd"],"application/vnd.previewsystems.box":["box"],"application/vnd.proteus.magazine":["mgz"],"application/vnd.publishare-delta-tree":["qps"],"application/vnd.pvi.ptid1":["ptid"],"application/vnd.quark.quarkxpress":["qxd","qxt","qwd","qwt","qxl","qxb"],"application/vnd.rar":["rar"],"application/vnd.realvnc.bed":["bed"],"application/vnd.recordare.musicxml":["mxl"],"application/vnd.recordare.musicxml+xml":["musicxml"],"application/vnd.rig.cryptonote":["cryptonote"],"application/vnd.rim.cod":["cod"],"application/vnd.rn-realmedia":["rm"],"application/vnd.rn-realmedia-vbr":["rmvb"],"application/vnd.route66.link66+xml":["link66"],"application/vnd.sailingtracker.track":["st"],"application/vnd.seemail":["see"],"application/vnd.sema":["sema"],"application/vnd.semd":["semd"],"application/vnd.semf":["semf"],"application/vnd.shana.informed.formdata":["ifm"],"application/vnd.shana.informed.formtemplate":["itp"],"application/vnd.shana.informed.interchange":["iif"],"application/vnd.shana.informed.package":["ipk"],"application/vnd.simtech-mindmapper":["twd","twds"],"application/vnd.smaf":["mmf"],"application/vnd.smart.teacher":["teacher"],"application/vnd.software602.filler.form+xml":["fo"],"application/vnd.solent.sdkm+xml":["sdkm","sdkd"],"application/vnd.spotfire.dxp":["dxp"],"application/vnd.spotfire.sfs":["sfs"],"application/vnd.stardivision.calc":["sdc"],"application/vnd.stardivision.draw":["sda"],"application/vnd.stardivision.impress":["sdd"],"application/vnd.stardivision.math":["smf"],"application/vnd.stardivision.writer":["sdw","vor"],"application/vnd.stardivision.writer-global":["sgl"],"application/vnd.stepmania.package":["smzip"],"application/vnd.stepmania.stepchart":["sm"],"application/vnd.sun.wadl+xml":["wadl"],"application/vnd.sun.xml.calc":["sxc"],"application/vnd.sun.xml.calc.template":["stc"],"application/vnd.sun.xml.draw":["sxd"],"application/vnd.sun.xml.draw.template":["std"],"application/vnd.sun.xml.impress":["sxi"],"application/vnd.sun.xml.impress.template":["sti"],"application/vnd.sun.xml.math":["sxm"],"application/vnd.sun.xml.writer":["sxw"],"application/vnd.sun.xml.writer.global":["sxg"],"application/vnd.sun.xml.writer.template":["stw"],"application/vnd.sus-calendar":["sus","susp"],"application/vnd.svd":["svd"],"application/vnd.symbian.install":["sis","sisx"],"application/vnd.syncml+xml":["xsm"],"application/vnd.syncml.dm+wbxml":["bdm"],"application/vnd.syncml.dm+xml":["xdm"],"application/vnd.syncml.dmddf+xml":["ddf"],"application/vnd.tao.intent-module-archive":["tao"],"application/vnd.tcpdump.pcap":["pcap","cap","dmp"],"application/vnd.tmobile-livetv":["tmo"],"application/vnd.trid.tpt":["tpt"],"application/vnd.triscape.mxs":["mxs"],"application/vnd.trueapp":["tra"],"application/vnd.ufdl":["ufd","ufdl"],"application/vnd.uiq.theme":["utz"],"application/vnd.umajin":["umj"],"application/vnd.unity":["unityweb"],"application/vnd.uoml+xml":["uoml"],"application/vnd.vcx":["vcx"],"application/vnd.visio":["vsd","vst","vss","vsw"],"application/vnd.visionary":["vis"],"application/vnd.vsf":["vsf"],"application/vnd.wap.wbxml":["wbxml"],"application/vnd.wap.wmlc":["wmlc"],"application/vnd.wap.wmlscriptc":["wmlsc"],"application/vnd.webturbo":["wtb"],"application/vnd.wolfram.player":["nbp"],"application/vnd.wordperfect":["wpd"],"application/vnd.wqd":["wqd"],"application/vnd.wt.stf":["stf"],"application/vnd.xara":["xar"],"application/vnd.xfdl":["xfdl"],"application/vnd.yamaha.hv-dic":["hvd"],"application/vnd.yamaha.hv-script":["hvs"],"application/vnd.yamaha.hv-voice":["hvp"],"application/vnd.yamaha.openscoreformat":["osf"],"application/vnd.yamaha.openscoreformat.osfpvg+xml":["osfpvg"],"application/vnd.yamaha.smaf-audio":["saf"],"application/vnd.yamaha.smaf-phrase":["spf"],"application/vnd.yellowriver-custom-menu":["cmp"],"application/vnd.zul":["zir","zirz"],"application/vnd.zzazz.deck+xml":["zaz"],"application/x-7z-compressed":["7z"],"application/x-abiword":["abw"],"application/x-ace-compressed":["ace"],"application/x-apple-diskimage":["*dmg"],"application/x-arj":["arj"],"application/x-authorware-bin":["aab","x32","u32","vox"],"application/x-authorware-map":["aam"],"application/x-authorware-seg":["aas"],"application/x-bcpio":["bcpio"],"application/x-bdoc":["*bdoc"],"application/x-bittorrent":["torrent"],"application/x-blorb":["blb","blorb"],"application/x-bzip":["bz"],"application/x-bzip2":["bz2","boz"],"application/x-cbr":["cbr","cba","cbt","cbz","cb7"],"application/x-cdlink":["vcd"],"application/x-cfs-compressed":["cfs"],"application/x-chat":["chat"],"application/x-chess-pgn":["pgn"],"application/x-chrome-extension":["crx"],"application/x-cocoa":["cco"],"application/x-conference":["nsc"],"application/x-cpio":["cpio"],"application/x-csh":["csh"],"application/x-debian-package":["*deb","udeb"],"application/x-dgc-compressed":["dgc"],"application/x-director":["dir","dcr","dxr","cst","cct","cxt","w3d","fgd","swa"],"application/x-doom":["wad"],"application/x-dtbncx+xml":["ncx"],"application/x-dtbook+xml":["dtb"],"application/x-dtbresource+xml":["res"],"application/x-dvi":["dvi"],"application/x-envoy":["evy"],"application/x-eva":["eva"],"application/x-font-bdf":["bdf"],"application/x-font-ghostscript":["gsf"],"application/x-font-linux-psf":["psf"],"application/x-font-pcf":["pcf"],"application/x-font-snf":["snf"],"application/x-font-type1":["pfa","pfb","pfm","afm"],"application/x-freearc":["arc"],"application/x-futuresplash":["spl"],"application/x-gca-compressed":["gca"],"application/x-glulx":["ulx"],"application/x-gnumeric":["gnumeric"],"application/x-gramps-xml":["gramps"],"application/x-gtar":["gtar"],"application/x-hdf":["hdf"],"application/x-httpd-php":["php"],"application/x-install-instructions":["install"],"application/x-iso9660-image":["*iso"],"application/x-iwork-keynote-sffkey":["*key"],"application/x-iwork-numbers-sffnumbers":["*numbers"],"application/x-iwork-pages-sffpages":["*pages"],"application/x-java-archive-diff":["jardiff"],"application/x-java-jnlp-file":["jnlp"],"application/x-keepass2":["kdbx"],"application/x-latex":["latex"],"application/x-lua-bytecode":["luac"],"application/x-lzh-compressed":["lzh","lha"],"application/x-makeself":["run"],"application/x-mie":["mie"],"application/x-mobipocket-ebook":["prc","mobi"],"application/x-ms-application":["application"],"application/x-ms-shortcut":["lnk"],"application/x-ms-wmd":["wmd"],"application/x-ms-wmz":["wmz"],"application/x-ms-xbap":["xbap"],"application/x-msaccess":["mdb"],"application/x-msbinder":["obd"],"application/x-mscardfile":["crd"],"application/x-msclip":["clp"],"application/x-msdos-program":["*exe"],"application/x-msdownload":["*exe","*dll","com","bat","*msi"],"application/x-msmediaview":["mvb","m13","m14"],"application/x-msmetafile":["*wmf","*wmz","*emf","emz"],"application/x-msmoney":["mny"],"application/x-mspublisher":["pub"],"application/x-msschedule":["scd"],"application/x-msterminal":["trm"],"application/x-mswrite":["wri"],"application/x-netcdf":["nc","cdf"],"application/x-ns-proxy-autoconfig":["pac"],"application/x-nzb":["nzb"],"application/x-perl":["pl","pm"],"application/x-pilot":["*prc","*pdb"],"application/x-pkcs12":["p12","pfx"],"application/x-pkcs7-certificates":["p7b","spc"],"application/x-pkcs7-certreqresp":["p7r"],"application/x-rar-compressed":["*rar"],"application/x-redhat-package-manager":["rpm"],"application/x-research-info-systems":["ris"],"application/x-sea":["sea"],"application/x-sh":["sh"],"application/x-shar":["shar"],"application/x-shockwave-flash":["swf"],"application/x-silverlight-app":["xap"],"application/x-sql":["sql"],"application/x-stuffit":["sit"],"application/x-stuffitx":["sitx"],"application/x-subrip":["srt"],"application/x-sv4cpio":["sv4cpio"],"application/x-sv4crc":["sv4crc"],"application/x-t3vm-image":["t3"],"application/x-tads":["gam"],"application/x-tar":["tar"],"application/x-tcl":["tcl","tk"],"application/x-tex":["tex"],"application/x-tex-tfm":["tfm"],"application/x-texinfo":["texinfo","texi"],"application/x-tgif":["*obj"],"application/x-ustar":["ustar"],"application/x-virtualbox-hdd":["hdd"],"application/x-virtualbox-ova":["ova"],"application/x-virtualbox-ovf":["ovf"],"application/x-virtualbox-vbox":["vbox"],"application/x-virtualbox-vbox-extpack":["vbox-extpack"],"application/x-virtualbox-vdi":["vdi"],"application/x-virtualbox-vhd":["vhd"],"application/x-virtualbox-vmdk":["vmdk"],"application/x-wais-source":["src"],"application/x-web-app-manifest+json":["webapp"],"application/x-x509-ca-cert":["der","crt","pem"],"application/x-xfig":["fig"],"application/x-xliff+xml":["*xlf"],"application/x-xpinstall":["xpi"],"application/x-xz":["xz"],"application/x-zmachine":["z1","z2","z3","z4","z5","z6","z7","z8"],"audio/vnd.dece.audio":["uva","uvva"],"audio/vnd.digital-winds":["eol"],"audio/vnd.dra":["dra"],"audio/vnd.dts":["dts"],"audio/vnd.dts.hd":["dtshd"],"audio/vnd.lucent.voice":["lvp"],"audio/vnd.ms-playready.media.pya":["pya"],"audio/vnd.nuera.ecelp4800":["ecelp4800"],"audio/vnd.nuera.ecelp7470":["ecelp7470"],"audio/vnd.nuera.ecelp9600":["ecelp9600"],"audio/vnd.rip":["rip"],"audio/x-aac":["aac"],"audio/x-aiff":["aif","aiff","aifc"],"audio/x-caf":["caf"],"audio/x-flac":["flac"],"audio/x-m4a":["*m4a"],"audio/x-matroska":["mka"],"audio/x-mpegurl":["m3u"],"audio/x-ms-wax":["wax"],"audio/x-ms-wma":["wma"],"audio/x-pn-realaudio":["ram","ra"],"audio/x-pn-realaudio-plugin":["rmp"],"audio/x-realaudio":["*ra"],"audio/x-wav":["*wav"],"chemical/x-cdx":["cdx"],"chemical/x-cif":["cif"],"chemical/x-cmdf":["cmdf"],"chemical/x-cml":["cml"],"chemical/x-csml":["csml"],"chemical/x-xyz":["xyz"],"image/prs.btif":["btif"],"image/prs.pti":["pti"],"image/vnd.adobe.photoshop":["psd"],"image/vnd.airzip.accelerator.azv":["azv"],"image/vnd.dece.graphic":["uvi","uvvi","uvg","uvvg"],"image/vnd.djvu":["djvu","djv"],"image/vnd.dvb.subtitle":["*sub"],"image/vnd.dwg":["dwg"],"image/vnd.dxf":["dxf"],"image/vnd.fastbidsheet":["fbs"],"image/vnd.fpx":["fpx"],"image/vnd.fst":["fst"],"image/vnd.fujixerox.edmics-mmr":["mmr"],"image/vnd.fujixerox.edmics-rlc":["rlc"],"image/vnd.microsoft.icon":["ico"],"image/vnd.ms-dds":["dds"],"image/vnd.ms-modi":["mdi"],"image/vnd.ms-photo":["wdp"],"image/vnd.net-fpx":["npx"],"image/vnd.pco.b16":["b16"],"image/vnd.tencent.tap":["tap"],"image/vnd.valve.source.texture":["vtf"],"image/vnd.wap.wbmp":["wbmp"],"image/vnd.xiff":["xif"],"image/vnd.zbrush.pcx":["pcx"],"image/x-3ds":["3ds"],"image/x-cmu-raster":["ras"],"image/x-cmx":["cmx"],"image/x-freehand":["fh","fhc","fh4","fh5","fh7"],"image/x-icon":["*ico"],"image/x-jng":["jng"],"image/x-mrsid-image":["sid"],"image/x-ms-bmp":["*bmp"],"image/x-pcx":["*pcx"],"image/x-pict":["pic","pct"],"image/x-portable-anymap":["pnm"],"image/x-portable-bitmap":["pbm"],"image/x-portable-graymap":["pgm"],"image/x-portable-pixmap":["ppm"],"image/x-rgb":["rgb"],"image/x-tga":["tga"],"image/x-xbitmap":["xbm"],"image/x-xpixmap":["xpm"],"image/x-xwindowdump":["xwd"],"message/vnd.wfa.wsc":["wsc"],"model/vnd.collada+xml":["dae"],"model/vnd.dwf":["dwf"],"model/vnd.gdl":["gdl"],"model/vnd.gtw":["gtw"],"model/vnd.mts":["mts"],"model/vnd.opengex":["ogex"],"model/vnd.parasolid.transmit.binary":["x_b"],"model/vnd.parasolid.transmit.text":["x_t"],"model/vnd.sap.vds":["vds"],"model/vnd.usdz+zip":["usdz"],"model/vnd.valve.source.compiled-map":["bsp"],"model/vnd.vtu":["vtu"],"text/prs.lines.tag":["dsc"],"text/vnd.curl":["curl"],"text/vnd.curl.dcurl":["dcurl"],"text/vnd.curl.mcurl":["mcurl"],"text/vnd.curl.scurl":["scurl"],"text/vnd.dvb.subtitle":["sub"],"text/vnd.fly":["fly"],"text/vnd.fmi.flexstor":["flx"],"text/vnd.graphviz":["gv"],"text/vnd.in3d.3dml":["3dml"],"text/vnd.in3d.spot":["spot"],"text/vnd.sun.j2me.app-descriptor":["jad"],"text/vnd.wap.wml":["wml"],"text/vnd.wap.wmlscript":["wmls"],"text/x-asm":["s","asm"],"text/x-c":["c","cc","cxx","cpp","h","hh","dic"],"text/x-component":["htc"],"text/x-fortran":["f","for","f77","f90"],"text/x-handlebars-template":["hbs"],"text/x-java-source":["java"],"text/x-lua":["lua"],"text/x-markdown":["mkd"],"text/x-nfo":["nfo"],"text/x-opml":["opml"],"text/x-org":["*org"],"text/x-pascal":["p","pas"],"text/x-processing":["pde"],"text/x-sass":["sass"],"text/x-scss":["scss"],"text/x-setext":["etx"],"text/x-sfv":["sfv"],"text/x-suse-ymp":["ymp"],"text/x-uuencode":["uu"],"text/x-vcalendar":["vcs"],"text/x-vcard":["vcf"],"video/vnd.dece.hd":["uvh","uvvh"],"video/vnd.dece.mobile":["uvm","uvvm"],"video/vnd.dece.pd":["uvp","uvvp"],"video/vnd.dece.sd":["uvs","uvvs"],"video/vnd.dece.video":["uvv","uvvv"],"video/vnd.dvb.file":["dvb"],"video/vnd.fvt":["fvt"],"video/vnd.mpegurl":["mxu","m4u"],"video/vnd.ms-playready.media.pyv":["pyv"],"video/vnd.uvvu.mp4":["uvu","uvvu"],"video/vnd.vivo":["viv"],"video/x-f4v":["f4v"],"video/x-fli":["fli"],"video/x-flv":["flv"],"video/x-m4v":["m4v"],"video/x-matroska":["mkv","mk3d","mks"],"video/x-mng":["mng"],"video/x-ms-asf":["asf","asx"],"video/x-ms-vob":["vob"],"video/x-ms-wm":["wm"],"video/x-ms-wmv":["wmv"],"video/x-ms-wmx":["wmx"],"video/x-ms-wvx":["wvx"],"video/x-msvideo":["avi"],"video/x-sgi-movie":["movie"],"video/x-smv":["smv"],"x-conference/x-cooltalk":["ice"]};
	return other;
}

var mime;
var hasRequiredMime;

function requireMime () {
	if (hasRequiredMime) return mime;
	hasRequiredMime = 1;

	let Mime = requireMime$1();
	mime = new Mime(requireStandard(), requireOther());
	return mime;
}

var send = {};

/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */

var escapeHtml_1;
var hasRequiredEscapeHtml;

function requireEscapeHtml () {
	if (hasRequiredEscapeHtml) return escapeHtml_1;
	hasRequiredEscapeHtml = 1;

	/**
	 * Module variables.
	 * @private
	 */

	var matchHtmlRegExp = /["'&<>]/;

	/**
	 * Module exports.
	 * @public
	 */

	escapeHtml_1 = escapeHtml;

	/**
	 * Escape special characters in the given string of html.
	 *
	 * @param  {string} string The string to escape for inserting into HTML
	 * @return {string}
	 * @public
	 */

	function escapeHtml(string) {
	  var str = '' + string;
	  var match = matchHtmlRegExp.exec(str);

	  if (!match) {
	    return str;
	  }

	  var escape;
	  var html = '';
	  var index = 0;
	  var lastIndex = 0;

	  for (index = match.index; index < str.length; index++) {
	    switch (str.charCodeAt(index)) {
	      case 34: // "
	        escape = '&quot;';
	        break;
	      case 38: // &
	        escape = '&amp;';
	        break;
	      case 39: // '
	        escape = '&#39;';
	        break;
	      case 60: // <
	        escape = '&lt;';
	        break;
	      case 62: // >
	        escape = '&gt;';
	        break;
	      default:
	        continue;
	    }

	    if (lastIndex !== index) {
	      html += str.substring(lastIndex, index);
	    }

	    lastIndex = index + 1;
	    html += escape;
	  }

	  return lastIndex !== index
	    ? html + str.substring(lastIndex, index)
	    : html;
	}
	return escapeHtml_1;
}

var dist = {};

var hasRequiredDist;

function requireDist () {
	if (hasRequiredDist) return dist;
	hasRequiredDist = 1;
	var RGX = /^(-?(?:\d+)?\.?\d+) *(m(?:illiseconds?|s(?:ecs?)?))?(s(?:ec(?:onds?|s)?)?)?(m(?:in(?:utes?|s)?)?)?(h(?:ours?|rs?)?)?(d(?:ays?)?)?(w(?:eeks?|ks?)?)?(y(?:ears?|rs?)?)?$/,
		SEC = 1e3,
		MIN = SEC * 60,
		HOUR = MIN * 60,
		DAY = HOUR * 24,
		YEAR = DAY * 365.25;

	function parse(val) {
		var num, arr = val.toLowerCase().match(RGX);
		if (arr != null && (num = parseFloat(arr[1]))) {
			if (arr[3] != null) return num * SEC;
			if (arr[4] != null) return num * MIN;
			if (arr[5] != null) return num * HOUR;
			if (arr[6] != null) return num * DAY;
			if (arr[7] != null) return num * DAY * 7;
			if (arr[8] != null) return num * YEAR;
			return num;
		}
	}

	function fmt(val, pfx, str, long) {
		var num = (val | 0) === val ? val : ~~(val + 0.5);
		return pfx + num + (long ? (' ' + str + (num != 1 ? 's' : '')) : str[0]);
	}

	function format(num, long) {
		var pfx = num < 0  ? '-' : '', abs = num < 0 ? -num : num;
		if (abs < SEC) return num + (long ? ' ms' : 'ms');
		if (abs < MIN) return fmt(abs / SEC, pfx, 'second', long);
		if (abs < HOUR) return fmt(abs / MIN, pfx, 'minute', long);
		if (abs < DAY) return fmt(abs / HOUR, pfx, 'hour', long);
		if (abs < YEAR) return fmt(abs / DAY, pfx, 'day', long);
		return fmt(abs / YEAR, pfx, 'year', long);
	}

	dist.format = format;
	dist.parse = parse;
	return dist;
}

var collapseLeadingSlashes = {};

var hasRequiredCollapseLeadingSlashes;

function requireCollapseLeadingSlashes () {
	if (hasRequiredCollapseLeadingSlashes) return collapseLeadingSlashes;
	hasRequiredCollapseLeadingSlashes = 1;

	/**
	 * Collapse all leading slashes into a single slash
	 *
	 * @param {string} str
	 * @private
	 */

	function collapseLeadingSlashes$1 (str) {
	  if (
	    str[0] !== '/' ||
	    str[1] !== '/'
	  ) {
	    return str
	  }
	  for (let i = 2, il = str.length; i < il; ++i) {
	    if (str[i] !== '/') {
	      return str.slice(i - 1)
	    }
	  }
	  /* c8 ignore next */
	}

	collapseLeadingSlashes.collapseLeadingSlashes = collapseLeadingSlashes$1;
	return collapseLeadingSlashes;
}

var containsDotFile = {};

/*!
 * send
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */

var hasRequiredContainsDotFile;

function requireContainsDotFile () {
	if (hasRequiredContainsDotFile) return containsDotFile;
	hasRequiredContainsDotFile = 1;
	/**
	 * Determine if path parts contain a dotfile.
	 *
	 * @api private
	 */
	function containsDotFile$1 (parts) {
	  for (let i = 0, il = parts.length; i < il; ++i) {
	    if (parts[i].length !== 1 && parts[i][0] === '.') {
	      return true
	    }
	  }

	  return false
	}

	containsDotFile.containsDotFile = containsDotFile$1;
	return containsDotFile;
}

var contentRange = {};

/*!
 * send
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */

var hasRequiredContentRange;

function requireContentRange () {
	if (hasRequiredContentRange) return contentRange;
	hasRequiredContentRange = 1;
	/**
	 * Create a Content-Range header.
	 *
	 * @param {string} type
	 * @param {number} size
	 * @param {array} [range]
	 */
	function contentRange$1 (type, size, range) {
	  return type + ' ' + (range ? range.start + '-' + range.end : '*') + '/' + size
	}
	contentRange.contentRange = contentRange$1;
	return contentRange;
}

var createHtmlDocument = {};

/*!
 * send
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */

var hasRequiredCreateHtmlDocument;

function requireCreateHtmlDocument () {
	if (hasRequiredCreateHtmlDocument) return createHtmlDocument;
	hasRequiredCreateHtmlDocument = 1;
	/**
	 * Create a minimal HTML document.
	 *
	 * @param {string} title
	 * @param {string} body
	 * @private
	 */
	function createHtmlDocument$1 (title, body) {
	  const html = '<!DOCTYPE html>\n' +
	    '<html lang="en">\n' +
	    '<head>\n' +
	    '<meta charset="utf-8">\n' +
	    '<title>' + title + '</title>\n' +
	    '</head>\n' +
	    '<body>\n' +
	    '<pre>' + body + '</pre>\n' +
	    '</body>\n' +
	    '</html>\n';

	  return [html, Buffer.byteLength(html)]
	}
	createHtmlDocument.createHtmlDocument = createHtmlDocument$1;
	return createHtmlDocument;
}

var normalizeList = {};

var hasRequiredNormalizeList;

function requireNormalizeList () {
	if (hasRequiredNormalizeList) return normalizeList;
	hasRequiredNormalizeList = 1;

	/**
	 * Normalize the index option into an array.
	 *
	 * @param {boolean|string|array} val
	 * @param {string} name
	 * @private
	 */

	function normalizeList$1 (val, name) {
	  if (typeof val === 'string') {
	    return [val]
	  } else if (val === false) {
	    return []
	  } else if (Array.isArray(val)) {
	    for (let i = 0, il = val.length; i < il; ++i) {
	      if (typeof val[i] !== 'string') {
	        throw new TypeError(name + ' must be array of strings or false')
	      }
	    }
	    return val
	  } else {
	    throw new TypeError(name + ' must be array of strings or false')
	  }
	}

	normalizeList.normalizeList = normalizeList$1;
	return normalizeList;
}

var parseBytesRange = {};

var hasRequiredParseBytesRange;

function requireParseBytesRange () {
	if (hasRequiredParseBytesRange) return parseBytesRange;
	hasRequiredParseBytesRange = 1;

	/*!
	 * Based on range-parser
	 *
	 * Copyright(c) 2012-2014 TJ Holowaychuk
	 * Copyright(c) 2015-2016 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	/**
	 * Parse "Range" header `str` relative to the given file `size`.
	 *
	 * @param {Number} size
	 * @param {String} str
	 * @return {Array}
	 * @public
	 */

	function parseBytesRange$1 (size, str) {
	  // split the range string
	  const values = str.slice(str.indexOf('=') + 1);
	  const ranges = [];

	  const len = values.length;
	  let i = 0;
	  let il = 0;
	  let j = 0;
	  let start;
	  let end;
	  let commaIdx = values.indexOf(',');
	  let dashIdx = values.indexOf('-');
	  let prevIdx = -1;

	  // parse all ranges
	  while (true) {
	    commaIdx === -1 && (commaIdx = len);
	    start = parseInt(values.slice(prevIdx + 1, dashIdx), 10);
	    end = parseInt(values.slice(dashIdx + 1, commaIdx), 10);

	    // -nnn
	    // eslint-disable-next-line no-self-compare
	    if (start !== start) { // fast path of isNaN(number)
	      start = size - end;
	      end = size - 1;
	      // nnn-
	    // eslint-disable-next-line no-self-compare
	    } else if (end !== end) { // fast path of isNaN(number)
	      end = size - 1;
	      // limit last-byte-pos to current length
	    } else if (end > size - 1) {
	      end = size - 1;
	    }

	    // add range only on valid ranges
	    if (
	      // eslint-disable-next-line no-self-compare
	      start === start && // fast path of isNaN(number)
	      // eslint-disable-next-line no-self-compare
	      end === end && // fast path of isNaN(number)
	      start > -1 &&
	      start <= end
	    ) {
	      // add range
	      ranges.push({
	        start,
	        end,
	        index: j++
	      });
	    }

	    if (commaIdx === len) {
	      break
	    }
	    prevIdx = commaIdx++;
	    dashIdx = values.indexOf('-', commaIdx);
	    commaIdx = values.indexOf(',', commaIdx);
	  }

	  // unsatisfiable
	  if (
	    j < 2
	  ) {
	    return ranges
	  }

	  ranges.sort(sortByRangeStart);

	  il = j;
	  j = 0;
	  i = 1;
	  while (i < il) {
	    const range = ranges[i++];
	    const current = ranges[j];

	    if (range.start > current.end + 1) {
	      // next range
	      ranges[++j] = range;
	    } else if (range.end > current.end) {
	      // extend range
	      current.end = range.end;
	      current.index > range.index && (current.index = range.index);
	    }
	  }

	  // trim ordered array
	  ranges.length = j + 1;

	  // generate combined range
	  ranges.sort(sortByRangeIndex);

	  return ranges
	}

	/**
	 * Sort function to sort ranges by index.
	 * @private
	 */

	function sortByRangeIndex (a, b) {
	  return a.index - b.index
	}

	/**
	 * Sort function to sort ranges by start position.
	 * @private
	 */

	function sortByRangeStart (a, b) {
	  return a.start - b.start
	}

	parseBytesRange.parseBytesRange = parseBytesRange$1;
	return parseBytesRange;
}

var parseTokenList = {};

var hasRequiredParseTokenList;

function requireParseTokenList () {
	if (hasRequiredParseTokenList) return parseTokenList;
	hasRequiredParseTokenList = 1;

	/**
	 * Parse a HTTP token list.
	 *
	 * @param {string} str
	 * @private
	 */

	const slice = String.prototype.slice;

	function parseTokenList$1 (str, cb) {
	  let end = 0;
	  let start = 0;
	  let result;

	  // gather tokens
	  for (let i = 0, len = str.length; i < len; i++) {
	    switch (str.charCodeAt(i)) {
	      case 0x20: /*   */
	        if (start === end) {
	          start = end = i + 1;
	        }
	        break
	      case 0x2c: /* , */
	        if (start !== end) {
	          result = cb(slice.call(str, start, end));
	          if (result !== undefined) {
	            return result
	          }
	        }
	        start = end = i + 1;
	        break
	      default:
	        end = i + 1;
	        break
	    }
	  }

	  // final token
	  if (start !== end) {
	    return cb(slice.call(str, start, end))
	  }
	}

	parseTokenList.parseTokenList = parseTokenList$1;
	return parseTokenList;
}

var createHttpError = {};

var httpErrors = {exports: {}};

/*!
 * depd
 * Copyright(c) 2014-2018 Douglas Christopher Wilson
 * MIT Licensed
 */

var depd_1;
var hasRequiredDepd;

function requireDepd () {
	if (hasRequiredDepd) return depd_1;
	hasRequiredDepd = 1;
	/**
	 * Module dependencies.
	 */

	var relative = path.relative;

	/**
	 * Module exports.
	 */

	depd_1 = depd;

	/**
	 * Get the path to base files on.
	 */

	var basePath = process.cwd();

	/**
	 * Determine if namespace is contained in the string.
	 */

	function containsNamespace (str, namespace) {
	  var vals = str.split(/[ ,]+/);
	  var ns = String(namespace).toLowerCase();

	  for (var i = 0; i < vals.length; i++) {
	    var val = vals[i];

	    // namespace contained
	    if (val && (val === '*' || val.toLowerCase() === ns)) {
	      return true
	    }
	  }

	  return false
	}

	/**
	 * Convert a data descriptor to accessor descriptor.
	 */

	function convertDataDescriptorToAccessor (obj, prop, message) {
	  var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
	  var value = descriptor.value;

	  descriptor.get = function getter () { return value };

	  if (descriptor.writable) {
	    descriptor.set = function setter (val) { return (value = val) };
	  }

	  delete descriptor.value;
	  delete descriptor.writable;

	  Object.defineProperty(obj, prop, descriptor);

	  return descriptor
	}

	/**
	 * Create arguments string to keep arity.
	 */

	function createArgumentsString (arity) {
	  var str = '';

	  for (var i = 0; i < arity; i++) {
	    str += ', arg' + i;
	  }

	  return str.substr(2)
	}

	/**
	 * Create stack string from stack.
	 */

	function createStackString (stack) {
	  var str = this.name + ': ' + this.namespace;

	  if (this.message) {
	    str += ' deprecated ' + this.message;
	  }

	  for (var i = 0; i < stack.length; i++) {
	    str += '\n    at ' + stack[i].toString();
	  }

	  return str
	}

	/**
	 * Create deprecate for namespace in caller.
	 */

	function depd (namespace) {
	  if (!namespace) {
	    throw new TypeError('argument namespace is required')
	  }

	  var stack = getStack();
	  var site = callSiteLocation(stack[1]);
	  var file = site[0];

	  function deprecate (message) {
	    // call to self as log
	    log.call(deprecate, message);
	  }

	  deprecate._file = file;
	  deprecate._ignored = isignored(namespace);
	  deprecate._namespace = namespace;
	  deprecate._traced = istraced(namespace);
	  deprecate._warned = Object.create(null);

	  deprecate.function = wrapfunction;
	  deprecate.property = wrapproperty;

	  return deprecate
	}

	/**
	 * Determine if event emitter has listeners of a given type.
	 *
	 * The way to do this check is done three different ways in Node.js >= 0.8
	 * so this consolidates them into a minimal set using instance methods.
	 *
	 * @param {EventEmitter} emitter
	 * @param {string} type
	 * @returns {boolean}
	 * @private
	 */

	function eehaslisteners (emitter, type) {
	  var count = typeof emitter.listenerCount !== 'function'
	    ? emitter.listeners(type).length
	    : emitter.listenerCount(type);

	  return count > 0
	}

	/**
	 * Determine if namespace is ignored.
	 */

	function isignored (namespace) {
	  if (process.noDeprecation) {
	    // --no-deprecation support
	    return true
	  }

	  var str = process.env.NO_DEPRECATION || '';

	  // namespace ignored
	  return containsNamespace(str, namespace)
	}

	/**
	 * Determine if namespace is traced.
	 */

	function istraced (namespace) {
	  if (process.traceDeprecation) {
	    // --trace-deprecation support
	    return true
	  }

	  var str = process.env.TRACE_DEPRECATION || '';

	  // namespace traced
	  return containsNamespace(str, namespace)
	}

	/**
	 * Display deprecation message.
	 */

	function log (message, site) {
	  var haslisteners = eehaslisteners(process, 'deprecation');

	  // abort early if no destination
	  if (!haslisteners && this._ignored) {
	    return
	  }

	  var caller;
	  var callFile;
	  var callSite;
	  var depSite;
	  var i = 0;
	  var seen = false;
	  var stack = getStack();
	  var file = this._file;

	  if (site) {
	    // provided site
	    depSite = site;
	    callSite = callSiteLocation(stack[1]);
	    callSite.name = depSite.name;
	    file = callSite[0];
	  } else {
	    // get call site
	    i = 2;
	    depSite = callSiteLocation(stack[i]);
	    callSite = depSite;
	  }

	  // get caller of deprecated thing in relation to file
	  for (; i < stack.length; i++) {
	    caller = callSiteLocation(stack[i]);
	    callFile = caller[0];

	    if (callFile === file) {
	      seen = true;
	    } else if (callFile === this._file) {
	      file = this._file;
	    } else if (seen) {
	      break
	    }
	  }

	  var key = caller
	    ? depSite.join(':') + '__' + caller.join(':')
	    : undefined;

	  if (key !== undefined && key in this._warned) {
	    // already warned
	    return
	  }

	  this._warned[key] = true;

	  // generate automatic message from call site
	  var msg = message;
	  if (!msg) {
	    msg = callSite === depSite || !callSite.name
	      ? defaultMessage(depSite)
	      : defaultMessage(callSite);
	  }

	  // emit deprecation if listeners exist
	  if (haslisteners) {
	    var err = DeprecationError(this._namespace, msg, stack.slice(i));
	    process.emit('deprecation', err);
	    return
	  }

	  // format and write message
	  var format = process.stderr.isTTY
	    ? formatColor
	    : formatPlain;
	  var output = format.call(this, msg, caller, stack.slice(i));
	  process.stderr.write(output + '\n', 'utf8');
	}

	/**
	 * Get call site location as array.
	 */

	function callSiteLocation (callSite) {
	  var file = callSite.getFileName() || '<anonymous>';
	  var line = callSite.getLineNumber();
	  var colm = callSite.getColumnNumber();

	  if (callSite.isEval()) {
	    file = callSite.getEvalOrigin() + ', ' + file;
	  }

	  var site = [file, line, colm];

	  site.callSite = callSite;
	  site.name = callSite.getFunctionName();

	  return site
	}

	/**
	 * Generate a default message from the site.
	 */

	function defaultMessage (site) {
	  var callSite = site.callSite;
	  var funcName = site.name;

	  // make useful anonymous name
	  if (!funcName) {
	    funcName = '<anonymous@' + formatLocation(site) + '>';
	  }

	  var context = callSite.getThis();
	  var typeName = context && callSite.getTypeName();

	  // ignore useless type name
	  if (typeName === 'Object') {
	    typeName = undefined;
	  }

	  // make useful type name
	  if (typeName === 'Function') {
	    typeName = context.name || typeName;
	  }

	  return typeName && callSite.getMethodName()
	    ? typeName + '.' + funcName
	    : funcName
	}

	/**
	 * Format deprecation message without color.
	 */

	function formatPlain (msg, caller, stack) {
	  var timestamp = new Date().toUTCString();

	  var formatted = timestamp +
	    ' ' + this._namespace +
	    ' deprecated ' + msg;

	  // add stack trace
	  if (this._traced) {
	    for (var i = 0; i < stack.length; i++) {
	      formatted += '\n    at ' + stack[i].toString();
	    }

	    return formatted
	  }

	  if (caller) {
	    formatted += ' at ' + formatLocation(caller);
	  }

	  return formatted
	}

	/**
	 * Format deprecation message with color.
	 */

	function formatColor (msg, caller, stack) {
	  var formatted = '\x1b[36;1m' + this._namespace + '\x1b[22;39m' + // bold cyan
	    ' \x1b[33;1mdeprecated\x1b[22;39m' + // bold yellow
	    ' \x1b[0m' + msg + '\x1b[39m'; // reset

	  // add stack trace
	  if (this._traced) {
	    for (var i = 0; i < stack.length; i++) {
	      formatted += '\n    \x1b[36mat ' + stack[i].toString() + '\x1b[39m'; // cyan
	    }

	    return formatted
	  }

	  if (caller) {
	    formatted += ' \x1b[36m' + formatLocation(caller) + '\x1b[39m'; // cyan
	  }

	  return formatted
	}

	/**
	 * Format call site location.
	 */

	function formatLocation (callSite) {
	  return relative(basePath, callSite[0]) +
	    ':' + callSite[1] +
	    ':' + callSite[2]
	}

	/**
	 * Get the stack as array of call sites.
	 */

	function getStack () {
	  var limit = Error.stackTraceLimit;
	  var obj = {};
	  var prep = Error.prepareStackTrace;

	  Error.prepareStackTrace = prepareObjectStackTrace;
	  Error.stackTraceLimit = Math.max(10, limit);

	  // capture the stack
	  Error.captureStackTrace(obj);

	  // slice this function off the top
	  var stack = obj.stack.slice(1);

	  Error.prepareStackTrace = prep;
	  Error.stackTraceLimit = limit;

	  return stack
	}

	/**
	 * Capture call site stack from v8.
	 */

	function prepareObjectStackTrace (obj, stack) {
	  return stack
	}

	/**
	 * Return a wrapped function in a deprecation message.
	 */

	function wrapfunction (fn, message) {
	  if (typeof fn !== 'function') {
	    throw new TypeError('argument fn must be a function')
	  }

	  var args = createArgumentsString(fn.length);
	  var stack = getStack();
	  var site = callSiteLocation(stack[1]);

	  site.name = fn.name;

	  // eslint-disable-next-line no-new-func
	  var deprecatedfn = new Function('fn', 'log', 'deprecate', 'message', 'site',
	    '"use strict"\n' +
	    'return function (' + args + ') {' +
	    'log.call(deprecate, message, site)\n' +
	    'return fn.apply(this, arguments)\n' +
	    '}')(fn, log, this, message, site);

	  return deprecatedfn
	}

	/**
	 * Wrap property in a deprecation message.
	 */

	function wrapproperty (obj, prop, message) {
	  if (!obj || (typeof obj !== 'object' && typeof obj !== 'function')) {
	    throw new TypeError('argument obj must be object')
	  }

	  var descriptor = Object.getOwnPropertyDescriptor(obj, prop);

	  if (!descriptor) {
	    throw new TypeError('must call property on owner object')
	  }

	  if (!descriptor.configurable) {
	    throw new TypeError('property must be configurable')
	  }

	  var deprecate = this;
	  var stack = getStack();
	  var site = callSiteLocation(stack[1]);

	  // set site name
	  site.name = prop;

	  // convert data descriptor
	  if ('value' in descriptor) {
	    descriptor = convertDataDescriptorToAccessor(obj, prop);
	  }

	  var get = descriptor.get;
	  var set = descriptor.set;

	  // wrap getter
	  if (typeof get === 'function') {
	    descriptor.get = function getter () {
	      log.call(deprecate, message, site);
	      return get.apply(this, arguments)
	    };
	  }

	  // wrap setter
	  if (typeof set === 'function') {
	    descriptor.set = function setter () {
	      log.call(deprecate, message, site);
	      return set.apply(this, arguments)
	    };
	  }

	  Object.defineProperty(obj, prop, descriptor);
	}

	/**
	 * Create DeprecationError for deprecation
	 */

	function DeprecationError (namespace, message, stack) {
	  var error = new Error();
	  var stackString;

	  Object.defineProperty(error, 'constructor', {
	    value: DeprecationError
	  });

	  Object.defineProperty(error, 'message', {
	    configurable: true,
	    enumerable: false,
	    value: message,
	    writable: true
	  });

	  Object.defineProperty(error, 'name', {
	    enumerable: false,
	    configurable: true,
	    value: 'DeprecationError',
	    writable: true
	  });

	  Object.defineProperty(error, 'namespace', {
	    configurable: true,
	    enumerable: false,
	    value: namespace,
	    writable: true
	  });

	  Object.defineProperty(error, 'stack', {
	    configurable: true,
	    enumerable: false,
	    get: function () {
	      if (stackString !== undefined) {
	        return stackString
	      }

	      // prepare stack trace
	      return (stackString = createStackString.call(this, stack))
	    },
	    set: function setter (val) {
	      stackString = val;
	    }
	  });

	  return error
	}
	return depd_1;
}

var setprototypeof;
var hasRequiredSetprototypeof;

function requireSetprototypeof () {
	if (hasRequiredSetprototypeof) return setprototypeof;
	hasRequiredSetprototypeof = 1;
	/* eslint no-proto: 0 */
	setprototypeof = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties);

	function setProtoOf (obj, proto) {
	  obj.__proto__ = proto;
	  return obj
	}

	function mixinProperties (obj, proto) {
	  for (var prop in proto) {
	    if (!Object.prototype.hasOwnProperty.call(obj, prop)) {
	      obj[prop] = proto[prop];
	    }
	  }
	  return obj
	}
	return setprototypeof;
}

var require$$0 = {
	"100": "Continue",
	"101": "Switching Protocols",
	"102": "Processing",
	"103": "Early Hints",
	"200": "OK",
	"201": "Created",
	"202": "Accepted",
	"203": "Non-Authoritative Information",
	"204": "No Content",
	"205": "Reset Content",
	"206": "Partial Content",
	"207": "Multi-Status",
	"208": "Already Reported",
	"226": "IM Used",
	"300": "Multiple Choices",
	"301": "Moved Permanently",
	"302": "Found",
	"303": "See Other",
	"304": "Not Modified",
	"305": "Use Proxy",
	"307": "Temporary Redirect",
	"308": "Permanent Redirect",
	"400": "Bad Request",
	"401": "Unauthorized",
	"402": "Payment Required",
	"403": "Forbidden",
	"404": "Not Found",
	"405": "Method Not Allowed",
	"406": "Not Acceptable",
	"407": "Proxy Authentication Required",
	"408": "Request Timeout",
	"409": "Conflict",
	"410": "Gone",
	"411": "Length Required",
	"412": "Precondition Failed",
	"413": "Payload Too Large",
	"414": "URI Too Long",
	"415": "Unsupported Media Type",
	"416": "Range Not Satisfiable",
	"417": "Expectation Failed",
	"418": "I'm a Teapot",
	"421": "Misdirected Request",
	"422": "Unprocessable Entity",
	"423": "Locked",
	"424": "Failed Dependency",
	"425": "Too Early",
	"426": "Upgrade Required",
	"428": "Precondition Required",
	"429": "Too Many Requests",
	"431": "Request Header Fields Too Large",
	"451": "Unavailable For Legal Reasons",
	"500": "Internal Server Error",
	"501": "Not Implemented",
	"502": "Bad Gateway",
	"503": "Service Unavailable",
	"504": "Gateway Timeout",
	"505": "HTTP Version Not Supported",
	"506": "Variant Also Negotiates",
	"507": "Insufficient Storage",
	"508": "Loop Detected",
	"509": "Bandwidth Limit Exceeded",
	"510": "Not Extended",
	"511": "Network Authentication Required"
};

/*!
 * statuses
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */

var statuses;
var hasRequiredStatuses;

function requireStatuses () {
	if (hasRequiredStatuses) return statuses;
	hasRequiredStatuses = 1;

	/**
	 * Module dependencies.
	 * @private
	 */

	var codes = require$$0;

	/**
	 * Module exports.
	 * @public
	 */

	statuses = status;

	// status code to message map
	status.message = codes;

	// status message (lower-case) to code map
	status.code = createMessageToStatusCodeMap(codes);

	// array of status codes
	status.codes = createStatusCodeList(codes);

	// status codes for redirects
	status.redirect = {
	  300: true,
	  301: true,
	  302: true,
	  303: true,
	  305: true,
	  307: true,
	  308: true
	};

	// status codes for empty bodies
	status.empty = {
	  204: true,
	  205: true,
	  304: true
	};

	// status codes for when you should retry the request
	status.retry = {
	  502: true,
	  503: true,
	  504: true
	};

	/**
	 * Create a map of message to status code.
	 * @private
	 */

	function createMessageToStatusCodeMap (codes) {
	  var map = {};

	  Object.keys(codes).forEach(function forEachCode (code) {
	    var message = codes[code];
	    var status = Number(code);

	    // populate map
	    map[message.toLowerCase()] = status;
	  });

	  return map
	}

	/**
	 * Create a list of all status codes.
	 * @private
	 */

	function createStatusCodeList (codes) {
	  return Object.keys(codes).map(function mapCode (code) {
	    return Number(code)
	  })
	}

	/**
	 * Get the status code for given message.
	 * @private
	 */

	function getStatusCode (message) {
	  var msg = message.toLowerCase();

	  if (!Object.prototype.hasOwnProperty.call(status.code, msg)) {
	    throw new Error('invalid status message: "' + message + '"')
	  }

	  return status.code[msg]
	}

	/**
	 * Get the status message for given code.
	 * @private
	 */

	function getStatusMessage (code) {
	  if (!Object.prototype.hasOwnProperty.call(status.message, code)) {
	    throw new Error('invalid status code: ' + code)
	  }

	  return status.message[code]
	}

	/**
	 * Get the status code.
	 *
	 * Given a number, this will throw if it is not a known status
	 * code, otherwise the code will be returned. Given a string,
	 * the string will be parsed for a number and return the code
	 * if valid, otherwise will lookup the code assuming this is
	 * the status message.
	 *
	 * @param {string|number} code
	 * @returns {number}
	 * @public
	 */

	function status (code) {
	  if (typeof code === 'number') {
	    return getStatusMessage(code)
	  }

	  if (typeof code !== 'string') {
	    throw new TypeError('code must be a number or string')
	  }

	  // '403'
	  var n = parseInt(code, 10);
	  if (!isNaN(n)) {
	    return getStatusMessage(n)
	  }

	  return getStatusCode(code)
	}
	return statuses;
}

var inherits = {exports: {}};

var inherits_browser = {exports: {}};

var hasRequiredInherits_browser;

function requireInherits_browser () {
	if (hasRequiredInherits_browser) return inherits_browser.exports;
	hasRequiredInherits_browser = 1;
	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  inherits_browser.exports = function inherits(ctor, superCtor) {
	    if (superCtor) {
	      ctor.super_ = superCtor;
	      ctor.prototype = Object.create(superCtor.prototype, {
	        constructor: {
	          value: ctor,
	          enumerable: false,
	          writable: true,
	          configurable: true
	        }
	      });
	    }
	  };
	} else {
	  // old school shim for old browsers
	  inherits_browser.exports = function inherits(ctor, superCtor) {
	    if (superCtor) {
	      ctor.super_ = superCtor;
	      var TempCtor = function () {};
	      TempCtor.prototype = superCtor.prototype;
	      ctor.prototype = new TempCtor();
	      ctor.prototype.constructor = ctor;
	    }
	  };
	}
	return inherits_browser.exports;
}

var hasRequiredInherits;

function requireInherits () {
	if (hasRequiredInherits) return inherits.exports;
	hasRequiredInherits = 1;
	try {
	  var util = require('util');
	  /* istanbul ignore next */
	  if (typeof util.inherits !== 'function') throw '';
	  inherits.exports = util.inherits;
	} catch (e) {
	  /* istanbul ignore next */
	  inherits.exports = requireInherits_browser();
	}
	return inherits.exports;
}

/*!
 * toidentifier
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */

var toidentifier;
var hasRequiredToidentifier;

function requireToidentifier () {
	if (hasRequiredToidentifier) return toidentifier;
	hasRequiredToidentifier = 1;

	/**
	 * Module exports.
	 * @public
	 */

	toidentifier = toIdentifier;

	/**
	 * Trasform the given string into a JavaScript identifier
	 *
	 * @param {string} str
	 * @returns {string}
	 * @public
	 */

	function toIdentifier (str) {
	  return str
	    .split(' ')
	    .map(function (token) {
	      return token.slice(0, 1).toUpperCase() + token.slice(1)
	    })
	    .join('')
	    .replace(/[^ _0-9a-z]/gi, '')
	}
	return toidentifier;
}

/*!
 * http-errors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */

var hasRequiredHttpErrors;

function requireHttpErrors () {
	if (hasRequiredHttpErrors) return httpErrors.exports;
	hasRequiredHttpErrors = 1;
	(function (module) {

		/**
		 * Module dependencies.
		 * @private
		 */

		var deprecate = requireDepd()('http-errors');
		var setPrototypeOf = requireSetprototypeof();
		var statuses = requireStatuses();
		var inherits = requireInherits();
		var toIdentifier = requireToidentifier();

		/**
		 * Module exports.
		 * @public
		 */

		module.exports = createError;
		module.exports.HttpError = createHttpErrorConstructor();
		module.exports.isHttpError = createIsHttpErrorFunction(module.exports.HttpError);

		// Populate exports for all constructors
		populateConstructorExports(module.exports, statuses.codes, module.exports.HttpError);

		/**
		 * Get the code class of a status code.
		 * @private
		 */

		function codeClass (status) {
		  return Number(String(status).charAt(0) + '00')
		}

		/**
		 * Create a new HTTP Error.
		 *
		 * @returns {Error}
		 * @public
		 */

		function createError () {
		  // so much arity going on ~_~
		  var err;
		  var msg;
		  var status = 500;
		  var props = {};
		  for (var i = 0; i < arguments.length; i++) {
		    var arg = arguments[i];
		    var type = typeof arg;
		    if (type === 'object' && arg instanceof Error) {
		      err = arg;
		      status = err.status || err.statusCode || status;
		    } else if (type === 'number' && i === 0) {
		      status = arg;
		    } else if (type === 'string') {
		      msg = arg;
		    } else if (type === 'object') {
		      props = arg;
		    } else {
		      throw new TypeError('argument #' + (i + 1) + ' unsupported type ' + type)
		    }
		  }

		  if (typeof status === 'number' && (status < 400 || status >= 600)) {
		    deprecate('non-error status code; use only 4xx or 5xx status codes');
		  }

		  if (typeof status !== 'number' ||
		    (!statuses.message[status] && (status < 400 || status >= 600))) {
		    status = 500;
		  }

		  // constructor
		  var HttpError = createError[status] || createError[codeClass(status)];

		  if (!err) {
		    // create error
		    err = HttpError
		      ? new HttpError(msg)
		      : new Error(msg || statuses.message[status]);
		    Error.captureStackTrace(err, createError);
		  }

		  if (!HttpError || !(err instanceof HttpError) || err.status !== status) {
		    // add properties to generic error
		    err.expose = status < 500;
		    err.status = err.statusCode = status;
		  }

		  for (var key in props) {
		    if (key !== 'status' && key !== 'statusCode') {
		      err[key] = props[key];
		    }
		  }

		  return err
		}

		/**
		 * Create HTTP error abstract base class.
		 * @private
		 */

		function createHttpErrorConstructor () {
		  function HttpError () {
		    throw new TypeError('cannot construct abstract class')
		  }

		  inherits(HttpError, Error);

		  return HttpError
		}

		/**
		 * Create a constructor for a client error.
		 * @private
		 */

		function createClientErrorConstructor (HttpError, name, code) {
		  var className = toClassName(name);

		  function ClientError (message) {
		    // create the error object
		    var msg = message != null ? message : statuses.message[code];
		    var err = new Error(msg);

		    // capture a stack trace to the construction point
		    Error.captureStackTrace(err, ClientError);

		    // adjust the [[Prototype]]
		    setPrototypeOf(err, ClientError.prototype);

		    // redefine the error message
		    Object.defineProperty(err, 'message', {
		      enumerable: true,
		      configurable: true,
		      value: msg,
		      writable: true
		    });

		    // redefine the error name
		    Object.defineProperty(err, 'name', {
		      enumerable: false,
		      configurable: true,
		      value: className,
		      writable: true
		    });

		    return err
		  }

		  inherits(ClientError, HttpError);
		  nameFunc(ClientError, className);

		  ClientError.prototype.status = code;
		  ClientError.prototype.statusCode = code;
		  ClientError.prototype.expose = true;

		  return ClientError
		}

		/**
		 * Create function to test is a value is a HttpError.
		 * @private
		 */

		function createIsHttpErrorFunction (HttpError) {
		  return function isHttpError (val) {
		    if (!val || typeof val !== 'object') {
		      return false
		    }

		    if (val instanceof HttpError) {
		      return true
		    }

		    return val instanceof Error &&
		      typeof val.expose === 'boolean' &&
		      typeof val.statusCode === 'number' && val.status === val.statusCode
		  }
		}

		/**
		 * Create a constructor for a server error.
		 * @private
		 */

		function createServerErrorConstructor (HttpError, name, code) {
		  var className = toClassName(name);

		  function ServerError (message) {
		    // create the error object
		    var msg = message != null ? message : statuses.message[code];
		    var err = new Error(msg);

		    // capture a stack trace to the construction point
		    Error.captureStackTrace(err, ServerError);

		    // adjust the [[Prototype]]
		    setPrototypeOf(err, ServerError.prototype);

		    // redefine the error message
		    Object.defineProperty(err, 'message', {
		      enumerable: true,
		      configurable: true,
		      value: msg,
		      writable: true
		    });

		    // redefine the error name
		    Object.defineProperty(err, 'name', {
		      enumerable: false,
		      configurable: true,
		      value: className,
		      writable: true
		    });

		    return err
		  }

		  inherits(ServerError, HttpError);
		  nameFunc(ServerError, className);

		  ServerError.prototype.status = code;
		  ServerError.prototype.statusCode = code;
		  ServerError.prototype.expose = false;

		  return ServerError
		}

		/**
		 * Set the name of a function, if possible.
		 * @private
		 */

		function nameFunc (func, name) {
		  var desc = Object.getOwnPropertyDescriptor(func, 'name');

		  if (desc && desc.configurable) {
		    desc.value = name;
		    Object.defineProperty(func, 'name', desc);
		  }
		}

		/**
		 * Populate the exports object with constructors for every error class.
		 * @private
		 */

		function populateConstructorExports (exports, codes, HttpError) {
		  codes.forEach(function forEachCode (code) {
		    var CodeError;
		    var name = toIdentifier(statuses.message[code]);

		    switch (codeClass(code)) {
		      case 400:
		        CodeError = createClientErrorConstructor(HttpError, name, code);
		        break
		      case 500:
		        CodeError = createServerErrorConstructor(HttpError, name, code);
		        break
		    }

		    if (CodeError) {
		      // export the constructor
		      exports[code] = CodeError;
		      exports[name] = CodeError;
		    }
		  });
		}

		/**
		 * Get a class name from a name identifier.
		 * @private
		 */

		function toClassName (name) {
		  return name.substr(-5) !== 'Error'
		    ? name + 'Error'
		    : name
		} 
	} (httpErrors));
	return httpErrors.exports;
}

var hasRequiredCreateHttpError;

function requireCreateHttpError () {
	if (hasRequiredCreateHttpError) return createHttpError;
	hasRequiredCreateHttpError = 1;

	const createError = requireHttpErrors();

	/**
	 * Create a HttpError object from simple arguments.
	 *
	 * @param {number} status
	 * @param {Error|object} err
	 * @private
	 */

	function createHttpError$1 (status, err) {
	  if (!err) {
	    return createError(status)
	  }

	  return err instanceof Error
	    ? createError(status, err, { expose: false })
	    : createError(status, err)
	}

	createHttpError.createHttpError = createHttpError$1;
	return createHttpError;
}

var hasRequiredSend$1;

function requireSend$1 () {
	if (hasRequiredSend$1) return send;
	hasRequiredSend$1 = 1;

	const fs = fs$1;
	const path = path$1;
	const stream = require$$0$7;
	const debug = require$$0$2.debuglog('send');

	const decode = requireFastDecodeUriComponent();
	const escapeHtml = requireEscapeHtml();
	const mime = requireMime();
	const ms = requireDist();

	const { collapseLeadingSlashes } = requireCollapseLeadingSlashes();
	const { containsDotFile } = requireContainsDotFile();
	const { contentRange } = requireContentRange();
	const { createHtmlDocument } = requireCreateHtmlDocument();
	const { isUtf8MimeType } = requireIsUtf8MimeType();
	const { normalizeList } = requireNormalizeList();
	const { parseBytesRange } = requireParseBytesRange();
	const { parseTokenList } = requireParseTokenList();
	const { createHttpError } = requireCreateHttpError();

	/**
	 * Path function references.
	 * @private
	 */

	const extname = path.extname;
	const join = path.join;
	const normalize = path.normalize;
	const resolve = path.resolve;
	const sep = path.sep;

	/**
	 * Stream function references.
	 * @private
	 */
	const Readable = stream.Readable;

	/**
	 * Regular expression for identifying a bytes Range header.
	 * @private
	 */

	const BYTES_RANGE_REGEXP = /^ *bytes=/;

	/**
	 * Maximum value allowed for the max age.
	 * @private
	 */

	const MAX_MAXAGE = 60 * 60 * 24 * 365 * 1000; // 1 year

	/**
	 * Regular expression to match a path with a directory up component.
	 * @private
	 */

	const UP_PATH_REGEXP = /(?:^|[\\/])\.\.(?:[\\/]|$)/;

	const ERROR_RESPONSES = {
	  400: createHtmlDocument('Error', 'Bad Request'),
	  403: createHtmlDocument('Error', 'Forbidden'),
	  404: createHtmlDocument('Error', 'Not Found'),
	  412: createHtmlDocument('Error', 'Precondition Failed'),
	  416: createHtmlDocument('Error', 'Range Not Satisfiable'),
	  500: createHtmlDocument('Error', 'Internal Server Error')
	};

	const validDotFilesOptions = [
	  'allow',
	  'ignore',
	  'deny'
	];

	function normalizeMaxAge (_maxage) {
	  let maxage;
	  if (typeof _maxage === 'string') {
	    maxage = ms.parse(_maxage);
	  } else {
	    maxage = Number(_maxage);
	  }

	  // eslint-disable-next-line no-self-compare
	  if (maxage !== maxage) {
	    // fast path of isNaN(number)
	    return 0
	  }

	  return Math.min(Math.max(0, maxage), MAX_MAXAGE)
	}

	function normalizeOptions (options) {
	  options = options ?? {};

	  const acceptRanges = options.acceptRanges !== undefined
	    ? Boolean(options.acceptRanges)
	    : true;

	  const cacheControl = options.cacheControl !== undefined
	    ? Boolean(options.cacheControl)
	    : true;

	  const contentType = options.contentType !== undefined
	    ? Boolean(options.contentType)
	    : true;

	  const etag = options.etag !== undefined
	    ? Boolean(options.etag)
	    : true;

	  const dotfiles = options.dotfiles !== undefined
	    ? validDotFilesOptions.indexOf(options.dotfiles)
	    : 1; // 'ignore'
	  if (dotfiles === -1) {
	    throw new TypeError('dotfiles option must be "allow", "deny", or "ignore"')
	  }

	  const extensions = options.extensions !== undefined
	    ? normalizeList(options.extensions, 'extensions option')
	    : [];

	  const immutable = options.immutable !== undefined
	    ? Boolean(options.immutable)
	    : false;

	  const index = options.index !== undefined
	    ? normalizeList(options.index, 'index option')
	    : ['index.html'];

	  const lastModified = options.lastModified !== undefined
	    ? Boolean(options.lastModified)
	    : true;

	  const maxage = normalizeMaxAge(options.maxAge ?? options.maxage);

	  const maxContentRangeChunkSize = options.maxContentRangeChunkSize !== undefined
	    ? Number(options.maxContentRangeChunkSize)
	    : null;

	  const root = options.root
	    ? resolve(options.root)
	    : null;

	  const highWaterMark = Number.isSafeInteger(options.highWaterMark) && options.highWaterMark > 0
	    ? options.highWaterMark
	    : null;

	  return {
	    acceptRanges,
	    cacheControl,
	    contentType,
	    etag,
	    dotfiles,
	    extensions,
	    immutable,
	    index,
	    lastModified,
	    maxage,
	    maxContentRangeChunkSize,
	    root,
	    highWaterMark,
	    start: options.start,
	    end: options.end
	  }
	}

	function normalizePath (_path, root) {
	  // decode the path
	  let path = decode(_path);
	  if (path == null) {
	    return { statusCode: 400 }
	  }

	  // null byte(s)
	  if (~path.indexOf('\0')) {
	    return { statusCode: 400 }
	  }

	  let parts;
	  if (root !== null) {
	    // normalize
	    if (path) {
	      path = normalize('.' + sep + path);
	    }

	    // malicious path
	    if (UP_PATH_REGEXP.test(path)) {
	      debug('malicious path "%s"', path);
	      return { statusCode: 403 }
	    }

	    // explode path parts
	    parts = path.split(sep);

	    // join / normalize from optional root dir
	    path = normalize(join(root, path));
	  } else {
	    // ".." is malicious without "root"
	    if (UP_PATH_REGEXP.test(path)) {
	      debug('malicious path "%s"', path);
	      return { statusCode: 403 }
	    }

	    // explode path parts
	    parts = normalize(path).split(sep);

	    // resolve the path
	    path = resolve(path);
	  }

	  return { path, parts }
	}

	/**
	 * Check if the pathname ends with "/".
	 *
	 * @return {boolean}
	 * @private
	 */

	function hasTrailingSlash (path) {
	  return path[path.length - 1] === '/'
	}

	/**
	 * Check if this is a conditional GET request.
	 *
	 * @return {Boolean}
	 * @api private
	 */

	function isConditionalGET (request) {
	  return request.headers['if-match'] ||
	    request.headers['if-unmodified-since'] ||
	    request.headers['if-none-match'] ||
	    request.headers['if-modified-since']
	}

	function isNotModifiedFailure (request, headers) {
	  // Always return stale when Cache-Control: no-cache
	  // to support end-to-end reload requests
	  // https://tools.ietf.org/html/rfc2616#section-14.9.4
	  if (
	    'cache-control' in request.headers &&
	    request.headers['cache-control'].indexOf('no-cache') !== -1
	  ) {
	    return false
	  }

	  // if-none-match
	  if ('if-none-match' in request.headers) {
	    const ifNoneMatch = request.headers['if-none-match'];

	    if (ifNoneMatch === '*') {
	      return true
	    }

	    const etag = headers.ETag;

	    if (typeof etag !== 'string') {
	      return false
	    }

	    const etagL = etag.length;
	    const isMatching = parseTokenList(ifNoneMatch, function (match) {
	      const mL = match.length;

	      if (
	        (etagL === mL && match === etag) ||
	        (etagL > mL && 'W/' + match === etag)
	      ) {
	        return true
	      }
	    });

	    if (isMatching) {
	      return true
	    }

	    /**
	     * A recipient MUST ignore If-Modified-Since if the request contains an
	     * If-None-Match header field; the condition in If-None-Match is considered
	     * to be a more accurate replacement for the condition in If-Modified-Since,
	     * and the two are only combined for the sake of interoperating with older
	     * intermediaries that might not implement If-None-Match.
	     *
	     * @see RFC 9110 section 13.1.3
	     */
	    return false
	  }

	  // if-modified-since
	  if ('if-modified-since' in request.headers) {
	    const ifModifiedSince = request.headers['if-modified-since'];
	    const lastModified = headers['Last-Modified'];

	    if (!lastModified || (Date.parse(lastModified) <= Date.parse(ifModifiedSince))) {
	      return true
	    }
	  }

	  return false
	}

	/**
	 * Check if the request preconditions failed.
	 *
	 * @return {boolean}
	 * @private
	 */

	function isPreconditionFailure (request, headers) {
	  // if-match
	  const ifMatch = request.headers['if-match'];
	  if (ifMatch) {
	    const etag = headers.ETag;

	    if (ifMatch !== '*') {
	      const isMatching = parseTokenList(ifMatch, function (match) {
	        if (
	          match === etag ||
	          'W/' + match === etag
	        ) {
	          return true
	        }
	      }) || false;

	      if (isMatching !== true) {
	        return true
	      }
	    }
	  }

	  // if-unmodified-since
	  if ('if-unmodified-since' in request.headers) {
	    const ifUnmodifiedSince = request.headers['if-unmodified-since'];
	    const unmodifiedSince = Date.parse(ifUnmodifiedSince);
	    // eslint-disable-next-line no-self-compare
	    if (unmodifiedSince === unmodifiedSince) { // fast path of isNaN(number)
	      const lastModified = Date.parse(headers['Last-Modified']);
	      if (
	        // eslint-disable-next-line no-self-compare
	        lastModified !== lastModified ||// fast path of isNaN(number)
	        lastModified > unmodifiedSince
	      ) {
	        return true
	      }
	    }
	  }

	  return false
	}

	/**
	 * Check if the range is fresh.
	 *
	 * @return {Boolean}
	 * @api private
	 */

	function isRangeFresh (request, headers) {
	  if (!('if-range' in request.headers)) {
	    return true
	  }

	  const ifRange = request.headers['if-range'];

	  // if-range as etag
	  if (ifRange.indexOf('"') !== -1) {
	    const etag = headers.ETag;
	    return (etag && ifRange.indexOf(etag) !== -1) || false
	  }

	  const ifRangeTimestamp = Date.parse(ifRange);
	  // eslint-disable-next-line no-self-compare
	  if (ifRangeTimestamp !== ifRangeTimestamp) { // fast path of isNaN(number)
	    return false
	  }

	  // if-range as modified date
	  const lastModified = Date.parse(headers['Last-Modified']);

	  return (
	    // eslint-disable-next-line no-self-compare
	    lastModified !== lastModified || // fast path of isNaN(number)
	    lastModified <= ifRangeTimestamp
	  )
	}

	// we provide stat function that will always resolve
	// without throwing
	function tryStat (path) {
	  return new Promise((resolve) => {
	    fs.stat(path, function onstat (error, stat) {
	      resolve({ error, stat });
	    });
	  })
	}

	function sendError (statusCode, err) {
	  const headers = {};

	  // add error headers
	  if (err && err.headers) {
	    for (const headerName in err.headers) {
	      headers[headerName] = err.headers[headerName];
	    }
	  }

	  const doc = ERROR_RESPONSES[statusCode];

	  // basic response
	  headers['Content-Type'] = 'text/html; charset=utf-8';
	  headers['Content-Length'] = doc[1];
	  headers['Content-Security-Policy'] = "default-src 'none'";
	  headers['X-Content-Type-Options'] = 'nosniff';

	  return {
	    statusCode,
	    headers,
	    stream: Readable.from(doc[0]),
	    // metadata
	    type: 'error',
	    metadata: { error: createHttpError(statusCode, err) }
	  }
	}

	function sendStatError (err) {
	  // POSIX throws ENAMETOOLONG and ENOTDIR, Windows only ENOENT
	  /* c8 ignore start */
	  switch (err.code) {
	    case 'ENAMETOOLONG':
	    case 'ENOTDIR':
	    case 'ENOENT':
	      return sendError(404, err)
	    default:
	      return sendError(500, err)
	  }
	  /* c8 ignore stop */
	}

	/**
	 * Respond with 304 not modified.
	 *
	 * @api private
	 */

	function sendNotModified (headers, path, stat) {
	  debug('not modified');

	  delete headers['Content-Encoding'];
	  delete headers['Content-Language'];
	  delete headers['Content-Length'];
	  delete headers['Content-Range'];
	  delete headers['Content-Type'];

	  return {
	    statusCode: 304,
	    headers,
	    stream: Readable.from(''),
	    // metadata
	    type: 'file',
	    metadata: { path, stat }
	  }
	}

	function sendFileDirectly (request, path, stat, options) {
	  let len = stat.size;
	  let offset = options.start ?? 0;

	  let statusCode = 200;
	  const headers = {};

	  debug('send "%s"', path);

	  // set header fields
	  if (options.acceptRanges) {
	    debug('accept ranges');
	    headers['Accept-Ranges'] = 'bytes';
	  }

	  if (options.cacheControl) {
	    let cacheControl = 'public, max-age=' + Math.floor(options.maxage / 1000);

	    if (options.immutable) {
	      cacheControl += ', immutable';
	    }

	    debug('cache-control %s', cacheControl);
	    headers['Cache-Control'] = cacheControl;
	  }

	  if (options.lastModified) {
	    const modified = stat.mtime.toUTCString();
	    debug('modified %s', modified);
	    headers['Last-Modified'] = modified;
	  }

	  if (options.etag) {
	    const etag = 'W/"' + stat.size.toString(16) + '-' + stat.mtime.getTime().toString(16) + '"';
	    debug('etag %s', etag);
	    headers.ETag = etag;
	  }

	  // set content-type
	  if (options.contentType) {
	    let type = mime.getType(path) || mime.default_type;
	    debug('content-type %s', type);
	    if (type && isUtf8MimeType(type)) {
	      type += '; charset=utf-8';
	    }
	    if (type) {
	      headers['Content-Type'] = type;
	    }
	  }

	  // conditional GET support
	  if (isConditionalGET(request)) {
	    if (isPreconditionFailure(request, headers)) {
	      return sendError(412)
	    }

	    if (isNotModifiedFailure(request, headers)) {
	      return sendNotModified(headers, path, stat)
	    }
	  }

	  // adjust len to start/end options
	  len = Math.max(0, len - offset);
	  if (options.end !== undefined) {
	    const bytes = options.end - offset + 1;
	    if (len > bytes) len = bytes;
	  }

	  // Range support
	  if (options.acceptRanges) {
	    const rangeHeader = request.headers.range;

	    if (
	      rangeHeader !== undefined &&
	      BYTES_RANGE_REGEXP.test(rangeHeader)
	    ) {
	      // If-Range support
	      if (isRangeFresh(request, headers)) {
	        // parse
	        const ranges = parseBytesRange(len, rangeHeader);

	        // unsatisfiable
	        if (ranges.length === 0) {
	          debug('range unsatisfiable');

	          // Content-Range
	          headers['Content-Range'] = contentRange('bytes', len);

	          // 416 Requested Range Not Satisfiable
	          return sendError(416, {
	            headers: { 'Content-Range': headers['Content-Range'] }
	          })
	          // valid (syntactically invalid/multiple ranges are treated as a regular response)
	        } else if (ranges.length === 1) {
	          debug('range %j', ranges);

	          // Content-Range
	          statusCode = 206;
	          if (options.maxContentRangeChunkSize) {
	            ranges[0].end = Math.min(ranges[0].end, ranges[0].start + options.maxContentRangeChunkSize - 1);
	          }
	          headers['Content-Range'] = contentRange('bytes', len, ranges[0]);

	          // adjust for requested range
	          offset += ranges[0].start;
	          len = ranges[0].end - ranges[0].start + 1;
	        }
	      } else {
	        debug('range stale');
	      }
	    }
	  }

	  // content-length
	  headers['Content-Length'] = len;

	  // HEAD support
	  if (request.method === 'HEAD') {
	    return {
	      statusCode,
	      headers,
	      stream: Readable.from(''),
	      // metadata
	      type: 'file',
	      metadata: { path, stat }
	    }
	  }

	  const stream = fs.createReadStream(path, {
	    highWaterMark: options.highWaterMark,
	    start: offset,
	    end: Math.max(offset, offset + len - 1)
	  });

	  return {
	    statusCode,
	    headers,
	    stream,
	    // metadata
	    type: 'file',
	    metadata: { path, stat }
	  }
	}

	function sendRedirect (path, options) {
	  if (hasTrailingSlash(options.path)) {
	    return sendError(403)
	  }

	  const loc = encodeURI(collapseLeadingSlashes(options.path + '/'));
	  const doc = createHtmlDocument('Redirecting', 'Redirecting to ' + escapeHtml(loc));

	  const headers = {};
	  headers['Content-Type'] = 'text/html; charset=utf-8';
	  headers['Content-Length'] = doc[1];
	  headers['Content-Security-Policy'] = "default-src 'none'";
	  headers['X-Content-Type-Options'] = 'nosniff';
	  headers.Location = loc;

	  return {
	    statusCode: 301,
	    headers,
	    stream: Readable.from(doc[0]),
	    // metadata
	    type: 'directory',
	    metadata: { requestPath: options.path, path }
	  }
	}

	async function sendIndex (request, path, options) {
	  let err;
	  for (let i = 0; i < options.index.length; i++) {
	    const index = options.index[i];
	    const p = join(path, index);
	    const { error, stat } = await tryStat(p);
	    if (error) {
	      err = error;
	      continue
	    }
	    if (stat.isDirectory()) continue
	    return sendFileDirectly(request, p, stat, options)
	  }

	  if (err) {
	    return sendStatError(err)
	  }

	  return sendError(404)
	}

	async function sendFile (request, path, options) {
	  const { error, stat } = await tryStat(path);
	  if (error && error.code === 'ENOENT' && !extname(path) && path[path.length - 1] !== sep) {
	    let err = error;
	    // not found, check extensions
	    for (let i = 0; i < options.extensions.length; i++) {
	      const extension = options.extensions[i];
	      const p = path + '.' + extension;
	      const { error, stat } = await tryStat(p);
	      if (error) {
	        err = error;
	        continue
	      }
	      if (stat.isDirectory()) {
	        err = null;
	        continue
	      }
	      return sendFileDirectly(request, p, stat, options)
	    }
	    if (err) {
	      return sendStatError(err)
	    }
	    return sendError(404)
	  }
	  if (error) return sendStatError(error)
	  if (stat.isDirectory()) return sendRedirect(path, options)
	  return sendFileDirectly(request, path, stat, options)
	}

	async function send$1 (request, _path, options) {
	  const opts = normalizeOptions(options);
	  opts.path = _path;

	  const parsed = normalizePath(_path, opts.root);
	  const { path, parts } = parsed;
	  if (parsed.statusCode !== undefined) {
	    return sendError(parsed.statusCode)
	  }

	  // dotfile handling
	  if (
	    (
	      debug.enabled || // if debugging is enabled, then check for all cases to log allow case
	      opts.dotfiles !== 0 // if debugging is not enabled, then only check if 'deny' or 'ignore' is set
	    ) &&
	    containsDotFile(parts)
	  ) {
	    switch (opts.dotfiles) {
	      /* c8 ignore start */ /* unreachable, because NODE_DEBUG can not be set after process is running */
	      case 0: // 'allow'
	        debug('allow dotfile "%s"', path);
	        break
	      /* c8 ignore stop */
	      case 2: // 'deny'
	        debug('deny dotfile "%s"', path);
	        return sendError(403)
	      case 1: // 'ignore'
	      default:
	        debug('ignore dotfile "%s"', path);
	        return sendError(404)
	    }
	  }

	  // index file support
	  if (opts.index.length && hasTrailingSlash(_path)) {
	    return sendIndex(request, path, opts)
	  }

	  return sendFile(request, path, opts)
	}

	send.send = send$1;
	return send;
}

/*!
 * send
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */

var hasRequiredSend;

function requireSend () {
	if (hasRequiredSend) return send$1.exports;
	hasRequiredSend = 1;

	/**
	 * Module dependencies.
	 * @private
	 */
	const isUtf8MimeType = requireIsUtf8MimeType().isUtf8MimeType;
	const mime = requireMime();
	const send = requireSend$1().send;

	/**
	 * Module exports.
	 * @public
	 */

	send$1.exports = send;
	send$1.exports.default = send;
	send$1.exports.send = send;

	send$1.exports.isUtf8MimeType = isUtf8MimeType;
	send$1.exports.mime = mime;
	return send$1.exports;
}

var acceptNegotiator = {exports: {}};

var hasRequiredAcceptNegotiator;

function requireAcceptNegotiator () {
	if (hasRequiredAcceptNegotiator) return acceptNegotiator.exports;
	hasRequiredAcceptNegotiator = 1;

	function Negotiator (options) {
	  if (!new.target) {
	    return new Negotiator(options)
	  }

	  const {
	    supportedValues = [],
	    cache
	  } = (options && typeof options === 'object' && options) || {};

	  this.supportedValues = supportedValues;

	  this.cache = cache;
	}

	Negotiator.prototype.negotiate = function (header) {
	  if (typeof header !== 'string') {
	    return null
	  }
	  if (!this.cache) {
	    return negotiate(header, this.supportedValues)
	  }
	  if (!this.cache.has(header)) {
	    this.cache.set(header, negotiate(header, this.supportedValues));
	  }
	  return this.cache.get(header)
	};

	function negotiate (header, supportedValues) {
	  if (
	    !header ||
	    !Array.isArray(supportedValues) ||
	    supportedValues.length === 0
	  ) {
	    return null
	  }

	  if (header === '*') {
	    return supportedValues[0]
	  }

	  let preferredEncoding = null;
	  let preferredEncodingPriority = Infinity;
	  let preferredEncodingQuality = 0;

	  function processMatch (enc, quality) {
	    if (quality === 0 || preferredEncodingQuality > quality) {
	      return false
	    }

	    const encoding = (enc === '*' && supportedValues[0]) || enc;
	    const priority = supportedValues.indexOf(encoding);
	    if (priority === -1) {
	      return false
	    }

	    if (priority === 0 && quality === 1) {
	      preferredEncoding = encoding;
	      return true
	    } else if (preferredEncodingQuality < quality) {
	      preferredEncoding = encoding;
	      preferredEncodingPriority = priority;
	      preferredEncodingQuality = quality;
	    } else if (preferredEncodingPriority > priority) {
	      preferredEncoding = encoding;
	      preferredEncodingPriority = priority;
	      preferredEncodingQuality = quality;
	    }
	    return false
	  }

	  parse(header, processMatch);

	  return preferredEncoding
	}

	const BEGIN = 0;
	const TOKEN = 1;
	const QUALITY = 2;
	const END = 3;

	function parse (header, processMatch) {
	  let str = '';
	  let quality;
	  let state = BEGIN;
	  for (let i = 0, il = header.length; i < il; ++i) {
	    const char = header[i];

	    if (char === ' ' || char === '\t') {
	      continue
	    } else if (char === ';') {
	      if (state === TOKEN) {
	        state = QUALITY;
	        quality = '';
	      }
	      continue
	    } else if (char === ',') {
	      if (state === TOKEN) {
	        if (processMatch(str, 1)) {
	          state = END;
	          break
	        }
	        state = BEGIN;
	        str = '';
	      } else if (state === QUALITY) {
	        if (processMatch(str, parseFloat(quality) || 0)) {
	          state = END;
	          break
	        }
	        state = BEGIN;
	        str = '';
	        quality = '';
	      }
	      continue
	    } else if (
	      state === QUALITY
	    ) {
	      if (char === 'q' || char === '=') {
	        continue
	      } else if (
	        char === '.' ||
	        char === '1' ||
	        char === '0' ||
	        char === '2' ||
	        char === '3' ||
	        char === '4' ||
	        char === '5' ||
	        char === '6' ||
	        char === '7' ||
	        char === '8' ||
	        char === '9'
	      ) {
	        quality += char;
	        continue
	      }
	    } else if (state === BEGIN) {
	      state = TOKEN;
	      str += char;
	      continue
	    }
	    if (state === TOKEN) {
	      const prevChar = header[i - 1];
	      if (prevChar === ' ' || prevChar === '\t') {
	        str = '';
	      }
	      str += char;
	      continue
	    }
	    if (processMatch(str, parseFloat(quality) || 0)) {
	      state = END;
	      break
	    }
	    state = BEGIN;
	    str = char;
	    quality = '';
	  }

	  if (state === TOKEN) {
	    processMatch(str, 1);
	  } else if (state === QUALITY) {
	    processMatch(str, parseFloat(quality) || 0);
	  }
	}

	acceptNegotiator.exports = negotiate;
	acceptNegotiator.exports.default = negotiate;
	acceptNegotiator.exports.negotiate = negotiate;
	acceptNegotiator.exports.Negotiator = Negotiator;
	return acceptNegotiator.exports;
}

var contentDisposition = {exports: {}};

var safeBuffer = {exports: {}};

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */

var hasRequiredSafeBuffer;

function requireSafeBuffer () {
	if (hasRequiredSafeBuffer) return safeBuffer.exports;
	hasRequiredSafeBuffer = 1;
	(function (module, exports) {
		/* eslint-disable node/no-deprecated-api */
		var buffer = require$$7;
		var Buffer = buffer.Buffer;

		// alternative to using Object.keys for old browsers
		function copyProps (src, dst) {
		  for (var key in src) {
		    dst[key] = src[key];
		  }
		}
		if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
		  module.exports = buffer;
		} else {
		  // Copy properties from require('buffer')
		  copyProps(buffer, exports);
		  exports.Buffer = SafeBuffer;
		}

		function SafeBuffer (arg, encodingOrOffset, length) {
		  return Buffer(arg, encodingOrOffset, length)
		}

		SafeBuffer.prototype = Object.create(Buffer.prototype);

		// Copy static methods from Buffer
		copyProps(Buffer, SafeBuffer);

		SafeBuffer.from = function (arg, encodingOrOffset, length) {
		  if (typeof arg === 'number') {
		    throw new TypeError('Argument must not be a number')
		  }
		  return Buffer(arg, encodingOrOffset, length)
		};

		SafeBuffer.alloc = function (size, fill, encoding) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  var buf = Buffer(size);
		  if (fill !== undefined) {
		    if (typeof encoding === 'string') {
		      buf.fill(fill, encoding);
		    } else {
		      buf.fill(fill);
		    }
		  } else {
		    buf.fill(0);
		  }
		  return buf
		};

		SafeBuffer.allocUnsafe = function (size) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  return Buffer(size)
		};

		SafeBuffer.allocUnsafeSlow = function (size) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  return buffer.SlowBuffer(size)
		}; 
	} (safeBuffer, safeBuffer.exports));
	return safeBuffer.exports;
}

/*!
 * content-disposition
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */

var hasRequiredContentDisposition;

function requireContentDisposition () {
	if (hasRequiredContentDisposition) return contentDisposition.exports;
	hasRequiredContentDisposition = 1;

	/**
	 * Module exports.
	 * @public
	 */

	contentDisposition.exports = contentDisposition$1;
	contentDisposition.exports.parse = parse;

	/**
	 * Module dependencies.
	 * @private
	 */

	var basename = path.basename;
	var Buffer = requireSafeBuffer().Buffer;

	/**
	 * RegExp to match non attr-char, *after* encodeURIComponent (i.e. not including "%")
	 * @private
	 */

	var ENCODE_URL_ATTR_CHAR_REGEXP = /[\x00-\x20"'()*,/:;<=>?@[\\\]{}\x7f]/g; // eslint-disable-line no-control-regex

	/**
	 * RegExp to match percent encoding escape.
	 * @private
	 */

	var HEX_ESCAPE_REGEXP = /%[0-9A-Fa-f]{2}/;
	var HEX_ESCAPE_REPLACE_REGEXP = /%([0-9A-Fa-f]{2})/g;

	/**
	 * RegExp to match non-latin1 characters.
	 * @private
	 */

	var NON_LATIN1_REGEXP = /[^\x20-\x7e\xa0-\xff]/g;

	/**
	 * RegExp to match quoted-pair in RFC 2616
	 *
	 * quoted-pair = "\" CHAR
	 * CHAR        = <any US-ASCII character (octets 0 - 127)>
	 * @private
	 */

	var QESC_REGEXP = /\\([\u0000-\u007f])/g; // eslint-disable-line no-control-regex

	/**
	 * RegExp to match chars that must be quoted-pair in RFC 2616
	 * @private
	 */

	var QUOTE_REGEXP = /([\\"])/g;

	/**
	 * RegExp for various RFC 2616 grammar
	 *
	 * parameter     = token "=" ( token | quoted-string )
	 * token         = 1*<any CHAR except CTLs or separators>
	 * separators    = "(" | ")" | "<" | ">" | "@"
	 *               | "," | ";" | ":" | "\" | <">
	 *               | "/" | "[" | "]" | "?" | "="
	 *               | "{" | "}" | SP | HT
	 * quoted-string = ( <"> *(qdtext | quoted-pair ) <"> )
	 * qdtext        = <any TEXT except <">>
	 * quoted-pair   = "\" CHAR
	 * CHAR          = <any US-ASCII character (octets 0 - 127)>
	 * TEXT          = <any OCTET except CTLs, but including LWS>
	 * LWS           = [CRLF] 1*( SP | HT )
	 * CRLF          = CR LF
	 * CR            = <US-ASCII CR, carriage return (13)>
	 * LF            = <US-ASCII LF, linefeed (10)>
	 * SP            = <US-ASCII SP, space (32)>
	 * HT            = <US-ASCII HT, horizontal-tab (9)>
	 * CTL           = <any US-ASCII control character (octets 0 - 31) and DEL (127)>
	 * OCTET         = <any 8-bit sequence of data>
	 * @private
	 */

	var PARAM_REGEXP = /;[\x09\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*=[\x09\x20]*("(?:[\x20!\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*/g; // eslint-disable-line no-control-regex
	var TEXT_REGEXP = /^[\x20-\x7e\x80-\xff]+$/;
	var TOKEN_REGEXP = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/;

	/**
	 * RegExp for various RFC 5987 grammar
	 *
	 * ext-value     = charset  "'" [ language ] "'" value-chars
	 * charset       = "UTF-8" / "ISO-8859-1" / mime-charset
	 * mime-charset  = 1*mime-charsetc
	 * mime-charsetc = ALPHA / DIGIT
	 *               / "!" / "#" / "$" / "%" / "&"
	 *               / "+" / "-" / "^" / "_" / "`"
	 *               / "{" / "}" / "~"
	 * language      = ( 2*3ALPHA [ extlang ] )
	 *               / 4ALPHA
	 *               / 5*8ALPHA
	 * extlang       = *3( "-" 3ALPHA )
	 * value-chars   = *( pct-encoded / attr-char )
	 * pct-encoded   = "%" HEXDIG HEXDIG
	 * attr-char     = ALPHA / DIGIT
	 *               / "!" / "#" / "$" / "&" / "+" / "-" / "."
	 *               / "^" / "_" / "`" / "|" / "~"
	 * @private
	 */

	var EXT_VALUE_REGEXP = /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/;

	/**
	 * RegExp for various RFC 6266 grammar
	 *
	 * disposition-type = "inline" | "attachment" | disp-ext-type
	 * disp-ext-type    = token
	 * disposition-parm = filename-parm | disp-ext-parm
	 * filename-parm    = "filename" "=" value
	 *                  | "filename*" "=" ext-value
	 * disp-ext-parm    = token "=" value
	 *                  | ext-token "=" ext-value
	 * ext-token        = <the characters in token, followed by "*">
	 * @private
	 */

	var DISPOSITION_TYPE_REGEXP = /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*(?:$|;)/; // eslint-disable-line no-control-regex

	/**
	 * Create an attachment Content-Disposition header.
	 *
	 * @param {string} [filename]
	 * @param {object} [options]
	 * @param {string} [options.type=attachment]
	 * @param {string|boolean} [options.fallback=true]
	 * @return {string}
	 * @public
	 */

	function contentDisposition$1 (filename, options) {
	  var opts = options || {};

	  // get type
	  var type = opts.type || 'attachment';

	  // get parameters
	  var params = createparams(filename, opts.fallback);

	  // format into string
	  return format(new ContentDisposition(type, params))
	}

	/**
	 * Create parameters object from filename and fallback.
	 *
	 * @param {string} [filename]
	 * @param {string|boolean} [fallback=true]
	 * @return {object}
	 * @private
	 */

	function createparams (filename, fallback) {
	  if (filename === undefined) {
	    return
	  }

	  var params = {};

	  if (typeof filename !== 'string') {
	    throw new TypeError('filename must be a string')
	  }

	  // fallback defaults to true
	  if (fallback === undefined) {
	    fallback = true;
	  }

	  if (typeof fallback !== 'string' && typeof fallback !== 'boolean') {
	    throw new TypeError('fallback must be a string or boolean')
	  }

	  if (typeof fallback === 'string' && NON_LATIN1_REGEXP.test(fallback)) {
	    throw new TypeError('fallback must be ISO-8859-1 string')
	  }

	  // restrict to file base name
	  var name = basename(filename);

	  // determine if name is suitable for quoted string
	  var isQuotedString = TEXT_REGEXP.test(name);

	  // generate fallback name
	  var fallbackName = typeof fallback !== 'string'
	    ? fallback && getlatin1(name)
	    : basename(fallback);
	  var hasFallback = typeof fallbackName === 'string' && fallbackName !== name;

	  // set extended filename parameter
	  if (hasFallback || !isQuotedString || HEX_ESCAPE_REGEXP.test(name)) {
	    params['filename*'] = name;
	  }

	  // set filename parameter
	  if (isQuotedString || hasFallback) {
	    params.filename = hasFallback
	      ? fallbackName
	      : name;
	  }

	  return params
	}

	/**
	 * Format object to Content-Disposition header.
	 *
	 * @param {object} obj
	 * @param {string} obj.type
	 * @param {object} [obj.parameters]
	 * @return {string}
	 * @private
	 */

	function format (obj) {
	  var parameters = obj.parameters;
	  var type = obj.type;

	  if (!type || typeof type !== 'string' || !TOKEN_REGEXP.test(type)) {
	    throw new TypeError('invalid type')
	  }

	  // start with normalized type
	  var string = String(type).toLowerCase();

	  // append parameters
	  if (parameters && typeof parameters === 'object') {
	    var param;
	    var params = Object.keys(parameters).sort();

	    for (var i = 0; i < params.length; i++) {
	      param = params[i];

	      var val = param.substr(-1) === '*'
	        ? ustring(parameters[param])
	        : qstring(parameters[param]);

	      string += '; ' + param + '=' + val;
	    }
	  }

	  return string
	}

	/**
	 * Decode a RFC 5987 field value (gracefully).
	 *
	 * @param {string} str
	 * @return {string}
	 * @private
	 */

	function decodefield (str) {
	  var match = EXT_VALUE_REGEXP.exec(str);

	  if (!match) {
	    throw new TypeError('invalid extended field value')
	  }

	  var charset = match[1].toLowerCase();
	  var encoded = match[2];
	  var value;

	  // to binary string
	  var binary = encoded.replace(HEX_ESCAPE_REPLACE_REGEXP, pdecode);

	  switch (charset) {
	    case 'iso-8859-1':
	      value = getlatin1(binary);
	      break
	    case 'utf-8':
	      value = Buffer.from(binary, 'binary').toString('utf8');
	      break
	    default:
	      throw new TypeError('unsupported charset in extended field')
	  }

	  return value
	}

	/**
	 * Get ISO-8859-1 version of string.
	 *
	 * @param {string} val
	 * @return {string}
	 * @private
	 */

	function getlatin1 (val) {
	  // simple Unicode -> ISO-8859-1 transformation
	  return String(val).replace(NON_LATIN1_REGEXP, '?')
	}

	/**
	 * Parse Content-Disposition header string.
	 *
	 * @param {string} string
	 * @return {object}
	 * @public
	 */

	function parse (string) {
	  if (!string || typeof string !== 'string') {
	    throw new TypeError('argument string is required')
	  }

	  var match = DISPOSITION_TYPE_REGEXP.exec(string);

	  if (!match) {
	    throw new TypeError('invalid type format')
	  }

	  // normalize type
	  var index = match[0].length;
	  var type = match[1].toLowerCase();

	  var key;
	  var names = [];
	  var params = {};
	  var value;

	  // calculate index to start at
	  index = PARAM_REGEXP.lastIndex = match[0].substr(-1) === ';'
	    ? index - 1
	    : index;

	  // match parameters
	  while ((match = PARAM_REGEXP.exec(string))) {
	    if (match.index !== index) {
	      throw new TypeError('invalid parameter format')
	    }

	    index += match[0].length;
	    key = match[1].toLowerCase();
	    value = match[2];

	    if (names.indexOf(key) !== -1) {
	      throw new TypeError('invalid duplicate parameter')
	    }

	    names.push(key);

	    if (key.indexOf('*') + 1 === key.length) {
	      // decode extended value
	      key = key.slice(0, -1);
	      value = decodefield(value);

	      // overwrite existing value
	      params[key] = value;
	      continue
	    }

	    if (typeof params[key] === 'string') {
	      continue
	    }

	    if (value[0] === '"') {
	      // remove quotes and escapes
	      value = value
	        .substr(1, value.length - 2)
	        .replace(QESC_REGEXP, '$1');
	    }

	    params[key] = value;
	  }

	  if (index !== -1 && index !== string.length) {
	    throw new TypeError('invalid parameter format')
	  }

	  return new ContentDisposition(type, params)
	}

	/**
	 * Percent decode a single character.
	 *
	 * @param {string} str
	 * @param {string} hex
	 * @return {string}
	 * @private
	 */

	function pdecode (str, hex) {
	  return String.fromCharCode(parseInt(hex, 16))
	}

	/**
	 * Percent encode a single character.
	 *
	 * @param {string} char
	 * @return {string}
	 * @private
	 */

	function pencode (char) {
	  return '%' + String(char)
	    .charCodeAt(0)
	    .toString(16)
	    .toUpperCase()
	}

	/**
	 * Quote a string for HTTP.
	 *
	 * @param {string} val
	 * @return {string}
	 * @private
	 */

	function qstring (val) {
	  var str = String(val);

	  return '"' + str.replace(QUOTE_REGEXP, '\\$1') + '"'
	}

	/**
	 * Encode a Unicode string for HTTP (RFC 5987).
	 *
	 * @param {string} val
	 * @return {string}
	 * @private
	 */

	function ustring (val) {
	  var str = String(val);

	  // percent encode as UTF-8
	  var encoded = encodeURIComponent(str)
	    .replace(ENCODE_URL_ATTR_CHAR_REGEXP, pencode);

	  return 'UTF-8\'\'' + encoded
	}

	/**
	 * Class for parsed Content-Disposition header for v8 optimization
	 *
	 * @public
	 * @param {string} type
	 * @param {object} parameters
	 * @constructor
	 */

	function ContentDisposition (type, parameters) {
	  this.type = type;
	  this.parameters = parameters;
	}
	return contentDisposition.exports;
}

var dirList_1;
var hasRequiredDirList;

function requireDirList () {
	if (hasRequiredDirList) return dirList_1;
	hasRequiredDirList = 1;

	const os = require$$0$5;
	const path = path$1;
	const fs = require$$5;
	const fastq = requireQueue();
	const fastqConcurrency = Math.max(1, os.cpus().length - 1);

	const dirList = {
	  _getExtendedInfo: async function (dir, info) {
	    const depth = dir.split(path.sep).length;
	    const files = await fs.readdir(dir);

	    const worker = async (filename) => {
	      const filePath = path.join(dir, filename);
	      let stats;
	      try {
	        stats = await fs.stat(filePath);
	      } catch {
	        return
	      }

	      if (stats.isDirectory()) {
	        info.totalFolderCount++;
	        filePath.split(path.sep).length === depth + 1 && info.folderCount++;
	        await dirList._getExtendedInfo(filePath, info);
	      } else {
	        info.totalSize += stats.size;
	        info.totalFileCount++;
	        filePath.split(path.sep).length === depth + 1 && info.fileCount++;
	        info.lastModified = Math.max(info.lastModified, stats.mtimeMs);
	      }
	    };
	    const queue = fastq.promise(worker, fastqConcurrency);
	    await Promise.all(files.map(filename => queue.push(filename)));
	  },

	  /**
	   * get extended info about a folder
	   * @param {string} folderPath full path fs dir
	   * @return {Promise<ExtendedInfo>}
	   */
	  getExtendedInfo: async function (folderPath) {
	    const info = {
	      totalSize: 0,
	      fileCount: 0,
	      totalFileCount: 0,
	      folderCount: 0,
	      totalFolderCount: 0,
	      lastModified: 0
	    };

	    await dirList._getExtendedInfo(folderPath, info);

	    return info
	  },

	  /**
	   * get files and dirs from dir, or error
	   * @param {string} dir full path fs dir
	   * @param {(boolean | ListOptionsJsonFormat | ListOptionsHtmlFormat)} options
	   * @param {string} dotfiles
	   * note: can't use glob because don't get error on non existing dir
	   */
	  list: async function (dir, options, dotfiles) {
	    const entries = { dirs: [], files: [] };
	    let files = await fs.readdir(dir);
	    if (dotfiles === 'deny' || dotfiles === 'ignore') {
	      files = files.filter(file => file.charAt(0) !== '.');
	    }
	    if (files.length < 1) {
	      return entries
	    }

	    const worker = async (filename) => {
	      let stats;
	      try {
	        stats = await fs.stat(path.join(dir, filename));
	      } catch {
	        return
	      }
	      const entry = { name: filename, stats };
	      if (stats.isDirectory()) {
	        if (options.extendedFolderInfo) {
	          entry.extendedInfo = await dirList.getExtendedInfo(path.join(dir, filename));
	        }
	        entries.dirs.push(entry);
	      } else {
	        entries.files.push(entry);
	      }
	    };
	    const queue = fastq.promise(worker, fastqConcurrency);
	    await Promise.all(files.map(filename => queue.push(filename)));

	    entries.dirs.sort((a, b) => a.name.localeCompare(b.name));
	    entries.files.sort((a, b) => a.name.localeCompare(b.name));

	    return entries
	  },

	  /**
	   * send dir list content, or 404 on error
	   * @param {Fastify.Reply} reply
	   * @param {string} dir full path fs dir
	   * @param {(boolean | ListOptionsJsonFormat | ListOptionsHtmlFormat)} options
	   * @param {string} route request route
	   * @param {string} dotfiles
	   */
	  send: async function ({ reply, dir, options, route, prefix, dotfiles }) {
	    if (reply.request.query.format === 'html' && typeof options.render !== 'function') {
	      throw new TypeError('The `list.render` option must be a function and is required with the URL parameter `format=html`')
	    }

	    let entries;
	    try {
	      entries = await dirList.list(dir, options, dotfiles);
	    } catch {
	      return reply.callNotFound()
	    }

	    const format = reply.request.query.format || options.format;
	    if (format !== 'html') {
	      if (options.jsonFormat !== 'extended') {
	        const nameEntries = { dirs: [], files: [] };
	        entries.dirs.forEach(entry => nameEntries.dirs.push(entry.name));
	        entries.files.forEach(entry => nameEntries.files.push(entry.name));

	        await reply.send(nameEntries);
	      } else {
	        await reply.send(entries);
	      }
	      return
	    }

	    const html = options.render(
	      entries.dirs.map(entry => dirList.htmlInfo(entry, route, prefix, options)),
	      entries.files.map(entry => dirList.htmlInfo(entry, route, prefix, options)));
	    await reply.type('text/html').send(html);
	  },

	  /**
	   * provide the html information about entry and route, to get name and full route
	   * @param entry file or dir name and stats
	   * @param {string} route request route
	   * @return {ListFile}
	   */
	  htmlInfo: function (entry, route, prefix, options) {
	    if (options.names?.includes(path.basename(route))) {
	      route = path.normalize(path.join(route, '..'));
	    }
	    return {
	      href: encodeURI(path.join(prefix, route, entry.name).replace(/\\/gu, '/')),
	      name: entry.name,
	      stats: entry.stats,
	      extendedInfo: entry.extendedInfo
	    }
	  },

	  /**
	   * say if the route can be handled by dir list or not
	   * @param {string} route request route
	   * @param {(boolean | ListOptionsJsonFormat | ListOptionsHtmlFormat)} options
	   * @return {boolean}
	   */
	  handle: function (route, options) {
	    return options.names?.includes(path.basename(route)) ||
	      // match trailing slash
	      ((options.names?.includes('/') && route[route.length - 1] === '/') ?? false)
	  },

	  /**
	   * get path from route and fs root paths, considering trailing slash
	   * @param {string} root fs root path
	   * @param {string} route request route
	   */
	  path: function (root, route) {
	    const _route = route[route.length - 1] === '/'
	      ? route + 'none'
	      : route;
	    return path.dirname(path.join(root, _route))
	  },

	  /**
	   * validate options
	   * @return {Error}
	   */
	  validateOptions: function (options) {
	    if (!options.list) {
	      return
	    }

	    if (Array.isArray(options.root)) {
	      return new TypeError('multi-root with list option is not supported')
	    }

	    if (options.list.format && options.list.format !== 'json' && options.list.format !== 'html') {
	      return new TypeError('The `list.format` option must be json or html')
	    }
	    if (options.list.names && !Array.isArray(options.list.names)) {
	      return new TypeError('The `list.names` option must be an array')
	    }
	    if (options.list.jsonFormat != null && options.list.jsonFormat !== 'names' && options.list.jsonFormat !== 'extended') {
	      return new TypeError('The `list.jsonFormat` option must be name or extended')
	    }
	    if (options.list.format === 'html' && typeof options.list.render !== 'function') {
	      return new TypeError('The `list.render` option must be a function and is required with html format')
	    }
	  }
	};

	dirList_1 = dirList;
	return dirList_1;
}

var hasRequired_static;

function require_static () {
	if (hasRequired_static) return _static.exports;
	hasRequired_static = 1;

	const path = path$1;
	const { fileURLToPath } = require$$1$3;
	const { statSync } = fs$1;
	const { glob } = requireCommonjs();
	const fp = requirePlugin();
	const send = requireSend();
	const encodingNegotiator = requireAcceptNegotiator();
	const contentDisposition = requireContentDisposition();

	const dirList = requireDirList();

	const endForwardSlashRegex = /\/$/u;
	const asteriskRegex = /\*/gu;

	const supportedEncodings = ['br', 'gzip', 'deflate'];
	send.mime.default_type = 'application/octet-stream';

	async function fastifyStatic (fastify, opts) {
	  opts.root = normalizeRoot(opts.root);
	  checkRootPathForErrors(fastify, opts.root);

	  const setHeaders = opts.setHeaders;
	  if (setHeaders !== undefined && typeof setHeaders !== 'function') {
	    throw new TypeError('The `setHeaders` option must be a function')
	  }

	  const invalidDirListOpts = dirList.validateOptions(opts);
	  if (invalidDirListOpts) {
	    throw invalidDirListOpts
	  }

	  if (opts.dotfiles === undefined) {
	    opts.dotfiles = 'allow';
	  }

	  const sendOptions = {
	    root: opts.root,
	    acceptRanges: opts.acceptRanges,
	    contentType: opts.contentType,
	    cacheControl: opts.cacheControl,
	    dotfiles: opts.dotfiles,
	    etag: opts.etag,
	    extensions: opts.extensions,
	    immutable: opts.immutable,
	    index: opts.index,
	    lastModified: opts.lastModified,
	    maxAge: opts.maxAge
	  };

	  let prefix = opts.prefix ?? (opts.prefix = '/');

	  if (!opts.prefixAvoidTrailingSlash) {
	    prefix =
	      prefix[prefix.length - 1] === '/'
	        ? prefix
	        : prefix + '/';
	  }

	  // Set the schema hide property if defined in opts or true by default
	  const routeOpts = {
	    constraints: opts.constraints,
	    schema: {
	      hide: opts.schemaHide !== undefined ? opts.schemaHide : true
	    },
	    logLevel: opts.logLevel,
	    errorHandler (error, request, reply) {
	      if (error?.code === 'ERR_STREAM_PREMATURE_CLOSE') {
	        reply.request.raw.destroy();
	        return
	      }

	      fastify.errorHandler(error, request, reply);
	    }
	  };

	  if (opts.decorateReply !== false) {
	    fastify.decorateReply('sendFile', function (filePath, rootPath, options) {
	      const opts = typeof rootPath === 'object' ? rootPath : options;
	      const root = typeof rootPath === 'string' ? rootPath : opts?.root;
	      pumpSendToReply(
	        this.request,
	        this,
	        filePath,
	        root || sendOptions.root,
	        0,
	        opts
	      );
	      return this
	    });

	    fastify.decorateReply(
	      'download',
	      function (filePath, fileName, options = {}) {
	        const { root, ...opts } =
	          typeof fileName === 'object' ? fileName : options;
	        fileName = typeof fileName === 'string' ? fileName : filePath;

	        // Set content disposition header
	        this.header('content-disposition', contentDisposition(fileName));

	        pumpSendToReply(this.request, this, filePath, root, 0, opts);

	        return this
	      }
	    );
	  }

	  if (opts.serve !== false) {
	    if (opts.wildcard && typeof opts.wildcard !== 'boolean') {
	      throw new TypeError('"wildcard" option must be a boolean')
	    }
	    if (opts.wildcard === undefined || opts.wildcard === true) {
	      fastify.route({
	        ...routeOpts,
	        method: ['HEAD', 'GET'],
	        path: prefix + '*',
	        handler (req, reply) {
	          pumpSendToReply(req, reply, '/' + req.params['*'], sendOptions.root);
	        }
	      });
	      if (opts.redirect === true && prefix !== opts.prefix) {
	        fastify.get(opts.prefix, routeOpts, (req, reply) => {
	          reply.redirect(getRedirectUrl(req.raw.url), 301);
	        });
	      }
	    } else {
	      const indexes = opts.index === undefined ? ['index.html'] : [].concat(opts.index);
	      const indexDirs = new Map();
	      const routes = new Set();

	      const roots = Array.isArray(sendOptions.root) ? sendOptions.root : [sendOptions.root];
	      for (let rootPath of roots) {
	        rootPath = rootPath.split(path.win32.sep).join(path.posix.sep);
	        !rootPath.endsWith('/') && (rootPath += '/');
	        const files = await glob('**/**', {
	          cwd: rootPath, absolute: false, follow: true, nodir: true, dot: opts.serveDotFiles, ignore: opts.globIgnore
	        });

	        for (let file of files) {
	          file = file.split(path.win32.sep).join(path.posix.sep);
	          const route = prefix + file;

	          if (routes.has(route)) {
	            continue
	          }

	          routes.add(route);

	          setUpHeadAndGet(routeOpts, route, `/${file}`, rootPath);

	          const key = path.posix.basename(route);
	          if (indexes.includes(key) && !indexDirs.has(key)) {
	            indexDirs.set(path.posix.dirname(route), rootPath);
	          }
	        }
	      }

	      for (const [dirname, rootPath] of indexDirs.entries()) {
	        const pathname = dirname + (dirname.endsWith('/') ? '' : '/');
	        const file = '/' + pathname.replace(prefix, '');
	        setUpHeadAndGet(routeOpts, pathname, file, rootPath);

	        if (opts.redirect === true) {
	          setUpHeadAndGet(routeOpts, pathname.replace(endForwardSlashRegex, ''), file.replace(endForwardSlashRegex, ''), rootPath);
	        }
	      }
	    }
	  }

	  const allowedPath = opts.allowedPath;

	  async function pumpSendToReply (
	    request,
	    reply,
	    pathname,
	    rootPath,
	    rootPathOffset = 0,
	    pumpOptions,
	    checkedEncodings
	  ) {
	    const pathnameOrig = pathname;
	    const options = Object.assign({}, sendOptions, pumpOptions);

	    if (rootPath) {
	      if (Array.isArray(rootPath)) {
	        options.root = rootPath[rootPathOffset];
	      } else {
	        options.root = rootPath;
	      }
	    }

	    if (allowedPath && !allowedPath(pathname, options.root, request)) {
	      return reply.callNotFound()
	    }

	    let encoding;
	    let pathnameForSend = pathname;

	    if (opts.preCompressed) {
	      /**
	       * We conditionally create this structure to track our attempts
	       * at sending pre-compressed assets
	       */
	      if (!checkedEncodings) {
	        checkedEncodings = new Set();
	      }

	      encoding = getEncodingHeader(request.headers, checkedEncodings);

	      if (encoding) {
	        if (pathname.endsWith('/')) {
	          pathname = findIndexFile(pathname, options.root, options.index);
	          if (!pathname) {
	            return reply.callNotFound()
	          }
	          pathnameForSend = pathnameForSend + pathname + '.' + getEncodingExtension(encoding);
	        } else {
	          pathnameForSend = pathname + '.' + getEncodingExtension(encoding);
	        }
	      }
	    }

	    // `send(..., path, ...)` will URI-decode path so we pass an encoded path here
	    const {
	      statusCode,
	      headers,
	      stream,
	      type,
	      metadata
	    } = await send(request.raw, encodeURI(pathnameForSend), options);
	    switch (type) {
	      case 'directory': {
	        const path = metadata.path;
	        if (opts.list) {
	          await dirList.send({
	            reply,
	            dir: path,
	            options: opts.list,
	            route: pathname,
	            prefix,
	            dotfiles: opts.dotfiles
	          }).catch((err) => reply.send(err));
	        }

	        if (opts.redirect === true) {
	          try {
	            reply.redirect(getRedirectUrl(request.raw.url), 301);
	          } /* c8 ignore start */ catch (error) {
	            // the try-catch here is actually unreachable, but we keep it for safety and prevent DoS attack
	            await reply.send(error);
	          } /* c8 ignore stop */
	        } else {
	          // if is a directory path without a trailing slash, and has an index file, reply as if it has a trailing slash
	          if (!pathname.endsWith('/') && findIndexFile(pathname, options.root, options.index)) {
	            return pumpSendToReply(
	              request,
	              reply,
	              pathname + '/',
	              rootPath,
	              undefined,
	              undefined,
	              checkedEncodings
	            )
	          }

	          reply.callNotFound();
	        }
	        break
	      }
	      case 'error': {
	        if (
	          statusCode === 403 &&
	          (!options.index || !options.index.length) &&
	          pathnameForSend[pathnameForSend.length - 1] === '/'
	        ) {
	          if (opts.list) {
	            await dirList.send({
	              reply,
	              dir: dirList.path(opts.root, pathname),
	              options: opts.list,
	              route: pathname,
	              prefix,
	              dotfiles: opts.dotfiles
	            }).catch((err) => reply.send(err));
	            return
	          }
	        }

	        if (metadata.error.code === 'ENOENT') {
	        // when preCompress is enabled and the path is a directory without a trailing slash
	          if (opts.preCompressed && encoding) {
	            if (opts.redirect !== true) {
	              const indexPathname = findIndexFile(pathname, options.root, options.index);
	              if (indexPathname) {
	                return pumpSendToReply(
	                  request,
	                  reply,
	                  pathname + '/',
	                  rootPath,
	                  undefined,
	                  undefined,
	                  checkedEncodings
	                )
	              }
	            }
	          }

	          // if file exists, send real file, otherwise send dir list if name match
	          if (opts.list && dirList.handle(pathname, opts.list)) {
	            await dirList.send({
	              reply,
	              dir: dirList.path(opts.root, pathname),
	              options: opts.list,
	              route: pathname,
	              prefix,
	              dotfiles: opts.dotfiles
	            }).catch((err) => reply.send(err));
	            return
	          }

	          // root paths left to try?
	          if (Array.isArray(rootPath) && rootPathOffset < (rootPath.length - 1)) {
	            return pumpSendToReply(request, reply, pathname, rootPath, rootPathOffset + 1)
	          }

	          if (opts.preCompressed && !checkedEncodings.has(encoding)) {
	            checkedEncodings.add(encoding);
	            return pumpSendToReply(
	              request,
	              reply,
	              pathnameOrig,
	              rootPath,
	              rootPathOffset,
	              undefined,
	              checkedEncodings
	            )
	          }

	          return reply.callNotFound()
	        }

	        // The `send` library terminates the request with a 404 if the requested
	        // path contains a dotfile and `send` is initialized with `{dotfiles:
	        // 'ignore'}`. `send` aborts the request before getting far enough to
	        // check if the file exists (hence, a 404 `NotFoundError` instead of
	        // `ENOENT`).
	        // https://github.com/pillarjs/send/blob/de073ed3237ade9ff71c61673a34474b30e5d45b/index.js#L582
	        if (metadata.error.status === 404) {
	          return reply.callNotFound()
	        }

	        await reply.send(metadata.error);
	        break
	      }
	      case 'file': {
	        // reply.raw.statusCode by default 200
	        // when ever the user changed it, we respect the status code
	        // otherwise use send provided status code
	        const newStatusCode = reply.statusCode !== 200 ? reply.statusCode : statusCode;
	        reply.code(newStatusCode);
	        if (setHeaders !== undefined) {
	          setHeaders(reply.raw, metadata.path, metadata.stat);
	        }
	        reply.headers(headers);
	        if (encoding) {
	          reply.header('content-type', getContentType(pathname));
	          reply.header('content-encoding', encoding);
	        }
	        await reply.send(stream);
	        break
	      }
	    }
	  }

	  function setUpHeadAndGet (routeOpts, route, file, rootPath) {
	    const toSetUp = Object.assign({}, routeOpts, {
	      method: ['HEAD', 'GET'],
	      url: route,
	      handler: serveFileHandler
	    });
	    toSetUp.config = toSetUp.config || {};
	    toSetUp.config.file = file;
	    toSetUp.config.rootPath = rootPath;
	    fastify.route(toSetUp);
	  }

	  async function serveFileHandler (req, reply) {
	    // TODO: remove the fallback branch when bump major
	    /* c8 ignore next */
	    const routeConfig = req.routeOptions?.config || req.routeConfig;
	    return pumpSendToReply(req, reply, routeConfig.file, routeConfig.rootPath)
	  }
	}

	function normalizeRoot (root) {
	  if (root === undefined) {
	    return root
	  }
	  if (root instanceof URL && root.protocol === 'file:') {
	    return fileURLToPath(root)
	  }
	  if (Array.isArray(root)) {
	    const result = [];
	    for (let i = 0, il = root.length; i < il; ++i) {
	      if (root[i] instanceof URL && root[i].protocol === 'file:') {
	        result.push(fileURLToPath(root[i]));
	      } else {
	        result.push(root[i]);
	      }
	    }

	    return result
	  }

	  return root
	}

	function checkRootPathForErrors (fastify, rootPath) {
	  if (rootPath === undefined) {
	    throw new Error('"root" option is required')
	  }

	  if (Array.isArray(rootPath)) {
	    if (!rootPath.length) {
	      throw new Error('"root" option array requires one or more paths')
	    }

	    if (new Set(rootPath).size !== rootPath.length) {
	      throw new Error(
	        '"root" option array contains one or more duplicate paths'
	      )
	    }

	    // check each path and fail at first invalid
	    rootPath.map((path) => checkPath(fastify, path));
	    return
	  }

	  if (typeof rootPath === 'string') {
	    return checkPath(fastify, rootPath)
	  }

	  throw new Error('"root" option must be a string or array of strings')
	}

	function checkPath (fastify, rootPath) {
	  if (typeof rootPath !== 'string') {
	    throw new TypeError('"root" option must be a string')
	  }
	  if (path.isAbsolute(rootPath) === false) {
	    throw new Error('"root" option must be an absolute path')
	  }

	  let pathStat;

	  try {
	    pathStat = statSync(rootPath);
	  } catch (e) {
	    if (e.code === 'ENOENT') {
	      fastify.log.warn(`"root" path "${rootPath}" must exist`);
	      return
	    }

	    throw e
	  }

	  if (pathStat.isDirectory() === false) {
	    throw new Error('"root" option must point to a directory')
	  }
	}

	function getContentType (path) {
	  const type = send.mime.getType(path) || send.mime.default_type;

	  if (!send.isUtf8MimeType(type)) {
	    return type
	  }
	  return `${type}; charset=utf-8`
	}

	function findIndexFile (pathname, root, indexFiles = ['index.html']) {
	  if (Array.isArray(indexFiles)) {
	    return indexFiles.find(filename => {
	      const p = path.join(root, pathname, filename);
	      try {
	        const stats = statSync(p);
	        return !stats.isDirectory()
	      } catch {
	        return false
	      }
	    })
	  }
	  /* c8 ignore next */
	  return false
	}

	// Adapted from https://github.com/fastify/fastify-compress/blob/665e132fa63d3bf05ad37df3c20346660b71a857/index.js#L451
	function getEncodingHeader (headers, checked) {
	  if (!('accept-encoding' in headers)) return

	  // consider the no-preference token as gzip for downstream compat
	  const header = headers['accept-encoding'].toLowerCase().replace(asteriskRegex, 'gzip');

	  return encodingNegotiator.negotiate(
	    header,
	    supportedEncodings.filter((enc) => !checked.has(enc))
	  )
	}

	function getEncodingExtension (encoding) {
	  switch (encoding) {
	    case 'br':
	      return 'br'

	    case 'gzip':
	      return 'gz'
	  }
	}

	function getRedirectUrl (url) {
	  let i = 0;
	  // we detect how many slash before a valid path
	  for (; i < url.length; ++i) {
	    if (url[i] !== '/' && url[i] !== '\\') break
	  }
	  // turns all leading / or \ into a single /
	  url = '/' + url.substr(i);
	  try {
	    const parsed = new URL(url, 'http://localhost.com/');
	    const parsedPathname = parsed.pathname;
	    return parsedPathname + (parsedPathname[parsedPathname.length - 1] !== '/' ? '/' : '') + (parsed.search || '')
	  } /* c8 ignore start */ catch {
	    // the try-catch here is actually unreachable, but we keep it for safety and prevent DoS attack
	    const err = new Error(`Invalid redirect URL: ${url}`);
	    err.statusCode = 400;
	    throw err
	  } /* c8 ignore stop */
	}

	_static.exports = fp(fastifyStatic, {
	  fastify: '5.x',
	  name: '@fastify/static'
	});
	_static.exports.default = fastifyStatic;
	_static.exports.fastifyStatic = fastifyStatic;
	return _static.exports;
}

var _staticExports = require_static();

function commonjsRequire(path) {
	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}

var view = {exports: {}};

var hasRequiredView;

function requireView () {
	if (hasRequiredView) return view.exports;
	hasRequiredView = 1;
	const { readFile } = require$$5;
	const fp = requirePlugin();
	const { accessSync, existsSync, mkdirSync, readdirSync } = fs$1;
	const { basename, dirname, extname, join, resolve } = path$1;
	const { LruMap } = requireToadCache();
	const supportedEngines = ['ejs', 'nunjucks', 'pug', 'handlebars', 'mustache', 'twig', 'liquid', 'dot', 'eta', 'edge'];

	const viewCache = Symbol('@fastify/view/cache');

	const fastifyViewCache = fp(
	  async function cachePlugin (fastify, opts) {
	    const lru = new LruMap(opts.maxCache || 100);
	    fastify.decorate(viewCache, lru);
	  },
	  {
	    fastify: '5.x',
	    name: '@fastify/view/cache'
	  }
	);

	async function fastifyView (fastify, opts) {
	  if (fastify[viewCache] === undefined) {
	    await fastify.register(fastifyViewCache, opts);
	  }
	  if (!opts.engine) {
	    throw new Error('Missing engine')
	  }
	  const type = Object.keys(opts.engine)[0];
	  if (supportedEngines.indexOf(type) === -1) {
	    throw new Error(`'${type}' not yet supported, PR? :)`)
	  }
	  const charset = opts.charset || 'utf-8';
	  const propertyName = opts.propertyName || 'view';
	  const asyncPropertyName = opts.asyncPropertyName || `${propertyName}Async`;
	  const engine = await opts.engine[type];
	  const globalOptions = opts.options || {};
	  const templatesDir = resolveTemplateDir(opts);
	  const includeViewExtension = opts.includeViewExtension || false;
	  const viewExt = opts.viewExt || '';
	  const prod = typeof opts.production === 'boolean' ? opts.production : process.env.NODE_ENV === 'production';
	  const defaultCtx = opts.defaultContext;
	  const globalLayoutFileName = opts.layout;

	  /**
	   * @type {Map<string, Promise>}
	   */
	  const readFileMap = new Map();

	  function readFileSemaphore (filePath) {
	    if (readFileMap.has(filePath) === false) {
	      const promise = readFile(filePath, 'utf-8');
	      readFileMap.set(filePath, promise);
	      return promise.finally(() => readFileMap.delete(filePath))
	    }
	    return readFileMap.get(filePath)
	  }

	  function templatesDirIsValid (_templatesDir) {
	    if (Array.isArray(_templatesDir) && type !== 'nunjucks') {
	      throw new Error('Only Nunjucks supports the "templates" option as an array')
	    }
	  }

	  function layoutIsValid (_layoutFileName) {
	    if (type !== 'dot' && type !== 'handlebars' && type !== 'ejs' && type !== 'eta') {
	      throw new Error('Only Dot, Handlebars, EJS and Eta support the "layout" option')
	    }

	    if (!hasAccessToLayoutFile(_layoutFileName, getDefaultExtension(type))) {
	      throw new Error(`unable to access template "${_layoutFileName}"`)
	    }
	  }

	  function setupNunjucksEnv (_engine) {
	    if (type === 'nunjucks') {
	      const env = _engine.configure(templatesDir, globalOptions);
	      if (typeof globalOptions.onConfigure === 'function') {
	        globalOptions.onConfigure(env);
	      }
	      return env
	    }
	    return null
	  }

	  templatesDirIsValid(templatesDir);

	  if (globalLayoutFileName) {
	    layoutIsValid(globalLayoutFileName);
	  }

	  const dotRender = type === 'dot' ? viewDot.call(fastify, preProcessDot.call(fastify, templatesDir, globalOptions)) : null;
	  const nunjucksEnv = setupNunjucksEnv(engine);

	  const renders = {
	    ejs: withLayout(viewEjs, globalLayoutFileName),
	    handlebars: withLayout(viewHandlebars, globalLayoutFileName),
	    mustache: viewMustache,
	    nunjucks: viewNunjucks,
	    twig: viewTwig,
	    liquid: viewLiquid,
	    dot: withLayout(dotRender, globalLayoutFileName),
	    eta: withLayout(viewEta, globalLayoutFileName),
	    edge: viewEdge,
	    _default: view
	  };

	  const renderer = renders[type] ? renders[type] : renders._default;

	  async function asyncRender (page) {
	    if (!page) {
	      throw new Error('Missing page')
	    }

	    let result = await renderer.apply(this, arguments);

	    if (minify && !isPathExcludedMinification(this)) {
	      result = await minify(result, globalOptions.htmlMinifierOptions);
	    }

	    if (this.getHeader && !this.getHeader('Content-Type')) {
	      this.header('Content-Type', 'text/html; charset=' + charset);
	    }

	    return result
	  }

	  function viewDecorator () {
	    const args = Array.from(arguments);

	    let done;
	    if (typeof args[args.length - 1] === 'function') {
	      done = args.pop();
	    }

	    const promise = asyncRender.apply({}, args);

	    if (typeof done === 'function') {
	      promise.then(done.bind(null, null), done);
	      return
	    }

	    return promise
	  }

	  viewDecorator.clearCache = function () {
	    fastify[viewCache].clear();
	  };

	  fastify.decorate(propertyName, viewDecorator);

	  fastify.decorateReply(propertyName, async function (page, data, opts) {
	    try {
	      const html = await asyncRender.call(this, page, data, opts);
	      this.send(html);
	    } catch (err) {
	      this.send(err);
	    }

	    return this
	  });

	  fastify.decorateReply(asyncPropertyName, asyncRender);

	  if (!fastify.hasReplyDecorator('locals')) {
	    fastify.decorateReply('locals', null);

	    fastify.addHook('onRequest', (_req, reply, done) => {
	      reply.locals = {};
	      done();
	    });
	  }

	  function getPage (page, extension) {
	    const pageLRU = `getPage-${page}-${extension}`;
	    let result = fastify[viewCache].get(pageLRU);

	    if (typeof result === 'string') {
	      return result
	    }

	    const filename = basename(page, extname(page));
	    result = join(dirname(page), filename + getExtension(page, extension));

	    fastify[viewCache].set(pageLRU, result);

	    return result
	  }

	  function getDefaultExtension (type) {
	    const mappedExtensions = {
	      handlebars: 'hbs',
	      nunjucks: 'njk'
	    };

	    return viewExt || (mappedExtensions[type] || type)
	  }

	  function getExtension (page, extension) {
	    let filextension = extname(page);
	    if (!filextension) {
	      filextension = '.' + getDefaultExtension(type);
	    }

	    return viewExt ? `.${viewExt}` : (includeViewExtension ? `.${extension}` : filextension)
	  }

	  const minify = typeof globalOptions.useHtmlMinifier?.minify === 'function'
	    ? globalOptions.useHtmlMinifier.minify
	    : null;

	  const minifyExcludedPaths = Array.isArray(globalOptions.pathsToExcludeHtmlMinifier)
	    ? new Set(globalOptions.pathsToExcludeHtmlMinifier)
	    : null;

	  function getRequestedPath (fastify) {
	    return fastify?.request?.routeOptions.url ?? null
	  }
	  function isPathExcludedMinification (that) {
	    return minifyExcludedPaths?.has(getRequestedPath(that))
	  }
	  function onTemplatesLoaded (file, data) {
	    if (type === 'handlebars') {
	      data = engine.compile(data, globalOptions.compileOptions);
	    }
	    fastify[viewCache].set(file, data);
	    return data
	  }

	  // Gets template as string (or precompiled for Handlebars)
	  // from LRU cache or filesystem.
	  const getTemplate = async function (file) {
	    if (typeof file === 'function') {
	      return file
	    }
	    let isRaw = false;
	    if (typeof file === 'object' && file.raw) {
	      isRaw = true;
	      file = file.raw;
	    }
	    const data = fastify[viewCache].get(file);
	    if (data && prod) {
	      return data
	    }
	    if (isRaw) {
	      return onTemplatesLoaded(file, file)
	    }
	    const fileData = await readFileSemaphore(join(templatesDir, file));
	    return onTemplatesLoaded(file, fileData)
	  };

	  // Gets partials as collection of strings from LRU cache or filesystem.
	  const getPartials = async function (page, { partials, requestedPath }) {
	    const cacheKey = getPartialsCacheKey(page, partials, requestedPath);
	    const partialsObj = fastify[viewCache].get(cacheKey);
	    if (partialsObj && prod) {
	      return partialsObj
	    } else {
	      const partialKeys = Object.keys(partials);
	      if (partialKeys.length === 0) {
	        return {}
	      }
	      const partialsHtml = {};
	      await Promise.all(partialKeys.map(async (key) => {
	        partialsHtml[key] = await readFileSemaphore(join(templatesDir, partials[key]));
	      }));
	      fastify[viewCache].set(cacheKey, partialsHtml);
	      return partialsHtml
	    }
	  };

	  function getPartialsCacheKey (page, partials, requestedPath) {
	    let cacheKey = page;

	    for (const key of Object.keys(partials)) {
	      cacheKey += `|${key}:${partials[key]}`;
	    }

	    cacheKey += `|${requestedPath}-Partials`;

	    return cacheKey
	  }

	  function readCallbackParser (page, html, localOptions) {
	    if ((type === 'ejs') && viewExt && !globalOptions.includer) {
	      globalOptions.includer = (originalPath, parsedPath) => ({
	        filename: parsedPath || join(templatesDir, originalPath + '.' + viewExt)
	      });
	    }
	    if (localOptions) {
	      for (const key in globalOptions) {
	        if (!Object.hasOwn(localOptions, key)) localOptions[key] = globalOptions[key];
	      }
	    } else localOptions = globalOptions;

	    const compiledPage = engine.compile(html, localOptions);

	    fastify[viewCache].set(page, compiledPage);
	    return compiledPage
	  }

	  function readCallback (page, _data, localOptions, html) {
	    globalOptions.filename = join(templatesDir, page);
	    return readCallbackParser(page, html, localOptions)
	  }

	  function preProcessDot (templatesDir, options) {
	    // Process all templates to in memory functions
	    // https://github.com/olado/doT#security-considerations
	    const destinationDir = options.destination || join(__dirname, 'out');
	    if (!existsSync(destinationDir)) {
	      mkdirSync(destinationDir);
	    }

	    const renderer = engine.process(Object.assign(
	      {},
	      options,
	      {
	        path: templatesDir,
	        destination: destinationDir
	      }
	    ));

	    // .jst files are compiled to .js files so we need to require them
	    for (const file of readdirSync(destinationDir, { withFileTypes: false })) {
	      renderer[basename(file, '.js')] = commonjsRequire(resolve(join(destinationDir, file)));
	    }
	    if (Object.keys(renderer).length === 0) {
	      this.log.warn(`WARN: no template found in ${templatesDir}`);
	    }

	    return renderer
	  }

	  async function view (page, data, opts) {
	    data = Object.assign({}, defaultCtx, this.locals, data);
	    if (typeof page === 'function') {
	      return page(data)
	    }
	    let isRaw = false;
	    if (typeof page === 'object' && page.raw) {
	      isRaw = true;
	      page = page.raw.toString();
	    } else {
	      // append view extension
	      page = getPage(page, type);
	    }
	    const toHtml = fastify[viewCache].get(page);

	    if (toHtml && prod) {
	      return toHtml(data)
	    } else if (isRaw) {
	      const compiledPage = readCallbackParser(page, page, opts);
	      return compiledPage(data)
	    }

	    const file = await readFileSemaphore(join(templatesDir, page));
	    const render = readCallback(page, data, opts, file);
	    return render(data)
	  }

	  async function viewEjs (page, data, opts) {
	    if (opts?.layout) {
	      layoutIsValid(opts.layout);
	      return withLayout(viewEjs, opts.layout).call(this, page, data)
	    }
	    data = Object.assign({}, defaultCtx, this.locals, data);
	    if (typeof page === 'function') {
	      return page(data)
	    }
	    let isRaw = false;
	    if (typeof page === 'object' && page.raw) {
	      isRaw = true;
	      page = page.raw.toString();
	    } else {
	      // append view extension
	      page = getPage(page, type);
	    }
	    const toHtml = fastify[viewCache].get(page);

	    if (toHtml && prod) {
	      return toHtml(data)
	    } else if (isRaw) {
	      const compiledPage = readCallbackParser(page, page, opts);
	      return compiledPage(data)
	    }

	    const file = await readFileSemaphore(join(templatesDir, page));
	    const render = readCallback(page, data, opts, file);
	    return render(data)
	  }

	  async function viewNunjucks (page, data) {
	    data = Object.assign({}, defaultCtx, this.locals, data);
	    let render;
	    if (typeof page === 'string') {
	      // Append view extension.
	      page = getPage(page, 'njk');
	      render = nunjucksEnv.render.bind(nunjucksEnv, page);
	    } else if (typeof page === 'object' && typeof page.render === 'function') {
	      render = page.render.bind(page);
	    } else if (typeof page === 'object' && page.raw) {
	      render = nunjucksEnv.renderString.bind(nunjucksEnv, page.raw.toString());
	    } else {
	      throw new Error('Unknown template type')
	    }
	    return new Promise((resolve, reject) => {
	      render(data, (err, html) => {
	        if (err) {
	          reject(err);
	          return
	        }

	        resolve(html);
	      });
	    })
	  }

	  async function viewHandlebars (page, data, opts) {
	    if (opts?.layout) {
	      layoutIsValid(opts.layout);
	      return withLayout(viewHandlebars, opts.layout).call(this, page, data)
	    }

	    let options;

	    if (globalOptions.useDataVariables) {
	      options = {
	        data: defaultCtx ? Object.assign({}, defaultCtx, this.locals) : this.locals
	      };
	    } else {
	      data = Object.assign({}, defaultCtx, this.locals, data);
	    }

	    if (typeof page === 'string') {
	      // append view extension
	      page = getPage(page, 'hbs');
	    }
	    const requestedPath = getRequestedPath(this);
	    const template = await getTemplate(page);

	    if (prod) {
	      return template(data, options)
	    } else {
	      const partialsObject = await getPartials(type, { partials: globalOptions.partials || {}, requestedPath });

	      Object.keys(partialsObject).forEach((name) => {
	        engine.registerPartial(name, engine.compile(partialsObject[name], globalOptions.compileOptions));
	      });

	      return template(data, options)
	    }
	  }

	  async function viewMustache (page, data, opts) {
	    const options = Object.assign({}, opts);
	    data = Object.assign({}, defaultCtx, this.locals, data);
	    if (typeof page === 'string') {
	      // append view extension
	      page = getPage(page, 'mustache');
	    }
	    const partials = Object.assign({}, globalOptions.partials || {}, options.partials || {});
	    const requestedPath = getRequestedPath(this);
	    const templateString = await getTemplate(page);
	    const partialsObject = await getPartials(page, { partials, requestedPath });

	    let html;
	    if (typeof templateString === 'function') {
	      html = templateString(data, partialsObject);
	    } else {
	      html = engine.render(templateString, data, partialsObject);
	    }

	    return html
	  }

	  async function viewTwig (page, data) {
	    data = Object.assign({}, defaultCtx, globalOptions, this.locals, data);
	    let render;
	    if (typeof page === 'string') {
	      // Append view extension.
	      page = getPage(page, 'twig');
	      render = engine.renderFile.bind(engine, join(templatesDir, page));
	    } else if (typeof page === 'object' && typeof page.render === 'function') {
	      render = (data, cb) => cb(null, page.render(data));
	    } else if (typeof page === 'object' && page.raw) {
	      render = (data, cb) => cb(null, engine.twig({ data: page.raw.toString() }).render(data));
	    } else {
	      throw new Error('Unknown template type')
	    }
	    return new Promise((resolve, reject) => {
	      render(data, (err, html) => {
	        if (err) {
	          reject(err);
	          return
	        }

	        resolve(html);
	      });
	    })
	  }

	  async function viewLiquid (page, data, opts) {
	    data = Object.assign({}, defaultCtx, this.locals, data);
	    let render;
	    if (typeof page === 'string') {
	      // Append view extension.
	      page = getPage(page, 'liquid');
	      render = engine.renderFile.bind(engine, join(templatesDir, page));
	    } else if (typeof page === 'function') {
	      render = page;
	    } else if (typeof page === 'object' && page.raw) {
	      const templates = engine.parse(page.raw);
	      render = engine.render.bind(engine, templates);
	    }

	    return render(data, opts)
	  }

	  function viewDot (renderModule) {
	    return async function _viewDot (page, data, opts) {
	      if (opts?.layout) {
	        layoutIsValid(opts.layout);
	        return withLayout(dotRender, opts.layout).call(this, page, data)
	      }
	      data = Object.assign({}, defaultCtx, this.locals, data);
	      let render;
	      if (typeof page === 'function') {
	        render = page;
	      } else if (typeof page === 'object' && page.raw) {
	        render = engine.template(page.raw.toString(), { ...engine.templateSettings, ...globalOptions, ...page.settings }, page.imports);
	      } else {
	        render = renderModule[page];
	      }
	      return render(data)
	    }
	  }

	  async function viewEta (page, data, opts) {
	    if (opts?.layout) {
	      layoutIsValid(opts.layout);
	      return withLayout(viewEta, opts.layout).call(this, page, data)
	    }

	    if (globalOptions.templatesSync) {
	      engine.templatesSync = globalOptions.templatesSync;
	    }

	    engine.configure({
	      views: templatesDir,
	      cache: prod || globalOptions.templatesSync
	    });

	    const config = Object.assign({
	      cache: prod,
	      views: templatesDir
	    }, globalOptions);

	    data = Object.assign({}, defaultCtx, this.locals, data);

	    if (typeof page === 'function') {
	      const ret = await page.call(engine, data, config);
	      return ret
	    }

	    let render, renderAsync;
	    if (typeof page === 'object' && page.raw) {
	      page = page.raw.toString();
	      render = engine.renderString.bind(engine);
	      renderAsync = engine.renderStringAsync.bind(engine);
	    } else {
	      // Append view extension (Eta will append '.eta' by default,
	      // but this also allows custom extensions)
	      page = getPage(page, 'eta');
	      render = engine.render.bind(engine);
	      renderAsync = engine.renderAsync.bind(engine);
	    }

	    /* c8 ignore next */
	    if (opts?.async ?? globalOptions.async) {
	      return renderAsync(page, data, config)
	    } else {
	      return render(page, data, config)
	    }
	  }

	  if (prod && type === 'handlebars' && globalOptions.partials) {
	    const partialsObject = await getPartials(type, { partials: globalOptions.partials, requestedPath: getRequestedPath(this) });
	    Object.keys(partialsObject).forEach((name) => {
	      engine.registerPartial(name, engine.compile(partialsObject[name], globalOptions.compileOptions));
	    });
	  }

	  async function viewEdge (page, data, opts) {
	    data = Object.assign({}, defaultCtx, this.locals, data);

	    switch (typeof page) {
	      case 'string':
	        return engine.render(getPage(page, 'edge'), data)
	      case 'function':
	        return page(data)
	      case 'object':
	        return engine.renderRaw(page, data)
	      default:
	        throw new Error('Unknown page type')
	    }
	  }

	  function withLayout (render, layout) {
	    if (layout) {
	      return async function (page, data, opts) {
	        if (opts?.layout) throw new Error('A layout can either be set globally or on render, not both.')
	        data = Object.assign({}, defaultCtx, this.locals, data);
	        const result = await render.call(this, page, data, opts);
	        data = Object.assign(data, { body: result });
	        return render.call(this, layout, data, opts)
	      }
	    }
	    return render
	  }

	  function resolveTemplateDir (_opts) {
	    if (_opts.root) {
	      return _opts.root
	    }

	    return Array.isArray(_opts.templates)
	      ? _opts.templates.map((dir) => resolve(dir))
	      : resolve(_opts.templates || './')
	  }

	  function hasAccessToLayoutFile (fileName, ext) {
	    const layoutKey = `layout-${fileName}-${ext}`;
	    let result = fastify[viewCache].get(layoutKey);

	    if (typeof result === 'boolean') {
	      return result
	    }

	    try {
	      accessSync(join(templatesDir, getPage(fileName, ext)));
	      result = true;
	    } catch {
	      result = false;
	    }

	    fastify[viewCache].set(layoutKey, result);

	    return result
	  }
	}

	view.exports = fp(fastifyView, {
	  fastify: '5.x',
	  name: '@fastify/view'
	});
	view.exports.default = fastifyView;
	view.exports.fastifyView = fastifyView;
	view.exports.fastifyViewCache = viewCache;
	return view.exports;
}

var viewExports = requireView();

var ejs$1 = {};

var utils$1 = {};

/*
 * EJS Embedded JavaScript templates
 * Copyright 2112 Matthew Eernisse (mde@fleegix.org)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
*/

var hasRequiredUtils$1;

function requireUtils$1 () {
	if (hasRequiredUtils$1) return utils$1;
	hasRequiredUtils$1 = 1;
	(function (exports) {

		var regExpChars = /[|\\{}()[\]^$+*?.]/g;
		var hasOwnProperty = Object.prototype.hasOwnProperty;
		var hasOwn = function (obj, key) { return hasOwnProperty.apply(obj, [key]); };

		/**
		 * Escape characters reserved in regular expressions.
		 *
		 * If `string` is `undefined` or `null`, the empty string is returned.
		 *
		 * @param {String} string Input string
		 * @return {String} Escaped string
		 * @static
		 * @private
		 */
		exports.escapeRegExpChars = function (string) {
		  // istanbul ignore if
		  if (!string) {
		    return '';
		  }
		  return String(string).replace(regExpChars, '\\$&');
		};

		var _ENCODE_HTML_RULES = {
		  '&': '&amp;',
		  '<': '&lt;',
		  '>': '&gt;',
		  '"': '&#34;',
		  "'": '&#39;'
		};
		var _MATCH_HTML = /[&<>'"]/g;

		function encode_char(c) {
		  return _ENCODE_HTML_RULES[c] || c;
		}

		/**
		 * Stringified version of constants used by {@link module:utils.escapeXML}.
		 *
		 * It is used in the process of generating {@link ClientFunction}s.
		 *
		 * @readonly
		 * @type {String}
		 */

		var escapeFuncStr =
		  'var _ENCODE_HTML_RULES = {\n'
		+ '      "&": "&amp;"\n'
		+ '    , "<": "&lt;"\n'
		+ '    , ">": "&gt;"\n'
		+ '    , \'"\': "&#34;"\n'
		+ '    , "\'": "&#39;"\n'
		+ '    }\n'
		+ '  , _MATCH_HTML = /[&<>\'"]/g;\n'
		+ 'function encode_char(c) {\n'
		+ '  return _ENCODE_HTML_RULES[c] || c;\n'
		+ '};\n';

		/**
		 * Escape characters reserved in XML.
		 *
		 * If `markup` is `undefined` or `null`, the empty string is returned.
		 *
		 * @implements {EscapeCallback}
		 * @param {String} markup Input string
		 * @return {String} Escaped string
		 * @static
		 * @private
		 */

		exports.escapeXML = function (markup) {
		  return markup == undefined
		    ? ''
		    : String(markup)
		      .replace(_MATCH_HTML, encode_char);
		};

		function escapeXMLToString() {
		  return Function.prototype.toString.call(this) + ';\n' + escapeFuncStr;
		}

		try {
		  if (typeof Object.defineProperty === 'function') {
		  // If the Function prototype is frozen, the "toString" property is non-writable. This means that any objects which inherit this property
		  // cannot have the property changed using an assignment. If using strict mode, attempting that will cause an error. If not using strict
		  // mode, attempting that will be silently ignored.
		  // However, we can still explicitly shadow the prototype's "toString" property by defining a new "toString" property on this object.
		    Object.defineProperty(exports.escapeXML, 'toString', { value: escapeXMLToString });
		  } else {
		    // If Object.defineProperty() doesn't exist, attempt to shadow this property using the assignment operator.
		    exports.escapeXML.toString = escapeXMLToString;
		  }
		} catch (err) {
		  console.warn('Unable to set escapeXML.toString (is the Function prototype frozen?)');
		}

		/**
		 * Naive copy of properties from one object to another.
		 * Does not recurse into non-scalar properties
		 * Does not check to see if the property has a value before copying
		 *
		 * @param  {Object} to   Destination object
		 * @param  {Object} from Source object
		 * @return {Object}      Destination object
		 * @static
		 * @private
		 */
		exports.shallowCopy = function (to, from) {
		  from = from || {};
		  if ((to !== null) && (to !== undefined)) {
		    for (var p in from) {
		      if (!hasOwn(from, p)) {
		        continue;
		      }
		      if (p === '__proto__' || p === 'constructor') {
		        continue;
		      }
		      to[p] = from[p];
		    }
		  }
		  return to;
		};

		/**
		 * Naive copy of a list of key names, from one object to another.
		 * Only copies property if it is actually defined
		 * Does not recurse into non-scalar properties
		 *
		 * @param  {Object} to   Destination object
		 * @param  {Object} from Source object
		 * @param  {Array} list List of properties to copy
		 * @return {Object}      Destination object
		 * @static
		 * @private
		 */
		exports.shallowCopyFromList = function (to, from, list) {
		  list = list || [];
		  from = from || {};
		  if ((to !== null) && (to !== undefined)) {
		    for (var i = 0; i < list.length; i++) {
		      var p = list[i];
		      if (typeof from[p] != 'undefined') {
		        if (!hasOwn(from, p)) {
		          continue;
		        }
		        if (p === '__proto__' || p === 'constructor') {
		          continue;
		        }
		        to[p] = from[p];
		      }
		    }
		  }
		  return to;
		};

		/**
		 * Simple in-process cache implementation. Does not implement limits of any
		 * sort.
		 *
		 * @implements {Cache}
		 * @static
		 * @private
		 */
		exports.cache = {
		  _data: {},
		  set: function (key, val) {
		    this._data[key] = val;
		  },
		  get: function (key) {
		    return this._data[key];
		  },
		  remove: function (key) {
		    delete this._data[key];
		  },
		  reset: function () {
		    this._data = {};
		  }
		};

		/**
		 * Transforms hyphen case variable into camel case.
		 *
		 * @param {String} string Hyphen case string
		 * @return {String} Camel case string
		 * @static
		 * @private
		 */
		exports.hyphenToCamel = function (str) {
		  return str.replace(/-[a-z]/g, function (match) { return match[1].toUpperCase(); });
		};

		/**
		 * Returns a null-prototype object in runtimes that support it
		 *
		 * @return {Object} Object, prototype will be set to null where possible
		 * @static
		 * @private
		 */
		exports.createNullProtoObjWherePossible = (function () {
		  if (typeof Object.create == 'function') {
		    return function () {
		      return Object.create(null);
		    };
		  }
		  if (!({__proto__: null} instanceof Object)) {
		    return function () {
		      return {__proto__: null};
		    };
		  }
		  // Not possible, just pass through
		  return function () {
		    return {};
		  };
		})();

		exports.hasOwnOnlyObject = function (obj) {
		  var o = exports.createNullProtoObjWherePossible();
		  for (var p in obj) {
		    if (hasOwn(obj, p)) {
		      o[p] = obj[p];
		    }
		  }
		  return o;
		}; 
	} (utils$1));
	return utils$1;
}

var version$1 = "3.1.10";
var require$$3 = {
	version: version$1};

/*
 * EJS Embedded JavaScript templates
 * Copyright 2112 Matthew Eernisse (mde@fleegix.org)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
*/

var hasRequiredEjs;

function requireEjs () {
	if (hasRequiredEjs) return ejs$1;
	hasRequiredEjs = 1;
	(function (exports) {

		/**
		 * @file Embedded JavaScript templating engine. {@link http://ejs.co}
		 * @author Matthew Eernisse <mde@fleegix.org>
		 * @author Tiancheng "Timothy" Gu <timothygu99@gmail.com>
		 * @project EJS
		 * @license {@link http://www.apache.org/licenses/LICENSE-2.0 Apache License, Version 2.0}
		 */

		/**
		 * EJS internal functions.
		 *
		 * Technically this "module" lies in the same file as {@link module:ejs}, for
		 * the sake of organization all the private functions re grouped into this
		 * module.
		 *
		 * @module ejs-internal
		 * @private
		 */

		/**
		 * Embedded JavaScript templating engine.
		 *
		 * @module ejs
		 * @public
		 */


		var fs$1 = fs;
		var path$1 = path;
		var utils = requireUtils$1();

		var scopeOptionWarned = false;
		/** @type {string} */
		var _VERSION_STRING = require$$3.version;
		var _DEFAULT_OPEN_DELIMITER = '<';
		var _DEFAULT_CLOSE_DELIMITER = '>';
		var _DEFAULT_DELIMITER = '%';
		var _DEFAULT_LOCALS_NAME = 'locals';
		var _NAME = 'ejs';
		var _REGEX_STRING = '(<%%|%%>|<%=|<%-|<%_|<%#|<%|%>|-%>|_%>)';
		var _OPTS_PASSABLE_WITH_DATA = ['delimiter', 'scope', 'context', 'debug', 'compileDebug',
		  'client', '_with', 'rmWhitespace', 'strict', 'filename', 'async'];
		// We don't allow 'cache' option to be passed in the data obj for
		// the normal `render` call, but this is where Express 2 & 3 put it
		// so we make an exception for `renderFile`
		var _OPTS_PASSABLE_WITH_DATA_EXPRESS = _OPTS_PASSABLE_WITH_DATA.concat('cache');
		var _BOM = /^\uFEFF/;
		var _JS_IDENTIFIER = /^[a-zA-Z_$][0-9a-zA-Z_$]*$/;

		/**
		 * EJS template function cache. This can be a LRU object from lru-cache NPM
		 * module. By default, it is {@link module:utils.cache}, a simple in-process
		 * cache that grows continuously.
		 *
		 * @type {Cache}
		 */

		exports.cache = utils.cache;

		/**
		 * Custom file loader. Useful for template preprocessing or restricting access
		 * to a certain part of the filesystem.
		 *
		 * @type {fileLoader}
		 */

		exports.fileLoader = fs$1.readFileSync;

		/**
		 * Name of the object containing the locals.
		 *
		 * This variable is overridden by {@link Options}`.localsName` if it is not
		 * `undefined`.
		 *
		 * @type {String}
		 * @public
		 */

		exports.localsName = _DEFAULT_LOCALS_NAME;

		/**
		 * Promise implementation -- defaults to the native implementation if available
		 * This is mostly just for testability
		 *
		 * @type {PromiseConstructorLike}
		 * @public
		 */

		exports.promiseImpl = (new Function('return this;'))().Promise;

		/**
		 * Get the path to the included file from the parent file path and the
		 * specified path.
		 *
		 * @param {String}  name     specified path
		 * @param {String}  filename parent file path
		 * @param {Boolean} [isDir=false] whether the parent file path is a directory
		 * @return {String}
		 */
		exports.resolveInclude = function(name, filename, isDir) {
		  var dirname = path$1.dirname;
		  var extname = path$1.extname;
		  var resolve = path$1.resolve;
		  var includePath = resolve(isDir ? filename : dirname(filename), name);
		  var ext = extname(name);
		  if (!ext) {
		    includePath += '.ejs';
		  }
		  return includePath;
		};

		/**
		 * Try to resolve file path on multiple directories
		 *
		 * @param  {String}        name  specified path
		 * @param  {Array<String>} paths list of possible parent directory paths
		 * @return {String}
		 */
		function resolvePaths(name, paths) {
		  var filePath;
		  if (paths.some(function (v) {
		    filePath = exports.resolveInclude(name, v, true);
		    return fs$1.existsSync(filePath);
		  })) {
		    return filePath;
		  }
		}

		/**
		 * Get the path to the included file by Options
		 *
		 * @param  {String}  path    specified path
		 * @param  {Options} options compilation options
		 * @return {String}
		 */
		function getIncludePath(path, options) {
		  var includePath;
		  var filePath;
		  var views = options.views;
		  var match = /^[A-Za-z]+:\\|^\//.exec(path);

		  // Abs path
		  if (match && match.length) {
		    path = path.replace(/^\/*/, '');
		    if (Array.isArray(options.root)) {
		      includePath = resolvePaths(path, options.root);
		    } else {
		      includePath = exports.resolveInclude(path, options.root || '/', true);
		    }
		  }
		  // Relative paths
		  else {
		    // Look relative to a passed filename first
		    if (options.filename) {
		      filePath = exports.resolveInclude(path, options.filename);
		      if (fs$1.existsSync(filePath)) {
		        includePath = filePath;
		      }
		    }
		    // Then look in any views directories
		    if (!includePath && Array.isArray(views)) {
		      includePath = resolvePaths(path, views);
		    }
		    if (!includePath && typeof options.includer !== 'function') {
		      throw new Error('Could not find the include file "' +
		          options.escapeFunction(path) + '"');
		    }
		  }
		  return includePath;
		}

		/**
		 * Get the template from a string or a file, either compiled on-the-fly or
		 * read from cache (if enabled), and cache the template if needed.
		 *
		 * If `template` is not set, the file specified in `options.filename` will be
		 * read.
		 *
		 * If `options.cache` is true, this function reads the file from
		 * `options.filename` so it must be set prior to calling this function.
		 *
		 * @memberof module:ejs-internal
		 * @param {Options} options   compilation options
		 * @param {String} [template] template source
		 * @return {(TemplateFunction|ClientFunction)}
		 * Depending on the value of `options.client`, either type might be returned.
		 * @static
		 */

		function handleCache(options, template) {
		  var func;
		  var filename = options.filename;
		  var hasTemplate = arguments.length > 1;

		  if (options.cache) {
		    if (!filename) {
		      throw new Error('cache option requires a filename');
		    }
		    func = exports.cache.get(filename);
		    if (func) {
		      return func;
		    }
		    if (!hasTemplate) {
		      template = fileLoader(filename).toString().replace(_BOM, '');
		    }
		  }
		  else if (!hasTemplate) {
		    // istanbul ignore if: should not happen at all
		    if (!filename) {
		      throw new Error('Internal EJS error: no file name or template '
		                    + 'provided');
		    }
		    template = fileLoader(filename).toString().replace(_BOM, '');
		  }
		  func = exports.compile(template, options);
		  if (options.cache) {
		    exports.cache.set(filename, func);
		  }
		  return func;
		}

		/**
		 * Try calling handleCache with the given options and data and call the
		 * callback with the result. If an error occurs, call the callback with
		 * the error. Used by renderFile().
		 *
		 * @memberof module:ejs-internal
		 * @param {Options} options    compilation options
		 * @param {Object} data        template data
		 * @param {RenderFileCallback} cb callback
		 * @static
		 */

		function tryHandleCache(options, data, cb) {
		  var result;
		  if (!cb) {
		    if (typeof exports.promiseImpl == 'function') {
		      return new exports.promiseImpl(function (resolve, reject) {
		        try {
		          result = handleCache(options)(data);
		          resolve(result);
		        }
		        catch (err) {
		          reject(err);
		        }
		      });
		    }
		    else {
		      throw new Error('Please provide a callback function');
		    }
		  }
		  else {
		    try {
		      result = handleCache(options)(data);
		    }
		    catch (err) {
		      return cb(err);
		    }

		    cb(null, result);
		  }
		}

		/**
		 * fileLoader is independent
		 *
		 * @param {String} filePath ejs file path.
		 * @return {String} The contents of the specified file.
		 * @static
		 */

		function fileLoader(filePath){
		  return exports.fileLoader(filePath);
		}

		/**
		 * Get the template function.
		 *
		 * If `options.cache` is `true`, then the template is cached.
		 *
		 * @memberof module:ejs-internal
		 * @param {String}  path    path for the specified file
		 * @param {Options} options compilation options
		 * @return {(TemplateFunction|ClientFunction)}
		 * Depending on the value of `options.client`, either type might be returned
		 * @static
		 */

		function includeFile(path, options) {
		  var opts = utils.shallowCopy(utils.createNullProtoObjWherePossible(), options);
		  opts.filename = getIncludePath(path, opts);
		  if (typeof options.includer === 'function') {
		    var includerResult = options.includer(path, opts.filename);
		    if (includerResult) {
		      if (includerResult.filename) {
		        opts.filename = includerResult.filename;
		      }
		      if (includerResult.template) {
		        return handleCache(opts, includerResult.template);
		      }
		    }
		  }
		  return handleCache(opts);
		}

		/**
		 * Re-throw the given `err` in context to the `str` of ejs, `filename`, and
		 * `lineno`.
		 *
		 * @implements {RethrowCallback}
		 * @memberof module:ejs-internal
		 * @param {Error}  err      Error object
		 * @param {String} str      EJS source
		 * @param {String} flnm     file name of the EJS file
		 * @param {Number} lineno   line number of the error
		 * @param {EscapeCallback} esc
		 * @static
		 */

		function rethrow(err, str, flnm, lineno, esc) {
		  var lines = str.split('\n');
		  var start = Math.max(lineno - 3, 0);
		  var end = Math.min(lines.length, lineno + 3);
		  var filename = esc(flnm);
		  // Error context
		  var context = lines.slice(start, end).map(function (line, i){
		    var curr = i + start + 1;
		    return (curr == lineno ? ' >> ' : '    ')
		      + curr
		      + '| '
		      + line;
		  }).join('\n');

		  // Alter exception message
		  err.path = filename;
		  err.message = (filename || 'ejs') + ':'
		    + lineno + '\n'
		    + context + '\n\n'
		    + err.message;

		  throw err;
		}

		function stripSemi(str){
		  return str.replace(/;(\s*$)/, '$1');
		}

		/**
		 * Compile the given `str` of ejs into a template function.
		 *
		 * @param {String}  template EJS template
		 *
		 * @param {Options} [opts] compilation options
		 *
		 * @return {(TemplateFunction|ClientFunction)}
		 * Depending on the value of `opts.client`, either type might be returned.
		 * Note that the return type of the function also depends on the value of `opts.async`.
		 * @public
		 */

		exports.compile = function compile(template, opts) {
		  var templ;

		  // v1 compat
		  // 'scope' is 'context'
		  // FIXME: Remove this in a future version
		  if (opts && opts.scope) {
		    if (!scopeOptionWarned){
		      console.warn('`scope` option is deprecated and will be removed in EJS 3');
		      scopeOptionWarned = true;
		    }
		    if (!opts.context) {
		      opts.context = opts.scope;
		    }
		    delete opts.scope;
		  }
		  templ = new Template(template, opts);
		  return templ.compile();
		};

		/**
		 * Render the given `template` of ejs.
		 *
		 * If you would like to include options but not data, you need to explicitly
		 * call this function with `data` being an empty object or `null`.
		 *
		 * @param {String}   template EJS template
		 * @param {Object}  [data={}] template data
		 * @param {Options} [opts={}] compilation and rendering options
		 * @return {(String|Promise<String>)}
		 * Return value type depends on `opts.async`.
		 * @public
		 */

		exports.render = function (template, d, o) {
		  var data = d || utils.createNullProtoObjWherePossible();
		  var opts = o || utils.createNullProtoObjWherePossible();

		  // No options object -- if there are optiony names
		  // in the data, copy them to options
		  if (arguments.length == 2) {
		    utils.shallowCopyFromList(opts, data, _OPTS_PASSABLE_WITH_DATA);
		  }

		  return handleCache(opts, template)(data);
		};

		/**
		 * Render an EJS file at the given `path` and callback `cb(err, str)`.
		 *
		 * If you would like to include options but not data, you need to explicitly
		 * call this function with `data` being an empty object or `null`.
		 *
		 * @param {String}             path     path to the EJS file
		 * @param {Object}            [data={}] template data
		 * @param {Options}           [opts={}] compilation and rendering options
		 * @param {RenderFileCallback} cb callback
		 * @public
		 */

		exports.renderFile = function () {
		  var args = Array.prototype.slice.call(arguments);
		  var filename = args.shift();
		  var cb;
		  var opts = {filename: filename};
		  var data;
		  var viewOpts;

		  // Do we have a callback?
		  if (typeof arguments[arguments.length - 1] == 'function') {
		    cb = args.pop();
		  }
		  // Do we have data/opts?
		  if (args.length) {
		    // Should always have data obj
		    data = args.shift();
		    // Normal passed opts (data obj + opts obj)
		    if (args.length) {
		      // Use shallowCopy so we don't pollute passed in opts obj with new vals
		      utils.shallowCopy(opts, args.pop());
		    }
		    // Special casing for Express (settings + opts-in-data)
		    else {
		      // Express 3 and 4
		      if (data.settings) {
		        // Pull a few things from known locations
		        if (data.settings.views) {
		          opts.views = data.settings.views;
		        }
		        if (data.settings['view cache']) {
		          opts.cache = true;
		        }
		        // Undocumented after Express 2, but still usable, esp. for
		        // items that are unsafe to be passed along with data, like `root`
		        viewOpts = data.settings['view options'];
		        if (viewOpts) {
		          utils.shallowCopy(opts, viewOpts);
		        }
		      }
		      // Express 2 and lower, values set in app.locals, or people who just
		      // want to pass options in their data. NOTE: These values will override
		      // anything previously set in settings  or settings['view options']
		      utils.shallowCopyFromList(opts, data, _OPTS_PASSABLE_WITH_DATA_EXPRESS);
		    }
		    opts.filename = filename;
		  }
		  else {
		    data = utils.createNullProtoObjWherePossible();
		  }

		  return tryHandleCache(opts, data, cb);
		};

		/**
		 * Clear intermediate JavaScript cache. Calls {@link Cache#reset}.
		 * @public
		 */

		/**
		 * EJS template class
		 * @public
		 */
		exports.Template = Template;

		exports.clearCache = function () {
		  exports.cache.reset();
		};

		function Template(text, optsParam) {
		  var opts = utils.hasOwnOnlyObject(optsParam);
		  var options = utils.createNullProtoObjWherePossible();
		  this.templateText = text;
		  /** @type {string | null} */
		  this.mode = null;
		  this.truncate = false;
		  this.currentLine = 1;
		  this.source = '';
		  options.client = opts.client || false;
		  options.escapeFunction = opts.escape || opts.escapeFunction || utils.escapeXML;
		  options.compileDebug = opts.compileDebug !== false;
		  options.debug = !!opts.debug;
		  options.filename = opts.filename;
		  options.openDelimiter = opts.openDelimiter || exports.openDelimiter || _DEFAULT_OPEN_DELIMITER;
		  options.closeDelimiter = opts.closeDelimiter || exports.closeDelimiter || _DEFAULT_CLOSE_DELIMITER;
		  options.delimiter = opts.delimiter || exports.delimiter || _DEFAULT_DELIMITER;
		  options.strict = opts.strict || false;
		  options.context = opts.context;
		  options.cache = opts.cache || false;
		  options.rmWhitespace = opts.rmWhitespace;
		  options.root = opts.root;
		  options.includer = opts.includer;
		  options.outputFunctionName = opts.outputFunctionName;
		  options.localsName = opts.localsName || exports.localsName || _DEFAULT_LOCALS_NAME;
		  options.views = opts.views;
		  options.async = opts.async;
		  options.destructuredLocals = opts.destructuredLocals;
		  options.legacyInclude = typeof opts.legacyInclude != 'undefined' ? !!opts.legacyInclude : true;

		  if (options.strict) {
		    options._with = false;
		  }
		  else {
		    options._with = typeof opts._with != 'undefined' ? opts._with : true;
		  }

		  this.opts = options;

		  this.regex = this.createRegex();
		}

		Template.modes = {
		  EVAL: 'eval',
		  ESCAPED: 'escaped',
		  RAW: 'raw',
		  COMMENT: 'comment',
		  LITERAL: 'literal'
		};

		Template.prototype = {
		  createRegex: function () {
		    var str = _REGEX_STRING;
		    var delim = utils.escapeRegExpChars(this.opts.delimiter);
		    var open = utils.escapeRegExpChars(this.opts.openDelimiter);
		    var close = utils.escapeRegExpChars(this.opts.closeDelimiter);
		    str = str.replace(/%/g, delim)
		      .replace(/</g, open)
		      .replace(/>/g, close);
		    return new RegExp(str);
		  },

		  compile: function () {
		    /** @type {string} */
		    var src;
		    /** @type {ClientFunction} */
		    var fn;
		    var opts = this.opts;
		    var prepended = '';
		    var appended = '';
		    /** @type {EscapeCallback} */
		    var escapeFn = opts.escapeFunction;
		    /** @type {FunctionConstructor} */
		    var ctor;
		    /** @type {string} */
		    var sanitizedFilename = opts.filename ? JSON.stringify(opts.filename) : 'undefined';

		    if (!this.source) {
		      this.generateSource();
		      prepended +=
		        '  var __output = "";\n' +
		        '  function __append(s) { if (s !== undefined && s !== null) __output += s }\n';
		      if (opts.outputFunctionName) {
		        if (!_JS_IDENTIFIER.test(opts.outputFunctionName)) {
		          throw new Error('outputFunctionName is not a valid JS identifier.');
		        }
		        prepended += '  var ' + opts.outputFunctionName + ' = __append;' + '\n';
		      }
		      if (opts.localsName && !_JS_IDENTIFIER.test(opts.localsName)) {
		        throw new Error('localsName is not a valid JS identifier.');
		      }
		      if (opts.destructuredLocals && opts.destructuredLocals.length) {
		        var destructuring = '  var __locals = (' + opts.localsName + ' || {}),\n';
		        for (var i = 0; i < opts.destructuredLocals.length; i++) {
		          var name = opts.destructuredLocals[i];
		          if (!_JS_IDENTIFIER.test(name)) {
		            throw new Error('destructuredLocals[' + i + '] is not a valid JS identifier.');
		          }
		          if (i > 0) {
		            destructuring += ',\n  ';
		          }
		          destructuring += name + ' = __locals.' + name;
		        }
		        prepended += destructuring + ';\n';
		      }
		      if (opts._with !== false) {
		        prepended +=  '  with (' + opts.localsName + ' || {}) {' + '\n';
		        appended += '  }' + '\n';
		      }
		      appended += '  return __output;' + '\n';
		      this.source = prepended + this.source + appended;
		    }

		    if (opts.compileDebug) {
		      src = 'var __line = 1' + '\n'
		        + '  , __lines = ' + JSON.stringify(this.templateText) + '\n'
		        + '  , __filename = ' + sanitizedFilename + ';' + '\n'
		        + 'try {' + '\n'
		        + this.source
		        + '} catch (e) {' + '\n'
		        + '  rethrow(e, __lines, __filename, __line, escapeFn);' + '\n'
		        + '}' + '\n';
		    }
		    else {
		      src = this.source;
		    }

		    if (opts.client) {
		      src = 'escapeFn = escapeFn || ' + escapeFn.toString() + ';' + '\n' + src;
		      if (opts.compileDebug) {
		        src = 'rethrow = rethrow || ' + rethrow.toString() + ';' + '\n' + src;
		      }
		    }

		    if (opts.strict) {
		      src = '"use strict";\n' + src;
		    }
		    if (opts.debug) {
		      console.log(src);
		    }
		    if (opts.compileDebug && opts.filename) {
		      src = src + '\n'
		        + '//# sourceURL=' + sanitizedFilename + '\n';
		    }

		    try {
		      if (opts.async) {
		        // Have to use generated function for this, since in envs without support,
		        // it breaks in parsing
		        try {
		          ctor = (new Function('return (async function(){}).constructor;'))();
		        }
		        catch(e) {
		          if (e instanceof SyntaxError) {
		            throw new Error('This environment does not support async/await');
		          }
		          else {
		            throw e;
		          }
		        }
		      }
		      else {
		        ctor = Function;
		      }
		      fn = new ctor(opts.localsName + ', escapeFn, include, rethrow', src);
		    }
		    catch(e) {
		      // istanbul ignore else
		      if (e instanceof SyntaxError) {
		        if (opts.filename) {
		          e.message += ' in ' + opts.filename;
		        }
		        e.message += ' while compiling ejs\n\n';
		        e.message += 'If the above error is not helpful, you may want to try EJS-Lint:\n';
		        e.message += 'https://github.com/RyanZim/EJS-Lint';
		        if (!opts.async) {
		          e.message += '\n';
		          e.message += 'Or, if you meant to create an async function, pass `async: true` as an option.';
		        }
		      }
		      throw e;
		    }

		    // Return a callable function which will execute the function
		    // created by the source-code, with the passed data as locals
		    // Adds a local `include` function which allows full recursive include
		    var returnedFn = opts.client ? fn : function anonymous(data) {
		      var include = function (path, includeData) {
		        var d = utils.shallowCopy(utils.createNullProtoObjWherePossible(), data);
		        if (includeData) {
		          d = utils.shallowCopy(d, includeData);
		        }
		        return includeFile(path, opts)(d);
		      };
		      return fn.apply(opts.context,
		        [data || utils.createNullProtoObjWherePossible(), escapeFn, include, rethrow]);
		    };
		    if (opts.filename && typeof Object.defineProperty === 'function') {
		      var filename = opts.filename;
		      var basename = path$1.basename(filename, path$1.extname(filename));
		      try {
		        Object.defineProperty(returnedFn, 'name', {
		          value: basename,
		          writable: false,
		          enumerable: false,
		          configurable: true
		        });
		      } catch (e) {/* ignore */}
		    }
		    return returnedFn;
		  },

		  generateSource: function () {
		    var opts = this.opts;

		    if (opts.rmWhitespace) {
		      // Have to use two separate replace here as `^` and `$` operators don't
		      // work well with `\r` and empty lines don't work well with the `m` flag.
		      this.templateText =
		        this.templateText.replace(/[\r\n]+/g, '\n').replace(/^\s+|\s+$/gm, '');
		    }

		    // Slurp spaces and tabs before <%_ and after _%>
		    this.templateText =
		      this.templateText.replace(/[ \t]*<%_/gm, '<%_').replace(/_%>[ \t]*/gm, '_%>');

		    var self = this;
		    var matches = this.parseTemplateText();
		    var d = this.opts.delimiter;
		    var o = this.opts.openDelimiter;
		    var c = this.opts.closeDelimiter;

		    if (matches && matches.length) {
		      matches.forEach(function (line, index) {
		        var closing;
		        // If this is an opening tag, check for closing tags
		        // FIXME: May end up with some false positives here
		        // Better to store modes as k/v with openDelimiter + delimiter as key
		        // Then this can simply check against the map
		        if ( line.indexOf(o + d) === 0        // If it is a tag
		          && line.indexOf(o + d + d) !== 0) { // and is not escaped
		          closing = matches[index + 2];
		          if (!(closing == d + c || closing == '-' + d + c || closing == '_' + d + c)) {
		            throw new Error('Could not find matching close tag for "' + line + '".');
		          }
		        }
		        self.scanLine(line);
		      });
		    }

		  },

		  parseTemplateText: function () {
		    var str = this.templateText;
		    var pat = this.regex;
		    var result = pat.exec(str);
		    var arr = [];
		    var firstPos;

		    while (result) {
		      firstPos = result.index;

		      if (firstPos !== 0) {
		        arr.push(str.substring(0, firstPos));
		        str = str.slice(firstPos);
		      }

		      arr.push(result[0]);
		      str = str.slice(result[0].length);
		      result = pat.exec(str);
		    }

		    if (str) {
		      arr.push(str);
		    }

		    return arr;
		  },

		  _addOutput: function (line) {
		    if (this.truncate) {
		      // Only replace single leading linebreak in the line after
		      // -%> tag -- this is the single, trailing linebreak
		      // after the tag that the truncation mode replaces
		      // Handle Win / Unix / old Mac linebreaks -- do the \r\n
		      // combo first in the regex-or
		      line = line.replace(/^(?:\r\n|\r|\n)/, '');
		      this.truncate = false;
		    }
		    if (!line) {
		      return line;
		    }

		    // Preserve literal slashes
		    line = line.replace(/\\/g, '\\\\');

		    // Convert linebreaks
		    line = line.replace(/\n/g, '\\n');
		    line = line.replace(/\r/g, '\\r');

		    // Escape double-quotes
		    // - this will be the delimiter during execution
		    line = line.replace(/"/g, '\\"');
		    this.source += '    ; __append("' + line + '")' + '\n';
		  },

		  scanLine: function (line) {
		    var self = this;
		    var d = this.opts.delimiter;
		    var o = this.opts.openDelimiter;
		    var c = this.opts.closeDelimiter;
		    var newLineCount = 0;

		    newLineCount = (line.split('\n').length - 1);

		    switch (line) {
		    case o + d:
		    case o + d + '_':
		      this.mode = Template.modes.EVAL;
		      break;
		    case o + d + '=':
		      this.mode = Template.modes.ESCAPED;
		      break;
		    case o + d + '-':
		      this.mode = Template.modes.RAW;
		      break;
		    case o + d + '#':
		      this.mode = Template.modes.COMMENT;
		      break;
		    case o + d + d:
		      this.mode = Template.modes.LITERAL;
		      this.source += '    ; __append("' + line.replace(o + d + d, o + d) + '")' + '\n';
		      break;
		    case d + d + c:
		      this.mode = Template.modes.LITERAL;
		      this.source += '    ; __append("' + line.replace(d + d + c, d + c) + '")' + '\n';
		      break;
		    case d + c:
		    case '-' + d + c:
		    case '_' + d + c:
		      if (this.mode == Template.modes.LITERAL) {
		        this._addOutput(line);
		      }

		      this.mode = null;
		      this.truncate = line.indexOf('-') === 0 || line.indexOf('_') === 0;
		      break;
		    default:
		      // In script mode, depends on type of tag
		      if (this.mode) {
		        // If '//' is found without a line break, add a line break.
		        switch (this.mode) {
		        case Template.modes.EVAL:
		        case Template.modes.ESCAPED:
		        case Template.modes.RAW:
		          if (line.lastIndexOf('//') > line.lastIndexOf('\n')) {
		            line += '\n';
		          }
		        }
		        switch (this.mode) {
		        // Just executing code
		        case Template.modes.EVAL:
		          this.source += '    ; ' + line + '\n';
		          break;
		          // Exec, esc, and output
		        case Template.modes.ESCAPED:
		          this.source += '    ; __append(escapeFn(' + stripSemi(line) + '))' + '\n';
		          break;
		          // Exec and output
		        case Template.modes.RAW:
		          this.source += '    ; __append(' + stripSemi(line) + ')' + '\n';
		          break;
		        case Template.modes.COMMENT:
		          // Do nothing
		          break;
		          // Literal <%% mode, append as raw output
		        case Template.modes.LITERAL:
		          this._addOutput(line);
		          break;
		        }
		      }
		      // In string mode, just add the output
		      else {
		        this._addOutput(line);
		      }
		    }

		    if (self.opts.compileDebug && newLineCount) {
		      this.currentLine += newLineCount;
		      this.source += '    ; __line = ' + this.currentLine + '\n';
		    }
		  }
		};

		/**
		 * Escape characters reserved in XML.
		 *
		 * This is simply an export of {@link module:utils.escapeXML}.
		 *
		 * If `markup` is `undefined` or `null`, the empty string is returned.
		 *
		 * @param {String} markup Input string
		 * @return {String} Escaped string
		 * @public
		 * @func
		 * */
		exports.escapeXML = utils.escapeXML;

		/**
		 * Express.js support.
		 *
		 * This is an alias for {@link module:ejs.renderFile}, in order to support
		 * Express.js out-of-the-box.
		 *
		 * @func
		 */

		exports.__express = exports.renderFile;

		/**
		 * Version of EJS.
		 *
		 * @readonly
		 * @type {String}
		 * @public
		 */

		exports.VERSION = _VERSION_STRING;

		/**
		 * Name for detection of EJS.
		 *
		 * @readonly
		 * @type {String}
		 * @public
		 */

		exports.name = _NAME;

		/* istanbul ignore if */
		if (typeof window != 'undefined') {
		  window.ejs = exports;
		} 
	} (ejs$1));
	return ejs$1;
}

var ejsExports = requireEjs();
var ejs = /*@__PURE__*/getDefaultExportFromCjs(ejsExports);

var lib = {};

var decoder = {};

var utils = {};

var hasRequiredUtils;

function requireUtils () {
	if (hasRequiredUtils) return utils;
	hasRequiredUtils = 1;
	Object.defineProperty(utils, "__esModule", { value: true });
	const legacyErrorMessage = `Maxmind v2 module has changed API.\n\
Upgrade instructions can be found here: \
https://github.com/runk/node-maxmind/wiki/Migration-guide\n\
If you want to use legacy library then explicitly install maxmind@1`;
	const assert = (condition, message) => {
	    if (!condition) {
	        throw new Error(message);
	    }
	};
	utils.default = {
	    assert,
	    legacyErrorMessage,
	};
	return utils;
}

var hasRequiredDecoder;

function requireDecoder () {
	if (hasRequiredDecoder) return decoder;
	hasRequiredDecoder = 1;
	var __importDefault = (decoder && decoder.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(decoder, "__esModule", { value: true });
	const utils_1 = __importDefault(requireUtils());
	utils_1.default.assert(typeof BigInt !== 'undefined', 'Apparently you are using old version of node. Please upgrade to node 10.4.x or above.');
	const MAX_INT_32 = 2_147_483_647;
	var DataType;
	(function (DataType) {
	    DataType[DataType["Extended"] = 0] = "Extended";
	    DataType[DataType["Pointer"] = 1] = "Pointer";
	    DataType[DataType["Utf8String"] = 2] = "Utf8String";
	    DataType[DataType["Double"] = 3] = "Double";
	    DataType[DataType["Bytes"] = 4] = "Bytes";
	    DataType[DataType["Uint16"] = 5] = "Uint16";
	    DataType[DataType["Uint32"] = 6] = "Uint32";
	    DataType[DataType["Map"] = 7] = "Map";
	    DataType[DataType["Int32"] = 8] = "Int32";
	    DataType[DataType["Uint64"] = 9] = "Uint64";
	    DataType[DataType["Uint128"] = 10] = "Uint128";
	    DataType[DataType["Array"] = 11] = "Array";
	    DataType[DataType["Container"] = 12] = "Container";
	    DataType[DataType["EndMarker"] = 13] = "EndMarker";
	    DataType[DataType["Boolean"] = 14] = "Boolean";
	    DataType[DataType["Float"] = 15] = "Float";
	})(DataType || (DataType = {}));
	const pointerValueOffset = [0, 2048, 526336, 0];
	const noCache = {
	    get: () => undefined,
	    set: () => undefined,
	};
	const cursor = (value, offset) => ({ value, offset });
	class Decoder {
	    constructor(db, baseOffset = 0, cache = noCache) {
	        this.telemetry = {};
	        utils_1.default.assert(Boolean(db), 'Database buffer is required');
	        this.db = db;
	        this.baseOffset = baseOffset;
	        this.cache = cache;
	    }
	    decode(offset) {
	        let tmp;
	        const ctrlByte = this.db[offset++];
	        let type = ctrlByte >> 5;
	        if (type === DataType.Pointer) {
	            tmp = this.decodePointer(ctrlByte, offset);
	            return cursor(this.decodeFast(tmp.value).value, tmp.offset);
	        }
	        if (type === DataType.Extended) {
	            tmp = this.db[offset] + 7;
	            if (tmp < 8) {
	                throw new Error('Invalid Extended Type at offset ' + offset + ' val ' + tmp);
	            }
	            type = tmp;
	            offset++;
	        }
	        const size = this.sizeFromCtrlByte(ctrlByte, offset);
	        return this.decodeByType(type, size.offset, size.value);
	    }
	    decodeFast(offset) {
	        const cached = this.cache.get(offset);
	        if (cached) {
	            return cached;
	        }
	        const result = this.decode(offset);
	        this.cache.set(offset, result);
	        return result;
	    }
	    decodeByType(type, offset, size) {
	        const newOffset = offset + size;
	        // ipv4 types occurrence stats:
	        // 3618591 x utf8_string
	        // 448163 x map
	        // 175085 x uint32
	        // 83040 x double
	        // 24745 x array
	        // 3 x uint16
	        // 1 x uint64
	        // 14 x boolean
	        switch (type) {
	            case DataType.Utf8String:
	                return cursor(this.decodeString(offset, size), newOffset);
	            case DataType.Map:
	                return this.decodeMap(size, offset);
	            case DataType.Uint32:
	                return cursor(this.decodeUint(offset, size), newOffset);
	            case DataType.Double:
	                return cursor(this.decodeDouble(offset), newOffset);
	            case DataType.Array:
	                return this.decodeArray(size, offset);
	            case DataType.Boolean:
	                return cursor(this.decodeBoolean(size), offset);
	            case DataType.Float:
	                return cursor(this.decodeFloat(offset), newOffset);
	            case DataType.Bytes:
	                return cursor(this.decodeBytes(offset, size), newOffset);
	            case DataType.Uint16:
	                return cursor(this.decodeUint(offset, size), newOffset);
	            case DataType.Int32:
	                return cursor(this.decodeInt32(offset, size), newOffset);
	            case DataType.Uint64:
	                return cursor(this.decodeBigUint(offset, size), newOffset);
	            case DataType.Uint128:
	                return cursor(this.decodeBigUint(offset, size), newOffset);
	        }
	        throw new Error('Unknown type ' + type + ' at offset ' + offset);
	    }
	    sizeFromCtrlByte(ctrlByte, offset) {
	        // The first three bits of the control byte tell you what type the field is. If
	        // these bits are all 0, then this is an "extended" type, which means that the
	        // *next* byte contains the actual type. Otherwise, the first three bits will
	        // contain a number from 1 to 7, the actual type for the field.
	        // var type = ctrlByte >> 3;
	        // The next five bits in the control byte tell you how long the data field's
	        // payload is, except for maps and pointers. Maps and pointers use this size
	        // information a bit differently.``
	        const size = ctrlByte & 0x1f;
	        // If the five bits are smaller than 29, then those bits are the payload size in
	        // bytes. For example:
	        //   01000010          UTF-8 string - 2 bytes long
	        //   01011100          UTF-8 string - 28 bytes long
	        //   11000001          unsigned 32-bit int - 1 byte long
	        //   00000011 00000011 unsigned 128-bit int - 3 bytes long
	        if (size < 29) {
	            return cursor(size, offset);
	        }
	        // If the value is 29, then the size is 29 + *the next byte after the type
	        // specifying bytes as an unsigned integer*.
	        if (size === 29) {
	            return cursor(29 + this.db[offset], offset + 1);
	        }
	        // If the value is 30, then the size is 285 + *the next two bytes after the type
	        // specifying bytes as a single unsigned integer*.
	        if (size === 30) {
	            return cursor(285 + this.db.readUInt16BE(offset), offset + 2);
	        }
	        // At this point `size` is always 31.
	        // If the value is 31, then the size is 65,821 + *the next three bytes after the
	        // type specifying bytes as a single unsigned integer*.
	        return cursor(65821 + this.db.readUIntBE(offset, 3), offset + 3);
	    }
	    decodeBytes(offset, size) {
	        return this.db.subarray(offset, offset + size);
	    }
	    decodePointer(ctrlByte, offset) {
	        // Pointers use the last five bits in the control byte to calculate the pointer value.
	        // To calculate the pointer value, we start by subdividing the five bits into two
	        // groups. The first two bits indicate the size, and the next three bits are part
	        // of the value, so we end up with a control byte breaking down like this:
	        // 001SSVVV.
	        const pointerSize = (ctrlByte >> 3) & 3;
	        const pointer = this.baseOffset + pointerValueOffset[pointerSize];
	        let packed = 0;
	        // The size can be 0, 1, 2, or 3.
	        // If the size is 0, the pointer is built by appending the next byte to the last
	        // three bits to produce an 11-bit value.
	        if (pointerSize === 0) {
	            packed = ((ctrlByte & 7) << 8) | this.db[offset];
	            // If the size is 1, the pointer is built by appending the next two bytes to the
	            // last three bits to produce a 19-bit value + 2048.
	        }
	        else if (pointerSize === 1) {
	            packed = ((ctrlByte & 7) << 16) | this.db.readUInt16BE(offset);
	            // If the size is 2, the pointer is built by appending the next three bytes to the
	            // last three bits to produce a 27-bit value + 526336.
	        }
	        else if (pointerSize === 2) {
	            packed = ((ctrlByte & 7) << 24) | this.db.readUIntBE(offset, 3);
	            // At next point `size` is always 3.
	            // Finally, if the size is 3, the pointer's value is contained in the next four
	            // bytes as a 32-bit value. In this case, the last three bits of the control byte
	            // are ignored.
	        }
	        else {
	            packed = this.db.readUInt32BE(offset);
	        }
	        offset += pointerSize + 1;
	        return cursor(pointer + packed, offset);
	    }
	    decodeArray(size, offset) {
	        let tmp;
	        const array = new Array(size);
	        for (let i = 0; i < size; i++) {
	            tmp = this.decode(offset);
	            offset = tmp.offset;
	            array[i] = tmp.value;
	        }
	        return cursor(array, offset);
	    }
	    decodeBoolean(size) {
	        return size !== 0;
	    }
	    decodeDouble(offset) {
	        return this.db.readDoubleBE(offset);
	    }
	    decodeFloat(offset) {
	        return this.db.readFloatBE(offset);
	    }
	    decodeMap(size, offset) {
	        let tmp;
	        let key;
	        const map = {};
	        for (let i = 0; i < size; i++) {
	            tmp = this.decode(offset);
	            key = tmp.value;
	            tmp = this.decode(tmp.offset);
	            offset = tmp.offset;
	            map[key] = tmp.value;
	        }
	        return cursor(map, offset);
	    }
	    decodeInt32(offset, size) {
	        if (size === 0) {
	            return 0;
	        }
	        if (size < 4) {
	            return this.db.readUIntBE(offset, size);
	        }
	        return this.db.readInt32BE(offset);
	    }
	    decodeUint(offset, size) {
	        if (size === 0) {
	            return 0;
	        }
	        if (size <= 4) {
	            return this.db.readUIntBE(offset, size);
	        }
	        throw new Error(`Invalid size for unsigned integer: ${size}`);
	    }
	    decodeString(offset, size) {
	        const newOffset = offset + size;
	        return newOffset >= MAX_INT_32
	            ? this.db.subarray(offset, newOffset).toString('utf8')
	            : this.db.toString('utf8', offset, newOffset);
	    }
	    decodeBigUint(offset, size) {
	        if (size > 16) {
	            throw new Error(`Invalid size for big unsigned integer: ${size}`);
	        }
	        let integer = 0n;
	        for (let i = 0; i < size; i++) {
	            integer <<= 8n;
	            integer |= BigInt(this.db.readUInt8(offset + i));
	        }
	        return integer;
	    }
	}
	decoder.default = Decoder;
	return decoder;
}

var ip = {};

var hasRequiredIp;

function requireIp () {
	if (hasRequiredIp) return ip;
	hasRequiredIp = 1;
	var __importDefault = (ip && ip.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(ip, "__esModule", { value: true });
	const net_1 = __importDefault(require$$0$b);
	const parseIPv4 = (input) => {
	    const ip = input.split('.', 4);
	    const o0 = parseInt(ip[0]);
	    const o1 = parseInt(ip[1]);
	    const o2 = parseInt(ip[2]);
	    const o3 = parseInt(ip[3]);
	    return [o0, o1, o2, o3];
	};
	const hex = (v) => {
	    const h = parseInt(v, 10).toString(16);
	    return h.length === 2 ? h : '0' + h;
	};
	const parseIPv6 = (input) => {
	    const addr = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
	    let i;
	    let parsed;
	    let chunk;
	    // ipv4 e.g. `::ffff:64.17.254.216`
	    const ip = input.indexOf('.') > -1
	        ? input.replace(/(\d+)\.(\d+)\.(\d+)\.(\d+)/, (match, a, b, c, d) => {
	            return hex(a) + hex(b) + ':' + hex(c) + hex(d);
	        })
	        : input;
	    const [left, right] = ip.split('::', 2);
	    if (left) {
	        parsed = left.split(':');
	        for (i = 0; i < parsed.length; i++) {
	            chunk = parseInt(parsed[i], 16);
	            addr[i * 2] = chunk >> 8;
	            addr[i * 2 + 1] = chunk & 0xff;
	        }
	    }
	    if (right) {
	        parsed = right.split(':');
	        const offset = 16 - parsed.length * 2; // 2 bytes per chunk
	        for (i = 0; i < parsed.length; i++) {
	            chunk = parseInt(parsed[i], 16);
	            addr[offset + i * 2] = chunk >> 8;
	            addr[offset + (i * 2 + 1)] = chunk & 0xff;
	        }
	    }
	    return addr;
	};
	const parse = (ip) => {
	    return ip.indexOf(':') === -1 ? parseIPv4(ip) : parseIPv6(ip);
	};
	const bitAt = (rawAddress, idx) => {
	    // 8 bits per octet in the buffer (>>3 is slightly faster than Math.floor(idx/8))
	    const bufIdx = idx >> 3;
	    // Offset within the octet (basically equivalent to 8  - (idx % 8))
	    const bitIdx = 7 ^ (idx & 7);
	    // Shift the offset rightwards by bitIdx bits and & it to grab the bit
	    return (rawAddress[bufIdx] >>> bitIdx) & 1;
	};
	const validate = (ip) => {
	    const version = net_1.default.isIP(ip);
	    return version === 4 || version === 6;
	};
	ip.default = {
	    bitAt,
	    parse,
	    validate,
	};
	return ip;
}

var metadata = {};

var hasRequiredMetadata;

function requireMetadata () {
	if (hasRequiredMetadata) return metadata;
	hasRequiredMetadata = 1;
	(function (exports) {
		var __importDefault = (metadata && metadata.__importDefault) || function (mod) {
		    return (mod && mod.__esModule) ? mod : { "default": mod };
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.isLegacyFormat = exports.parseMetadata = void 0;
		const decoder_1 = __importDefault(requireDecoder());
		const utils_1 = __importDefault(requireUtils());
		const METADATA_START_MARKER = Buffer.from('ABCDEF4D61784D696E642E636F6D', 'hex');
		const parseMetadata = (db) => {
		    const offset = findStart(db);
		    const decoder = new decoder_1.default(db, offset);
		    const metadata = decoder.decode(offset).value;
		    if (!metadata) {
		        throw new Error((0, exports.isLegacyFormat)(db)
		            ? utils_1.default.legacyErrorMessage
		            : 'Cannot parse binary database');
		    }
		    utils_1.default.assert([24, 28, 32].indexOf(metadata.record_size) > -1, 'Unsupported record size');
		    return {
		        binaryFormatMajorVersion: metadata.binary_format_major_version,
		        binaryFormatMinorVersion: metadata.binary_format_minor_version,
		        buildEpoch: new Date(Number(metadata.build_epoch) * 1000),
		        databaseType: metadata.database_type,
		        description: metadata.description,
		        ipVersion: metadata.ip_version,
		        languages: metadata.languages,
		        nodeByteSize: metadata.record_size / 4,
		        nodeCount: metadata.node_count,
		        recordSize: metadata.record_size,
		        searchTreeSize: (metadata.node_count * metadata.record_size) / 4,
		        // Depth depends on the IP version, it's 32 for IPv4 and 128 for IPv6.
		        treeDepth: Math.pow(2, metadata.ip_version + 1),
		    };
		};
		exports.parseMetadata = parseMetadata;
		const findStart = (db) => {
		    let found = 0;
		    let fsize = db.length - 1;
		    const mlen = METADATA_START_MARKER.length - 1;
		    while (found <= mlen && fsize-- > 0) {
		        found += db[fsize] === METADATA_START_MARKER[mlen - found] ? 1 : -found;
		    }
		    return fsize + found;
		};
		const isLegacyFormat = (db) => {
		    const structureInfoMaxSize = 20;
		    for (let i = 0; i < structureInfoMaxSize; i++) {
		        const delim = db.slice(db.length - 3 - i, db.length - i);
		        // Look for [0xff, 0xff, 0xff] metadata delimiter
		        if (delim[0] === 255 && delim[1] === 255 && delim[2] === 255) {
		            return true;
		        }
		    }
		    return false;
		};
		exports.isLegacyFormat = isLegacyFormat; 
	} (metadata));
	return metadata;
}

var walker = {};

var hasRequiredWalker;

function requireWalker () {
	if (hasRequiredWalker) return walker;
	hasRequiredWalker = 1;
	Object.defineProperty(walker, "__esModule", { value: true });
	const readNodeRight24 = (db) => (offset) => db.readUIntBE(offset + 3, 3);
	const readNodeLeft24 = (db) => (offset) => db.readUIntBE(offset, 3);
	const readNodeLeft28 = (db) => (offset) => ((db[offset + 3] & 0xf0) << 20) | db.readUIntBE(offset, 3);
	const readNodeRight28 = (db) => (offset) => ((db[offset + 3] & 0x0f) << 24) | db.readUIntBE(offset + 4, 3);
	const readNodeLeft32 = (db) => (offset) => db.readUInt32BE(offset);
	const readNodeRight32 = (db) => (offset) => db.readUInt32BE(offset + 4);
	walker.default = (db, recordSize) => {
	    switch (recordSize) {
	        case 24:
	            return { left: readNodeLeft24(db), right: readNodeRight24(db) };
	        case 28:
	            return { left: readNodeLeft28(db), right: readNodeRight28(db) };
	        case 32:
	            return { left: readNodeLeft32(db), right: readNodeRight32(db) };
	    }
	    throw new Error('Unsupported record size');
	};
	return walker;
}

var response = {};

var hasRequiredResponse;

function requireResponse () {
	if (hasRequiredResponse) return response;
	hasRequiredResponse = 1;
	Object.defineProperty(response, "__esModule", { value: true });
	return response;
}

var hasRequiredLib;

function requireLib () {
	if (hasRequiredLib) return lib;
	hasRequiredLib = 1;
	(function (exports) {
		var __createBinding = (lib && lib.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (lib && lib.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		var __importDefault = (lib && lib.__importDefault) || function (mod) {
		    return (mod && mod.__esModule) ? mod : { "default": mod };
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.Reader = void 0;
		const decoder_1 = __importDefault(requireDecoder());
		const ip_1 = __importDefault(requireIp());
		const metadata_1 = requireMetadata();
		const walker_1 = __importDefault(requireWalker());
		const DATA_SECTION_SEPARATOR_SIZE = 16;
		class Reader {
		    constructor(db, opts = {}) {
		        this.opts = opts;
		        this.load(db);
		    }
		    load(db) {
		        if (!Buffer.isBuffer(db)) {
		            throw new Error(`mmdb-lib expects an instance of Buffer, got: ${typeof db}`);
		        }
		        this.db = db;
		        this.metadata = (0, metadata_1.parseMetadata)(this.db);
		        this.decoder = new decoder_1.default(this.db, this.metadata.searchTreeSize + DATA_SECTION_SEPARATOR_SIZE, this.opts.cache);
		        this.walker = (0, walker_1.default)(this.db, this.metadata.recordSize);
		        this.ipv4StartNodeNumber = this.ipv4Start();
		    }
		    get(ipAddress) {
		        const [data] = this.getWithPrefixLength(ipAddress);
		        return data;
		    }
		    getWithPrefixLength(ipAddress) {
		        const [pointer, prefixLength] = this.findAddressInTree(ipAddress);
		        const data = pointer ? this.resolveDataPointer(pointer) : null;
		        return [data, prefixLength];
		    }
		    findAddressInTree(ipAddress) {
		        const rawAddress = ip_1.default.parse(ipAddress);
		        const nodeCount = this.metadata.nodeCount;
		        const bitLength = rawAddress.length * 8;
		        // Binary search tree consists of certain (`nodeCount`) number of nodes. Tree
		        // depth depends on the ip version, it's 32 for IPv4 and 128 for IPv6. Each
		        // tree node has the same fixed length and usually 6-8 bytes. It consists
		        // of two records, left and right:
		        // |         node        |
		        // | 0x000000 | 0x000000 |
		        let bit;
		        let nodeNumber = 0;
		        let offset;
		        let depth = 0;
		        // When storing IPv4 addresses in an IPv6 tree, they are stored as-is, so they
		        // occupy the first 32-bits of the address space (from 0 to 2**32 - 1).
		        // Which means they're padded with zeros.
		        if (rawAddress.length === 4) {
		            nodeNumber = this.ipv4StartNodeNumber;
		        }
		        // Record value can point to one of three things:
		        // 1. Another node in the tree (most common case)
		        // 2. Data section address with relevant information (less common case)
		        // 3. Point to the value of `nodeCount`, which means IP address is unknown
		        for (; depth < bitLength && nodeNumber < nodeCount; depth++) {
		            bit = ip_1.default.bitAt(rawAddress, depth);
		            offset = nodeNumber * this.metadata.nodeByteSize;
		            nodeNumber = bit ? this.walker.right(offset) : this.walker.left(offset);
		        }
		        if (nodeNumber > nodeCount) {
		            return [nodeNumber, depth];
		        }
		        return [null, depth];
		    }
		    resolveDataPointer(pointer) {
		        // In order to determine where in the file this offset really points to, we also
		        // need to know where the data section starts. This can be calculated by
		        // determining the size of the search tree in bytes and then adding an additional
		        // 16 bytes for the data section separator.
		        // So the final formula to determine the offset in the file is:
		        //     $offset_in_file = ( $record_value - $node_count )
		        //                       + $search_tree_size_in_bytes
		        const resolved = pointer - this.metadata.nodeCount + this.metadata.searchTreeSize;
		        return this.decoder.decodeFast(resolved).value;
		    }
		    ipv4Start() {
		        if (this.metadata.ipVersion === 4) {
		            return 0;
		        }
		        const nodeCount = this.metadata.nodeCount;
		        let pointer = 0;
		        let i = 0;
		        for (; i < 96 && pointer < nodeCount; i++) {
		            const offset = pointer * this.metadata.nodeByteSize;
		            pointer = this.walker.left(offset);
		        }
		        return pointer;
		    }
		}
		exports.Reader = Reader;
		__exportStar(requireResponse(), exports); 
	} (lib));
	return lib;
}

var libExports = requireLib();

const EU = ["AT", "BE", "BG", "HR", "CY", "CZ", "DK", "EE", "FI", "FR", "DE", "GR", "HU", "IE", "IT", "LV", "LT", "LU", "MT", "NL", "PL", "PT", "RO", "SK", "SI", "ES", "SE"];
function buildResult(CountryDB, CityDB, ASNDB, TorDB, BadAsnDB, ip) {
  const countryResult = CountryDB.get(ip);
  const cityResult = CityDB.get(ip);
  const asnResult = ASNDB.get(ip);
  const result = {
    ip
  };
  if (countryResult?.country) {
    result.country = countryResult.country.names.en;
    result.country_iso = countryResult.country.iso_code;
    result.country_eu = EU.includes(countryResult.country.iso_code);
  }
  if (countryResult?.registered_country) {
    result.country_registered = countryResult.registered_country.names.en;
  }
  if (cityResult?.city) {
    result.city = cityResult.city.names.en;
  }
  if (cityResult?.location) {
    const location = cityResult.location;
    if (location.latitude) {
      result.latitude = location.latitude;
    }
    if (location.longitude) {
      result.longitude = location.longitude;
    }
    if (location.time_zone) {
      result.time_zone = location.time_zone;
    }
  }
  if (asnResult) {
    result.asn = "AS" + asnResult.autonomous_system_number;
    result.asn_org = asnResult.autonomous_system_organization;
  }
  result.tor = TorDB.has(ip);
  result.bad_asn = result.asn ? BadAsnDB.has(result.asn) : void 0;
  return result;
}
async function readIP(dbRoot, ips) {
  const files = await Promise.all([
    fs__namespace.readFile(path.join(dbRoot, "GeoLite2-Country.mmdb")),
    fs__namespace.readFile(path.join(dbRoot, "GeoLite2-City.mmdb")),
    fs__namespace.readFile(path.join(dbRoot, "GeoLite2-ASN.mmdb")),
    fs__namespace.readFile(path.join(dbRoot, "torlist.json"), { encoding: "utf8" }),
    fs__namespace.readFile(path.join(dbRoot, "asnlist.json"), { encoding: "utf8" })
  ]);
  const CountryDB = new libExports.Reader(files[0]);
  const CityDB = new libExports.Reader(files[1]);
  const ASNDB = new libExports.Reader(files[2]);
  const TorDB = new Set(JSON.parse(files[3]));
  const BadAsnDB = new Set(JSON.parse(files[4]));
  return ips.map((ip) => buildResult(CountryDB, CityDB, ASNDB, TorDB, BadAsnDB, ip));
}
class Reader {
  config;
  logger;
  queue;
  drainTimer;
  constructor(config, logger) {
    this.config = config;
    this.logger = logger;
    this.queue = [];
    this.drainTimer = null;
  }
  async queueWorker() {
    const queueIPs = [...new Set(this.queue.map(({ ip }) => ip))];
    try {
      const result = await readIP(this.config.dbRoot, queueIPs);
      this.queue = this.queue.filter(({ ip, resolve }) => {
        const index = queueIPs.indexOf(ip);
        if (index > -1) {
          resolve(result[index]);
          return false;
        }
        return true;
      });
    } catch (err) {
      this.queue = this.queue.filter(({ ip, reject }) => {
        if (queueIPs.indexOf(ip) > -1) {
          reject(err);
          return false;
        }
        return true;
      });
    }
    if (this.queue.length) {
      this.logger.debug(`Queue ${this.queue.length} not cleared, consuming again`);
      this.queueWorker();
    } else {
      this.drainTimer = null;
    }
  }
  read(ip) {
    return new Promise((resolve, reject) => {
      this.queue.push({
        ip,
        resolve,
        reject
      });
      if (!this.drainTimer) {
        this.drainTimer = setTimeout(() => this.queueWorker(), 50);
      }
    });
  }
}

const gitHomepage = (() => {
  const url = new URL(pkgJson.repository.url);
  return `https://${url.host}${url.pathname.replace(".git", "")}`;
})();
const ipQueryString = {
  querystring: {
    type: "object",
    properties: {
      ip: {
        type: "string",
        isIP: true
      }
    }
  }
};
const ipQueryPost = {
  body: {
    oneOf: [
      {
        type: "array",
        minItems: 1,
        maxItems: 1e3,
        items: {
          type: "string",
          isIP: true
        }
      },
      {
        type: "array",
        minItems: 1,
        maxItems: 1e3,
        items: {
          type: "object",
          properties: {
            ip: {
              type: "string",
              isIP: true
            }
          },
          required: ["ip"]
        }
      },
      {
        type: "object",
        properties: {
          ip: {
            type: "string",
            isIP: true
          }
        },
        required: ["ip"]
      }
    ]
  }
};
const CLI_USERAGENT = [
  "curl",
  "HTTPie",
  "httpie-go",
  "Wget",
  "fetch libfetch",
  "Go",
  "Go-http-client",
  "ddclient",
  "Mikrotik",
  "xh"
];
function parseUserAgent(userAgent) {
  const result = {};
  const productVer = userAgent.split(" ")[0];
  if (productVer.split("/")[0]) {
    result.product = productVer.split("/")[0];
  }
  if (productVer.split("/")[1]) {
    result.version = productVer.split("/")[1];
  }
  if (userAgent.split(" ")[1]) {
    let comment = userAgent.slice(productVer.length);
    if (comment.slice(0, 1) === " ") {
      comment = comment.slice(1);
    }
    result.comment = comment;
  }
  result.raw_value = userAgent;
  return result;
}
function resultToString(ipResult) {
  let lookupStr = ipResult.ip;
  if (ipResult.country) {
    lookupStr += ` ( Country: ${ipResult.country} )`;
  }
  if (ipResult.city) {
    lookupStr += ` ( City: ${ipResult.city} )`;
  }
  if (ipResult.time_zone) {
    lookupStr += ` ( Timezone: ${ipResult.time_zone} )`;
  }
  if (ipResult.asn && ipResult.asn_org) {
    lookupStr += ` ( ASN: ${ipResult.asn} - ${ipResult.asn_org} )`;
  }
  if (ipResult.tor) {
    lookupStr += " ( Tor Exit )";
  }
  if (ipResult.bad_asn) {
    lookupStr += " ( Bad ASN )";
  }
  if (ipResult.user_agent) {
    lookupStr += ` ( ${ipResult.user_agent.raw_value} )`;
  }
  return lookupStr;
}
function listenServer(server) {
  const { logger, config, app, reader } = server;
  let { statsQueue } = server;
  process$1.on("message", (msg) => {
    const queue = statsQueue.find((q) => q.uuid === msg.uuid);
    if (!queue) {
      return;
    }
    if (msg.error) {
      queue.reject(new Error(msg.error));
    } else {
      const msgJson = JSON.parse(JSON.stringify(msg));
      delete msgJson.uuid;
      queue.resolve(msgJson);
    }
    queue.resolved = true;
    statsQueue = statsQueue.filter((q) => !q.resolved);
  });
  function getStats() {
    return new Promise((resolve, reject) => {
      if (!process$1.send) {
        reject(new Error("Not cluster"));
        return;
      }
      const uuid = require$$3$2.webcrypto.randomUUID();
      process$1.send({
        uuid,
        type: "getStats"
      });
      statsQueue.push({
        uuid,
        resolve,
        reject,
        resolved: false
      });
    });
  }
  function addVisitor(ip) {
    if (process$1.send) {
      process$1.send({ type: "addVisitor", ip });
    }
  }
  async function ipJson(req, reply) {
    try {
      const requestIP = req.query?.ip || req.ip;
      const ipResult = await reader.read(requestIP);
      reply.header("Content-Type", "application/json; charset=utf-8").send(JSON.stringify(ipResult, null, 2));
    } catch (error) {
      reply.status(500).send({ error: error.stack || error.message });
    }
  }
  async function ipJsonPost(req, reply) {
    try {
      if (!Array.isArray(req.body)) {
        const requestIP = req.body.ip;
        const ipResult2 = await reader.read(requestIP);
        reply.header("Content-Type", "application/json; charset=utf-8").send(JSON.stringify(ipResult2, null, 2));
        return;
      }
      const ipBody = req.body.map((body) => {
        if (typeof body === "string") {
          return body;
        } else if (typeof body === "object" && body.ip) {
          return body.ip;
        }
        throw new Error("Not supported type");
      });
      const ipResult = await Promise.all(ipBody.map((ip) => reader.read(ip)));
      reply.send(ipResult);
    } catch (error) {
      reply.status(500).send({ error: error.stack || error.message });
    }
  }
  async function ipKey(req, reply, key) {
    try {
      const requestIP = req.query?.ip || req.ip;
      const ipResult = await reader.read(requestIP);
      reply.send(ipResult[key] ?? "unknown");
    } catch (error) {
      reply.status(500).send({ error: error.stack || error.message });
    }
  }
  async function ipString(req, reply) {
    try {
      const requestIP = req.query?.ip || req.ip;
      const ipResult = await reader.read(requestIP);
      reply.send(resultToString(ipResult));
    } catch (error) {
      reply.status(500).send({ error: error.stack || error.message });
    }
  }
  async function ipView(req, reply) {
    try {
      const queryStringIP = req.query?.ip;
      const requestIP = queryStringIP || req.ip;
      const [ipResult, stats] = await Promise.all([reader.read(requestIP), getStats()]);
      const userAgent = parseUserAgent(req.headers?.["user-agent"] || "").product;
      if (CLI_USERAGENT.includes(userAgent || "")) {
        reply.send(resultToString(ipResult));
        return;
      }
      if (req.headers?.accept?.includes("application/json")) {
        reply.send(ipResult);
        return;
      }
      reply.view("./index.html", {
        name: config.name,
        description: config.description,
        keywords: config.keywords,
        googleVerification: config.googleVerification || null,
        defaultName: pkgJson.name,
        version: pkgJson.version,
        homepage: gitHomepage,
        public: config.publicEndpoint,
        lookup: ipResult,
        text: resultToString(ipResult),
        json: JSON.stringify(ipResult, null, 2),
        stats: JSON.stringify(stats, null, 2),
        queryString: queryStringIP ? "?ip=" + queryStringIP : "",
        dbVersion: stats.dbVersion,
        noCloudflare: config.noCloudflare
      });
    } catch (error) {
      reply.status(500).send({ error: error.stack || error.message });
    }
  }
  async function statsJson(reply) {
    try {
      reply.send(await getStats());
    } catch (error) {
      reply.status(500).send({ error: error.stack || error.message });
    }
  }
  app.register(corsExports.fastifyCors, () => (req, callback) => {
    callback(null, {
      origin: req.headers.origin || "*",
      credentials: true,
      methods: ["GET, POST, OPTIONS"],
      headers: [
        "DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type"
      ]
    });
  });
  app.register(_staticExports.fastifyStatic, {
    root: viewsDir
  });
  app.register(viewExports.fastifyView, {
    engine: {
      ejs
    },
    root: viewsDir
  });
  app.get("/", { schema: ipQueryString }, (req, reply) => {
    addVisitor(req.ip);
    ipView(req, reply);
  });
  app.get("/json", { schema: ipQueryString }, (req, reply) => {
    addVisitor(req.ip);
    ipJson(req, reply);
  });
  app.post("/json", { schema: ipQueryPost }, (req, reply) => {
    addVisitor(req.ip);
    ipJsonPost(req, reply);
  });
  app.get("/text", { schema: ipQueryString }, (req, reply) => {
    addVisitor(req.ip);
    ipString(req, reply);
  });
  app.get("/ip", (req, reply) => {
    addVisitor(req.ip);
    reply.send(req.ip);
  });
  app.get("/country", { schema: ipQueryString }, (req, reply) => {
    addVisitor(req.ip);
    ipKey(req, reply, "country");
  });
  app.get("/country-iso", { schema: ipQueryString }, (req, reply) => {
    addVisitor(req.ip);
    ipKey(req, reply, "country_iso");
  });
  app.get("/city", { schema: ipQueryString }, (req, reply) => {
    addVisitor(req.ip);
    ipKey(req, reply, "city");
  });
  app.get("/asn", { schema: ipQueryString }, (req, reply) => {
    addVisitor(req.ip);
    ipKey(req, reply, "asn");
  });
  app.get("/asn-org", { schema: ipQueryString }, (req, reply) => {
    addVisitor(req.ip);
    ipKey(req, reply, "asn_org");
  });
  app.get("/tor", { schema: ipQueryString }, (req, reply) => {
    addVisitor(req.ip);
    ipKey(req, reply, "tor");
  });
  app.get("/bad_asn", { schema: ipQueryString }, (req, reply) => {
    addVisitor(req.ip);
    ipKey(req, reply, "bad_asn");
  });
  app.get("/stats", (req, reply) => {
    addVisitor(req.ip);
    statsJson(reply);
  });
  app.listen({ port: config.port, host: config.host }, (err, address) => {
    if (err) {
      logger.error("Router", "Error from router");
      console.log(err);
      process$1.exit(1);
    }
    logger.debug("Router", `Server listening on ${address}`);
  });
}
class WebServer {
  config;
  logger;
  logSystem;
  logComponent;
  app;
  reader;
  statsQueue;
  constructor(config, forkId = 0) {
    this.config = config;
    this.logSystem = "Website";
    this.logComponent = `Thread ${forkId}`;
    this.logger = new Logger(config, this.logSystem, this.logComponent);
    const app = fastifyExports.fastify({
      // Defining ajv keyword here
      ajv: {
        customOptions: {
          keywords: [
            {
              keyword: "isIP",
              validate: (schema, data) => {
                try {
                  return Boolean(require$$0$b.isIP(data));
                } catch {
                  return false;
                }
              },
              errors: true
            }
          ]
        }
      },
      trustProxy: config.reverseProxy ? 1 : false
    });
    const reader = new Reader(this.config, this.logger);
    this.app = app;
    this.reader = reader;
    this.statsQueue = [];
    listenServer(this);
  }
}

const proc = typeof process === 'object' && process
    ? process
    : {
        stdout: null,
        stderr: null,
    };
/**
 * Return true if the argument is a Minipass stream, Node stream, or something
 * else that Minipass can interact with.
 */
const isStream = (s) => !!s &&
    typeof s === 'object' &&
    (s instanceof Minipass ||
        s instanceof require$$0$7 ||
        isReadable(s) ||
        isWritable(s));
/**
 * Return true if the argument is a valid {@link Minipass.Readable}
 */
const isReadable = (s) => !!s &&
    typeof s === 'object' &&
    s instanceof require$$0$3.EventEmitter &&
    typeof s.pipe === 'function' &&
    // node core Writable streams have a pipe() method, but it throws
    s.pipe !== require$$0$7.Writable.prototype.pipe;
/**
 * Return true if the argument is a valid {@link Minipass.Writable}
 */
const isWritable = (s) => !!s &&
    typeof s === 'object' &&
    s instanceof require$$0$3.EventEmitter &&
    typeof s.write === 'function' &&
    typeof s.end === 'function';
const EOF$1 = Symbol('EOF');
const MAYBE_EMIT_END = Symbol('maybeEmitEnd');
const EMITTED_END = Symbol('emittedEnd');
const EMITTING_END = Symbol('emittingEnd');
const EMITTED_ERROR = Symbol('emittedError');
const CLOSED = Symbol('closed');
const READ$1 = Symbol('read');
const FLUSH = Symbol('flush');
const FLUSHCHUNK = Symbol('flushChunk');
const ENCODING = Symbol('encoding');
const DECODER = Symbol('decoder');
const FLOWING = Symbol('flowing');
const PAUSED = Symbol('paused');
const RESUME = Symbol('resume');
const BUFFER$1 = Symbol('buffer');
const PIPES = Symbol('pipes');
const BUFFERLENGTH = Symbol('bufferLength');
const BUFFERPUSH = Symbol('bufferPush');
const BUFFERSHIFT = Symbol('bufferShift');
const OBJECTMODE = Symbol('objectMode');
// internal event when stream is destroyed
const DESTROYED = Symbol('destroyed');
// internal event when stream has an error
const ERROR = Symbol('error');
const EMITDATA = Symbol('emitData');
const EMITEND = Symbol('emitEnd');
const EMITEND2 = Symbol('emitEnd2');
const ASYNC = Symbol('async');
const ABORT = Symbol('abort');
const ABORTED$1 = Symbol('aborted');
const SIGNAL = Symbol('signal');
const DATALISTENERS = Symbol('dataListeners');
const DISCARDED = Symbol('discarded');
const defer = (fn) => Promise.resolve().then(fn);
const nodefer = (fn) => fn();
const isEndish = (ev) => ev === 'end' || ev === 'finish' || ev === 'prefinish';
const isArrayBufferLike = (b) => b instanceof ArrayBuffer ||
    (!!b &&
        typeof b === 'object' &&
        b.constructor &&
        b.constructor.name === 'ArrayBuffer' &&
        b.byteLength >= 0);
const isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
/**
 * Internal class representing a pipe to a destination stream.
 *
 * @internal
 */
class Pipe {
    src;
    dest;
    opts;
    ondrain;
    constructor(src, dest, opts) {
        this.src = src;
        this.dest = dest;
        this.opts = opts;
        this.ondrain = () => src[RESUME]();
        this.dest.on('drain', this.ondrain);
    }
    unpipe() {
        this.dest.removeListener('drain', this.ondrain);
    }
    // only here for the prototype
    /* c8 ignore start */
    proxyErrors(_er) { }
    /* c8 ignore stop */
    end() {
        this.unpipe();
        if (this.opts.end)
            this.dest.end();
    }
}
/**
 * Internal class representing a pipe to a destination stream where
 * errors are proxied.
 *
 * @internal
 */
class PipeProxyErrors extends Pipe {
    unpipe() {
        this.src.removeListener('error', this.proxyErrors);
        super.unpipe();
    }
    constructor(src, dest, opts) {
        super(src, dest, opts);
        this.proxyErrors = er => dest.emit('error', er);
        src.on('error', this.proxyErrors);
    }
}
const isObjectModeOptions = (o) => !!o.objectMode;
const isEncodingOptions = (o) => !o.objectMode && !!o.encoding && o.encoding !== 'buffer';
/**
 * Main export, the Minipass class
 *
 * `RType` is the type of data emitted, defaults to Buffer
 *
 * `WType` is the type of data to be written, if RType is buffer or string,
 * then any {@link Minipass.ContiguousData} is allowed.
 *
 * `Events` is the set of event handler signatures that this object
 * will emit, see {@link Minipass.Events}
 */
class Minipass extends require$$0$3.EventEmitter {
    [FLOWING] = false;
    [PAUSED] = false;
    [PIPES] = [];
    [BUFFER$1] = [];
    [OBJECTMODE];
    [ENCODING];
    [ASYNC];
    [DECODER];
    [EOF$1] = false;
    [EMITTED_END] = false;
    [EMITTING_END] = false;
    [CLOSED] = false;
    [EMITTED_ERROR] = null;
    [BUFFERLENGTH] = 0;
    [DESTROYED] = false;
    [SIGNAL];
    [ABORTED$1] = false;
    [DATALISTENERS] = 0;
    [DISCARDED] = false;
    /**
     * true if the stream can be written
     */
    writable = true;
    /**
     * true if the stream can be read
     */
    readable = true;
    /**
     * If `RType` is Buffer, then options do not need to be provided.
     * Otherwise, an options object must be provided to specify either
     * {@link Minipass.SharedOptions.objectMode} or
     * {@link Minipass.SharedOptions.encoding}, as appropriate.
     */
    constructor(...args) {
        const options = (args[0] ||
            {});
        super();
        if (options.objectMode && typeof options.encoding === 'string') {
            throw new TypeError('Encoding and objectMode may not be used together');
        }
        if (isObjectModeOptions(options)) {
            this[OBJECTMODE] = true;
            this[ENCODING] = null;
        }
        else if (isEncodingOptions(options)) {
            this[ENCODING] = options.encoding;
            this[OBJECTMODE] = false;
        }
        else {
            this[OBJECTMODE] = false;
            this[ENCODING] = null;
        }
        this[ASYNC] = !!options.async;
        this[DECODER] = this[ENCODING]
            ? new require$$2$4.StringDecoder(this[ENCODING])
            : null;
        //@ts-ignore - private option for debugging and testing
        if (options && options.debugExposeBuffer === true) {
            Object.defineProperty(this, 'buffer', { get: () => this[BUFFER$1] });
        }
        //@ts-ignore - private option for debugging and testing
        if (options && options.debugExposePipes === true) {
            Object.defineProperty(this, 'pipes', { get: () => this[PIPES] });
        }
        const { signal } = options;
        if (signal) {
            this[SIGNAL] = signal;
            if (signal.aborted) {
                this[ABORT]();
            }
            else {
                signal.addEventListener('abort', () => this[ABORT]());
            }
        }
    }
    /**
     * The amount of data stored in the buffer waiting to be read.
     *
     * For Buffer strings, this will be the total byte length.
     * For string encoding streams, this will be the string character length,
     * according to JavaScript's `string.length` logic.
     * For objectMode streams, this is a count of the items waiting to be
     * emitted.
     */
    get bufferLength() {
        return this[BUFFERLENGTH];
    }
    /**
     * The `BufferEncoding` currently in use, or `null`
     */
    get encoding() {
        return this[ENCODING];
    }
    /**
     * @deprecated - This is a read only property
     */
    set encoding(_enc) {
        throw new Error('Encoding must be set at instantiation time');
    }
    /**
     * @deprecated - Encoding may only be set at instantiation time
     */
    setEncoding(_enc) {
        throw new Error('Encoding must be set at instantiation time');
    }
    /**
     * True if this is an objectMode stream
     */
    get objectMode() {
        return this[OBJECTMODE];
    }
    /**
     * @deprecated - This is a read-only property
     */
    set objectMode(_om) {
        throw new Error('objectMode must be set at instantiation time');
    }
    /**
     * true if this is an async stream
     */
    get ['async']() {
        return this[ASYNC];
    }
    /**
     * Set to true to make this stream async.
     *
     * Once set, it cannot be unset, as this would potentially cause incorrect
     * behavior.  Ie, a sync stream can be made async, but an async stream
     * cannot be safely made sync.
     */
    set ['async'](a) {
        this[ASYNC] = this[ASYNC] || !!a;
    }
    // drop everything and get out of the flow completely
    [ABORT]() {
        this[ABORTED$1] = true;
        this.emit('abort', this[SIGNAL]?.reason);
        this.destroy(this[SIGNAL]?.reason);
    }
    /**
     * True if the stream has been aborted.
     */
    get aborted() {
        return this[ABORTED$1];
    }
    /**
     * No-op setter. Stream aborted status is set via the AbortSignal provided
     * in the constructor options.
     */
    set aborted(_) { }
    write(chunk, encoding, cb) {
        if (this[ABORTED$1])
            return false;
        if (this[EOF$1])
            throw new Error('write after end');
        if (this[DESTROYED]) {
            this.emit('error', Object.assign(new Error('Cannot call write after a stream was destroyed'), { code: 'ERR_STREAM_DESTROYED' }));
            return true;
        }
        if (typeof encoding === 'function') {
            cb = encoding;
            encoding = 'utf8';
        }
        if (!encoding)
            encoding = 'utf8';
        const fn = this[ASYNC] ? defer : nodefer;
        // convert array buffers and typed array views into buffers
        // at some point in the future, we may want to do the opposite!
        // leave strings and buffers as-is
        // anything is only allowed if in object mode, so throw
        if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
            if (isArrayBufferView(chunk)) {
                //@ts-ignore - sinful unsafe type changing
                chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
            }
            else if (isArrayBufferLike(chunk)) {
                //@ts-ignore - sinful unsafe type changing
                chunk = Buffer.from(chunk);
            }
            else if (typeof chunk !== 'string') {
                throw new Error('Non-contiguous data written to non-objectMode stream');
            }
        }
        // handle object mode up front, since it's simpler
        // this yields better performance, fewer checks later.
        if (this[OBJECTMODE]) {
            // maybe impossible?
            /* c8 ignore start */
            if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
                this[FLUSH](true);
            /* c8 ignore stop */
            if (this[FLOWING])
                this.emit('data', chunk);
            else
                this[BUFFERPUSH](chunk);
            if (this[BUFFERLENGTH] !== 0)
                this.emit('readable');
            if (cb)
                fn(cb);
            return this[FLOWING];
        }
        // at this point the chunk is a buffer or string
        // don't buffer it up or send it to the decoder
        if (!chunk.length) {
            if (this[BUFFERLENGTH] !== 0)
                this.emit('readable');
            if (cb)
                fn(cb);
            return this[FLOWING];
        }
        // fast-path writing strings of same encoding to a stream with
        // an empty buffer, skipping the buffer/decoder dance
        if (typeof chunk === 'string' &&
            // unless it is a string already ready for us to use
            !(encoding === this[ENCODING] && !this[DECODER]?.lastNeed)) {
            //@ts-ignore - sinful unsafe type change
            chunk = Buffer.from(chunk, encoding);
        }
        if (Buffer.isBuffer(chunk) && this[ENCODING]) {
            //@ts-ignore - sinful unsafe type change
            chunk = this[DECODER].write(chunk);
        }
        // Note: flushing CAN potentially switch us into not-flowing mode
        if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
            this[FLUSH](true);
        if (this[FLOWING])
            this.emit('data', chunk);
        else
            this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0)
            this.emit('readable');
        if (cb)
            fn(cb);
        return this[FLOWING];
    }
    /**
     * Low-level explicit read method.
     *
     * In objectMode, the argument is ignored, and one item is returned if
     * available.
     *
     * `n` is the number of bytes (or in the case of encoding streams,
     * characters) to consume. If `n` is not provided, then the entire buffer
     * is returned, or `null` is returned if no data is available.
     *
     * If `n` is greater that the amount of data in the internal buffer,
     * then `null` is returned.
     */
    read(n) {
        if (this[DESTROYED])
            return null;
        this[DISCARDED] = false;
        if (this[BUFFERLENGTH] === 0 ||
            n === 0 ||
            (n && n > this[BUFFERLENGTH])) {
            this[MAYBE_EMIT_END]();
            return null;
        }
        if (this[OBJECTMODE])
            n = null;
        if (this[BUFFER$1].length > 1 && !this[OBJECTMODE]) {
            // not object mode, so if we have an encoding, then RType is string
            // otherwise, must be Buffer
            this[BUFFER$1] = [
                (this[ENCODING]
                    ? this[BUFFER$1].join('')
                    : Buffer.concat(this[BUFFER$1], this[BUFFERLENGTH])),
            ];
        }
        const ret = this[READ$1](n || null, this[BUFFER$1][0]);
        this[MAYBE_EMIT_END]();
        return ret;
    }
    [READ$1](n, chunk) {
        if (this[OBJECTMODE])
            this[BUFFERSHIFT]();
        else {
            const c = chunk;
            if (n === c.length || n === null)
                this[BUFFERSHIFT]();
            else if (typeof c === 'string') {
                this[BUFFER$1][0] = c.slice(n);
                chunk = c.slice(0, n);
                this[BUFFERLENGTH] -= n;
            }
            else {
                this[BUFFER$1][0] = c.subarray(n);
                chunk = c.subarray(0, n);
                this[BUFFERLENGTH] -= n;
            }
        }
        this.emit('data', chunk);
        if (!this[BUFFER$1].length && !this[EOF$1])
            this.emit('drain');
        return chunk;
    }
    end(chunk, encoding, cb) {
        if (typeof chunk === 'function') {
            cb = chunk;
            chunk = undefined;
        }
        if (typeof encoding === 'function') {
            cb = encoding;
            encoding = 'utf8';
        }
        if (chunk !== undefined)
            this.write(chunk, encoding);
        if (cb)
            this.once('end', cb);
        this[EOF$1] = true;
        this.writable = false;
        // if we haven't written anything, then go ahead and emit,
        // even if we're not reading.
        // we'll re-emit if a new 'end' listener is added anyway.
        // This makes MP more suitable to write-only use cases.
        if (this[FLOWING] || !this[PAUSED])
            this[MAYBE_EMIT_END]();
        return this;
    }
    // don't let the internal resume be overwritten
    [RESUME]() {
        if (this[DESTROYED])
            return;
        if (!this[DATALISTENERS] && !this[PIPES].length) {
            this[DISCARDED] = true;
        }
        this[PAUSED] = false;
        this[FLOWING] = true;
        this.emit('resume');
        if (this[BUFFER$1].length)
            this[FLUSH]();
        else if (this[EOF$1])
            this[MAYBE_EMIT_END]();
        else
            this.emit('drain');
    }
    /**
     * Resume the stream if it is currently in a paused state
     *
     * If called when there are no pipe destinations or `data` event listeners,
     * this will place the stream in a "discarded" state, where all data will
     * be thrown away. The discarded state is removed if a pipe destination or
     * data handler is added, if pause() is called, or if any synchronous or
     * asynchronous iteration is started.
     */
    resume() {
        return this[RESUME]();
    }
    /**
     * Pause the stream
     */
    pause() {
        this[FLOWING] = false;
        this[PAUSED] = true;
        this[DISCARDED] = false;
    }
    /**
     * true if the stream has been forcibly destroyed
     */
    get destroyed() {
        return this[DESTROYED];
    }
    /**
     * true if the stream is currently in a flowing state, meaning that
     * any writes will be immediately emitted.
     */
    get flowing() {
        return this[FLOWING];
    }
    /**
     * true if the stream is currently in a paused state
     */
    get paused() {
        return this[PAUSED];
    }
    [BUFFERPUSH](chunk) {
        if (this[OBJECTMODE])
            this[BUFFERLENGTH] += 1;
        else
            this[BUFFERLENGTH] += chunk.length;
        this[BUFFER$1].push(chunk);
    }
    [BUFFERSHIFT]() {
        if (this[OBJECTMODE])
            this[BUFFERLENGTH] -= 1;
        else
            this[BUFFERLENGTH] -= this[BUFFER$1][0].length;
        return this[BUFFER$1].shift();
    }
    [FLUSH](noDrain = false) {
        do { } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) &&
            this[BUFFER$1].length);
        if (!noDrain && !this[BUFFER$1].length && !this[EOF$1])
            this.emit('drain');
    }
    [FLUSHCHUNK](chunk) {
        this.emit('data', chunk);
        return this[FLOWING];
    }
    /**
     * Pipe all data emitted by this stream into the destination provided.
     *
     * Triggers the flow of data.
     */
    pipe(dest, opts) {
        if (this[DESTROYED])
            return dest;
        this[DISCARDED] = false;
        const ended = this[EMITTED_END];
        opts = opts || {};
        if (dest === proc.stdout || dest === proc.stderr)
            opts.end = false;
        else
            opts.end = opts.end !== false;
        opts.proxyErrors = !!opts.proxyErrors;
        // piping an ended stream ends immediately
        if (ended) {
            if (opts.end)
                dest.end();
        }
        else {
            // "as" here just ignores the WType, which pipes don't care about,
            // since they're only consuming from us, and writing to the dest
            this[PIPES].push(!opts.proxyErrors
                ? new Pipe(this, dest, opts)
                : new PipeProxyErrors(this, dest, opts));
            if (this[ASYNC])
                defer(() => this[RESUME]());
            else
                this[RESUME]();
        }
        return dest;
    }
    /**
     * Fully unhook a piped destination stream.
     *
     * If the destination stream was the only consumer of this stream (ie,
     * there are no other piped destinations or `'data'` event listeners)
     * then the flow of data will stop until there is another consumer or
     * {@link Minipass#resume} is explicitly called.
     */
    unpipe(dest) {
        const p = this[PIPES].find(p => p.dest === dest);
        if (p) {
            if (this[PIPES].length === 1) {
                if (this[FLOWING] && this[DATALISTENERS] === 0) {
                    this[FLOWING] = false;
                }
                this[PIPES] = [];
            }
            else
                this[PIPES].splice(this[PIPES].indexOf(p), 1);
            p.unpipe();
        }
    }
    /**
     * Alias for {@link Minipass#on}
     */
    addListener(ev, handler) {
        return this.on(ev, handler);
    }
    /**
     * Mostly identical to `EventEmitter.on`, with the following
     * behavior differences to prevent data loss and unnecessary hangs:
     *
     * - Adding a 'data' event handler will trigger the flow of data
     *
     * - Adding a 'readable' event handler when there is data waiting to be read
     *   will cause 'readable' to be emitted immediately.
     *
     * - Adding an 'endish' event handler ('end', 'finish', etc.) which has
     *   already passed will cause the event to be emitted immediately and all
     *   handlers removed.
     *
     * - Adding an 'error' event handler after an error has been emitted will
     *   cause the event to be re-emitted immediately with the error previously
     *   raised.
     */
    on(ev, handler) {
        const ret = super.on(ev, handler);
        if (ev === 'data') {
            this[DISCARDED] = false;
            this[DATALISTENERS]++;
            if (!this[PIPES].length && !this[FLOWING]) {
                this[RESUME]();
            }
        }
        else if (ev === 'readable' && this[BUFFERLENGTH] !== 0) {
            super.emit('readable');
        }
        else if (isEndish(ev) && this[EMITTED_END]) {
            super.emit(ev);
            this.removeAllListeners(ev);
        }
        else if (ev === 'error' && this[EMITTED_ERROR]) {
            const h = handler;
            if (this[ASYNC])
                defer(() => h.call(this, this[EMITTED_ERROR]));
            else
                h.call(this, this[EMITTED_ERROR]);
        }
        return ret;
    }
    /**
     * Alias for {@link Minipass#off}
     */
    removeListener(ev, handler) {
        return this.off(ev, handler);
    }
    /**
     * Mostly identical to `EventEmitter.off`
     *
     * If a 'data' event handler is removed, and it was the last consumer
     * (ie, there are no pipe destinations or other 'data' event listeners),
     * then the flow of data will stop until there is another consumer or
     * {@link Minipass#resume} is explicitly called.
     */
    off(ev, handler) {
        const ret = super.off(ev, handler);
        // if we previously had listeners, and now we don't, and we don't
        // have any pipes, then stop the flow, unless it's been explicitly
        // put in a discarded flowing state via stream.resume().
        if (ev === 'data') {
            this[DATALISTENERS] = this.listeners('data').length;
            if (this[DATALISTENERS] === 0 &&
                !this[DISCARDED] &&
                !this[PIPES].length) {
                this[FLOWING] = false;
            }
        }
        return ret;
    }
    /**
     * Mostly identical to `EventEmitter.removeAllListeners`
     *
     * If all 'data' event handlers are removed, and they were the last consumer
     * (ie, there are no pipe destinations), then the flow of data will stop
     * until there is another consumer or {@link Minipass#resume} is explicitly
     * called.
     */
    removeAllListeners(ev) {
        const ret = super.removeAllListeners(ev);
        if (ev === 'data' || ev === undefined) {
            this[DATALISTENERS] = 0;
            if (!this[DISCARDED] && !this[PIPES].length) {
                this[FLOWING] = false;
            }
        }
        return ret;
    }
    /**
     * true if the 'end' event has been emitted
     */
    get emittedEnd() {
        return this[EMITTED_END];
    }
    [MAYBE_EMIT_END]() {
        if (!this[EMITTING_END] &&
            !this[EMITTED_END] &&
            !this[DESTROYED] &&
            this[BUFFER$1].length === 0 &&
            this[EOF$1]) {
            this[EMITTING_END] = true;
            this.emit('end');
            this.emit('prefinish');
            this.emit('finish');
            if (this[CLOSED])
                this.emit('close');
            this[EMITTING_END] = false;
        }
    }
    /**
     * Mostly identical to `EventEmitter.emit`, with the following
     * behavior differences to prevent data loss and unnecessary hangs:
     *
     * If the stream has been destroyed, and the event is something other
     * than 'close' or 'error', then `false` is returned and no handlers
     * are called.
     *
     * If the event is 'end', and has already been emitted, then the event
     * is ignored. If the stream is in a paused or non-flowing state, then
     * the event will be deferred until data flow resumes. If the stream is
     * async, then handlers will be called on the next tick rather than
     * immediately.
     *
     * If the event is 'close', and 'end' has not yet been emitted, then
     * the event will be deferred until after 'end' is emitted.
     *
     * If the event is 'error', and an AbortSignal was provided for the stream,
     * and there are no listeners, then the event is ignored, matching the
     * behavior of node core streams in the presense of an AbortSignal.
     *
     * If the event is 'finish' or 'prefinish', then all listeners will be
     * removed after emitting the event, to prevent double-firing.
     */
    emit(ev, ...args) {
        const data = args[0];
        // error and close are only events allowed after calling destroy()
        if (ev !== 'error' &&
            ev !== 'close' &&
            ev !== DESTROYED &&
            this[DESTROYED]) {
            return false;
        }
        else if (ev === 'data') {
            return !this[OBJECTMODE] && !data
                ? false
                : this[ASYNC]
                    ? (defer(() => this[EMITDATA](data)), true)
                    : this[EMITDATA](data);
        }
        else if (ev === 'end') {
            return this[EMITEND]();
        }
        else if (ev === 'close') {
            this[CLOSED] = true;
            // don't emit close before 'end' and 'finish'
            if (!this[EMITTED_END] && !this[DESTROYED])
                return false;
            const ret = super.emit('close');
            this.removeAllListeners('close');
            return ret;
        }
        else if (ev === 'error') {
            this[EMITTED_ERROR] = data;
            super.emit(ERROR, data);
            const ret = !this[SIGNAL] || this.listeners('error').length
                ? super.emit('error', data)
                : false;
            this[MAYBE_EMIT_END]();
            return ret;
        }
        else if (ev === 'resume') {
            const ret = super.emit('resume');
            this[MAYBE_EMIT_END]();
            return ret;
        }
        else if (ev === 'finish' || ev === 'prefinish') {
            const ret = super.emit(ev);
            this.removeAllListeners(ev);
            return ret;
        }
        // Some other unknown event
        const ret = super.emit(ev, ...args);
        this[MAYBE_EMIT_END]();
        return ret;
    }
    [EMITDATA](data) {
        for (const p of this[PIPES]) {
            if (p.dest.write(data) === false)
                this.pause();
        }
        const ret = this[DISCARDED] ? false : super.emit('data', data);
        this[MAYBE_EMIT_END]();
        return ret;
    }
    [EMITEND]() {
        if (this[EMITTED_END])
            return false;
        this[EMITTED_END] = true;
        this.readable = false;
        return this[ASYNC]
            ? (defer(() => this[EMITEND2]()), true)
            : this[EMITEND2]();
    }
    [EMITEND2]() {
        if (this[DECODER]) {
            const data = this[DECODER].end();
            if (data) {
                for (const p of this[PIPES]) {
                    p.dest.write(data);
                }
                if (!this[DISCARDED])
                    super.emit('data', data);
            }
        }
        for (const p of this[PIPES]) {
            p.end();
        }
        const ret = super.emit('end');
        this.removeAllListeners('end');
        return ret;
    }
    /**
     * Return a Promise that resolves to an array of all emitted data once
     * the stream ends.
     */
    async collect() {
        const buf = Object.assign([], {
            dataLength: 0,
        });
        if (!this[OBJECTMODE])
            buf.dataLength = 0;
        // set the promise first, in case an error is raised
        // by triggering the flow here.
        const p = this.promise();
        this.on('data', c => {
            buf.push(c);
            if (!this[OBJECTMODE])
                buf.dataLength += c.length;
        });
        await p;
        return buf;
    }
    /**
     * Return a Promise that resolves to the concatenation of all emitted data
     * once the stream ends.
     *
     * Not allowed on objectMode streams.
     */
    async concat() {
        if (this[OBJECTMODE]) {
            throw new Error('cannot concat in objectMode');
        }
        const buf = await this.collect();
        return (this[ENCODING]
            ? buf.join('')
            : Buffer.concat(buf, buf.dataLength));
    }
    /**
     * Return a void Promise that resolves once the stream ends.
     */
    async promise() {
        return new Promise((resolve, reject) => {
            this.on(DESTROYED, () => reject(new Error('stream destroyed')));
            this.on('error', er => reject(er));
            this.on('end', () => resolve());
        });
    }
    /**
     * Asynchronous `for await of` iteration.
     *
     * This will continue emitting all chunks until the stream terminates.
     */
    [Symbol.asyncIterator]() {
        // set this up front, in case the consumer doesn't call next()
        // right away.
        this[DISCARDED] = false;
        let stopped = false;
        const stop = async () => {
            this.pause();
            stopped = true;
            return { value: undefined, done: true };
        };
        const next = () => {
            if (stopped)
                return stop();
            const res = this.read();
            if (res !== null)
                return Promise.resolve({ done: false, value: res });
            if (this[EOF$1])
                return stop();
            let resolve;
            let reject;
            const onerr = (er) => {
                this.off('data', ondata);
                this.off('end', onend);
                this.off(DESTROYED, ondestroy);
                stop();
                reject(er);
            };
            const ondata = (value) => {
                this.off('error', onerr);
                this.off('end', onend);
                this.off(DESTROYED, ondestroy);
                this.pause();
                resolve({ value, done: !!this[EOF$1] });
            };
            const onend = () => {
                this.off('error', onerr);
                this.off('data', ondata);
                this.off(DESTROYED, ondestroy);
                stop();
                resolve({ done: true, value: undefined });
            };
            const ondestroy = () => onerr(new Error('stream destroyed'));
            return new Promise((res, rej) => {
                reject = rej;
                resolve = res;
                this.once(DESTROYED, ondestroy);
                this.once('error', onerr);
                this.once('end', onend);
                this.once('data', ondata);
            });
        };
        return {
            next,
            throw: stop,
            return: stop,
            [Symbol.asyncIterator]() {
                return this;
            },
        };
    }
    /**
     * Synchronous `for of` iteration.
     *
     * The iteration will terminate when the internal buffer runs out, even
     * if the stream has not yet terminated.
     */
    [Symbol.iterator]() {
        // set this up front, in case the consumer doesn't call next()
        // right away.
        this[DISCARDED] = false;
        let stopped = false;
        const stop = () => {
            this.pause();
            this.off(ERROR, stop);
            this.off(DESTROYED, stop);
            this.off('end', stop);
            stopped = true;
            return { done: true, value: undefined };
        };
        const next = () => {
            if (stopped)
                return stop();
            const value = this.read();
            return value === null ? stop() : { done: false, value };
        };
        this.once('end', stop);
        this.once(ERROR, stop);
        this.once(DESTROYED, stop);
        return {
            next,
            throw: stop,
            return: stop,
            [Symbol.iterator]() {
                return this;
            },
        };
    }
    /**
     * Destroy a stream, preventing it from being used for any further purpose.
     *
     * If the stream has a `close()` method, then it will be called on
     * destruction.
     *
     * After destruction, any attempt to write data, read data, or emit most
     * events will be ignored.
     *
     * If an error argument is provided, then it will be emitted in an
     * 'error' event.
     */
    destroy(er) {
        if (this[DESTROYED]) {
            if (er)
                this.emit('error', er);
            else
                this.emit(DESTROYED);
            return this;
        }
        this[DESTROYED] = true;
        this[DISCARDED] = true;
        // throw away all buffered data, it's never coming out
        this[BUFFER$1].length = 0;
        this[BUFFERLENGTH] = 0;
        const wc = this;
        if (typeof wc.close === 'function' && !this[CLOSED])
            wc.close();
        if (er)
            this.emit('error', er);
        // if no error to emit, still reject pending promises
        else
            this.emit(DESTROYED);
        return this;
    }
    /**
     * Alias for {@link isStream}
     *
     * Former export location, maintained for backwards compatibility.
     *
     * @deprecated
     */
    static get isStream() {
        return isStream;
    }
}

const writev = fs.writev;
const _autoClose = Symbol('_autoClose');
const _close = Symbol('_close');
const _ended = Symbol('_ended');
const _fd = Symbol('_fd');
const _finished = Symbol('_finished');
const _flags = Symbol('_flags');
const _flush = Symbol('_flush');
const _handleChunk = Symbol('_handleChunk');
const _makeBuf = Symbol('_makeBuf');
const _mode = Symbol('_mode');
const _needDrain = Symbol('_needDrain');
const _onerror = Symbol('_onerror');
const _onopen = Symbol('_onopen');
const _onread = Symbol('_onread');
const _onwrite = Symbol('_onwrite');
const _open = Symbol('_open');
const _path = Symbol('_path');
const _pos = Symbol('_pos');
const _queue = Symbol('_queue');
const _read = Symbol('_read');
const _readSize = Symbol('_readSize');
const _reading = Symbol('_reading');
const _remain = Symbol('_remain');
const _size = Symbol('_size');
const _write = Symbol('_write');
const _writing = Symbol('_writing');
const _defaultFlag = Symbol('_defaultFlag');
const _errored = Symbol('_errored');
class ReadStream extends Minipass {
    [_errored] = false;
    [_fd];
    [_path];
    [_readSize];
    [_reading] = false;
    [_size];
    [_remain];
    [_autoClose];
    constructor(path, opt) {
        opt = opt || {};
        super(opt);
        this.readable = true;
        this.writable = false;
        if (typeof path !== 'string') {
            throw new TypeError('path must be a string');
        }
        this[_errored] = false;
        this[_fd] = typeof opt.fd === 'number' ? opt.fd : undefined;
        this[_path] = path;
        this[_readSize] = opt.readSize || 16 * 1024 * 1024;
        this[_reading] = false;
        this[_size] = typeof opt.size === 'number' ? opt.size : Infinity;
        this[_remain] = this[_size];
        this[_autoClose] =
            typeof opt.autoClose === 'boolean' ? opt.autoClose : true;
        if (typeof this[_fd] === 'number') {
            this[_read]();
        }
        else {
            this[_open]();
        }
    }
    get fd() {
        return this[_fd];
    }
    get path() {
        return this[_path];
    }
    //@ts-ignore
    write() {
        throw new TypeError('this is a readable stream');
    }
    //@ts-ignore
    end() {
        throw new TypeError('this is a readable stream');
    }
    [_open]() {
        fs.open(this[_path], 'r', (er, fd) => this[_onopen](er, fd));
    }
    [_onopen](er, fd) {
        if (er) {
            this[_onerror](er);
        }
        else {
            this[_fd] = fd;
            this.emit('open', fd);
            this[_read]();
        }
    }
    [_makeBuf]() {
        return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]));
    }
    [_read]() {
        if (!this[_reading]) {
            this[_reading] = true;
            const buf = this[_makeBuf]();
            /* c8 ignore start */
            if (buf.length === 0) {
                return process.nextTick(() => this[_onread](null, 0, buf));
            }
            /* c8 ignore stop */
            fs.read(this[_fd], buf, 0, buf.length, null, (er, br, b) => this[_onread](er, br, b));
        }
    }
    [_onread](er, br, buf) {
        this[_reading] = false;
        if (er) {
            this[_onerror](er);
        }
        else if (this[_handleChunk](br, buf)) {
            this[_read]();
        }
    }
    [_close]() {
        if (this[_autoClose] && typeof this[_fd] === 'number') {
            const fd = this[_fd];
            this[_fd] = undefined;
            fs.close(fd, er => er ? this.emit('error', er) : this.emit('close'));
        }
    }
    [_onerror](er) {
        this[_reading] = true;
        this[_close]();
        this.emit('error', er);
    }
    [_handleChunk](br, buf) {
        let ret = false;
        // no effect if infinite
        this[_remain] -= br;
        if (br > 0) {
            ret = super.write(br < buf.length ? buf.subarray(0, br) : buf);
        }
        if (br === 0 || this[_remain] <= 0) {
            ret = false;
            this[_close]();
            super.end();
        }
        return ret;
    }
    emit(ev, ...args) {
        switch (ev) {
            case 'prefinish':
            case 'finish':
                return false;
            case 'drain':
                if (typeof this[_fd] === 'number') {
                    this[_read]();
                }
                return false;
            case 'error':
                if (this[_errored]) {
                    return false;
                }
                this[_errored] = true;
                return super.emit(ev, ...args);
            default:
                return super.emit(ev, ...args);
        }
    }
}
class ReadStreamSync extends ReadStream {
    [_open]() {
        let threw = true;
        try {
            this[_onopen](null, fs.openSync(this[_path], 'r'));
            threw = false;
        }
        finally {
            if (threw) {
                this[_close]();
            }
        }
    }
    [_read]() {
        let threw = true;
        try {
            if (!this[_reading]) {
                this[_reading] = true;
                do {
                    const buf = this[_makeBuf]();
                    /* c8 ignore start */
                    const br = buf.length === 0
                        ? 0
                        : fs.readSync(this[_fd], buf, 0, buf.length, null);
                    /* c8 ignore stop */
                    if (!this[_handleChunk](br, buf)) {
                        break;
                    }
                } while (true);
                this[_reading] = false;
            }
            threw = false;
        }
        finally {
            if (threw) {
                this[_close]();
            }
        }
    }
    [_close]() {
        if (this[_autoClose] && typeof this[_fd] === 'number') {
            const fd = this[_fd];
            this[_fd] = undefined;
            fs.closeSync(fd);
            this.emit('close');
        }
    }
}
class WriteStream extends require$$1$2 {
    readable = false;
    writable = true;
    [_errored] = false;
    [_writing] = false;
    [_ended] = false;
    [_queue] = [];
    [_needDrain] = false;
    [_path];
    [_mode];
    [_autoClose];
    [_fd];
    [_defaultFlag];
    [_flags];
    [_finished] = false;
    [_pos];
    constructor(path, opt) {
        opt = opt || {};
        super(opt);
        this[_path] = path;
        this[_fd] = typeof opt.fd === 'number' ? opt.fd : undefined;
        this[_mode] = opt.mode === undefined ? 0o666 : opt.mode;
        this[_pos] = typeof opt.start === 'number' ? opt.start : undefined;
        this[_autoClose] =
            typeof opt.autoClose === 'boolean' ? opt.autoClose : true;
        // truncating makes no sense when writing into the middle
        const defaultFlag = this[_pos] !== undefined ? 'r+' : 'w';
        this[_defaultFlag] = opt.flags === undefined;
        this[_flags] = opt.flags === undefined ? defaultFlag : opt.flags;
        if (this[_fd] === undefined) {
            this[_open]();
        }
    }
    emit(ev, ...args) {
        if (ev === 'error') {
            if (this[_errored]) {
                return false;
            }
            this[_errored] = true;
        }
        return super.emit(ev, ...args);
    }
    get fd() {
        return this[_fd];
    }
    get path() {
        return this[_path];
    }
    [_onerror](er) {
        this[_close]();
        this[_writing] = true;
        this.emit('error', er);
    }
    [_open]() {
        fs.open(this[_path], this[_flags], this[_mode], (er, fd) => this[_onopen](er, fd));
    }
    [_onopen](er, fd) {
        if (this[_defaultFlag] &&
            this[_flags] === 'r+' &&
            er &&
            er.code === 'ENOENT') {
            this[_flags] = 'w';
            this[_open]();
        }
        else if (er) {
            this[_onerror](er);
        }
        else {
            this[_fd] = fd;
            this.emit('open', fd);
            if (!this[_writing]) {
                this[_flush]();
            }
        }
    }
    end(buf, enc) {
        if (buf) {
            //@ts-ignore
            this.write(buf, enc);
        }
        this[_ended] = true;
        // synthetic after-write logic, where drain/finish live
        if (!this[_writing] &&
            !this[_queue].length &&
            typeof this[_fd] === 'number') {
            this[_onwrite](null, 0);
        }
        return this;
    }
    write(buf, enc) {
        if (typeof buf === 'string') {
            buf = Buffer.from(buf, enc);
        }
        if (this[_ended]) {
            this.emit('error', new Error('write() after end()'));
            return false;
        }
        if (this[_fd] === undefined || this[_writing] || this[_queue].length) {
            this[_queue].push(buf);
            this[_needDrain] = true;
            return false;
        }
        this[_writing] = true;
        this[_write](buf);
        return true;
    }
    [_write](buf) {
        fs.write(this[_fd], buf, 0, buf.length, this[_pos], (er, bw) => this[_onwrite](er, bw));
    }
    [_onwrite](er, bw) {
        if (er) {
            this[_onerror](er);
        }
        else {
            if (this[_pos] !== undefined && typeof bw === 'number') {
                this[_pos] += bw;
            }
            if (this[_queue].length) {
                this[_flush]();
            }
            else {
                this[_writing] = false;
                if (this[_ended] && !this[_finished]) {
                    this[_finished] = true;
                    this[_close]();
                    this.emit('finish');
                }
                else if (this[_needDrain]) {
                    this[_needDrain] = false;
                    this.emit('drain');
                }
            }
        }
    }
    [_flush]() {
        if (this[_queue].length === 0) {
            if (this[_ended]) {
                this[_onwrite](null, 0);
            }
        }
        else if (this[_queue].length === 1) {
            this[_write](this[_queue].pop());
        }
        else {
            const iovec = this[_queue];
            this[_queue] = [];
            writev(this[_fd], iovec, this[_pos], (er, bw) => this[_onwrite](er, bw));
        }
    }
    [_close]() {
        if (this[_autoClose] && typeof this[_fd] === 'number') {
            const fd = this[_fd];
            this[_fd] = undefined;
            fs.close(fd, er => er ? this.emit('error', er) : this.emit('close'));
        }
    }
}
class WriteStreamSync extends WriteStream {
    [_open]() {
        let fd;
        // only wrap in a try{} block if we know we'll retry, to avoid
        // the rethrow obscuring the error's source frame in most cases.
        if (this[_defaultFlag] && this[_flags] === 'r+') {
            try {
                fd = fs.openSync(this[_path], this[_flags], this[_mode]);
            }
            catch (er) {
                if (er?.code === 'ENOENT') {
                    this[_flags] = 'w';
                    return this[_open]();
                }
                else {
                    throw er;
                }
            }
        }
        else {
            fd = fs.openSync(this[_path], this[_flags], this[_mode]);
        }
        this[_onopen](null, fd);
    }
    [_close]() {
        if (this[_autoClose] && typeof this[_fd] === 'number') {
            const fd = this[_fd];
            this[_fd] = undefined;
            fs.closeSync(fd);
            this.emit('close');
        }
    }
    [_write](buf) {
        // throw the original, but try to close if it fails
        let threw = true;
        try {
            this[_onwrite](null, fs.writeSync(this[_fd], buf, 0, buf.length, this[_pos]));
            threw = false;
        }
        finally {
            if (threw) {
                try {
                    this[_close]();
                }
                catch {
                    // ok error
                }
            }
        }
    }
}

// turn tar(1) style args like `C` into the more verbose things like `cwd`
const argmap = new Map([
    ['C', 'cwd'],
    ['f', 'file'],
    ['z', 'gzip'],
    ['P', 'preservePaths'],
    ['U', 'unlink'],
    ['strip-components', 'strip'],
    ['stripComponents', 'strip'],
    ['keep-newer', 'newer'],
    ['keepNewer', 'newer'],
    ['keep-newer-files', 'newer'],
    ['keepNewerFiles', 'newer'],
    ['k', 'keep'],
    ['keep-existing', 'keep'],
    ['keepExisting', 'keep'],
    ['m', 'noMtime'],
    ['no-mtime', 'noMtime'],
    ['p', 'preserveOwner'],
    ['L', 'follow'],
    ['h', 'follow'],
    ['onentry', 'onReadEntry'],
]);
const isSyncFile = (o) => !!o.sync && !!o.file;
const isAsyncFile = (o) => !o.sync && !!o.file;
const isSyncNoFile = (o) => !!o.sync && !o.file;
const isAsyncNoFile = (o) => !o.sync && !o.file;
const isFile = (o) => !!o.file;
const dealiasKey = (k) => {
    const d = argmap.get(k);
    if (d)
        return d;
    return k;
};
const dealias = (opt = {}) => {
    if (!opt)
        return {};
    const result = {};
    for (const [key, v] of Object.entries(opt)) {
        // TS doesn't know that aliases are going to always be the same type
        const k = dealiasKey(key);
        result[k] = v;
    }
    // affordance for deprecated noChmod -> chmod
    if (result.chmod === undefined && result.noChmod === false) {
        result.chmod = true;
    }
    delete result.noChmod;
    return result;
};

const makeCommand = (syncFile, asyncFile, syncNoFile, asyncNoFile, validate) => {
    return Object.assign((opt_ = [], entries, cb) => {
        if (Array.isArray(opt_)) {
            entries = opt_;
            opt_ = {};
        }
        if (typeof entries === 'function') {
            cb = entries;
            entries = undefined;
        }
        if (!entries) {
            entries = [];
        }
        else {
            entries = Array.from(entries);
        }
        const opt = dealias(opt_);
        validate?.(opt, entries);
        if (isSyncFile(opt)) {
            if (typeof cb === 'function') {
                throw new TypeError('callback not supported for sync tar functions');
            }
            return syncFile(opt, entries);
        }
        else if (isAsyncFile(opt)) {
            const p = asyncFile(opt, entries);
            // weirdness to make TS happy
            const c = cb ? cb : undefined;
            return c ? p.then(() => c(), c) : p;
        }
        else if (isSyncNoFile(opt)) {
            if (typeof cb === 'function') {
                throw new TypeError('callback not supported for sync tar functions');
            }
            return syncNoFile(opt, entries);
        }
        else if (isAsyncNoFile(opt)) {
            if (typeof cb === 'function') {
                throw new TypeError('callback only supported with file option');
            }
            return asyncNoFile(opt, entries);
            /* c8 ignore start */
        }
        else {
            throw new Error('impossible options??');
        }
        /* c8 ignore stop */
    }, {
        syncFile,
        asyncFile,
        syncNoFile,
        asyncNoFile,
        validate,
    });
};

// Update with any zlib constants that are added or changed in the future.
// Node v6 didn't export this, so we just hard code the version and rely
// on all the other hard-coded values from zlib v4736.  When node v6
// support drops, we can just export the realZlibConstants object.
/* c8 ignore start */
const realZlibConstants = realZlib.constants || { ZLIB_VERNUM: 4736 };
/* c8 ignore stop */
const constants = Object.freeze(Object.assign(Object.create(null), {
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    Z_MEM_ERROR: -4,
    Z_BUF_ERROR: -5,
    Z_VERSION_ERROR: -6,
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    DEFLATE: 1,
    INFLATE: 2,
    GZIP: 3,
    GUNZIP: 4,
    DEFLATERAW: 5,
    INFLATERAW: 6,
    UNZIP: 7,
    BROTLI_DECODE: 8,
    BROTLI_ENCODE: 9,
    Z_MIN_WINDOWBITS: 8,
    Z_MAX_WINDOWBITS: 15,
    Z_DEFAULT_WINDOWBITS: 15,
    Z_MIN_CHUNK: 64,
    Z_MAX_CHUNK: Infinity,
    Z_DEFAULT_CHUNK: 16384,
    Z_MIN_MEMLEVEL: 1,
    Z_MAX_MEMLEVEL: 9,
    Z_DEFAULT_MEMLEVEL: 8,
    Z_MIN_LEVEL: -1,
    Z_MAX_LEVEL: 9,
    Z_DEFAULT_LEVEL: -1,
    BROTLI_OPERATION_PROCESS: 0,
    BROTLI_OPERATION_FLUSH: 1,
    BROTLI_OPERATION_FINISH: 2,
    BROTLI_OPERATION_EMIT_METADATA: 3,
    BROTLI_MODE_GENERIC: 0,
    BROTLI_MODE_TEXT: 1,
    BROTLI_MODE_FONT: 2,
    BROTLI_DEFAULT_MODE: 0,
    BROTLI_MIN_QUALITY: 0,
    BROTLI_MAX_QUALITY: 11,
    BROTLI_DEFAULT_QUALITY: 11,
    BROTLI_MIN_WINDOW_BITS: 10,
    BROTLI_MAX_WINDOW_BITS: 24,
    BROTLI_LARGE_MAX_WINDOW_BITS: 30,
    BROTLI_DEFAULT_WINDOW: 22,
    BROTLI_MIN_INPUT_BLOCK_BITS: 16,
    BROTLI_MAX_INPUT_BLOCK_BITS: 24,
    BROTLI_PARAM_MODE: 0,
    BROTLI_PARAM_QUALITY: 1,
    BROTLI_PARAM_LGWIN: 2,
    BROTLI_PARAM_LGBLOCK: 3,
    BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,
    BROTLI_PARAM_SIZE_HINT: 5,
    BROTLI_PARAM_LARGE_WINDOW: 6,
    BROTLI_PARAM_NPOSTFIX: 7,
    BROTLI_PARAM_NDIRECT: 8,
    BROTLI_DECODER_RESULT_ERROR: 0,
    BROTLI_DECODER_RESULT_SUCCESS: 1,
    BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,
    BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,
    BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,
    BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,
    BROTLI_DECODER_NO_ERROR: 0,
    BROTLI_DECODER_SUCCESS: 1,
    BROTLI_DECODER_NEEDS_MORE_INPUT: 2,
    BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,
    BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,
    BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,
    BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,
    BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,
    BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,
    BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,
    BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,
    BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,
    BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,
    BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,
    BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,
    BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,
    BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,
    BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,
    BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,
    BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,
    BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,
    BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,
    BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,
    BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,
    BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,
    BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,
    BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,
    BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,
    BROTLI_DECODER_ERROR_UNREACHABLE: -31,
}, realZlibConstants));

const OriginalBufferConcat = require$$7.Buffer.concat;
const desc = Object.getOwnPropertyDescriptor(require$$7.Buffer, 'concat');
const noop$1 = (args) => args;
const passthroughBufferConcat = desc?.writable === true || desc?.set !== undefined
    ? (makeNoOp) => {
        require$$7.Buffer.concat = makeNoOp ? noop$1 : OriginalBufferConcat;
    }
    : (_) => { };
const _superWrite = Symbol('_superWrite');
class ZlibError extends Error {
    code;
    errno;
    constructor(err) {
        super('zlib: ' + err.message);
        this.code = err.code;
        this.errno = err.errno;
        /* c8 ignore next */
        if (!this.code)
            this.code = 'ZLIB_ERROR';
        this.message = 'zlib: ' + err.message;
        Error.captureStackTrace(this, this.constructor);
    }
    get name() {
        return 'ZlibError';
    }
}
// the Zlib class they all inherit from
// This thing manages the queue of requests, and returns
// true or false if there is anything in the queue when
// you call the .write() method.
const _flushFlag = Symbol('flushFlag');
class ZlibBase extends Minipass {
    #sawError = false;
    #ended = false;
    #flushFlag;
    #finishFlushFlag;
    #fullFlushFlag;
    #handle;
    #onError;
    get sawError() {
        return this.#sawError;
    }
    get handle() {
        return this.#handle;
    }
    /* c8 ignore start */
    get flushFlag() {
        return this.#flushFlag;
    }
    /* c8 ignore stop */
    constructor(opts, mode) {
        if (!opts || typeof opts !== 'object')
            throw new TypeError('invalid options for ZlibBase constructor');
        //@ts-ignore
        super(opts);
        /* c8 ignore start */
        this.#flushFlag = opts.flush ?? 0;
        this.#finishFlushFlag = opts.finishFlush ?? 0;
        this.#fullFlushFlag = opts.fullFlushFlag ?? 0;
        /* c8 ignore stop */
        // this will throw if any options are invalid for the class selected
        try {
            // @types/node doesn't know that it exports the classes, but they're there
            //@ts-ignore
            this.#handle = new realZlib__namespace[mode](opts);
        }
        catch (er) {
            // make sure that all errors get decorated properly
            throw new ZlibError(er);
        }
        this.#onError = err => {
            // no sense raising multiple errors, since we abort on the first one.
            if (this.#sawError)
                return;
            this.#sawError = true;
            // there is no way to cleanly recover.
            // continuing only obscures problems.
            this.close();
            this.emit('error', err);
        };
        this.#handle?.on('error', er => this.#onError(new ZlibError(er)));
        this.once('end', () => this.close);
    }
    close() {
        if (this.#handle) {
            this.#handle.close();
            this.#handle = undefined;
            this.emit('close');
        }
    }
    reset() {
        if (!this.#sawError) {
            assert(this.#handle, 'zlib binding closed');
            //@ts-ignore
            return this.#handle.reset?.();
        }
    }
    flush(flushFlag) {
        if (this.ended)
            return;
        if (typeof flushFlag !== 'number')
            flushFlag = this.#fullFlushFlag;
        this.write(Object.assign(require$$7.Buffer.alloc(0), { [_flushFlag]: flushFlag }));
    }
    end(chunk, encoding, cb) {
        /* c8 ignore start */
        if (typeof chunk === 'function') {
            cb = chunk;
            encoding = undefined;
            chunk = undefined;
        }
        if (typeof encoding === 'function') {
            cb = encoding;
            encoding = undefined;
        }
        /* c8 ignore stop */
        if (chunk) {
            if (encoding)
                this.write(chunk, encoding);
            else
                this.write(chunk);
        }
        this.flush(this.#finishFlushFlag);
        this.#ended = true;
        return super.end(cb);
    }
    get ended() {
        return this.#ended;
    }
    // overridden in the gzip classes to do portable writes
    [_superWrite](data) {
        return super.write(data);
    }
    write(chunk, encoding, cb) {
        // process the chunk using the sync process
        // then super.write() all the outputted chunks
        if (typeof encoding === 'function')
            (cb = encoding), (encoding = 'utf8');
        if (typeof chunk === 'string')
            chunk = require$$7.Buffer.from(chunk, encoding);
        if (this.#sawError)
            return;
        assert(this.#handle, 'zlib binding closed');
        // _processChunk tries to .close() the native handle after it's done, so we
        // intercept that by temporarily making it a no-op.
        // diving into the node:zlib internals a bit here
        const nativeHandle = this.#handle
            ._handle;
        const originalNativeClose = nativeHandle.close;
        nativeHandle.close = () => { };
        const originalClose = this.#handle.close;
        this.#handle.close = () => { };
        // It also calls `Buffer.concat()` at the end, which may be convenient
        // for some, but which we are not interested in as it slows us down.
        passthroughBufferConcat(true);
        let result = undefined;
        try {
            const flushFlag = typeof chunk[_flushFlag] === 'number'
                ? chunk[_flushFlag]
                : this.#flushFlag;
            result = this.#handle._processChunk(chunk, flushFlag);
            // if we don't throw, reset it back how it was
            passthroughBufferConcat(false);
        }
        catch (err) {
            // or if we do, put Buffer.concat() back before we emit error
            // Error events call into user code, which may call Buffer.concat()
            passthroughBufferConcat(false);
            this.#onError(new ZlibError(err));
        }
        finally {
            if (this.#handle) {
                this.#handle._handle =
                    nativeHandle;
                nativeHandle.close = originalNativeClose;
                this.#handle.close = originalClose;
                // `_processChunk()` adds an 'error' listener. If we don't remove it
                // after each call, these handlers start piling up.
                this.#handle.removeAllListeners('error');
                // make sure OUR error listener is still attached tho
            }
        }
        if (this.#handle)
            this.#handle.on('error', er => this.#onError(new ZlibError(er)));
        let writeReturn;
        if (result) {
            if (Array.isArray(result) && result.length > 0) {
                const r = result[0];
                // The first buffer is always `handle._outBuffer`, which would be
                // re-used for later invocations; so, we always have to copy that one.
                writeReturn = this[_superWrite](require$$7.Buffer.from(r));
                for (let i = 1; i < result.length; i++) {
                    writeReturn = this[_superWrite](result[i]);
                }
            }
            else {
                // either a single Buffer or an empty array
                writeReturn = this[_superWrite](require$$7.Buffer.from(result));
            }
        }
        if (cb)
            cb();
        return writeReturn;
    }
}
class Zlib extends ZlibBase {
    #level;
    #strategy;
    constructor(opts, mode) {
        opts = opts || {};
        opts.flush = opts.flush || constants.Z_NO_FLUSH;
        opts.finishFlush = opts.finishFlush || constants.Z_FINISH;
        opts.fullFlushFlag = constants.Z_FULL_FLUSH;
        super(opts, mode);
        this.#level = opts.level;
        this.#strategy = opts.strategy;
    }
    params(level, strategy) {
        if (this.sawError)
            return;
        if (!this.handle)
            throw new Error('cannot switch params when binding is closed');
        // no way to test this without also not supporting params at all
        /* c8 ignore start */
        if (!this.handle.params)
            throw new Error('not supported in this implementation');
        /* c8 ignore stop */
        if (this.#level !== level || this.#strategy !== strategy) {
            this.flush(constants.Z_SYNC_FLUSH);
            assert(this.handle, 'zlib binding closed');
            // .params() calls .flush(), but the latter is always async in the
            // core zlib. We override .flush() temporarily to intercept that and
            // flush synchronously.
            const origFlush = this.handle.flush;
            this.handle.flush = (flushFlag, cb) => {
                /* c8 ignore start */
                if (typeof flushFlag === 'function') {
                    cb = flushFlag;
                    flushFlag = this.flushFlag;
                }
                /* c8 ignore stop */
                this.flush(flushFlag);
                cb?.();
            };
            try {
                ;
                this.handle.params(level, strategy);
            }
            finally {
                this.handle.flush = origFlush;
            }
            /* c8 ignore start */
            if (this.handle) {
                this.#level = level;
                this.#strategy = strategy;
            }
            /* c8 ignore stop */
        }
    }
}
class Gzip extends Zlib {
    #portable;
    constructor(opts) {
        super(opts, 'Gzip');
        this.#portable = opts && !!opts.portable;
    }
    [_superWrite](data) {
        if (!this.#portable)
            return super[_superWrite](data);
        // we'll always get the header emitted in one first chunk
        // overwrite the OS indicator byte with 0xFF
        this.#portable = false;
        data[9] = 255;
        return super[_superWrite](data);
    }
}
// auto-detect header.
class Unzip extends Zlib {
    constructor(opts) {
        super(opts, 'Unzip');
    }
}
class Brotli extends ZlibBase {
    constructor(opts, mode) {
        opts = opts || {};
        opts.flush = opts.flush || constants.BROTLI_OPERATION_PROCESS;
        opts.finishFlush =
            opts.finishFlush || constants.BROTLI_OPERATION_FINISH;
        opts.fullFlushFlag = constants.BROTLI_OPERATION_FLUSH;
        super(opts, mode);
    }
}
class BrotliCompress extends Brotli {
    constructor(opts) {
        super(opts, 'BrotliCompress');
    }
}
class BrotliDecompress extends Brotli {
    constructor(opts) {
        super(opts, 'BrotliDecompress');
    }
}

class Yallist {
    tail;
    head;
    length = 0;
    static create(list = []) {
        return new Yallist(list);
    }
    constructor(list = []) {
        for (const item of list) {
            this.push(item);
        }
    }
    *[Symbol.iterator]() {
        for (let walker = this.head; walker; walker = walker.next) {
            yield walker.value;
        }
    }
    removeNode(node) {
        if (node.list !== this) {
            throw new Error('removing node which does not belong to this list');
        }
        const next = node.next;
        const prev = node.prev;
        if (next) {
            next.prev = prev;
        }
        if (prev) {
            prev.next = next;
        }
        if (node === this.head) {
            this.head = next;
        }
        if (node === this.tail) {
            this.tail = prev;
        }
        this.length--;
        node.next = undefined;
        node.prev = undefined;
        node.list = undefined;
        return next;
    }
    unshiftNode(node) {
        if (node === this.head) {
            return;
        }
        if (node.list) {
            node.list.removeNode(node);
        }
        const head = this.head;
        node.list = this;
        node.next = head;
        if (head) {
            head.prev = node;
        }
        this.head = node;
        if (!this.tail) {
            this.tail = node;
        }
        this.length++;
    }
    pushNode(node) {
        if (node === this.tail) {
            return;
        }
        if (node.list) {
            node.list.removeNode(node);
        }
        const tail = this.tail;
        node.list = this;
        node.prev = tail;
        if (tail) {
            tail.next = node;
        }
        this.tail = node;
        if (!this.head) {
            this.head = node;
        }
        this.length++;
    }
    push(...args) {
        for (let i = 0, l = args.length; i < l; i++) {
            push(this, args[i]);
        }
        return this.length;
    }
    unshift(...args) {
        for (var i = 0, l = args.length; i < l; i++) {
            unshift(this, args[i]);
        }
        return this.length;
    }
    pop() {
        if (!this.tail) {
            return undefined;
        }
        const res = this.tail.value;
        const t = this.tail;
        this.tail = this.tail.prev;
        if (this.tail) {
            this.tail.next = undefined;
        }
        else {
            this.head = undefined;
        }
        t.list = undefined;
        this.length--;
        return res;
    }
    shift() {
        if (!this.head) {
            return undefined;
        }
        const res = this.head.value;
        const h = this.head;
        this.head = this.head.next;
        if (this.head) {
            this.head.prev = undefined;
        }
        else {
            this.tail = undefined;
        }
        h.list = undefined;
        this.length--;
        return res;
    }
    forEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this.head, i = 0; !!walker; i++) {
            fn.call(thisp, walker.value, i, this);
            walker = walker.next;
        }
    }
    forEachReverse(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this.tail, i = this.length - 1; !!walker; i--) {
            fn.call(thisp, walker.value, i, this);
            walker = walker.prev;
        }
    }
    get(n) {
        let i = 0;
        let walker = this.head;
        for (; !!walker && i < n; i++) {
            walker = walker.next;
        }
        if (i === n && !!walker) {
            return walker.value;
        }
    }
    getReverse(n) {
        let i = 0;
        let walker = this.tail;
        for (; !!walker && i < n; i++) {
            // abort out of the list early if we hit a cycle
            walker = walker.prev;
        }
        if (i === n && !!walker) {
            return walker.value;
        }
    }
    map(fn, thisp) {
        thisp = thisp || this;
        const res = new Yallist();
        for (let walker = this.head; !!walker;) {
            res.push(fn.call(thisp, walker.value, this));
            walker = walker.next;
        }
        return res;
    }
    mapReverse(fn, thisp) {
        thisp = thisp || this;
        var res = new Yallist();
        for (let walker = this.tail; !!walker;) {
            res.push(fn.call(thisp, walker.value, this));
            walker = walker.prev;
        }
        return res;
    }
    reduce(fn, initial) {
        let acc;
        let walker = this.head;
        if (arguments.length > 1) {
            acc = initial;
        }
        else if (this.head) {
            walker = this.head.next;
            acc = this.head.value;
        }
        else {
            throw new TypeError('Reduce of empty list with no initial value');
        }
        for (var i = 0; !!walker; i++) {
            acc = fn(acc, walker.value, i);
            walker = walker.next;
        }
        return acc;
    }
    reduceReverse(fn, initial) {
        let acc;
        let walker = this.tail;
        if (arguments.length > 1) {
            acc = initial;
        }
        else if (this.tail) {
            walker = this.tail.prev;
            acc = this.tail.value;
        }
        else {
            throw new TypeError('Reduce of empty list with no initial value');
        }
        for (let i = this.length - 1; !!walker; i--) {
            acc = fn(acc, walker.value, i);
            walker = walker.prev;
        }
        return acc;
    }
    toArray() {
        const arr = new Array(this.length);
        for (let i = 0, walker = this.head; !!walker; i++) {
            arr[i] = walker.value;
            walker = walker.next;
        }
        return arr;
    }
    toArrayReverse() {
        const arr = new Array(this.length);
        for (let i = 0, walker = this.tail; !!walker; i++) {
            arr[i] = walker.value;
            walker = walker.prev;
        }
        return arr;
    }
    slice(from = 0, to = this.length) {
        if (to < 0) {
            to += this.length;
        }
        if (from < 0) {
            from += this.length;
        }
        const ret = new Yallist();
        if (to < from || to < 0) {
            return ret;
        }
        if (from < 0) {
            from = 0;
        }
        if (to > this.length) {
            to = this.length;
        }
        let walker = this.head;
        let i = 0;
        for (i = 0; !!walker && i < from; i++) {
            walker = walker.next;
        }
        for (; !!walker && i < to; i++, walker = walker.next) {
            ret.push(walker.value);
        }
        return ret;
    }
    sliceReverse(from = 0, to = this.length) {
        if (to < 0) {
            to += this.length;
        }
        if (from < 0) {
            from += this.length;
        }
        const ret = new Yallist();
        if (to < from || to < 0) {
            return ret;
        }
        if (from < 0) {
            from = 0;
        }
        if (to > this.length) {
            to = this.length;
        }
        let i = this.length;
        let walker = this.tail;
        for (; !!walker && i > to; i--) {
            walker = walker.prev;
        }
        for (; !!walker && i > from; i--, walker = walker.prev) {
            ret.push(walker.value);
        }
        return ret;
    }
    splice(start, deleteCount = 0, ...nodes) {
        if (start > this.length) {
            start = this.length - 1;
        }
        if (start < 0) {
            start = this.length + start;
        }
        let walker = this.head;
        for (let i = 0; !!walker && i < start; i++) {
            walker = walker.next;
        }
        const ret = [];
        for (let i = 0; !!walker && i < deleteCount; i++) {
            ret.push(walker.value);
            walker = this.removeNode(walker);
        }
        if (!walker) {
            walker = this.tail;
        }
        else if (walker !== this.tail) {
            walker = walker.prev;
        }
        for (const v of nodes) {
            walker = insertAfter(this, walker, v);
        }
        return ret;
    }
    reverse() {
        const head = this.head;
        const tail = this.tail;
        for (let walker = head; !!walker; walker = walker.prev) {
            const p = walker.prev;
            walker.prev = walker.next;
            walker.next = p;
        }
        this.head = tail;
        this.tail = head;
        return this;
    }
}
// insertAfter undefined means "make the node the new head of list"
function insertAfter(self, node, value) {
    const prev = node;
    const next = node ? node.next : self.head;
    const inserted = new Node(value, prev, next, self);
    if (inserted.next === undefined) {
        self.tail = inserted;
    }
    if (inserted.prev === undefined) {
        self.head = inserted;
    }
    self.length++;
    return inserted;
}
function push(self, item) {
    self.tail = new Node(item, self.tail, undefined, self);
    if (!self.head) {
        self.head = self.tail;
    }
    self.length++;
}
function unshift(self, item) {
    self.head = new Node(item, undefined, self.head, self);
    if (!self.tail) {
        self.tail = self.head;
    }
    self.length++;
}
class Node {
    list;
    next;
    prev;
    value;
    constructor(value, prev, next, list) {
        this.list = list;
        this.value = value;
        if (prev) {
            prev.next = this;
            this.prev = prev;
        }
        else {
            this.prev = undefined;
        }
        if (next) {
            next.prev = this;
            this.next = next;
        }
        else {
            this.next = undefined;
        }
    }
}

// Tar can encode large and negative numbers using a leading byte of
// 0xff for negative, and 0x80 for positive.
const encode$1 = (num, buf) => {
    if (!Number.isSafeInteger(num)) {
        // The number is so large that javascript cannot represent it with integer
        // precision.
        throw Error('cannot encode number outside of javascript safe integer range');
    }
    else if (num < 0) {
        encodeNegative(num, buf);
    }
    else {
        encodePositive(num, buf);
    }
    return buf;
};
const encodePositive = (num, buf) => {
    buf[0] = 0x80;
    for (var i = buf.length; i > 1; i--) {
        buf[i - 1] = num & 0xff;
        num = Math.floor(num / 0x100);
    }
};
const encodeNegative = (num, buf) => {
    buf[0] = 0xff;
    var flipped = false;
    num = num * -1;
    for (var i = buf.length; i > 1; i--) {
        var byte = num & 0xff;
        num = Math.floor(num / 0x100);
        if (flipped) {
            buf[i - 1] = onesComp(byte);
        }
        else if (byte === 0) {
            buf[i - 1] = 0;
        }
        else {
            flipped = true;
            buf[i - 1] = twosComp(byte);
        }
    }
};
const parse$1 = (buf) => {
    const pre = buf[0];
    const value = pre === 0x80 ? pos(buf.subarray(1, buf.length))
        : pre === 0xff ? twos(buf)
            : null;
    if (value === null) {
        throw Error('invalid base256 encoding');
    }
    if (!Number.isSafeInteger(value)) {
        // The number is so large that javascript cannot represent it with integer
        // precision.
        throw Error('parsed number outside of javascript safe integer range');
    }
    return value;
};
const twos = (buf) => {
    var len = buf.length;
    var sum = 0;
    var flipped = false;
    for (var i = len - 1; i > -1; i--) {
        var byte = Number(buf[i]);
        var f;
        if (flipped) {
            f = onesComp(byte);
        }
        else if (byte === 0) {
            f = byte;
        }
        else {
            flipped = true;
            f = twosComp(byte);
        }
        if (f !== 0) {
            sum -= f * Math.pow(256, len - i - 1);
        }
    }
    return sum;
};
const pos = (buf) => {
    var len = buf.length;
    var sum = 0;
    for (var i = len - 1; i > -1; i--) {
        var byte = Number(buf[i]);
        if (byte !== 0) {
            sum += byte * Math.pow(256, len - i - 1);
        }
    }
    return sum;
};
const onesComp = (byte) => (0xff ^ byte) & 0xff;
const twosComp = (byte) => ((0xff ^ byte) + 1) & 0xff;

const isCode = (c) => name.has(c);
// map types from key to human-friendly name
const name = new Map([
    ['0', 'File'],
    // same as File
    ['', 'OldFile'],
    ['1', 'Link'],
    ['2', 'SymbolicLink'],
    // Devices and FIFOs aren't fully supported
    // they are parsed, but skipped when unpacking
    ['3', 'CharacterDevice'],
    ['4', 'BlockDevice'],
    ['5', 'Directory'],
    ['6', 'FIFO'],
    // same as File
    ['7', 'ContiguousFile'],
    // pax headers
    ['g', 'GlobalExtendedHeader'],
    ['x', 'ExtendedHeader'],
    // vendor-specific stuff
    // skip
    ['A', 'SolarisACL'],
    // like 5, but with data, which should be skipped
    ['D', 'GNUDumpDir'],
    // metadata only, skip
    ['I', 'Inode'],
    // data = link path of next file
    ['K', 'NextFileHasLongLinkpath'],
    // data = path of next file
    ['L', 'NextFileHasLongPath'],
    // skip
    ['M', 'ContinuationFile'],
    // like L
    ['N', 'OldGnuLongPath'],
    // skip
    ['S', 'SparseFile'],
    // skip
    ['V', 'TapeVolumeHeader'],
    // like x
    ['X', 'OldExtendedHeader'],
]);
// map the other direction
const code = new Map(Array.from(name).map(kv => [kv[1], kv[0]]));

// parse a 512-byte header block to a data object, or vice-versa
// encode returns `true` if a pax extended header is needed, because
// the data could not be faithfully encoded in a simple header.
// (Also, check header.needPax to see if it needs a pax header.)
class Header {
    cksumValid = false;
    needPax = false;
    nullBlock = false;
    block;
    path;
    mode;
    uid;
    gid;
    size;
    cksum;
    #type = 'Unsupported';
    linkpath;
    uname;
    gname;
    devmaj = 0;
    devmin = 0;
    atime;
    ctime;
    mtime;
    charset;
    comment;
    constructor(data, off = 0, ex, gex) {
        if (Buffer.isBuffer(data)) {
            this.decode(data, off || 0, ex, gex);
        }
        else if (data) {
            this.#slurp(data);
        }
    }
    decode(buf, off, ex, gex) {
        if (!off) {
            off = 0;
        }
        if (!buf || !(buf.length >= off + 512)) {
            throw new Error('need 512 bytes for header');
        }
        this.path = decString(buf, off, 100);
        this.mode = decNumber(buf, off + 100, 8);
        this.uid = decNumber(buf, off + 108, 8);
        this.gid = decNumber(buf, off + 116, 8);
        this.size = decNumber(buf, off + 124, 12);
        this.mtime = decDate(buf, off + 136, 12);
        this.cksum = decNumber(buf, off + 148, 12);
        // if we have extended or global extended headers, apply them now
        // See https://github.com/npm/node-tar/pull/187
        // Apply global before local, so it overrides
        if (gex)
            this.#slurp(gex, true);
        if (ex)
            this.#slurp(ex);
        // old tar versions marked dirs as a file with a trailing /
        const t = decString(buf, off + 156, 1);
        if (isCode(t)) {
            this.#type = t || '0';
        }
        if (this.#type === '0' && this.path.slice(-1) === '/') {
            this.#type = '5';
        }
        // tar implementations sometimes incorrectly put the stat(dir).size
        // as the size in the tarball, even though Directory entries are
        // not able to have any body at all.  In the very rare chance that
        // it actually DOES have a body, we weren't going to do anything with
        // it anyway, and it'll just be a warning about an invalid header.
        if (this.#type === '5') {
            this.size = 0;
        }
        this.linkpath = decString(buf, off + 157, 100);
        if (buf.subarray(off + 257, off + 265).toString() ===
            'ustar\u000000') {
            this.uname = decString(buf, off + 265, 32);
            this.gname = decString(buf, off + 297, 32);
            /* c8 ignore start */
            this.devmaj = decNumber(buf, off + 329, 8) ?? 0;
            this.devmin = decNumber(buf, off + 337, 8) ?? 0;
            /* c8 ignore stop */
            if (buf[off + 475] !== 0) {
                // definitely a prefix, definitely >130 chars.
                const prefix = decString(buf, off + 345, 155);
                this.path = prefix + '/' + this.path;
            }
            else {
                const prefix = decString(buf, off + 345, 130);
                if (prefix) {
                    this.path = prefix + '/' + this.path;
                }
                this.atime = decDate(buf, off + 476, 12);
                this.ctime = decDate(buf, off + 488, 12);
            }
        }
        let sum = 8 * 0x20;
        for (let i = off; i < off + 148; i++) {
            sum += buf[i];
        }
        for (let i = off + 156; i < off + 512; i++) {
            sum += buf[i];
        }
        this.cksumValid = sum === this.cksum;
        if (this.cksum === undefined && sum === 8 * 0x20) {
            this.nullBlock = true;
        }
    }
    #slurp(ex, gex = false) {
        Object.assign(this, Object.fromEntries(Object.entries(ex).filter(([k, v]) => {
            // we slurp in everything except for the path attribute in
            // a global extended header, because that's weird. Also, any
            // null/undefined values are ignored.
            return !(v === null ||
                v === undefined ||
                (k === 'path' && gex) ||
                (k === 'linkpath' && gex) ||
                k === 'global');
        })));
    }
    encode(buf, off = 0) {
        if (!buf) {
            buf = this.block = Buffer.alloc(512);
        }
        if (this.#type === 'Unsupported') {
            this.#type = '0';
        }
        if (!(buf.length >= off + 512)) {
            throw new Error('need 512 bytes for header');
        }
        const prefixSize = this.ctime || this.atime ? 130 : 155;
        const split = splitPrefix(this.path || '', prefixSize);
        const path = split[0];
        const prefix = split[1];
        this.needPax = !!split[2];
        this.needPax = encString(buf, off, 100, path) || this.needPax;
        this.needPax =
            encNumber(buf, off + 100, 8, this.mode) || this.needPax;
        this.needPax =
            encNumber(buf, off + 108, 8, this.uid) || this.needPax;
        this.needPax =
            encNumber(buf, off + 116, 8, this.gid) || this.needPax;
        this.needPax =
            encNumber(buf, off + 124, 12, this.size) || this.needPax;
        this.needPax =
            encDate(buf, off + 136, 12, this.mtime) || this.needPax;
        buf[off + 156] = this.#type.charCodeAt(0);
        this.needPax =
            encString(buf, off + 157, 100, this.linkpath) || this.needPax;
        buf.write('ustar\u000000', off + 257, 8);
        this.needPax =
            encString(buf, off + 265, 32, this.uname) || this.needPax;
        this.needPax =
            encString(buf, off + 297, 32, this.gname) || this.needPax;
        this.needPax =
            encNumber(buf, off + 329, 8, this.devmaj) || this.needPax;
        this.needPax =
            encNumber(buf, off + 337, 8, this.devmin) || this.needPax;
        this.needPax =
            encString(buf, off + 345, prefixSize, prefix) || this.needPax;
        if (buf[off + 475] !== 0) {
            this.needPax =
                encString(buf, off + 345, 155, prefix) || this.needPax;
        }
        else {
            this.needPax =
                encString(buf, off + 345, 130, prefix) || this.needPax;
            this.needPax =
                encDate(buf, off + 476, 12, this.atime) || this.needPax;
            this.needPax =
                encDate(buf, off + 488, 12, this.ctime) || this.needPax;
        }
        let sum = 8 * 0x20;
        for (let i = off; i < off + 148; i++) {
            sum += buf[i];
        }
        for (let i = off + 156; i < off + 512; i++) {
            sum += buf[i];
        }
        this.cksum = sum;
        encNumber(buf, off + 148, 8, this.cksum);
        this.cksumValid = true;
        return this.needPax;
    }
    get type() {
        return (this.#type === 'Unsupported' ?
            this.#type
            : name.get(this.#type));
    }
    get typeKey() {
        return this.#type;
    }
    set type(type) {
        const c = String(code.get(type));
        if (isCode(c) || c === 'Unsupported') {
            this.#type = c;
        }
        else if (isCode(type)) {
            this.#type = type;
        }
        else {
            throw new TypeError('invalid entry type: ' + type);
        }
    }
}
const splitPrefix = (p, prefixSize) => {
    const pathSize = 100;
    let pp = p;
    let prefix = '';
    let ret = undefined;
    const root = path$1.posix.parse(p).root || '.';
    if (Buffer.byteLength(pp) < pathSize) {
        ret = [pp, prefix, false];
    }
    else {
        // first set prefix to the dir, and path to the base
        prefix = path$1.posix.dirname(pp);
        pp = path$1.posix.basename(pp);
        do {
            if (Buffer.byteLength(pp) <= pathSize &&
                Buffer.byteLength(prefix) <= prefixSize) {
                // both fit!
                ret = [pp, prefix, false];
            }
            else if (Buffer.byteLength(pp) > pathSize &&
                Buffer.byteLength(prefix) <= prefixSize) {
                // prefix fits in prefix, but path doesn't fit in path
                ret = [pp.slice(0, pathSize - 1), prefix, true];
            }
            else {
                // make path take a bit from prefix
                pp = path$1.posix.join(path$1.posix.basename(prefix), pp);
                prefix = path$1.posix.dirname(prefix);
            }
        } while (prefix !== root && ret === undefined);
        // at this point, found no resolution, just truncate
        if (!ret) {
            ret = [p.slice(0, pathSize - 1), '', true];
        }
    }
    return ret;
};
const decString = (buf, off, size) => buf
    .subarray(off, off + size)
    .toString('utf8')
    .replace(/\0.*/, '');
const decDate = (buf, off, size) => numToDate(decNumber(buf, off, size));
const numToDate = (num) => num === undefined ? undefined : new Date(num * 1000);
const decNumber = (buf, off, size) => Number(buf[off]) & 0x80 ?
    parse$1(buf.subarray(off, off + size))
    : decSmallNumber(buf, off, size);
const nanUndef = (value) => (isNaN(value) ? undefined : value);
const decSmallNumber = (buf, off, size) => nanUndef(parseInt(buf
    .subarray(off, off + size)
    .toString('utf8')
    .replace(/\0.*$/, '')
    .trim(), 8));
// the maximum encodable as a null-terminated octal, by field size
const MAXNUM = {
    12: 0o77777777777,
    8: 0o7777777,
};
const encNumber = (buf, off, size, num) => num === undefined ? false
    : num > MAXNUM[size] || num < 0 ?
        (encode$1(num, buf.subarray(off, off + size)), true)
        : (encSmallNumber(buf, off, size, num), false);
const encSmallNumber = (buf, off, size, num) => buf.write(octalString(num, size), off, size, 'ascii');
const octalString = (num, size) => padOctal(Math.floor(num).toString(8), size);
const padOctal = (str, size) => (str.length === size - 1 ?
    str
    : new Array(size - str.length - 1).join('0') + str + ' ') + '\0';
const encDate = (buf, off, size, date) => date === undefined ? false : (encNumber(buf, off, size, date.getTime() / 1000));
// enough to fill the longest string we've got
const NULLS = new Array(156).join('\0');
// pad with nulls, return true if it's longer or non-ascii
const encString = (buf, off, size, str) => str === undefined ? false : ((buf.write(str + NULLS, off, size, 'utf8'),
    str.length !== Buffer.byteLength(str) || str.length > size));

class Pax {
    atime;
    mtime;
    ctime;
    charset;
    comment;
    gid;
    uid;
    gname;
    uname;
    linkpath;
    dev;
    ino;
    nlink;
    path;
    size;
    mode;
    global;
    constructor(obj, global = false) {
        this.atime = obj.atime;
        this.charset = obj.charset;
        this.comment = obj.comment;
        this.ctime = obj.ctime;
        this.dev = obj.dev;
        this.gid = obj.gid;
        this.global = global;
        this.gname = obj.gname;
        this.ino = obj.ino;
        this.linkpath = obj.linkpath;
        this.mtime = obj.mtime;
        this.nlink = obj.nlink;
        this.path = obj.path;
        this.size = obj.size;
        this.uid = obj.uid;
        this.uname = obj.uname;
    }
    encode() {
        const body = this.encodeBody();
        if (body === '') {
            return Buffer.allocUnsafe(0);
        }
        const bodyLen = Buffer.byteLength(body);
        // round up to 512 bytes
        // add 512 for header
        const bufLen = 512 * Math.ceil(1 + bodyLen / 512);
        const buf = Buffer.allocUnsafe(bufLen);
        // 0-fill the header section, it might not hit every field
        for (let i = 0; i < 512; i++) {
            buf[i] = 0;
        }
        new Header({
            // XXX split the path
            // then the path should be PaxHeader + basename, but less than 99,
            // prepend with the dirname
            /* c8 ignore start */
            path: ('PaxHeader/' + path$1.basename(this.path ?? '')).slice(0, 99),
            /* c8 ignore stop */
            mode: this.mode || 0o644,
            uid: this.uid,
            gid: this.gid,
            size: bodyLen,
            mtime: this.mtime,
            type: this.global ? 'GlobalExtendedHeader' : 'ExtendedHeader',
            linkpath: '',
            uname: this.uname || '',
            gname: this.gname || '',
            devmaj: 0,
            devmin: 0,
            atime: this.atime,
            ctime: this.ctime,
        }).encode(buf);
        buf.write(body, 512, bodyLen, 'utf8');
        // null pad after the body
        for (let i = bodyLen + 512; i < buf.length; i++) {
            buf[i] = 0;
        }
        return buf;
    }
    encodeBody() {
        return (this.encodeField('path') +
            this.encodeField('ctime') +
            this.encodeField('atime') +
            this.encodeField('dev') +
            this.encodeField('ino') +
            this.encodeField('nlink') +
            this.encodeField('charset') +
            this.encodeField('comment') +
            this.encodeField('gid') +
            this.encodeField('gname') +
            this.encodeField('linkpath') +
            this.encodeField('mtime') +
            this.encodeField('size') +
            this.encodeField('uid') +
            this.encodeField('uname'));
    }
    encodeField(field) {
        if (this[field] === undefined) {
            return '';
        }
        const r = this[field];
        const v = r instanceof Date ? r.getTime() / 1000 : r;
        const s = ' ' +
            (field === 'dev' || field === 'ino' || field === 'nlink' ?
                'SCHILY.'
                : '') +
            field +
            '=' +
            v +
            '\n';
        const byteLen = Buffer.byteLength(s);
        // the digits includes the length of the digits in ascii base-10
        // so if it's 9 characters, then adding 1 for the 9 makes it 10
        // which makes it 11 chars.
        let digits = Math.floor(Math.log(byteLen) / Math.log(10)) + 1;
        if (byteLen + digits >= Math.pow(10, digits)) {
            digits += 1;
        }
        const len = digits + byteLen;
        return len + s;
    }
    static parse(str, ex, g = false) {
        return new Pax(merge(parseKV(str), ex), g);
    }
}
const merge = (a, b) => b ? Object.assign({}, b, a) : a;
const parseKV = (str) => str
    .replace(/\n$/, '')
    .split('\n')
    .reduce(parseKVLine, Object.create(null));
const parseKVLine = (set, line) => {
    const n = parseInt(line, 10);
    // XXX Values with \n in them will fail this.
    // Refactor to not be a naive line-by-line parse.
    if (n !== Buffer.byteLength(line) + 1) {
        return set;
    }
    line = line.slice((n + ' ').length);
    const kv = line.split('=');
    const r = kv.shift();
    if (!r) {
        return set;
    }
    const k = r.replace(/^SCHILY\.(dev|ino|nlink)/, '$1');
    const v = kv.join('=');
    set[k] =
        /^([A-Z]+\.)?([mac]|birth|creation)time$/.test(k) ?
            new Date(Number(v) * 1000)
            : /^[0-9]+$/.test(v) ? +v
                : v;
    return set;
};

// on windows, either \ or / are valid directory separators.
// on unix, \ is a valid character in filenames.
// so, on windows, and only on windows, we replace all \ chars with /,
// so that we can use / as our one and only directory separator char.
const platform$4 = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;
const normalizeWindowsPath = platform$4 !== 'win32' ?
    (p) => p
    : (p) => p && p.replace(/\\/g, '/');

class ReadEntry extends Minipass {
    extended;
    globalExtended;
    header;
    startBlockSize;
    blockRemain;
    remain;
    type;
    meta = false;
    ignore = false;
    path;
    mode;
    uid;
    gid;
    uname;
    gname;
    size = 0;
    mtime;
    atime;
    ctime;
    linkpath;
    dev;
    ino;
    nlink;
    invalid = false;
    absolute;
    unsupported = false;
    constructor(header, ex, gex) {
        super({});
        // read entries always start life paused.  this is to avoid the
        // situation where Minipass's auto-ending empty streams results
        // in an entry ending before we're ready for it.
        this.pause();
        this.extended = ex;
        this.globalExtended = gex;
        this.header = header;
        /* c8 ignore start */
        this.remain = header.size ?? 0;
        /* c8 ignore stop */
        this.startBlockSize = 512 * Math.ceil(this.remain / 512);
        this.blockRemain = this.startBlockSize;
        this.type = header.type;
        switch (this.type) {
            case 'File':
            case 'OldFile':
            case 'Link':
            case 'SymbolicLink':
            case 'CharacterDevice':
            case 'BlockDevice':
            case 'Directory':
            case 'FIFO':
            case 'ContiguousFile':
            case 'GNUDumpDir':
                break;
            case 'NextFileHasLongLinkpath':
            case 'NextFileHasLongPath':
            case 'OldGnuLongPath':
            case 'GlobalExtendedHeader':
            case 'ExtendedHeader':
            case 'OldExtendedHeader':
                this.meta = true;
                break;
            // NOTE: gnutar and bsdtar treat unrecognized types as 'File'
            // it may be worth doing the same, but with a warning.
            default:
                this.ignore = true;
        }
        /* c8 ignore start */
        if (!header.path) {
            throw new Error('no path provided for tar.ReadEntry');
        }
        /* c8 ignore stop */
        this.path = normalizeWindowsPath(header.path);
        this.mode = header.mode;
        if (this.mode) {
            this.mode = this.mode & 0o7777;
        }
        this.uid = header.uid;
        this.gid = header.gid;
        this.uname = header.uname;
        this.gname = header.gname;
        this.size = this.remain;
        this.mtime = header.mtime;
        this.atime = header.atime;
        this.ctime = header.ctime;
        /* c8 ignore start */
        this.linkpath =
            header.linkpath ?
                normalizeWindowsPath(header.linkpath)
                : undefined;
        /* c8 ignore stop */
        this.uname = header.uname;
        this.gname = header.gname;
        if (ex) {
            this.#slurp(ex);
        }
        if (gex) {
            this.#slurp(gex, true);
        }
    }
    write(data) {
        const writeLen = data.length;
        if (writeLen > this.blockRemain) {
            throw new Error('writing more to entry than is appropriate');
        }
        const r = this.remain;
        const br = this.blockRemain;
        this.remain = Math.max(0, r - writeLen);
        this.blockRemain = Math.max(0, br - writeLen);
        if (this.ignore) {
            return true;
        }
        if (r >= writeLen) {
            return super.write(data);
        }
        // r < writeLen
        return super.write(data.subarray(0, r));
    }
    #slurp(ex, gex = false) {
        if (ex.path)
            ex.path = normalizeWindowsPath(ex.path);
        if (ex.linkpath)
            ex.linkpath = normalizeWindowsPath(ex.linkpath);
        Object.assign(this, Object.fromEntries(Object.entries(ex).filter(([k, v]) => {
            // we slurp in everything except for the path attribute in
            // a global extended header, because that's weird. Also, any
            // null/undefined values are ignored.
            return !(v === null ||
                v === undefined ||
                (k === 'path' && gex));
        })));
    }
}

const warnMethod = (self, code, message, data = {}) => {
    if (self.file) {
        data.file = self.file;
    }
    if (self.cwd) {
        data.cwd = self.cwd;
    }
    data.code =
        (message instanceof Error &&
            message.code) ||
            code;
    data.tarCode = code;
    if (!self.strict && data.recoverable !== false) {
        if (message instanceof Error) {
            data = Object.assign(message, data);
            message = message.message;
        }
        self.emit('warn', code, message, data);
    }
    else if (message instanceof Error) {
        self.emit('error', Object.assign(message, data));
    }
    else {
        self.emit('error', Object.assign(new Error(`${code}: ${message}`), data));
    }
};

// this[BUFFER] is the remainder of a chunk if we're waiting for
// the full 512 bytes of a header to come in.  We will Buffer.concat()
// it to the next write(), which is a mem copy, but a small one.
//
// this[QUEUE] is a Yallist of entries that haven't been emitted
// yet this can only get filled up if the user keeps write()ing after
// a write() returns false, or does a write() with more than one entry
//
// We don't buffer chunks, we always parse them and either create an
// entry, or push it into the active entry.  The ReadEntry class knows
// to throw data away if .ignore=true
//
// Shift entry off the buffer when it emits 'end', and emit 'entry' for
// the next one in the list.
//
// At any time, we're pushing body chunks into the entry at WRITEENTRY,
// and waiting for 'end' on the entry at READENTRY
//
// ignored entries get .resume() called on them straight away
const maxMetaEntrySize = 1024 * 1024;
const gzipHeader = Buffer.from([0x1f, 0x8b]);
const STATE = Symbol('state');
const WRITEENTRY = Symbol('writeEntry');
const READENTRY = Symbol('readEntry');
const NEXTENTRY = Symbol('nextEntry');
const PROCESSENTRY = Symbol('processEntry');
const EX = Symbol('extendedHeader');
const GEX = Symbol('globalExtendedHeader');
const META = Symbol('meta');
const EMITMETA = Symbol('emitMeta');
const BUFFER = Symbol('buffer');
const QUEUE$1 = Symbol('queue');
const ENDED$2 = Symbol('ended');
const EMITTEDEND = Symbol('emittedEnd');
const EMIT = Symbol('emit');
const UNZIP = Symbol('unzip');
const CONSUMECHUNK = Symbol('consumeChunk');
const CONSUMECHUNKSUB = Symbol('consumeChunkSub');
const CONSUMEBODY = Symbol('consumeBody');
const CONSUMEMETA = Symbol('consumeMeta');
const CONSUMEHEADER = Symbol('consumeHeader');
const CONSUMING = Symbol('consuming');
const BUFFERCONCAT = Symbol('bufferConcat');
const MAYBEEND = Symbol('maybeEnd');
const WRITING = Symbol('writing');
const ABORTED = Symbol('aborted');
const DONE = Symbol('onDone');
const SAW_VALID_ENTRY = Symbol('sawValidEntry');
const SAW_NULL_BLOCK = Symbol('sawNullBlock');
const SAW_EOF = Symbol('sawEOF');
const CLOSESTREAM = Symbol('closeStream');
const noop = () => true;
class Parser extends require$$1$2.EventEmitter {
    file;
    strict;
    maxMetaEntrySize;
    filter;
    brotli;
    writable = true;
    readable = false;
    [QUEUE$1] = new Yallist();
    [BUFFER];
    [READENTRY];
    [WRITEENTRY];
    [STATE] = 'begin';
    [META] = '';
    [EX];
    [GEX];
    [ENDED$2] = false;
    [UNZIP];
    [ABORTED] = false;
    [SAW_VALID_ENTRY];
    [SAW_NULL_BLOCK] = false;
    [SAW_EOF] = false;
    [WRITING] = false;
    [CONSUMING] = false;
    [EMITTEDEND] = false;
    constructor(opt = {}) {
        super();
        this.file = opt.file || '';
        // these BADARCHIVE errors can't be detected early. listen on DONE.
        this.on(DONE, () => {
            if (this[STATE] === 'begin' ||
                this[SAW_VALID_ENTRY] === false) {
                // either less than 1 block of data, or all entries were invalid.
                // Either way, probably not even a tarball.
                this.warn('TAR_BAD_ARCHIVE', 'Unrecognized archive format');
            }
        });
        if (opt.ondone) {
            this.on(DONE, opt.ondone);
        }
        else {
            this.on(DONE, () => {
                this.emit('prefinish');
                this.emit('finish');
                this.emit('end');
            });
        }
        this.strict = !!opt.strict;
        this.maxMetaEntrySize = opt.maxMetaEntrySize || maxMetaEntrySize;
        this.filter = typeof opt.filter === 'function' ? opt.filter : noop;
        // Unlike gzip, brotli doesn't have any magic bytes to identify it
        // Users need to explicitly tell us they're extracting a brotli file
        // Or we infer from the file extension
        const isTBR = opt.file &&
            (opt.file.endsWith('.tar.br') || opt.file.endsWith('.tbr'));
        // if it's a tbr file it MIGHT be brotli, but we don't know until
        // we look at it and verify it's not a valid tar file.
        this.brotli =
            !opt.gzip && opt.brotli !== undefined ? opt.brotli
                : isTBR ? undefined
                    : false;
        // have to set this so that streams are ok piping into it
        this.on('end', () => this[CLOSESTREAM]());
        if (typeof opt.onwarn === 'function') {
            this.on('warn', opt.onwarn);
        }
        if (typeof opt.onReadEntry === 'function') {
            this.on('entry', opt.onReadEntry);
        }
    }
    warn(code, message, data = {}) {
        warnMethod(this, code, message, data);
    }
    [CONSUMEHEADER](chunk, position) {
        if (this[SAW_VALID_ENTRY] === undefined) {
            this[SAW_VALID_ENTRY] = false;
        }
        let header;
        try {
            header = new Header(chunk, position, this[EX], this[GEX]);
        }
        catch (er) {
            return this.warn('TAR_ENTRY_INVALID', er);
        }
        if (header.nullBlock) {
            if (this[SAW_NULL_BLOCK]) {
                this[SAW_EOF] = true;
                // ending an archive with no entries.  pointless, but legal.
                if (this[STATE] === 'begin') {
                    this[STATE] = 'header';
                }
                this[EMIT]('eof');
            }
            else {
                this[SAW_NULL_BLOCK] = true;
                this[EMIT]('nullBlock');
            }
        }
        else {
            this[SAW_NULL_BLOCK] = false;
            if (!header.cksumValid) {
                this.warn('TAR_ENTRY_INVALID', 'checksum failure', { header });
            }
            else if (!header.path) {
                this.warn('TAR_ENTRY_INVALID', 'path is required', { header });
            }
            else {
                const type = header.type;
                if (/^(Symbolic)?Link$/.test(type) && !header.linkpath) {
                    this.warn('TAR_ENTRY_INVALID', 'linkpath required', {
                        header,
                    });
                }
                else if (!/^(Symbolic)?Link$/.test(type) &&
                    !/^(Global)?ExtendedHeader$/.test(type) &&
                    header.linkpath) {
                    this.warn('TAR_ENTRY_INVALID', 'linkpath forbidden', {
                        header,
                    });
                }
                else {
                    const entry = (this[WRITEENTRY] = new ReadEntry(header, this[EX], this[GEX]));
                    // we do this for meta & ignored entries as well, because they
                    // are still valid tar, or else we wouldn't know to ignore them
                    if (!this[SAW_VALID_ENTRY]) {
                        if (entry.remain) {
                            // this might be the one!
                            const onend = () => {
                                if (!entry.invalid) {
                                    this[SAW_VALID_ENTRY] = true;
                                }
                            };
                            entry.on('end', onend);
                        }
                        else {
                            this[SAW_VALID_ENTRY] = true;
                        }
                    }
                    if (entry.meta) {
                        if (entry.size > this.maxMetaEntrySize) {
                            entry.ignore = true;
                            this[EMIT]('ignoredEntry', entry);
                            this[STATE] = 'ignore';
                            entry.resume();
                        }
                        else if (entry.size > 0) {
                            this[META] = '';
                            entry.on('data', c => (this[META] += c));
                            this[STATE] = 'meta';
                        }
                    }
                    else {
                        this[EX] = undefined;
                        entry.ignore =
                            entry.ignore || !this.filter(entry.path, entry);
                        if (entry.ignore) {
                            // probably valid, just not something we care about
                            this[EMIT]('ignoredEntry', entry);
                            this[STATE] = entry.remain ? 'ignore' : 'header';
                            entry.resume();
                        }
                        else {
                            if (entry.remain) {
                                this[STATE] = 'body';
                            }
                            else {
                                this[STATE] = 'header';
                                entry.end();
                            }
                            if (!this[READENTRY]) {
                                this[QUEUE$1].push(entry);
                                this[NEXTENTRY]();
                            }
                            else {
                                this[QUEUE$1].push(entry);
                            }
                        }
                    }
                }
            }
        }
    }
    [CLOSESTREAM]() {
        queueMicrotask(() => this.emit('close'));
    }
    [PROCESSENTRY](entry) {
        let go = true;
        if (!entry) {
            this[READENTRY] = undefined;
            go = false;
        }
        else if (Array.isArray(entry)) {
            const [ev, ...args] = entry;
            this.emit(ev, ...args);
        }
        else {
            this[READENTRY] = entry;
            this.emit('entry', entry);
            if (!entry.emittedEnd) {
                entry.on('end', () => this[NEXTENTRY]());
                go = false;
            }
        }
        return go;
    }
    [NEXTENTRY]() {
        do { } while (this[PROCESSENTRY](this[QUEUE$1].shift()));
        if (!this[QUEUE$1].length) {
            // At this point, there's nothing in the queue, but we may have an
            // entry which is being consumed (readEntry).
            // If we don't, then we definitely can handle more data.
            // If we do, and either it's flowing, or it has never had any data
            // written to it, then it needs more.
            // The only other possibility is that it has returned false from a
            // write() call, so we wait for the next drain to continue.
            const re = this[READENTRY];
            const drainNow = !re || re.flowing || re.size === re.remain;
            if (drainNow) {
                if (!this[WRITING]) {
                    this.emit('drain');
                }
            }
            else {
                re.once('drain', () => this.emit('drain'));
            }
        }
    }
    [CONSUMEBODY](chunk, position) {
        // write up to but no  more than writeEntry.blockRemain
        const entry = this[WRITEENTRY];
        /* c8 ignore start */
        if (!entry) {
            throw new Error('attempt to consume body without entry??');
        }
        const br = entry.blockRemain ?? 0;
        /* c8 ignore stop */
        const c = br >= chunk.length && position === 0 ?
            chunk
            : chunk.subarray(position, position + br);
        entry.write(c);
        if (!entry.blockRemain) {
            this[STATE] = 'header';
            this[WRITEENTRY] = undefined;
            entry.end();
        }
        return c.length;
    }
    [CONSUMEMETA](chunk, position) {
        const entry = this[WRITEENTRY];
        const ret = this[CONSUMEBODY](chunk, position);
        // if we finished, then the entry is reset
        if (!this[WRITEENTRY] && entry) {
            this[EMITMETA](entry);
        }
        return ret;
    }
    [EMIT](ev, data, extra) {
        if (!this[QUEUE$1].length && !this[READENTRY]) {
            this.emit(ev, data, extra);
        }
        else {
            this[QUEUE$1].push([ev, data, extra]);
        }
    }
    [EMITMETA](entry) {
        this[EMIT]('meta', this[META]);
        switch (entry.type) {
            case 'ExtendedHeader':
            case 'OldExtendedHeader':
                this[EX] = Pax.parse(this[META], this[EX], false);
                break;
            case 'GlobalExtendedHeader':
                this[GEX] = Pax.parse(this[META], this[GEX], true);
                break;
            case 'NextFileHasLongPath':
            case 'OldGnuLongPath': {
                const ex = this[EX] ?? Object.create(null);
                this[EX] = ex;
                ex.path = this[META].replace(/\0.*/, '');
                break;
            }
            case 'NextFileHasLongLinkpath': {
                const ex = this[EX] || Object.create(null);
                this[EX] = ex;
                ex.linkpath = this[META].replace(/\0.*/, '');
                break;
            }
            /* c8 ignore start */
            default:
                throw new Error('unknown meta: ' + entry.type);
            /* c8 ignore stop */
        }
    }
    abort(error) {
        this[ABORTED] = true;
        this.emit('abort', error);
        // always throws, even in non-strict mode
        this.warn('TAR_ABORT', error, { recoverable: false });
    }
    write(chunk, encoding, cb) {
        if (typeof encoding === 'function') {
            cb = encoding;
            encoding = undefined;
        }
        if (typeof chunk === 'string') {
            chunk = Buffer.from(chunk, 
            /* c8 ignore next */
            typeof encoding === 'string' ? encoding : 'utf8');
        }
        if (this[ABORTED]) {
            /* c8 ignore next */
            cb?.();
            return false;
        }
        // first write, might be gzipped
        const needSniff = this[UNZIP] === undefined ||
            (this.brotli === undefined && this[UNZIP] === false);
        if (needSniff && chunk) {
            if (this[BUFFER]) {
                chunk = Buffer.concat([this[BUFFER], chunk]);
                this[BUFFER] = undefined;
            }
            if (chunk.length < gzipHeader.length) {
                this[BUFFER] = chunk;
                /* c8 ignore next */
                cb?.();
                return true;
            }
            // look for gzip header
            for (let i = 0; this[UNZIP] === undefined && i < gzipHeader.length; i++) {
                if (chunk[i] !== gzipHeader[i]) {
                    this[UNZIP] = false;
                }
            }
            const maybeBrotli = this.brotli === undefined;
            if (this[UNZIP] === false && maybeBrotli) {
                // read the first header to see if it's a valid tar file. If so,
                // we can safely assume that it's not actually brotli, despite the
                // .tbr or .tar.br file extension.
                // if we ended before getting a full chunk, yes, def brotli
                if (chunk.length < 512) {
                    if (this[ENDED$2]) {
                        this.brotli = true;
                    }
                    else {
                        this[BUFFER] = chunk;
                        /* c8 ignore next */
                        cb?.();
                        return true;
                    }
                }
                else {
                    // if it's tar, it's pretty reliably not brotli, chances of
                    // that happening are astronomical.
                    try {
                        new Header(chunk.subarray(0, 512));
                        this.brotli = false;
                    }
                    catch (_) {
                        this.brotli = true;
                    }
                }
            }
            if (this[UNZIP] === undefined ||
                (this[UNZIP] === false && this.brotli)) {
                const ended = this[ENDED$2];
                this[ENDED$2] = false;
                this[UNZIP] =
                    this[UNZIP] === undefined ?
                        new Unzip({})
                        : new BrotliDecompress({});
                this[UNZIP].on('data', chunk => this[CONSUMECHUNK](chunk));
                this[UNZIP].on('error', er => this.abort(er));
                this[UNZIP].on('end', () => {
                    this[ENDED$2] = true;
                    this[CONSUMECHUNK]();
                });
                this[WRITING] = true;
                const ret = !!this[UNZIP][ended ? 'end' : 'write'](chunk);
                this[WRITING] = false;
                cb?.();
                return ret;
            }
        }
        this[WRITING] = true;
        if (this[UNZIP]) {
            this[UNZIP].write(chunk);
        }
        else {
            this[CONSUMECHUNK](chunk);
        }
        this[WRITING] = false;
        // return false if there's a queue, or if the current entry isn't flowing
        const ret = this[QUEUE$1].length ? false
            : this[READENTRY] ? this[READENTRY].flowing
                : true;
        // if we have no queue, then that means a clogged READENTRY
        if (!ret && !this[QUEUE$1].length) {
            this[READENTRY]?.once('drain', () => this.emit('drain'));
        }
        /* c8 ignore next */
        cb?.();
        return ret;
    }
    [BUFFERCONCAT](c) {
        if (c && !this[ABORTED]) {
            this[BUFFER] =
                this[BUFFER] ? Buffer.concat([this[BUFFER], c]) : c;
        }
    }
    [MAYBEEND]() {
        if (this[ENDED$2] &&
            !this[EMITTEDEND] &&
            !this[ABORTED] &&
            !this[CONSUMING]) {
            this[EMITTEDEND] = true;
            const entry = this[WRITEENTRY];
            if (entry && entry.blockRemain) {
                // truncated, likely a damaged file
                const have = this[BUFFER] ? this[BUFFER].length : 0;
                this.warn('TAR_BAD_ARCHIVE', `Truncated input (needed ${entry.blockRemain} more bytes, only ${have} available)`, { entry });
                if (this[BUFFER]) {
                    entry.write(this[BUFFER]);
                }
                entry.end();
            }
            this[EMIT](DONE);
        }
    }
    [CONSUMECHUNK](chunk) {
        if (this[CONSUMING] && chunk) {
            this[BUFFERCONCAT](chunk);
        }
        else if (!chunk && !this[BUFFER]) {
            this[MAYBEEND]();
        }
        else if (chunk) {
            this[CONSUMING] = true;
            if (this[BUFFER]) {
                this[BUFFERCONCAT](chunk);
                const c = this[BUFFER];
                this[BUFFER] = undefined;
                this[CONSUMECHUNKSUB](c);
            }
            else {
                this[CONSUMECHUNKSUB](chunk);
            }
            while (this[BUFFER] &&
                this[BUFFER]?.length >= 512 &&
                !this[ABORTED] &&
                !this[SAW_EOF]) {
                const c = this[BUFFER];
                this[BUFFER] = undefined;
                this[CONSUMECHUNKSUB](c);
            }
            this[CONSUMING] = false;
        }
        if (!this[BUFFER] || this[ENDED$2]) {
            this[MAYBEEND]();
        }
    }
    [CONSUMECHUNKSUB](chunk) {
        // we know that we are in CONSUMING mode, so anything written goes into
        // the buffer.  Advance the position and put any remainder in the buffer.
        let position = 0;
        const length = chunk.length;
        while (position + 512 <= length &&
            !this[ABORTED] &&
            !this[SAW_EOF]) {
            switch (this[STATE]) {
                case 'begin':
                case 'header':
                    this[CONSUMEHEADER](chunk, position);
                    position += 512;
                    break;
                case 'ignore':
                case 'body':
                    position += this[CONSUMEBODY](chunk, position);
                    break;
                case 'meta':
                    position += this[CONSUMEMETA](chunk, position);
                    break;
                /* c8 ignore start */
                default:
                    throw new Error('invalid state: ' + this[STATE]);
                /* c8 ignore stop */
            }
        }
        if (position < length) {
            if (this[BUFFER]) {
                this[BUFFER] = Buffer.concat([
                    chunk.subarray(position),
                    this[BUFFER],
                ]);
            }
            else {
                this[BUFFER] = chunk.subarray(position);
            }
        }
    }
    end(chunk, encoding, cb) {
        if (typeof chunk === 'function') {
            cb = chunk;
            encoding = undefined;
            chunk = undefined;
        }
        if (typeof encoding === 'function') {
            cb = encoding;
            encoding = undefined;
        }
        if (typeof chunk === 'string') {
            chunk = Buffer.from(chunk, encoding);
        }
        if (cb)
            this.once('finish', cb);
        if (!this[ABORTED]) {
            if (this[UNZIP]) {
                /* c8 ignore start */
                if (chunk)
                    this[UNZIP].write(chunk);
                /* c8 ignore stop */
                this[UNZIP].end();
            }
            else {
                this[ENDED$2] = true;
                if (this.brotli === undefined)
                    chunk = chunk || Buffer.alloc(0);
                if (chunk)
                    this.write(chunk);
                this[MAYBEEND]();
            }
        }
        return this;
    }
}

// warning: extremely hot code path.
// This has been meticulously optimized for use
// within npm install on large package trees.
// Do not edit without careful benchmarking.
const stripTrailingSlashes = (str) => {
    let i = str.length - 1;
    let slashesStart = -1;
    while (i > -1 && str.charAt(i) === '/') {
        slashesStart = i;
        i--;
    }
    return slashesStart === -1 ? str : str.slice(0, slashesStart);
};

// tar -t
const onReadEntryFunction = (opt) => {
    const onReadEntry = opt.onReadEntry;
    opt.onReadEntry =
        onReadEntry ?
            e => {
                onReadEntry(e);
                e.resume();
            }
            : e => e.resume();
};
// construct a filter that limits the file entries listed
// include child entries if a dir is included
const filesFilter = (opt, files) => {
    const map = new Map(files.map(f => [stripTrailingSlashes(f), true]));
    const filter = opt.filter;
    const mapHas = (file, r = '') => {
        const root = r || path.parse(file).root || '.';
        let ret;
        if (file === root)
            ret = false;
        else {
            const m = map.get(file);
            if (m !== undefined) {
                ret = m;
            }
            else {
                ret = mapHas(path.dirname(file), root);
            }
        }
        map.set(file, ret);
        return ret;
    };
    opt.filter =
        filter ?
            (file, entry) => filter(file, entry) && mapHas(stripTrailingSlashes(file))
            : file => mapHas(stripTrailingSlashes(file));
};
const listFileSync = (opt) => {
    const p = new Parser(opt);
    const file = opt.file;
    let fd;
    try {
        const stat = fs$1.statSync(file);
        const readSize = opt.maxReadSize || 16 * 1024 * 1024;
        if (stat.size < readSize) {
            p.end(fs$1.readFileSync(file));
        }
        else {
            let pos = 0;
            const buf = Buffer.allocUnsafe(readSize);
            fd = fs$1.openSync(file, 'r');
            while (pos < stat.size) {
                const bytesRead = fs$1.readSync(fd, buf, 0, readSize, pos);
                pos += bytesRead;
                p.write(buf.subarray(0, bytesRead));
            }
            p.end();
        }
    }
    finally {
        if (typeof fd === 'number') {
            try {
                fs$1.closeSync(fd);
                /* c8 ignore next */
            }
            catch (er) { }
        }
    }
};
const listFile = (opt, _files) => {
    const parse = new Parser(opt);
    const readSize = opt.maxReadSize || 16 * 1024 * 1024;
    const file = opt.file;
    const p = new Promise((resolve, reject) => {
        parse.on('error', reject);
        parse.on('end', resolve);
        fs$1.stat(file, (er, stat) => {
            if (er) {
                reject(er);
            }
            else {
                const stream = new ReadStream(file, {
                    readSize: readSize,
                    size: stat.size,
                });
                stream.on('error', reject);
                stream.pipe(parse);
            }
        });
    });
    return p;
};
const list = makeCommand(listFileSync, listFile, opt => new Parser(opt), opt => new Parser(opt), (opt, files) => {
    if (files?.length)
        filesFilter(opt, files);
    if (!opt.noResume)
        onReadEntryFunction(opt);
});

const modeFix = (mode, isDir, portable) => {
    mode &= 0o7777;
    // in portable mode, use the minimum reasonable umask
    // if this system creates files with 0o664 by default
    // (as some linux distros do), then we'll write the
    // archive with 0o644 instead.  Also, don't ever create
    // a file that is not readable/writable by the owner.
    if (portable) {
        mode = (mode | 0o600) & -19;
    }
    // if dirs are readable, then they should be listable
    if (isDir) {
        if (mode & 0o400) {
            mode |= 0o100;
        }
        if (mode & 0o40) {
            mode |= 0o10;
        }
        if (mode & 0o4) {
            mode |= 0o1;
        }
    }
    return mode;
};

// unix absolute paths are also absolute on win32, so we use this for both
const { isAbsolute, parse } = path$1.win32;
// returns [root, stripped]
// Note that windows will think that //x/y/z/a has a "root" of //x/y, and in
// those cases, we want to sanitize it to x/y/z/a, not z/a, so we strip /
// explicitly if it's the first character.
// drive-specific relative paths on Windows get their root stripped off even
// though they are not absolute, so `c:../foo` becomes ['c:', '../foo']
const stripAbsolutePath = (path) => {
    let r = '';
    let parsed = parse(path);
    while (isAbsolute(path) || parsed.root) {
        // windows will think that //x/y/z has a "root" of //x/y/
        // but strip the //?/C:/ off of //?/C:/path
        const root = path.charAt(0) === '/' && path.slice(0, 4) !== '//?/' ?
            '/'
            : parsed.root;
        path = path.slice(root.length);
        r += root;
        parsed = parse(path);
    }
    return [r, path];
};

// When writing files on Windows, translate the characters to their
// 0xf000 higher-encoded versions.
const raw = ['|', '<', '>', '?', ':'];
const win = raw.map(char => String.fromCharCode(0xf000 + char.charCodeAt(0)));
const toWin = new Map(raw.map((char, i) => [char, win[i]]));
const toRaw = new Map(win.map((char, i) => [char, raw[i]]));
const encode = (s) => raw.reduce((s, c) => s.split(c).join(toWin.get(c)), s);
const decode = (s) => win.reduce((s, c) => s.split(c).join(toRaw.get(c)), s);

const prefixPath = (path, prefix) => {
    if (!prefix) {
        return normalizeWindowsPath(path);
    }
    path = normalizeWindowsPath(path).replace(/^\.(\/|$)/, '');
    return stripTrailingSlashes(prefix) + '/' + path;
};
const maxReadSize = 16 * 1024 * 1024;
const PROCESS$1 = Symbol('process');
const FILE$1 = Symbol('file');
const DIRECTORY$1 = Symbol('directory');
const SYMLINK$1 = Symbol('symlink');
const HARDLINK$1 = Symbol('hardlink');
const HEADER = Symbol('header');
const READ = Symbol('read');
const LSTAT = Symbol('lstat');
const ONLSTAT = Symbol('onlstat');
const ONREAD = Symbol('onread');
const ONREADLINK = Symbol('onreadlink');
const OPENFILE = Symbol('openfile');
const ONOPENFILE = Symbol('onopenfile');
const CLOSE = Symbol('close');
const MODE = Symbol('mode');
const AWAITDRAIN = Symbol('awaitDrain');
const ONDRAIN$1 = Symbol('ondrain');
const PREFIX = Symbol('prefix');
class WriteEntry extends Minipass {
    path;
    portable;
    myuid = (process.getuid && process.getuid()) || 0;
    // until node has builtin pwnam functions, this'll have to do
    myuser = process.env.USER || '';
    maxReadSize;
    linkCache;
    statCache;
    preservePaths;
    cwd;
    strict;
    mtime;
    noPax;
    noMtime;
    prefix;
    fd;
    blockLen = 0;
    blockRemain = 0;
    buf;
    pos = 0;
    remain = 0;
    length = 0;
    offset = 0;
    win32;
    absolute;
    header;
    type;
    linkpath;
    stat;
    onWriteEntry;
    #hadError = false;
    constructor(p, opt_ = {}) {
        const opt = dealias(opt_);
        super();
        this.path = normalizeWindowsPath(p);
        // suppress atime, ctime, uid, gid, uname, gname
        this.portable = !!opt.portable;
        this.maxReadSize = opt.maxReadSize || maxReadSize;
        this.linkCache = opt.linkCache || new Map();
        this.statCache = opt.statCache || new Map();
        this.preservePaths = !!opt.preservePaths;
        this.cwd = normalizeWindowsPath(opt.cwd || process.cwd());
        this.strict = !!opt.strict;
        this.noPax = !!opt.noPax;
        this.noMtime = !!opt.noMtime;
        this.mtime = opt.mtime;
        this.prefix =
            opt.prefix ? normalizeWindowsPath(opt.prefix) : undefined;
        this.onWriteEntry = opt.onWriteEntry;
        if (typeof opt.onwarn === 'function') {
            this.on('warn', opt.onwarn);
        }
        let pathWarn = false;
        if (!this.preservePaths) {
            const [root, stripped] = stripAbsolutePath(this.path);
            if (root && typeof stripped === 'string') {
                this.path = stripped;
                pathWarn = root;
            }
        }
        this.win32 = !!opt.win32 || process.platform === 'win32';
        if (this.win32) {
            // force the \ to / normalization, since we might not *actually*
            // be on windows, but want \ to be considered a path separator.
            this.path = decode(this.path.replace(/\\/g, '/'));
            p = p.replace(/\\/g, '/');
        }
        this.absolute = normalizeWindowsPath(opt.absolute || path.resolve(this.cwd, p));
        if (this.path === '') {
            this.path = './';
        }
        if (pathWarn) {
            this.warn('TAR_ENTRY_INFO', `stripping ${pathWarn} from absolute path`, {
                entry: this,
                path: pathWarn + this.path,
            });
        }
        const cs = this.statCache.get(this.absolute);
        if (cs) {
            this[ONLSTAT](cs);
        }
        else {
            this[LSTAT]();
        }
    }
    warn(code, message, data = {}) {
        return warnMethod(this, code, message, data);
    }
    emit(ev, ...data) {
        if (ev === 'error') {
            this.#hadError = true;
        }
        return super.emit(ev, ...data);
    }
    [LSTAT]() {
        fs.lstat(this.absolute, (er, stat) => {
            if (er) {
                return this.emit('error', er);
            }
            this[ONLSTAT](stat);
        });
    }
    [ONLSTAT](stat) {
        this.statCache.set(this.absolute, stat);
        this.stat = stat;
        if (!stat.isFile()) {
            stat.size = 0;
        }
        this.type = getType(stat);
        this.emit('stat', stat);
        this[PROCESS$1]();
    }
    [PROCESS$1]() {
        switch (this.type) {
            case 'File':
                return this[FILE$1]();
            case 'Directory':
                return this[DIRECTORY$1]();
            case 'SymbolicLink':
                return this[SYMLINK$1]();
            // unsupported types are ignored.
            default:
                return this.end();
        }
    }
    [MODE](mode) {
        return modeFix(mode, this.type === 'Directory', this.portable);
    }
    [PREFIX](path) {
        return prefixPath(path, this.prefix);
    }
    [HEADER]() {
        /* c8 ignore start */
        if (!this.stat) {
            throw new Error('cannot write header before stat');
        }
        /* c8 ignore stop */
        if (this.type === 'Directory' && this.portable) {
            this.noMtime = true;
        }
        this.onWriteEntry?.(this);
        this.header = new Header({
            path: this[PREFIX](this.path),
            // only apply the prefix to hard links.
            linkpath: this.type === 'Link' && this.linkpath !== undefined ?
                this[PREFIX](this.linkpath)
                : this.linkpath,
            // only the permissions and setuid/setgid/sticky bitflags
            // not the higher-order bits that specify file type
            mode: this[MODE](this.stat.mode),
            uid: this.portable ? undefined : this.stat.uid,
            gid: this.portable ? undefined : this.stat.gid,
            size: this.stat.size,
            mtime: this.noMtime ? undefined : this.mtime || this.stat.mtime,
            /* c8 ignore next */
            type: this.type === 'Unsupported' ? undefined : this.type,
            uname: this.portable ? undefined
                : this.stat.uid === this.myuid ? this.myuser
                    : '',
            atime: this.portable ? undefined : this.stat.atime,
            ctime: this.portable ? undefined : this.stat.ctime,
        });
        if (this.header.encode() && !this.noPax) {
            super.write(new Pax({
                atime: this.portable ? undefined : this.header.atime,
                ctime: this.portable ? undefined : this.header.ctime,
                gid: this.portable ? undefined : this.header.gid,
                mtime: this.noMtime ? undefined : (this.mtime || this.header.mtime),
                path: this[PREFIX](this.path),
                linkpath: this.type === 'Link' && this.linkpath !== undefined ?
                    this[PREFIX](this.linkpath)
                    : this.linkpath,
                size: this.header.size,
                uid: this.portable ? undefined : this.header.uid,
                uname: this.portable ? undefined : this.header.uname,
                dev: this.portable ? undefined : this.stat.dev,
                ino: this.portable ? undefined : this.stat.ino,
                nlink: this.portable ? undefined : this.stat.nlink,
            }).encode());
        }
        const block = this.header?.block;
        /* c8 ignore start */
        if (!block) {
            throw new Error('failed to encode header');
        }
        /* c8 ignore stop */
        super.write(block);
    }
    [DIRECTORY$1]() {
        /* c8 ignore start */
        if (!this.stat) {
            throw new Error('cannot create directory entry without stat');
        }
        /* c8 ignore stop */
        if (this.path.slice(-1) !== '/') {
            this.path += '/';
        }
        this.stat.size = 0;
        this[HEADER]();
        this.end();
    }
    [SYMLINK$1]() {
        fs.readlink(this.absolute, (er, linkpath) => {
            if (er) {
                return this.emit('error', er);
            }
            this[ONREADLINK](linkpath);
        });
    }
    [ONREADLINK](linkpath) {
        this.linkpath = normalizeWindowsPath(linkpath);
        this[HEADER]();
        this.end();
    }
    [HARDLINK$1](linkpath) {
        /* c8 ignore start */
        if (!this.stat) {
            throw new Error('cannot create link entry without stat');
        }
        /* c8 ignore stop */
        this.type = 'Link';
        this.linkpath = normalizeWindowsPath(path.relative(this.cwd, linkpath));
        this.stat.size = 0;
        this[HEADER]();
        this.end();
    }
    [FILE$1]() {
        /* c8 ignore start */
        if (!this.stat) {
            throw new Error('cannot create file entry without stat');
        }
        /* c8 ignore stop */
        if (this.stat.nlink > 1) {
            const linkKey = `${this.stat.dev}:${this.stat.ino}`;
            const linkpath = this.linkCache.get(linkKey);
            if (linkpath?.indexOf(this.cwd) === 0) {
                return this[HARDLINK$1](linkpath);
            }
            this.linkCache.set(linkKey, this.absolute);
        }
        this[HEADER]();
        if (this.stat.size === 0) {
            return this.end();
        }
        this[OPENFILE]();
    }
    [OPENFILE]() {
        fs.open(this.absolute, 'r', (er, fd) => {
            if (er) {
                return this.emit('error', er);
            }
            this[ONOPENFILE](fd);
        });
    }
    [ONOPENFILE](fd) {
        this.fd = fd;
        if (this.#hadError) {
            return this[CLOSE]();
        }
        /* c8 ignore start */
        if (!this.stat) {
            throw new Error('should stat before calling onopenfile');
        }
        /* c8 ignore start */
        this.blockLen = 512 * Math.ceil(this.stat.size / 512);
        this.blockRemain = this.blockLen;
        const bufLen = Math.min(this.blockLen, this.maxReadSize);
        this.buf = Buffer.allocUnsafe(bufLen);
        this.offset = 0;
        this.pos = 0;
        this.remain = this.stat.size;
        this.length = this.buf.length;
        this[READ]();
    }
    [READ]() {
        const { fd, buf, offset, length, pos } = this;
        if (fd === undefined || buf === undefined) {
            throw new Error('cannot read file without first opening');
        }
        fs.read(fd, buf, offset, length, pos, (er, bytesRead) => {
            if (er) {
                // ignoring the error from close(2) is a bad practice, but at
                // this point we already have an error, don't need another one
                return this[CLOSE](() => this.emit('error', er));
            }
            this[ONREAD](bytesRead);
        });
    }
    /* c8 ignore start */
    [CLOSE](cb = () => { }) {
        /* c8 ignore stop */
        if (this.fd !== undefined)
            fs.close(this.fd, cb);
    }
    [ONREAD](bytesRead) {
        if (bytesRead <= 0 && this.remain > 0) {
            const er = Object.assign(new Error('encountered unexpected EOF'), {
                path: this.absolute,
                syscall: 'read',
                code: 'EOF',
            });
            return this[CLOSE](() => this.emit('error', er));
        }
        if (bytesRead > this.remain) {
            const er = Object.assign(new Error('did not encounter expected EOF'), {
                path: this.absolute,
                syscall: 'read',
                code: 'EOF',
            });
            return this[CLOSE](() => this.emit('error', er));
        }
        /* c8 ignore start */
        if (!this.buf) {
            throw new Error('should have created buffer prior to reading');
        }
        /* c8 ignore stop */
        // null out the rest of the buffer, if we could fit the block padding
        // at the end of this loop, we've incremented bytesRead and this.remain
        // to be incremented up to the blockRemain level, as if we had expected
        // to get a null-padded file, and read it until the end.  then we will
        // decrement both remain and blockRemain by bytesRead, and know that we
        // reached the expected EOF, without any null buffer to append.
        if (bytesRead === this.remain) {
            for (let i = bytesRead; i < this.length && bytesRead < this.blockRemain; i++) {
                this.buf[i + this.offset] = 0;
                bytesRead++;
                this.remain++;
            }
        }
        const chunk = this.offset === 0 && bytesRead === this.buf.length ?
            this.buf
            : this.buf.subarray(this.offset, this.offset + bytesRead);
        const flushed = this.write(chunk);
        if (!flushed) {
            this[AWAITDRAIN](() => this[ONDRAIN$1]());
        }
        else {
            this[ONDRAIN$1]();
        }
    }
    [AWAITDRAIN](cb) {
        this.once('drain', cb);
    }
    write(chunk, encoding, cb) {
        /* c8 ignore start - just junk to comply with NodeJS.WritableStream */
        if (typeof encoding === 'function') {
            cb = encoding;
            encoding = undefined;
        }
        if (typeof chunk === 'string') {
            chunk = Buffer.from(chunk, typeof encoding === 'string' ? encoding : 'utf8');
        }
        /* c8 ignore stop */
        if (this.blockRemain < chunk.length) {
            const er = Object.assign(new Error('writing more data than expected'), {
                path: this.absolute,
            });
            return this.emit('error', er);
        }
        this.remain -= chunk.length;
        this.blockRemain -= chunk.length;
        this.pos += chunk.length;
        this.offset += chunk.length;
        return super.write(chunk, null, cb);
    }
    [ONDRAIN$1]() {
        if (!this.remain) {
            if (this.blockRemain) {
                super.write(Buffer.alloc(this.blockRemain));
            }
            return this[CLOSE](er => er ? this.emit('error', er) : this.end());
        }
        /* c8 ignore start */
        if (!this.buf) {
            throw new Error('buffer lost somehow in ONDRAIN');
        }
        /* c8 ignore stop */
        if (this.offset >= this.length) {
            // if we only have a smaller bit left to read, alloc a smaller buffer
            // otherwise, keep it the same length it was before.
            this.buf = Buffer.allocUnsafe(Math.min(this.blockRemain, this.buf.length));
            this.offset = 0;
        }
        this.length = this.buf.length - this.offset;
        this[READ]();
    }
}
class WriteEntrySync extends WriteEntry {
    sync = true;
    [LSTAT]() {
        this[ONLSTAT](fs.lstatSync(this.absolute));
    }
    [SYMLINK$1]() {
        this[ONREADLINK](fs.readlinkSync(this.absolute));
    }
    [OPENFILE]() {
        this[ONOPENFILE](fs.openSync(this.absolute, 'r'));
    }
    [READ]() {
        let threw = true;
        try {
            const { fd, buf, offset, length, pos } = this;
            /* c8 ignore start */
            if (fd === undefined || buf === undefined) {
                throw new Error('fd and buf must be set in READ method');
            }
            /* c8 ignore stop */
            const bytesRead = fs.readSync(fd, buf, offset, length, pos);
            this[ONREAD](bytesRead);
            threw = false;
        }
        finally {
            // ignoring the error from close(2) is a bad practice, but at
            // this point we already have an error, don't need another one
            if (threw) {
                try {
                    this[CLOSE](() => { });
                }
                catch (er) { }
            }
        }
    }
    [AWAITDRAIN](cb) {
        cb();
    }
    /* c8 ignore start */
    [CLOSE](cb = () => { }) {
        /* c8 ignore stop */
        if (this.fd !== undefined)
            fs.closeSync(this.fd);
        cb();
    }
}
class WriteEntryTar extends Minipass {
    blockLen = 0;
    blockRemain = 0;
    buf = 0;
    pos = 0;
    remain = 0;
    length = 0;
    preservePaths;
    portable;
    strict;
    noPax;
    noMtime;
    readEntry;
    type;
    prefix;
    path;
    mode;
    uid;
    gid;
    uname;
    gname;
    header;
    mtime;
    atime;
    ctime;
    linkpath;
    size;
    onWriteEntry;
    warn(code, message, data = {}) {
        return warnMethod(this, code, message, data);
    }
    constructor(readEntry, opt_ = {}) {
        const opt = dealias(opt_);
        super();
        this.preservePaths = !!opt.preservePaths;
        this.portable = !!opt.portable;
        this.strict = !!opt.strict;
        this.noPax = !!opt.noPax;
        this.noMtime = !!opt.noMtime;
        this.onWriteEntry = opt.onWriteEntry;
        this.readEntry = readEntry;
        const { type } = readEntry;
        /* c8 ignore start */
        if (type === 'Unsupported') {
            throw new Error('writing entry that should be ignored');
        }
        /* c8 ignore stop */
        this.type = type;
        if (this.type === 'Directory' && this.portable) {
            this.noMtime = true;
        }
        this.prefix = opt.prefix;
        this.path = normalizeWindowsPath(readEntry.path);
        this.mode =
            readEntry.mode !== undefined ?
                this[MODE](readEntry.mode)
                : undefined;
        this.uid = this.portable ? undefined : readEntry.uid;
        this.gid = this.portable ? undefined : readEntry.gid;
        this.uname = this.portable ? undefined : readEntry.uname;
        this.gname = this.portable ? undefined : readEntry.gname;
        this.size = readEntry.size;
        this.mtime =
            this.noMtime ? undefined : opt.mtime || readEntry.mtime;
        this.atime = this.portable ? undefined : readEntry.atime;
        this.ctime = this.portable ? undefined : readEntry.ctime;
        this.linkpath =
            readEntry.linkpath !== undefined ?
                normalizeWindowsPath(readEntry.linkpath)
                : undefined;
        if (typeof opt.onwarn === 'function') {
            this.on('warn', opt.onwarn);
        }
        let pathWarn = false;
        if (!this.preservePaths) {
            const [root, stripped] = stripAbsolutePath(this.path);
            if (root && typeof stripped === 'string') {
                this.path = stripped;
                pathWarn = root;
            }
        }
        this.remain = readEntry.size;
        this.blockRemain = readEntry.startBlockSize;
        this.onWriteEntry?.(this);
        this.header = new Header({
            path: this[PREFIX](this.path),
            linkpath: this.type === 'Link' && this.linkpath !== undefined ?
                this[PREFIX](this.linkpath)
                : this.linkpath,
            // only the permissions and setuid/setgid/sticky bitflags
            // not the higher-order bits that specify file type
            mode: this.mode,
            uid: this.portable ? undefined : this.uid,
            gid: this.portable ? undefined : this.gid,
            size: this.size,
            mtime: this.noMtime ? undefined : this.mtime,
            type: this.type,
            uname: this.portable ? undefined : this.uname,
            atime: this.portable ? undefined : this.atime,
            ctime: this.portable ? undefined : this.ctime,
        });
        if (pathWarn) {
            this.warn('TAR_ENTRY_INFO', `stripping ${pathWarn} from absolute path`, {
                entry: this,
                path: pathWarn + this.path,
            });
        }
        if (this.header.encode() && !this.noPax) {
            super.write(new Pax({
                atime: this.portable ? undefined : this.atime,
                ctime: this.portable ? undefined : this.ctime,
                gid: this.portable ? undefined : this.gid,
                mtime: this.noMtime ? undefined : this.mtime,
                path: this[PREFIX](this.path),
                linkpath: this.type === 'Link' && this.linkpath !== undefined ?
                    this[PREFIX](this.linkpath)
                    : this.linkpath,
                size: this.size,
                uid: this.portable ? undefined : this.uid,
                uname: this.portable ? undefined : this.uname,
                dev: this.portable ? undefined : this.readEntry.dev,
                ino: this.portable ? undefined : this.readEntry.ino,
                nlink: this.portable ? undefined : this.readEntry.nlink,
            }).encode());
        }
        const b = this.header?.block;
        /* c8 ignore start */
        if (!b)
            throw new Error('failed to encode header');
        /* c8 ignore stop */
        super.write(b);
        readEntry.pipe(this);
    }
    [PREFIX](path) {
        return prefixPath(path, this.prefix);
    }
    [MODE](mode) {
        return modeFix(mode, this.type === 'Directory', this.portable);
    }
    write(chunk, encoding, cb) {
        /* c8 ignore start - just junk to comply with NodeJS.WritableStream */
        if (typeof encoding === 'function') {
            cb = encoding;
            encoding = undefined;
        }
        if (typeof chunk === 'string') {
            chunk = Buffer.from(chunk, typeof encoding === 'string' ? encoding : 'utf8');
        }
        /* c8 ignore stop */
        const writeLen = chunk.length;
        if (writeLen > this.blockRemain) {
            throw new Error('writing more to entry than is appropriate');
        }
        this.blockRemain -= writeLen;
        return super.write(chunk, cb);
    }
    end(chunk, encoding, cb) {
        if (this.blockRemain) {
            super.write(Buffer.alloc(this.blockRemain));
        }
        /* c8 ignore start - just junk to comply with NodeJS.WritableStream */
        if (typeof chunk === 'function') {
            cb = chunk;
            encoding = undefined;
            chunk = undefined;
        }
        if (typeof encoding === 'function') {
            cb = encoding;
            encoding = undefined;
        }
        if (typeof chunk === 'string') {
            chunk = Buffer.from(chunk, encoding ?? 'utf8');
        }
        if (cb)
            this.once('finish', cb);
        chunk ? super.end(chunk, cb) : super.end(cb);
        /* c8 ignore stop */
        return this;
    }
}
const getType = (stat) => stat.isFile() ? 'File'
    : stat.isDirectory() ? 'Directory'
        : stat.isSymbolicLink() ? 'SymbolicLink'
            : 'Unsupported';

// A readable tar stream creator
// Technically, this is a transform stream that you write paths into,
// and tar format comes out of.
// The `add()` method is like `write()` but returns this,
// and end() return `this` as well, so you can
// do `new Pack(opt).add('files').add('dir').end().pipe(output)
// You could also do something like:
// streamOfPaths().pipe(new Pack()).pipe(new fs.WriteStream('out.tar'))
class PackJob {
    path;
    absolute;
    entry;
    stat;
    readdir;
    pending = false;
    ignore = false;
    piped = false;
    constructor(path, absolute) {
        this.path = path || './';
        this.absolute = absolute;
    }
}
const EOF = Buffer.alloc(1024);
const ONSTAT = Symbol('onStat');
const ENDED$1 = Symbol('ended');
const QUEUE = Symbol('queue');
const CURRENT = Symbol('current');
const PROCESS = Symbol('process');
const PROCESSING = Symbol('processing');
const PROCESSJOB = Symbol('processJob');
const JOBS = Symbol('jobs');
const JOBDONE = Symbol('jobDone');
const ADDFSENTRY = Symbol('addFSEntry');
const ADDTARENTRY = Symbol('addTarEntry');
const STAT = Symbol('stat');
const READDIR = Symbol('readdir');
const ONREADDIR = Symbol('onreaddir');
const PIPE = Symbol('pipe');
const ENTRY = Symbol('entry');
const ENTRYOPT = Symbol('entryOpt');
const WRITEENTRYCLASS = Symbol('writeEntryClass');
const WRITE = Symbol('write');
const ONDRAIN = Symbol('ondrain');
class Pack extends Minipass {
    opt;
    cwd;
    maxReadSize;
    preservePaths;
    strict;
    noPax;
    prefix;
    linkCache;
    statCache;
    file;
    portable;
    zip;
    readdirCache;
    noDirRecurse;
    follow;
    noMtime;
    mtime;
    filter;
    jobs;
    [WRITEENTRYCLASS];
    onWriteEntry;
    [QUEUE];
    [JOBS] = 0;
    [PROCESSING] = false;
    [ENDED$1] = false;
    constructor(opt = {}) {
        //@ts-ignore
        super();
        this.opt = opt;
        this.file = opt.file || '';
        this.cwd = opt.cwd || process.cwd();
        this.maxReadSize = opt.maxReadSize;
        this.preservePaths = !!opt.preservePaths;
        this.strict = !!opt.strict;
        this.noPax = !!opt.noPax;
        this.prefix = normalizeWindowsPath(opt.prefix || '');
        this.linkCache = opt.linkCache || new Map();
        this.statCache = opt.statCache || new Map();
        this.readdirCache = opt.readdirCache || new Map();
        this.onWriteEntry = opt.onWriteEntry;
        this[WRITEENTRYCLASS] = WriteEntry;
        if (typeof opt.onwarn === 'function') {
            this.on('warn', opt.onwarn);
        }
        this.portable = !!opt.portable;
        if (opt.gzip || opt.brotli) {
            if (opt.gzip && opt.brotli) {
                throw new TypeError('gzip and brotli are mutually exclusive');
            }
            if (opt.gzip) {
                if (typeof opt.gzip !== 'object') {
                    opt.gzip = {};
                }
                if (this.portable) {
                    opt.gzip.portable = true;
                }
                this.zip = new Gzip(opt.gzip);
            }
            if (opt.brotli) {
                if (typeof opt.brotli !== 'object') {
                    opt.brotli = {};
                }
                this.zip = new BrotliCompress(opt.brotli);
            }
            /* c8 ignore next */
            if (!this.zip)
                throw new Error('impossible');
            const zip = this.zip;
            zip.on('data', chunk => super.write(chunk));
            zip.on('end', () => super.end());
            zip.on('drain', () => this[ONDRAIN]());
            this.on('resume', () => zip.resume());
        }
        else {
            this.on('drain', this[ONDRAIN]);
        }
        this.noDirRecurse = !!opt.noDirRecurse;
        this.follow = !!opt.follow;
        this.noMtime = !!opt.noMtime;
        if (opt.mtime)
            this.mtime = opt.mtime;
        this.filter =
            typeof opt.filter === 'function' ? opt.filter : () => true;
        this[QUEUE] = new Yallist();
        this[JOBS] = 0;
        this.jobs = Number(opt.jobs) || 4;
        this[PROCESSING] = false;
        this[ENDED$1] = false;
    }
    [WRITE](chunk) {
        return super.write(chunk);
    }
    add(path) {
        this.write(path);
        return this;
    }
    end(path, encoding, cb) {
        /* c8 ignore start */
        if (typeof path === 'function') {
            cb = path;
            path = undefined;
        }
        if (typeof encoding === 'function') {
            cb = encoding;
            encoding = undefined;
        }
        /* c8 ignore stop */
        if (path) {
            this.add(path);
        }
        this[ENDED$1] = true;
        this[PROCESS]();
        /* c8 ignore next */
        if (cb)
            cb();
        return this;
    }
    write(path) {
        if (this[ENDED$1]) {
            throw new Error('write after end');
        }
        if (path instanceof ReadEntry) {
            this[ADDTARENTRY](path);
        }
        else {
            this[ADDFSENTRY](path);
        }
        return this.flowing;
    }
    [ADDTARENTRY](p) {
        const absolute = normalizeWindowsPath(path.resolve(this.cwd, p.path));
        // in this case, we don't have to wait for the stat
        if (!this.filter(p.path, p)) {
            p.resume();
        }
        else {
            const job = new PackJob(p.path, absolute);
            job.entry = new WriteEntryTar(p, this[ENTRYOPT](job));
            job.entry.on('end', () => this[JOBDONE](job));
            this[JOBS] += 1;
            this[QUEUE].push(job);
        }
        this[PROCESS]();
    }
    [ADDFSENTRY](p) {
        const absolute = normalizeWindowsPath(path.resolve(this.cwd, p));
        this[QUEUE].push(new PackJob(p, absolute));
        this[PROCESS]();
    }
    [STAT](job) {
        job.pending = true;
        this[JOBS] += 1;
        const stat = this.follow ? 'stat' : 'lstat';
        fs[stat](job.absolute, (er, stat) => {
            job.pending = false;
            this[JOBS] -= 1;
            if (er) {
                this.emit('error', er);
            }
            else {
                this[ONSTAT](job, stat);
            }
        });
    }
    [ONSTAT](job, stat) {
        this.statCache.set(job.absolute, stat);
        job.stat = stat;
        // now we have the stat, we can filter it.
        if (!this.filter(job.path, stat)) {
            job.ignore = true;
        }
        this[PROCESS]();
    }
    [READDIR](job) {
        job.pending = true;
        this[JOBS] += 1;
        fs.readdir(job.absolute, (er, entries) => {
            job.pending = false;
            this[JOBS] -= 1;
            if (er) {
                return this.emit('error', er);
            }
            this[ONREADDIR](job, entries);
        });
    }
    [ONREADDIR](job, entries) {
        this.readdirCache.set(job.absolute, entries);
        job.readdir = entries;
        this[PROCESS]();
    }
    [PROCESS]() {
        if (this[PROCESSING]) {
            return;
        }
        this[PROCESSING] = true;
        for (let w = this[QUEUE].head; !!w && this[JOBS] < this.jobs; w = w.next) {
            this[PROCESSJOB](w.value);
            if (w.value.ignore) {
                const p = w.next;
                this[QUEUE].removeNode(w);
                w.next = p;
            }
        }
        this[PROCESSING] = false;
        if (this[ENDED$1] && !this[QUEUE].length && this[JOBS] === 0) {
            if (this.zip) {
                this.zip.end(EOF);
            }
            else {
                super.write(EOF);
                super.end();
            }
        }
    }
    get [CURRENT]() {
        return this[QUEUE] && this[QUEUE].head && this[QUEUE].head.value;
    }
    [JOBDONE](_job) {
        this[QUEUE].shift();
        this[JOBS] -= 1;
        this[PROCESS]();
    }
    [PROCESSJOB](job) {
        if (job.pending) {
            return;
        }
        if (job.entry) {
            if (job === this[CURRENT] && !job.piped) {
                this[PIPE](job);
            }
            return;
        }
        if (!job.stat) {
            const sc = this.statCache.get(job.absolute);
            if (sc) {
                this[ONSTAT](job, sc);
            }
            else {
                this[STAT](job);
            }
        }
        if (!job.stat) {
            return;
        }
        // filtered out!
        if (job.ignore) {
            return;
        }
        if (!this.noDirRecurse &&
            job.stat.isDirectory() &&
            !job.readdir) {
            const rc = this.readdirCache.get(job.absolute);
            if (rc) {
                this[ONREADDIR](job, rc);
            }
            else {
                this[READDIR](job);
            }
            if (!job.readdir) {
                return;
            }
        }
        // we know it doesn't have an entry, because that got checked above
        job.entry = this[ENTRY](job);
        if (!job.entry) {
            job.ignore = true;
            return;
        }
        if (job === this[CURRENT] && !job.piped) {
            this[PIPE](job);
        }
    }
    [ENTRYOPT](job) {
        return {
            onwarn: (code, msg, data) => this.warn(code, msg, data),
            noPax: this.noPax,
            cwd: this.cwd,
            absolute: job.absolute,
            preservePaths: this.preservePaths,
            maxReadSize: this.maxReadSize,
            strict: this.strict,
            portable: this.portable,
            linkCache: this.linkCache,
            statCache: this.statCache,
            noMtime: this.noMtime,
            mtime: this.mtime,
            prefix: this.prefix,
            onWriteEntry: this.onWriteEntry,
        };
    }
    [ENTRY](job) {
        this[JOBS] += 1;
        try {
            const e = new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job));
            return e
                .on('end', () => this[JOBDONE](job))
                .on('error', er => this.emit('error', er));
        }
        catch (er) {
            this.emit('error', er);
        }
    }
    [ONDRAIN]() {
        if (this[CURRENT] && this[CURRENT].entry) {
            this[CURRENT].entry.resume();
        }
    }
    // like .pipe() but using super, because our write() is special
    [PIPE](job) {
        job.piped = true;
        if (job.readdir) {
            job.readdir.forEach(entry => {
                const p = job.path;
                const base = p === './' ? '' : p.replace(/\/*$/, '/');
                this[ADDFSENTRY](base + entry);
            });
        }
        const source = job.entry;
        const zip = this.zip;
        /* c8 ignore start */
        if (!source)
            throw new Error('cannot pipe without source');
        /* c8 ignore stop */
        if (zip) {
            source.on('data', chunk => {
                if (!zip.write(chunk)) {
                    source.pause();
                }
            });
        }
        else {
            source.on('data', chunk => {
                if (!super.write(chunk)) {
                    source.pause();
                }
            });
        }
    }
    pause() {
        if (this.zip) {
            this.zip.pause();
        }
        return super.pause();
    }
    warn(code, message, data = {}) {
        warnMethod(this, code, message, data);
    }
}
class PackSync extends Pack {
    sync = true;
    constructor(opt) {
        super(opt);
        this[WRITEENTRYCLASS] = WriteEntrySync;
    }
    // pause/resume are no-ops in sync streams.
    pause() { }
    resume() { }
    [STAT](job) {
        const stat = this.follow ? 'statSync' : 'lstatSync';
        this[ONSTAT](job, fs[stat](job.absolute));
    }
    [READDIR](job) {
        this[ONREADDIR](job, fs.readdirSync(job.absolute));
    }
    // gotta get it all in this tick
    [PIPE](job) {
        const source = job.entry;
        const zip = this.zip;
        if (job.readdir) {
            job.readdir.forEach(entry => {
                const p = job.path;
                const base = p === './' ? '' : p.replace(/\/*$/, '/');
                this[ADDFSENTRY](base + entry);
            });
        }
        /* c8 ignore start */
        if (!source)
            throw new Error('Cannot pipe without source');
        /* c8 ignore stop */
        if (zip) {
            source.on('data', chunk => {
                zip.write(chunk);
            });
        }
        else {
            source.on('data', chunk => {
                super[WRITE](chunk);
            });
        }
    }
}

const createFileSync = (opt, files) => {
    const p = new PackSync(opt);
    const stream = new WriteStreamSync(opt.file, {
        mode: opt.mode || 0o666,
    });
    p.pipe(stream);
    addFilesSync$1(p, files);
};
const createFile = (opt, files) => {
    const p = new Pack(opt);
    const stream = new WriteStream(opt.file, {
        mode: opt.mode || 0o666,
    });
    p.pipe(stream);
    const promise = new Promise((res, rej) => {
        stream.on('error', rej);
        stream.on('close', res);
        p.on('error', rej);
    });
    addFilesAsync$1(p, files);
    return promise;
};
const addFilesSync$1 = (p, files) => {
    files.forEach(file => {
        if (file.charAt(0) === '@') {
            list({
                file: path$1.resolve(p.cwd, file.slice(1)),
                sync: true,
                noResume: true,
                onReadEntry: entry => p.add(entry),
            });
        }
        else {
            p.add(file);
        }
    });
    p.end();
};
const addFilesAsync$1 = async (p, files) => {
    for (let i = 0; i < files.length; i++) {
        const file = String(files[i]);
        if (file.charAt(0) === '@') {
            await list({
                file: path$1.resolve(String(p.cwd), file.slice(1)),
                noResume: true,
                onReadEntry: entry => {
                    p.add(entry);
                },
            });
        }
        else {
            p.add(file);
        }
    }
    p.end();
};
const createSync = (opt, files) => {
    const p = new PackSync(opt);
    addFilesSync$1(p, files);
    return p;
};
const createAsync = (opt, files) => {
    const p = new Pack(opt);
    addFilesAsync$1(p, files);
    return p;
};
makeCommand(createFileSync, createFile, createSync, createAsync, (_opt, files) => {
    if (!files?.length) {
        throw new TypeError('no paths specified to add to archive');
    }
});

// Get the appropriate flag to use for creating files
// We use fmap on Windows platforms for files less than
// 512kb.  This is a fairly low limit, but avoids making
// things slower in some cases.  Since most of what this
// library is used for is extracting tarballs of many
// relatively small files in npm packages and the like,
// it can be a big boost on Windows platforms.
const platform$3 = process.env.__FAKE_PLATFORM__ || process.platform;
const isWindows$2 = platform$3 === 'win32';
/* c8 ignore start */
const { O_CREAT, O_TRUNC, O_WRONLY } = fs.constants;
const UV_FS_O_FILEMAP = Number(process.env.__FAKE_FS_O_FILENAME__) ||
    fs.constants.UV_FS_O_FILEMAP ||
    0;
/* c8 ignore stop */
const fMapEnabled = isWindows$2 && !!UV_FS_O_FILEMAP;
const fMapLimit = 512 * 1024;
const fMapFlag = UV_FS_O_FILEMAP | O_TRUNC | O_CREAT | O_WRONLY;
const getWriteFlag = !fMapEnabled ?
    () => 'w'
    : (size) => (size < fMapLimit ? fMapFlag : 'w');

const lchownSync = (path, uid, gid) => {
    try {
        return fs$1.lchownSync(path, uid, gid);
    }
    catch (er) {
        if (er?.code !== 'ENOENT')
            throw er;
    }
};
const chown = (cpath, uid, gid, cb) => {
    fs$1.lchown(cpath, uid, gid, er => {
        // Skip ENOENT error
        cb(er && er?.code !== 'ENOENT' ? er : null);
    });
};
const chownrKid = (p, child, uid, gid, cb) => {
    if (child.isDirectory()) {
        chownr(path$1.resolve(p, child.name), uid, gid, (er) => {
            if (er)
                return cb(er);
            const cpath = path$1.resolve(p, child.name);
            chown(cpath, uid, gid, cb);
        });
    }
    else {
        const cpath = path$1.resolve(p, child.name);
        chown(cpath, uid, gid, cb);
    }
};
const chownr = (p, uid, gid, cb) => {
    fs$1.readdir(p, { withFileTypes: true }, (er, children) => {
        // any error other than ENOTDIR or ENOTSUP means it's not readable,
        // or doesn't exist.  give up.
        if (er) {
            if (er.code === 'ENOENT')
                return cb();
            else if (er.code !== 'ENOTDIR' && er.code !== 'ENOTSUP')
                return cb(er);
        }
        if (er || !children.length)
            return chown(p, uid, gid, cb);
        let len = children.length;
        let errState = null;
        const then = (er) => {
            /* c8 ignore start */
            if (errState)
                return;
            /* c8 ignore stop */
            if (er)
                return cb((errState = er));
            if (--len === 0)
                return chown(p, uid, gid, cb);
        };
        for (const child of children) {
            chownrKid(p, child, uid, gid, then);
        }
    });
};
const chownrKidSync = (p, child, uid, gid) => {
    if (child.isDirectory())
        chownrSync(path$1.resolve(p, child.name), uid, gid);
    lchownSync(path$1.resolve(p, child.name), uid, gid);
};
const chownrSync = (p, uid, gid) => {
    let children;
    try {
        children = fs$1.readdirSync(p, { withFileTypes: true });
    }
    catch (er) {
        const e = er;
        if (e?.code === 'ENOENT')
            return;
        else if (e?.code === 'ENOTDIR' || e?.code === 'ENOTSUP')
            return lchownSync(p, uid, gid);
        else
            throw e;
    }
    for (const child of children) {
        chownrKidSync(p, child, uid, gid);
    }
    return lchownSync(p, uid, gid);
};

const optsArg = (opts) => {
    if (!opts) {
        opts = { mode: 0o777 };
    }
    else if (typeof opts === 'object') {
        opts = { mode: 0o777, ...opts };
    }
    else if (typeof opts === 'number') {
        opts = { mode: opts };
    }
    else if (typeof opts === 'string') {
        opts = { mode: parseInt(opts, 8) };
    }
    else {
        throw new TypeError('invalid options argument');
    }
    const resolved = opts;
    const optsFs = opts.fs || {};
    opts.mkdir = opts.mkdir || optsFs.mkdir || fs.mkdir;
    opts.mkdirAsync = opts.mkdirAsync
        ? opts.mkdirAsync
        : async (path, options) => {
            return new Promise((res, rej) => resolved.mkdir(path, options, (er, made) => er ? rej(er) : res(made)));
        };
    opts.stat = opts.stat || optsFs.stat || fs.stat;
    opts.statAsync = opts.statAsync
        ? opts.statAsync
        : async (path) => new Promise((res, rej) => resolved.stat(path, (err, stats) => (err ? rej(err) : res(stats))));
    opts.statSync = opts.statSync || optsFs.statSync || fs.statSync;
    opts.mkdirSync = opts.mkdirSync || optsFs.mkdirSync || fs.mkdirSync;
    return resolved;
};

const mkdirpManualSync = (path$1, options, made) => {
    const parent = path.dirname(path$1);
    const opts = { ...optsArg(options), recursive: false };
    if (parent === path$1) {
        try {
            return opts.mkdirSync(path$1, opts);
        }
        catch (er) {
            // swallowed by recursive implementation on posix systems
            // any other error is a failure
            const fer = er;
            if (fer && fer.code !== 'EISDIR') {
                throw er;
            }
            return;
        }
    }
    try {
        opts.mkdirSync(path$1, opts);
        return made || path$1;
    }
    catch (er) {
        const fer = er;
        if (fer && fer.code === 'ENOENT') {
            return mkdirpManualSync(path$1, opts, mkdirpManualSync(parent, opts, made));
        }
        if (fer && fer.code !== 'EEXIST' && fer && fer.code !== 'EROFS') {
            throw er;
        }
        try {
            if (!opts.statSync(path$1).isDirectory())
                throw er;
        }
        catch (_) {
            throw er;
        }
    }
};
const mkdirpManual = Object.assign(async (path$1, options, made) => {
    const opts = optsArg(options);
    opts.recursive = false;
    const parent = path.dirname(path$1);
    if (parent === path$1) {
        return opts.mkdirAsync(path$1, opts).catch(er => {
            // swallowed by recursive implementation on posix systems
            // any other error is a failure
            const fer = er;
            if (fer && fer.code !== 'EISDIR') {
                throw er;
            }
        });
    }
    return opts.mkdirAsync(path$1, opts).then(() => made || path$1, async (er) => {
        const fer = er;
        if (fer && fer.code === 'ENOENT') {
            return mkdirpManual(parent, opts).then((made) => mkdirpManual(path$1, opts, made));
        }
        if (fer && fer.code !== 'EEXIST' && fer.code !== 'EROFS') {
            throw er;
        }
        return opts.statAsync(path$1).then(st => {
            if (st.isDirectory()) {
                return made;
            }
            else {
                throw er;
            }
        }, () => {
            throw er;
        });
    });
}, { sync: mkdirpManualSync });

const findMade = async (opts, parent, path$1) => {
    // we never want the 'made' return value to be a root directory
    if (path$1 === parent) {
        return;
    }
    return opts.statAsync(parent).then(st => (st.isDirectory() ? path$1 : undefined), // will fail later
    // will fail later
    er => {
        const fer = er;
        return fer && fer.code === 'ENOENT'
            ? findMade(opts, path.dirname(parent), parent)
            : undefined;
    });
};
const findMadeSync = (opts, parent, path$1) => {
    if (path$1 === parent) {
        return undefined;
    }
    try {
        return opts.statSync(parent).isDirectory() ? path$1 : undefined;
    }
    catch (er) {
        const fer = er;
        return fer && fer.code === 'ENOENT'
            ? findMadeSync(opts, path.dirname(parent), parent)
            : undefined;
    }
};

const mkdirpNativeSync = (path$1, options) => {
    const opts = optsArg(options);
    opts.recursive = true;
    const parent = path.dirname(path$1);
    if (parent === path$1) {
        return opts.mkdirSync(path$1, opts);
    }
    const made = findMadeSync(opts, path$1);
    try {
        opts.mkdirSync(path$1, opts);
        return made;
    }
    catch (er) {
        const fer = er;
        if (fer && fer.code === 'ENOENT') {
            return mkdirpManualSync(path$1, opts);
        }
        else {
            throw er;
        }
    }
};
const mkdirpNative = Object.assign(async (path$1, options) => {
    const opts = { ...optsArg(options), recursive: true };
    const parent = path.dirname(path$1);
    if (parent === path$1) {
        return await opts.mkdirAsync(path$1, opts);
    }
    return findMade(opts, path$1).then((made) => opts
        .mkdirAsync(path$1, opts)
        .then(m => made || m)
        .catch(er => {
        const fer = er;
        if (fer && fer.code === 'ENOENT') {
            return mkdirpManual(path$1, opts);
        }
        else {
            throw er;
        }
    }));
}, { sync: mkdirpNativeSync });

const platform$2 = process.env.__TESTING_MKDIRP_PLATFORM__ || process.platform;
const pathArg = (path$1) => {
    if (/\0/.test(path$1)) {
        // simulate same failure that node raises
        throw Object.assign(new TypeError('path must be a string without null bytes'), {
            path: path$1,
            code: 'ERR_INVALID_ARG_VALUE',
        });
    }
    path$1 = path.resolve(path$1);
    if (platform$2 === 'win32') {
        const badWinChars = /[*|"<>?:]/;
        const { root } = path.parse(path$1);
        if (badWinChars.test(path$1.substring(root.length))) {
            throw Object.assign(new Error('Illegal characters in path.'), {
                path: path$1,
                code: 'EINVAL',
            });
        }
    }
    return path$1;
};

const version = process.env.__TESTING_MKDIRP_NODE_VERSION__ || process.version;
const versArr = version.replace(/^v/, '').split('.');
const hasNative = +versArr[0] > 10 || (+versArr[0] === 10 && +versArr[1] >= 12);
const useNativeSync = !hasNative
    ? () => false
    : (opts) => optsArg(opts).mkdirSync === fs.mkdirSync;
const useNative = Object.assign(!hasNative
    ? () => false
    : (opts) => optsArg(opts).mkdir === fs.mkdir, {
    sync: useNativeSync,
});

/* c8 ignore stop */
const mkdirpSync = (path, opts) => {
    path = pathArg(path);
    const resolved = optsArg(opts);
    return useNativeSync(resolved)
        ? mkdirpNativeSync(path, resolved)
        : mkdirpManualSync(path, resolved);
};
const mkdirp = Object.assign(async (path, opts) => {
    path = pathArg(path);
    const resolved = optsArg(opts);
    return useNative(resolved)
        ? mkdirpNative(path, resolved)
        : mkdirpManual(path, resolved);
}, {
    mkdirpSync,
    mkdirpNative,
    mkdirpNativeSync,
    mkdirpManual,
    mkdirpManualSync,
    sync: mkdirpSync,
    native: mkdirpNative,
    nativeSync: mkdirpNativeSync,
    manual: mkdirpManual,
    manualSync: mkdirpManualSync,
    useNative,
    useNativeSync,
});

class CwdError extends Error {
    path;
    code;
    syscall = 'chdir';
    constructor(path, code) {
        super(`${code}: Cannot cd into '${path}'`);
        this.path = path;
        this.code = code;
    }
    get name() {
        return 'CwdError';
    }
}

class SymlinkError extends Error {
    path;
    symlink;
    syscall = 'symlink';
    code = 'TAR_SYMLINK_ERROR';
    constructor(symlink, path) {
        super('TAR_SYMLINK_ERROR: Cannot extract through symbolic link');
        this.symlink = symlink;
        this.path = path;
    }
    get name() {
        return 'SymlinkError';
    }
}

const cGet = (cache, key) => cache.get(normalizeWindowsPath(key));
const cSet = (cache, key, val) => cache.set(normalizeWindowsPath(key), val);
const checkCwd = (dir, cb) => {
    fs.stat(dir, (er, st) => {
        if (er || !st.isDirectory()) {
            er = new CwdError(dir, er?.code || 'ENOTDIR');
        }
        cb(er);
    });
};
/**
 * Wrapper around mkdirp for tar's needs.
 *
 * The main purpose is to avoid creating directories if we know that
 * they already exist (and track which ones exist for this purpose),
 * and prevent entries from being extracted into symlinked folders,
 * if `preservePaths` is not set.
 */
const mkdir = (dir, opt, cb) => {
    dir = normalizeWindowsPath(dir);
    // if there's any overlap between mask and mode,
    // then we'll need an explicit chmod
    /* c8 ignore next */
    const umask = opt.umask ?? 0o22;
    const mode = opt.mode | 0o0700;
    const needChmod = (mode & umask) !== 0;
    const uid = opt.uid;
    const gid = opt.gid;
    const doChown = typeof uid === 'number' &&
        typeof gid === 'number' &&
        (uid !== opt.processUid || gid !== opt.processGid);
    const preserve = opt.preserve;
    const unlink = opt.unlink;
    const cache = opt.cache;
    const cwd = normalizeWindowsPath(opt.cwd);
    const done = (er, created) => {
        if (er) {
            cb(er);
        }
        else {
            cSet(cache, dir, true);
            if (created && doChown) {
                chownr(created, uid, gid, er => done(er));
            }
            else if (needChmod) {
                fs.chmod(dir, mode, cb);
            }
            else {
                cb();
            }
        }
    };
    if (cache && cGet(cache, dir) === true) {
        return done();
    }
    if (dir === cwd) {
        return checkCwd(dir, done);
    }
    if (preserve) {
        return mkdirp(dir, { mode }).then(made => done(null, made ?? undefined), // oh, ts
        done);
    }
    const sub = normalizeWindowsPath(path$1.relative(cwd, dir));
    const parts = sub.split('/');
    mkdir_(cwd, parts, mode, cache, unlink, cwd, undefined, done);
};
const mkdir_ = (base, parts, mode, cache, unlink, cwd, created, cb) => {
    if (!parts.length) {
        return cb(null, created);
    }
    const p = parts.shift();
    const part = normalizeWindowsPath(path$1.resolve(base + '/' + p));
    if (cGet(cache, part)) {
        return mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);
    }
    fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb));
};
const onmkdir = (part, parts, mode, cache, unlink, cwd, created, cb) => (er) => {
    if (er) {
        fs.lstat(part, (statEr, st) => {
            if (statEr) {
                statEr.path =
                    statEr.path && normalizeWindowsPath(statEr.path);
                cb(statEr);
            }
            else if (st.isDirectory()) {
                mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);
            }
            else if (unlink) {
                fs.unlink(part, er => {
                    if (er) {
                        return cb(er);
                    }
                    fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb));
                });
            }
            else if (st.isSymbolicLink()) {
                return cb(new SymlinkError(part, part + '/' + parts.join('/')));
            }
            else {
                cb(er);
            }
        });
    }
    else {
        created = created || part;
        mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);
    }
};
const checkCwdSync = (dir) => {
    let ok = false;
    let code = undefined;
    try {
        ok = fs.statSync(dir).isDirectory();
    }
    catch (er) {
        code = er?.code;
    }
    finally {
        if (!ok) {
            throw new CwdError(dir, code ?? 'ENOTDIR');
        }
    }
};
const mkdirSync = (dir, opt) => {
    dir = normalizeWindowsPath(dir);
    // if there's any overlap between mask and mode,
    // then we'll need an explicit chmod
    /* c8 ignore next */
    const umask = opt.umask ?? 0o22;
    const mode = opt.mode | 0o700;
    const needChmod = (mode & umask) !== 0;
    const uid = opt.uid;
    const gid = opt.gid;
    const doChown = typeof uid === 'number' &&
        typeof gid === 'number' &&
        (uid !== opt.processUid || gid !== opt.processGid);
    const preserve = opt.preserve;
    const unlink = opt.unlink;
    const cache = opt.cache;
    const cwd = normalizeWindowsPath(opt.cwd);
    const done = (created) => {
        cSet(cache, dir, true);
        if (created && doChown) {
            chownrSync(created, uid, gid);
        }
        if (needChmod) {
            fs.chmodSync(dir, mode);
        }
    };
    if (cache && cGet(cache, dir) === true) {
        return done();
    }
    if (dir === cwd) {
        checkCwdSync(cwd);
        return done();
    }
    if (preserve) {
        return done(mkdirpSync(dir, mode) ?? undefined);
    }
    const sub = normalizeWindowsPath(path$1.relative(cwd, dir));
    const parts = sub.split('/');
    let created = undefined;
    for (let p = parts.shift(), part = cwd; p && (part += '/' + p); p = parts.shift()) {
        part = normalizeWindowsPath(path$1.resolve(part));
        if (cGet(cache, part)) {
            continue;
        }
        try {
            fs.mkdirSync(part, mode);
            created = created || part;
            cSet(cache, part, true);
        }
        catch (er) {
            const st = fs.lstatSync(part);
            if (st.isDirectory()) {
                cSet(cache, part, true);
                continue;
            }
            else if (unlink) {
                fs.unlinkSync(part);
                fs.mkdirSync(part, mode);
                created = created || part;
                cSet(cache, part, true);
                continue;
            }
            else if (st.isSymbolicLink()) {
                return new SymlinkError(part, part + '/' + parts.join('/'));
            }
        }
    }
    return done(created);
};

// warning: extremely hot code path.
// This has been meticulously optimized for use
// within npm install on large package trees.
// Do not edit without careful benchmarking.
const normalizeCache = Object.create(null);
const { hasOwnProperty } = Object.prototype;
const normalizeUnicode = (s) => {
    if (!hasOwnProperty.call(normalizeCache, s)) {
        normalizeCache[s] = s.normalize('NFD');
    }
    return normalizeCache[s];
};

// A path exclusive reservation system
// reserve([list, of, paths], fn)
// When the fn is first in line for all its paths, it
// is called with a cb that clears the reservation.
//
// Used by async unpack to avoid clobbering paths in use,
// while still allowing maximal safe parallelization.
const platform$1 = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;
const isWindows$1 = platform$1 === 'win32';
// return a set of parent dirs for a given path
// '/a/b/c/d' -> ['/', '/a', '/a/b', '/a/b/c', '/a/b/c/d']
const getDirs = (path) => {
    const dirs = path
        .split('/')
        .slice(0, -1)
        .reduce((set, path) => {
        const s = set[set.length - 1];
        if (s !== undefined) {
            path = path$1.join(s, path);
        }
        set.push(path || '/');
        return set;
    }, []);
    return dirs;
};
class PathReservations {
    // path => [function or Set]
    // A Set object means a directory reservation
    // A fn is a direct reservation on that path
    #queues = new Map();
    // fn => {paths:[path,...], dirs:[path, ...]}
    #reservations = new Map();
    // functions currently running
    #running = new Set();
    reserve(paths, fn) {
        paths =
            isWindows$1 ?
                ['win32 parallelization disabled']
                : paths.map(p => {
                    // don't need normPath, because we skip this entirely for windows
                    return stripTrailingSlashes(path$1.join(normalizeUnicode(p))).toLowerCase();
                });
        const dirs = new Set(paths.map(path => getDirs(path)).reduce((a, b) => a.concat(b)));
        this.#reservations.set(fn, { dirs, paths });
        for (const p of paths) {
            const q = this.#queues.get(p);
            if (!q) {
                this.#queues.set(p, [fn]);
            }
            else {
                q.push(fn);
            }
        }
        for (const dir of dirs) {
            const q = this.#queues.get(dir);
            if (!q) {
                this.#queues.set(dir, [new Set([fn])]);
            }
            else {
                const l = q[q.length - 1];
                if (l instanceof Set) {
                    l.add(fn);
                }
                else {
                    q.push(new Set([fn]));
                }
            }
        }
        return this.#run(fn);
    }
    // return the queues for each path the function cares about
    // fn => {paths, dirs}
    #getQueues(fn) {
        const res = this.#reservations.get(fn);
        /* c8 ignore start */
        if (!res) {
            throw new Error('function does not have any path reservations');
        }
        /* c8 ignore stop */
        return {
            paths: res.paths.map((path) => this.#queues.get(path)),
            dirs: [...res.dirs].map(path => this.#queues.get(path)),
        };
    }
    // check if fn is first in line for all its paths, and is
    // included in the first set for all its dir queues
    check(fn) {
        const { paths, dirs } = this.#getQueues(fn);
        return (paths.every(q => q && q[0] === fn) &&
            dirs.every(q => q && q[0] instanceof Set && q[0].has(fn)));
    }
    // run the function if it's first in line and not already running
    #run(fn) {
        if (this.#running.has(fn) || !this.check(fn)) {
            return false;
        }
        this.#running.add(fn);
        fn(() => this.#clear(fn));
        return true;
    }
    #clear(fn) {
        if (!this.#running.has(fn)) {
            return false;
        }
        const res = this.#reservations.get(fn);
        /* c8 ignore start */
        if (!res) {
            throw new Error('invalid reservation');
        }
        /* c8 ignore stop */
        const { paths, dirs } = res;
        const next = new Set();
        for (const path of paths) {
            const q = this.#queues.get(path);
            /* c8 ignore start */
            if (!q || q?.[0] !== fn) {
                continue;
            }
            /* c8 ignore stop */
            const q0 = q[1];
            if (!q0) {
                this.#queues.delete(path);
                continue;
            }
            q.shift();
            if (typeof q0 === 'function') {
                next.add(q0);
            }
            else {
                for (const f of q0) {
                    next.add(f);
                }
            }
        }
        for (const dir of dirs) {
            const q = this.#queues.get(dir);
            const q0 = q?.[0];
            /* c8 ignore next - type safety only */
            if (!q || !(q0 instanceof Set))
                continue;
            if (q0.size === 1 && q.length === 1) {
                this.#queues.delete(dir);
                continue;
            }
            else if (q0.size === 1) {
                q.shift();
                // next one must be a function,
                // or else the Set would've been reused
                const n = q[0];
                if (typeof n === 'function') {
                    next.add(n);
                }
            }
            else {
                q0.delete(fn);
            }
        }
        this.#running.delete(fn);
        next.forEach(fn => this.#run(fn));
        return true;
    }
}

// the PEND/UNPEND stuff tracks whether we're ready to emit end/close yet.
// but the path reservations are required to avoid race conditions where
// parallelized unpack ops may mess with one another, due to dependencies
// (like a Link depending on its target) or destructive operations (like
// clobbering an fs object to create one of a different type.)
const ONENTRY = Symbol('onEntry');
const CHECKFS = Symbol('checkFs');
const CHECKFS2 = Symbol('checkFs2');
const PRUNECACHE = Symbol('pruneCache');
const ISREUSABLE = Symbol('isReusable');
const MAKEFS = Symbol('makeFs');
const FILE = Symbol('file');
const DIRECTORY = Symbol('directory');
const LINK = Symbol('link');
const SYMLINK = Symbol('symlink');
const HARDLINK = Symbol('hardlink');
const UNSUPPORTED = Symbol('unsupported');
const CHECKPATH = Symbol('checkPath');
const MKDIR = Symbol('mkdir');
const ONERROR = Symbol('onError');
const PENDING = Symbol('pending');
const PEND = Symbol('pend');
const UNPEND = Symbol('unpend');
const ENDED = Symbol('ended');
const MAYBECLOSE = Symbol('maybeClose');
const SKIP = Symbol('skip');
const DOCHOWN = Symbol('doChown');
const UID = Symbol('uid');
const GID = Symbol('gid');
const CHECKED_CWD = Symbol('checkedCwd');
const platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;
const isWindows = platform === 'win32';
const DEFAULT_MAX_DEPTH = 1024;
// Unlinks on Windows are not atomic.
//
// This means that if you have a file entry, followed by another
// file entry with an identical name, and you cannot re-use the file
// (because it's a hardlink, or because unlink:true is set, or it's
// Windows, which does not have useful nlink values), then the unlink
// will be committed to the disk AFTER the new file has been written
// over the old one, deleting the new file.
//
// To work around this, on Windows systems, we rename the file and then
// delete the renamed file.  It's a sloppy kludge, but frankly, I do not
// know of a better way to do this, given windows' non-atomic unlink
// semantics.
//
// See: https://github.com/npm/node-tar/issues/183
/* c8 ignore start */
const unlinkFile = (path, cb) => {
    if (!isWindows) {
        return fs$1.unlink(path, cb);
    }
    const name = path + '.DELETE.' + require$$0$a.randomBytes(16).toString('hex');
    fs$1.rename(path, name, er => {
        if (er) {
            return cb(er);
        }
        fs$1.unlink(name, cb);
    });
};
/* c8 ignore stop */
/* c8 ignore start */
const unlinkFileSync = (path) => {
    if (!isWindows) {
        return fs$1.unlinkSync(path);
    }
    const name = path + '.DELETE.' + require$$0$a.randomBytes(16).toString('hex');
    fs$1.renameSync(path, name);
    fs$1.unlinkSync(name);
};
/* c8 ignore stop */
// this.gid, entry.gid, this.processUid
const uint32 = (a, b, c) => a !== undefined && a === a >>> 0 ? a
    : b !== undefined && b === b >>> 0 ? b
        : c;
// clear the cache if it's a case-insensitive unicode-squashing match.
// we can't know if the current file system is case-sensitive or supports
// unicode fully, so we check for similarity on the maximally compatible
// representation.  Err on the side of pruning, since all it's doing is
// preventing lstats, and it's not the end of the world if we get a false
// positive.
// Note that on windows, we always drop the entire cache whenever a
// symbolic link is encountered, because 8.3 filenames are impossible
// to reason about, and collisions are hazards rather than just failures.
const cacheKeyNormalize = (path) => stripTrailingSlashes(normalizeWindowsPath(normalizeUnicode(path))).toLowerCase();
// remove all cache entries matching ${abs}/**
const pruneCache = (cache, abs) => {
    abs = cacheKeyNormalize(abs);
    for (const path of cache.keys()) {
        const pnorm = cacheKeyNormalize(path);
        if (pnorm === abs || pnorm.indexOf(abs + '/') === 0) {
            cache.delete(path);
        }
    }
};
const dropCache = (cache) => {
    for (const key of cache.keys()) {
        cache.delete(key);
    }
};
class Unpack extends Parser {
    [ENDED] = false;
    [CHECKED_CWD] = false;
    [PENDING] = 0;
    reservations = new PathReservations();
    transform;
    writable = true;
    readable = false;
    dirCache;
    uid;
    gid;
    setOwner;
    preserveOwner;
    processGid;
    processUid;
    maxDepth;
    forceChown;
    win32;
    newer;
    keep;
    noMtime;
    preservePaths;
    unlink;
    cwd;
    strip;
    processUmask;
    umask;
    dmode;
    fmode;
    chmod;
    constructor(opt = {}) {
        opt.ondone = () => {
            this[ENDED] = true;
            this[MAYBECLOSE]();
        };
        super(opt);
        this.transform = opt.transform;
        this.dirCache = opt.dirCache || new Map();
        this.chmod = !!opt.chmod;
        if (typeof opt.uid === 'number' || typeof opt.gid === 'number') {
            // need both or neither
            if (typeof opt.uid !== 'number' ||
                typeof opt.gid !== 'number') {
                throw new TypeError('cannot set owner without number uid and gid');
            }
            if (opt.preserveOwner) {
                throw new TypeError('cannot preserve owner in archive and also set owner explicitly');
            }
            this.uid = opt.uid;
            this.gid = opt.gid;
            this.setOwner = true;
        }
        else {
            this.uid = undefined;
            this.gid = undefined;
            this.setOwner = false;
        }
        // default true for root
        if (opt.preserveOwner === undefined &&
            typeof opt.uid !== 'number') {
            this.preserveOwner = !!(process.getuid && process.getuid() === 0);
        }
        else {
            this.preserveOwner = !!opt.preserveOwner;
        }
        this.processUid =
            (this.preserveOwner || this.setOwner) && process.getuid ?
                process.getuid()
                : undefined;
        this.processGid =
            (this.preserveOwner || this.setOwner) && process.getgid ?
                process.getgid()
                : undefined;
        // prevent excessively deep nesting of subfolders
        // set to `Infinity` to remove this restriction
        this.maxDepth =
            typeof opt.maxDepth === 'number' ?
                opt.maxDepth
                : DEFAULT_MAX_DEPTH;
        // mostly just for testing, but useful in some cases.
        // Forcibly trigger a chown on every entry, no matter what
        this.forceChown = opt.forceChown === true;
        // turn ><?| in filenames into 0xf000-higher encoded forms
        this.win32 = !!opt.win32 || isWindows;
        // do not unpack over files that are newer than what's in the archive
        this.newer = !!opt.newer;
        // do not unpack over ANY files
        this.keep = !!opt.keep;
        // do not set mtime/atime of extracted entries
        this.noMtime = !!opt.noMtime;
        // allow .., absolute path entries, and unpacking through symlinks
        // without this, warn and skip .., relativize absolutes, and error
        // on symlinks in extraction path
        this.preservePaths = !!opt.preservePaths;
        // unlink files and links before writing. This breaks existing hard
        // links, and removes symlink directories rather than erroring
        this.unlink = !!opt.unlink;
        this.cwd = normalizeWindowsPath(path$1.resolve(opt.cwd || process.cwd()));
        this.strip = Number(opt.strip) || 0;
        // if we're not chmodding, then we don't need the process umask
        this.processUmask =
            !this.chmod ? 0
                : typeof opt.processUmask === 'number' ? opt.processUmask
                    : process.umask();
        this.umask =
            typeof opt.umask === 'number' ? opt.umask : this.processUmask;
        // default mode for dirs created as parents
        this.dmode = opt.dmode || 0o0777 & ~this.umask;
        this.fmode = opt.fmode || 0o0666 & ~this.umask;
        this.on('entry', entry => this[ONENTRY](entry));
    }
    // a bad or damaged archive is a warning for Parser, but an error
    // when extracting.  Mark those errors as unrecoverable, because
    // the Unpack contract cannot be met.
    warn(code, msg, data = {}) {
        if (code === 'TAR_BAD_ARCHIVE' || code === 'TAR_ABORT') {
            data.recoverable = false;
        }
        return super.warn(code, msg, data);
    }
    [MAYBECLOSE]() {
        if (this[ENDED] && this[PENDING] === 0) {
            this.emit('prefinish');
            this.emit('finish');
            this.emit('end');
        }
    }
    [CHECKPATH](entry) {
        const p = normalizeWindowsPath(entry.path);
        const parts = p.split('/');
        if (this.strip) {
            if (parts.length < this.strip) {
                return false;
            }
            if (entry.type === 'Link') {
                const linkparts = normalizeWindowsPath(String(entry.linkpath)).split('/');
                if (linkparts.length >= this.strip) {
                    entry.linkpath = linkparts.slice(this.strip).join('/');
                }
                else {
                    return false;
                }
            }
            parts.splice(0, this.strip);
            entry.path = parts.join('/');
        }
        if (isFinite(this.maxDepth) && parts.length > this.maxDepth) {
            this.warn('TAR_ENTRY_ERROR', 'path excessively deep', {
                entry,
                path: p,
                depth: parts.length,
                maxDepth: this.maxDepth,
            });
            return false;
        }
        if (!this.preservePaths) {
            if (parts.includes('..') ||
                /* c8 ignore next */
                (isWindows && /^[a-z]:\.\.$/i.test(parts[0] ?? ''))) {
                this.warn('TAR_ENTRY_ERROR', `path contains '..'`, {
                    entry,
                    path: p,
                });
                return false;
            }
            // strip off the root
            const [root, stripped] = stripAbsolutePath(p);
            if (root) {
                entry.path = String(stripped);
                this.warn('TAR_ENTRY_INFO', `stripping ${root} from absolute path`, {
                    entry,
                    path: p,
                });
            }
        }
        if (path$1.isAbsolute(entry.path)) {
            entry.absolute = normalizeWindowsPath(path$1.resolve(entry.path));
        }
        else {
            entry.absolute = normalizeWindowsPath(path$1.resolve(this.cwd, entry.path));
        }
        // if we somehow ended up with a path that escapes the cwd, and we are
        // not in preservePaths mode, then something is fishy!  This should have
        // been prevented above, so ignore this for coverage.
        /* c8 ignore start - defense in depth */
        if (!this.preservePaths &&
            typeof entry.absolute === 'string' &&
            entry.absolute.indexOf(this.cwd + '/') !== 0 &&
            entry.absolute !== this.cwd) {
            this.warn('TAR_ENTRY_ERROR', 'path escaped extraction target', {
                entry,
                path: normalizeWindowsPath(entry.path),
                resolvedPath: entry.absolute,
                cwd: this.cwd,
            });
            return false;
        }
        /* c8 ignore stop */
        // an archive can set properties on the extraction directory, but it
        // may not replace the cwd with a different kind of thing entirely.
        if (entry.absolute === this.cwd &&
            entry.type !== 'Directory' &&
            entry.type !== 'GNUDumpDir') {
            return false;
        }
        // only encode : chars that aren't drive letter indicators
        if (this.win32) {
            const { root: aRoot } = path$1.win32.parse(String(entry.absolute));
            entry.absolute =
                aRoot + encode(String(entry.absolute).slice(aRoot.length));
            const { root: pRoot } = path$1.win32.parse(entry.path);
            entry.path = pRoot + encode(entry.path.slice(pRoot.length));
        }
        return true;
    }
    [ONENTRY](entry) {
        if (!this[CHECKPATH](entry)) {
            return entry.resume();
        }
        require$$0$9.equal(typeof entry.absolute, 'string');
        switch (entry.type) {
            case 'Directory':
            case 'GNUDumpDir':
                if (entry.mode) {
                    entry.mode = entry.mode | 0o700;
                }
            // eslint-disable-next-line no-fallthrough
            case 'File':
            case 'OldFile':
            case 'ContiguousFile':
            case 'Link':
            case 'SymbolicLink':
                return this[CHECKFS](entry);
            case 'CharacterDevice':
            case 'BlockDevice':
            case 'FIFO':
            default:
                return this[UNSUPPORTED](entry);
        }
    }
    [ONERROR](er, entry) {
        // Cwd has to exist, or else nothing works. That's serious.
        // Other errors are warnings, which raise the error in strict
        // mode, but otherwise continue on.
        if (er.name === 'CwdError') {
            this.emit('error', er);
        }
        else {
            this.warn('TAR_ENTRY_ERROR', er, { entry });
            this[UNPEND]();
            entry.resume();
        }
    }
    [MKDIR](dir, mode, cb) {
        mkdir(normalizeWindowsPath(dir), {
            uid: this.uid,
            gid: this.gid,
            processUid: this.processUid,
            processGid: this.processGid,
            umask: this.processUmask,
            preserve: this.preservePaths,
            unlink: this.unlink,
            cache: this.dirCache,
            cwd: this.cwd,
            mode: mode,
        }, cb);
    }
    [DOCHOWN](entry) {
        // in preserve owner mode, chown if the entry doesn't match process
        // in set owner mode, chown if setting doesn't match process
        return (this.forceChown ||
            (this.preserveOwner &&
                ((typeof entry.uid === 'number' &&
                    entry.uid !== this.processUid) ||
                    (typeof entry.gid === 'number' &&
                        entry.gid !== this.processGid))) ||
            (typeof this.uid === 'number' &&
                this.uid !== this.processUid) ||
            (typeof this.gid === 'number' && this.gid !== this.processGid));
    }
    [UID](entry) {
        return uint32(this.uid, entry.uid, this.processUid);
    }
    [GID](entry) {
        return uint32(this.gid, entry.gid, this.processGid);
    }
    [FILE](entry, fullyDone) {
        const mode = typeof entry.mode === 'number' ?
            entry.mode & 0o7777
            : this.fmode;
        const stream = new WriteStream(String(entry.absolute), {
            // slight lie, but it can be numeric flags
            flags: getWriteFlag(entry.size),
            mode: mode,
            autoClose: false,
        });
        stream.on('error', (er) => {
            if (stream.fd) {
                fs$1.close(stream.fd, () => { });
            }
            // flush all the data out so that we aren't left hanging
            // if the error wasn't actually fatal.  otherwise the parse
            // is blocked, and we never proceed.
            stream.write = () => true;
            this[ONERROR](er, entry);
            fullyDone();
        });
        let actions = 1;
        const done = (er) => {
            if (er) {
                /* c8 ignore start - we should always have a fd by now */
                if (stream.fd) {
                    fs$1.close(stream.fd, () => { });
                }
                /* c8 ignore stop */
                this[ONERROR](er, entry);
                fullyDone();
                return;
            }
            if (--actions === 0) {
                if (stream.fd !== undefined) {
                    fs$1.close(stream.fd, er => {
                        if (er) {
                            this[ONERROR](er, entry);
                        }
                        else {
                            this[UNPEND]();
                        }
                        fullyDone();
                    });
                }
            }
        };
        stream.on('finish', () => {
            // if futimes fails, try utimes
            // if utimes fails, fail with the original error
            // same for fchown/chown
            const abs = String(entry.absolute);
            const fd = stream.fd;
            if (typeof fd === 'number' && entry.mtime && !this.noMtime) {
                actions++;
                const atime = entry.atime || new Date();
                const mtime = entry.mtime;
                fs$1.futimes(fd, atime, mtime, er => er ?
                    fs$1.utimes(abs, atime, mtime, er2 => done(er2 && er))
                    : done());
            }
            if (typeof fd === 'number' && this[DOCHOWN](entry)) {
                actions++;
                const uid = this[UID](entry);
                const gid = this[GID](entry);
                if (typeof uid === 'number' && typeof gid === 'number') {
                    fs$1.fchown(fd, uid, gid, er => er ?
                        fs$1.chown(abs, uid, gid, er2 => done(er2 && er))
                        : done());
                }
            }
            done();
        });
        const tx = this.transform ? this.transform(entry) || entry : entry;
        if (tx !== entry) {
            tx.on('error', (er) => {
                this[ONERROR](er, entry);
                fullyDone();
            });
            entry.pipe(tx);
        }
        tx.pipe(stream);
    }
    [DIRECTORY](entry, fullyDone) {
        const mode = typeof entry.mode === 'number' ?
            entry.mode & 0o7777
            : this.dmode;
        this[MKDIR](String(entry.absolute), mode, er => {
            if (er) {
                this[ONERROR](er, entry);
                fullyDone();
                return;
            }
            let actions = 1;
            const done = () => {
                if (--actions === 0) {
                    fullyDone();
                    this[UNPEND]();
                    entry.resume();
                }
            };
            if (entry.mtime && !this.noMtime) {
                actions++;
                fs$1.utimes(String(entry.absolute), entry.atime || new Date(), entry.mtime, done);
            }
            if (this[DOCHOWN](entry)) {
                actions++;
                fs$1.chown(String(entry.absolute), Number(this[UID](entry)), Number(this[GID](entry)), done);
            }
            done();
        });
    }
    [UNSUPPORTED](entry) {
        entry.unsupported = true;
        this.warn('TAR_ENTRY_UNSUPPORTED', `unsupported entry type: ${entry.type}`, { entry });
        entry.resume();
    }
    [SYMLINK](entry, done) {
        this[LINK](entry, String(entry.linkpath), 'symlink', done);
    }
    [HARDLINK](entry, done) {
        const linkpath = normalizeWindowsPath(path$1.resolve(this.cwd, String(entry.linkpath)));
        this[LINK](entry, linkpath, 'link', done);
    }
    [PEND]() {
        this[PENDING]++;
    }
    [UNPEND]() {
        this[PENDING]--;
        this[MAYBECLOSE]();
    }
    [SKIP](entry) {
        this[UNPEND]();
        entry.resume();
    }
    // Check if we can reuse an existing filesystem entry safely and
    // overwrite it, rather than unlinking and recreating
    // Windows doesn't report a useful nlink, so we just never reuse entries
    [ISREUSABLE](entry, st) {
        return (entry.type === 'File' &&
            !this.unlink &&
            st.isFile() &&
            st.nlink <= 1 &&
            !isWindows);
    }
    // check if a thing is there, and if so, try to clobber it
    [CHECKFS](entry) {
        this[PEND]();
        const paths = [entry.path];
        if (entry.linkpath) {
            paths.push(entry.linkpath);
        }
        this.reservations.reserve(paths, done => this[CHECKFS2](entry, done));
    }
    [PRUNECACHE](entry) {
        // if we are not creating a directory, and the path is in the dirCache,
        // then that means we are about to delete the directory we created
        // previously, and it is no longer going to be a directory, and neither
        // is any of its children.
        // If a symbolic link is encountered, all bets are off.  There is no
        // reasonable way to sanitize the cache in such a way we will be able to
        // avoid having filesystem collisions.  If this happens with a non-symlink
        // entry, it'll just fail to unpack, but a symlink to a directory, using an
        // 8.3 shortname or certain unicode attacks, can evade detection and lead
        // to arbitrary writes to anywhere on the system.
        if (entry.type === 'SymbolicLink') {
            dropCache(this.dirCache);
        }
        else if (entry.type !== 'Directory') {
            pruneCache(this.dirCache, String(entry.absolute));
        }
    }
    [CHECKFS2](entry, fullyDone) {
        this[PRUNECACHE](entry);
        const done = (er) => {
            this[PRUNECACHE](entry);
            fullyDone(er);
        };
        const checkCwd = () => {
            this[MKDIR](this.cwd, this.dmode, er => {
                if (er) {
                    this[ONERROR](er, entry);
                    done();
                    return;
                }
                this[CHECKED_CWD] = true;
                start();
            });
        };
        const start = () => {
            if (entry.absolute !== this.cwd) {
                const parent = normalizeWindowsPath(path$1.dirname(String(entry.absolute)));
                if (parent !== this.cwd) {
                    return this[MKDIR](parent, this.dmode, er => {
                        if (er) {
                            this[ONERROR](er, entry);
                            done();
                            return;
                        }
                        afterMakeParent();
                    });
                }
            }
            afterMakeParent();
        };
        const afterMakeParent = () => {
            fs$1.lstat(String(entry.absolute), (lstatEr, st) => {
                if (st &&
                    (this.keep ||
                        /* c8 ignore next */
                        (this.newer && st.mtime > (entry.mtime ?? st.mtime)))) {
                    this[SKIP](entry);
                    done();
                    return;
                }
                if (lstatEr || this[ISREUSABLE](entry, st)) {
                    return this[MAKEFS](null, entry, done);
                }
                if (st.isDirectory()) {
                    if (entry.type === 'Directory') {
                        const needChmod = this.chmod &&
                            entry.mode &&
                            (st.mode & 0o7777) !== entry.mode;
                        const afterChmod = (er) => this[MAKEFS](er ?? null, entry, done);
                        if (!needChmod) {
                            return afterChmod();
                        }
                        return fs$1.chmod(String(entry.absolute), Number(entry.mode), afterChmod);
                    }
                    // Not a dir entry, have to remove it.
                    // NB: the only way to end up with an entry that is the cwd
                    // itself, in such a way that == does not detect, is a
                    // tricky windows absolute path with UNC or 8.3 parts (and
                    // preservePaths:true, or else it will have been stripped).
                    // In that case, the user has opted out of path protections
                    // explicitly, so if they blow away the cwd, c'est la vie.
                    if (entry.absolute !== this.cwd) {
                        return fs$1.rmdir(String(entry.absolute), (er) => this[MAKEFS](er ?? null, entry, done));
                    }
                }
                // not a dir, and not reusable
                // don't remove if the cwd, we want that error
                if (entry.absolute === this.cwd) {
                    return this[MAKEFS](null, entry, done);
                }
                unlinkFile(String(entry.absolute), er => this[MAKEFS](er ?? null, entry, done));
            });
        };
        if (this[CHECKED_CWD]) {
            start();
        }
        else {
            checkCwd();
        }
    }
    [MAKEFS](er, entry, done) {
        if (er) {
            this[ONERROR](er, entry);
            done();
            return;
        }
        switch (entry.type) {
            case 'File':
            case 'OldFile':
            case 'ContiguousFile':
                return this[FILE](entry, done);
            case 'Link':
                return this[HARDLINK](entry, done);
            case 'SymbolicLink':
                return this[SYMLINK](entry, done);
            case 'Directory':
            case 'GNUDumpDir':
                return this[DIRECTORY](entry, done);
        }
    }
    [LINK](entry, linkpath, link, done) {
        // XXX: get the type ('symlink' or 'junction') for windows
        fs$1[link](linkpath, String(entry.absolute), er => {
            if (er) {
                this[ONERROR](er, entry);
            }
            else {
                this[UNPEND]();
                entry.resume();
            }
            done();
        });
    }
}
const callSync = (fn) => {
    try {
        return [null, fn()];
    }
    catch (er) {
        return [er, null];
    }
};
class UnpackSync extends Unpack {
    sync = true;
    [MAKEFS](er, entry) {
        return super[MAKEFS](er, entry, () => { });
    }
    [CHECKFS](entry) {
        this[PRUNECACHE](entry);
        if (!this[CHECKED_CWD]) {
            const er = this[MKDIR](this.cwd, this.dmode);
            if (er) {
                return this[ONERROR](er, entry);
            }
            this[CHECKED_CWD] = true;
        }
        // don't bother to make the parent if the current entry is the cwd,
        // we've already checked it.
        if (entry.absolute !== this.cwd) {
            const parent = normalizeWindowsPath(path$1.dirname(String(entry.absolute)));
            if (parent !== this.cwd) {
                const mkParent = this[MKDIR](parent, this.dmode);
                if (mkParent) {
                    return this[ONERROR](mkParent, entry);
                }
            }
        }
        const [lstatEr, st] = callSync(() => fs$1.lstatSync(String(entry.absolute)));
        if (st &&
            (this.keep ||
                /* c8 ignore next */
                (this.newer && st.mtime > (entry.mtime ?? st.mtime)))) {
            return this[SKIP](entry);
        }
        if (lstatEr || this[ISREUSABLE](entry, st)) {
            return this[MAKEFS](null, entry);
        }
        if (st.isDirectory()) {
            if (entry.type === 'Directory') {
                const needChmod = this.chmod &&
                    entry.mode &&
                    (st.mode & 0o7777) !== entry.mode;
                const [er] = needChmod ?
                    callSync(() => {
                        fs$1.chmodSync(String(entry.absolute), Number(entry.mode));
                    })
                    : [];
                return this[MAKEFS](er, entry);
            }
            // not a dir entry, have to remove it
            const [er] = callSync(() => fs$1.rmdirSync(String(entry.absolute)));
            this[MAKEFS](er, entry);
        }
        // not a dir, and not reusable.
        // don't remove if it's the cwd, since we want that error.
        const [er] = entry.absolute === this.cwd ?
            []
            : callSync(() => unlinkFileSync(String(entry.absolute)));
        this[MAKEFS](er, entry);
    }
    [FILE](entry, done) {
        const mode = typeof entry.mode === 'number' ?
            entry.mode & 0o7777
            : this.fmode;
        const oner = (er) => {
            let closeError;
            try {
                fs$1.closeSync(fd);
            }
            catch (e) {
                closeError = e;
            }
            if (er || closeError) {
                this[ONERROR](er || closeError, entry);
            }
            done();
        };
        let fd;
        try {
            fd = fs$1.openSync(String(entry.absolute), getWriteFlag(entry.size), mode);
        }
        catch (er) {
            return oner(er);
        }
        const tx = this.transform ? this.transform(entry) || entry : entry;
        if (tx !== entry) {
            tx.on('error', (er) => this[ONERROR](er, entry));
            entry.pipe(tx);
        }
        tx.on('data', (chunk) => {
            try {
                fs$1.writeSync(fd, chunk, 0, chunk.length);
            }
            catch (er) {
                oner(er);
            }
        });
        tx.on('end', () => {
            let er = null;
            // try both, falling futimes back to utimes
            // if either fails, handle the first error
            if (entry.mtime && !this.noMtime) {
                const atime = entry.atime || new Date();
                const mtime = entry.mtime;
                try {
                    fs$1.futimesSync(fd, atime, mtime);
                }
                catch (futimeser) {
                    try {
                        fs$1.utimesSync(String(entry.absolute), atime, mtime);
                    }
                    catch (utimeser) {
                        er = futimeser;
                    }
                }
            }
            if (this[DOCHOWN](entry)) {
                const uid = this[UID](entry);
                const gid = this[GID](entry);
                try {
                    fs$1.fchownSync(fd, Number(uid), Number(gid));
                }
                catch (fchowner) {
                    try {
                        fs$1.chownSync(String(entry.absolute), Number(uid), Number(gid));
                    }
                    catch (chowner) {
                        er = er || fchowner;
                    }
                }
            }
            oner(er);
        });
    }
    [DIRECTORY](entry, done) {
        const mode = typeof entry.mode === 'number' ?
            entry.mode & 0o7777
            : this.dmode;
        const er = this[MKDIR](String(entry.absolute), mode);
        if (er) {
            this[ONERROR](er, entry);
            done();
            return;
        }
        if (entry.mtime && !this.noMtime) {
            try {
                fs$1.utimesSync(String(entry.absolute), entry.atime || new Date(), entry.mtime);
                /* c8 ignore next */
            }
            catch (er) { }
        }
        if (this[DOCHOWN](entry)) {
            try {
                fs$1.chownSync(String(entry.absolute), Number(this[UID](entry)), Number(this[GID](entry)));
            }
            catch (er) { }
        }
        done();
        entry.resume();
    }
    [MKDIR](dir, mode) {
        try {
            return mkdirSync(normalizeWindowsPath(dir), {
                uid: this.uid,
                gid: this.gid,
                processUid: this.processUid,
                processGid: this.processGid,
                umask: this.processUmask,
                preserve: this.preservePaths,
                unlink: this.unlink,
                cache: this.dirCache,
                cwd: this.cwd,
                mode: mode,
            });
        }
        catch (er) {
            return er;
        }
    }
    [LINK](entry, linkpath, link, done) {
        const ls = `${link}Sync`;
        try {
            fs$1[ls](linkpath, String(entry.absolute));
            done();
            entry.resume();
        }
        catch (er) {
            return this[ONERROR](er, entry);
        }
    }
}

// tar -x
const extractFileSync = (opt) => {
    const u = new UnpackSync(opt);
    const file = opt.file;
    const stat = fs$1.statSync(file);
    // This trades a zero-byte read() syscall for a stat
    // However, it will usually result in less memory allocation
    const readSize = opt.maxReadSize || 16 * 1024 * 1024;
    const stream = new ReadStreamSync(file, {
        readSize: readSize,
        size: stat.size,
    });
    stream.pipe(u);
};
const extractFile = (opt, _) => {
    const u = new Unpack(opt);
    const readSize = opt.maxReadSize || 16 * 1024 * 1024;
    const file = opt.file;
    const p = new Promise((resolve, reject) => {
        u.on('error', reject);
        u.on('close', resolve);
        // This trades a zero-byte read() syscall for a stat
        // However, it will usually result in less memory allocation
        fs$1.stat(file, (er, stat) => {
            if (er) {
                reject(er);
            }
            else {
                const stream = new ReadStream(file, {
                    readSize: readSize,
                    size: stat.size,
                });
                stream.on('error', reject);
                stream.pipe(u);
            }
        });
    });
    return p;
};
const extract = makeCommand(extractFileSync, extractFile, opt => new UnpackSync(opt), opt => new Unpack(opt), (opt, files) => {
    if (files?.length)
        filesFilter(opt, files);
});

// tar -r
// starting at the head of the file, read a Header
// If the checksum is invalid, that's our position to start writing
// If it is, jump forward by the specified size (round up to 512)
// and try again.
// Write the new Pack stream starting there.
const replaceSync = (opt, files) => {
    const p = new PackSync(opt);
    let threw = true;
    let fd;
    let position;
    try {
        try {
            fd = fs$1.openSync(opt.file, 'r+');
        }
        catch (er) {
            if (er?.code === 'ENOENT') {
                fd = fs$1.openSync(opt.file, 'w+');
            }
            else {
                throw er;
            }
        }
        const st = fs$1.fstatSync(fd);
        const headBuf = Buffer.alloc(512);
        POSITION: for (position = 0; position < st.size; position += 512) {
            for (let bufPos = 0, bytes = 0; bufPos < 512; bufPos += bytes) {
                bytes = fs$1.readSync(fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos);
                if (position === 0 &&
                    headBuf[0] === 0x1f &&
                    headBuf[1] === 0x8b) {
                    throw new Error('cannot append to compressed archives');
                }
                if (!bytes) {
                    break POSITION;
                }
            }
            const h = new Header(headBuf);
            if (!h.cksumValid) {
                break;
            }
            const entryBlockSize = 512 * Math.ceil((h.size || 0) / 512);
            if (position + entryBlockSize + 512 > st.size) {
                break;
            }
            // the 512 for the header we just parsed will be added as well
            // also jump ahead all the blocks for the body
            position += entryBlockSize;
            if (opt.mtimeCache && h.mtime) {
                opt.mtimeCache.set(String(h.path), h.mtime);
            }
        }
        threw = false;
        streamSync(opt, p, position, fd, files);
    }
    finally {
        if (threw) {
            try {
                fs$1.closeSync(fd);
            }
            catch (er) { }
        }
    }
};
const streamSync = (opt, p, position, fd, files) => {
    const stream = new WriteStreamSync(opt.file, {
        fd: fd,
        start: position,
    });
    p.pipe(stream);
    addFilesSync(p, files);
};
const replaceAsync = (opt, files) => {
    files = Array.from(files);
    const p = new Pack(opt);
    const getPos = (fd, size, cb_) => {
        const cb = (er, pos) => {
            if (er) {
                fs$1.close(fd, _ => cb_(er));
            }
            else {
                cb_(null, pos);
            }
        };
        let position = 0;
        if (size === 0) {
            return cb(null, 0);
        }
        let bufPos = 0;
        const headBuf = Buffer.alloc(512);
        const onread = (er, bytes) => {
            if (er || typeof bytes === 'undefined') {
                return cb(er);
            }
            bufPos += bytes;
            if (bufPos < 512 && bytes) {
                return fs$1.read(fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos, onread);
            }
            if (position === 0 &&
                headBuf[0] === 0x1f &&
                headBuf[1] === 0x8b) {
                return cb(new Error('cannot append to compressed archives'));
            }
            // truncated header
            if (bufPos < 512) {
                return cb(null, position);
            }
            const h = new Header(headBuf);
            if (!h.cksumValid) {
                return cb(null, position);
            }
            /* c8 ignore next */
            const entryBlockSize = 512 * Math.ceil((h.size ?? 0) / 512);
            if (position + entryBlockSize + 512 > size) {
                return cb(null, position);
            }
            position += entryBlockSize + 512;
            if (position >= size) {
                return cb(null, position);
            }
            if (opt.mtimeCache && h.mtime) {
                opt.mtimeCache.set(String(h.path), h.mtime);
            }
            bufPos = 0;
            fs$1.read(fd, headBuf, 0, 512, position, onread);
        };
        fs$1.read(fd, headBuf, 0, 512, position, onread);
    };
    const promise = new Promise((resolve, reject) => {
        p.on('error', reject);
        let flag = 'r+';
        const onopen = (er, fd) => {
            if (er && er.code === 'ENOENT' && flag === 'r+') {
                flag = 'w+';
                return fs$1.open(opt.file, flag, onopen);
            }
            if (er || !fd) {
                return reject(er);
            }
            fs$1.fstat(fd, (er, st) => {
                if (er) {
                    return fs$1.close(fd, () => reject(er));
                }
                getPos(fd, st.size, (er, position) => {
                    if (er) {
                        return reject(er);
                    }
                    const stream = new WriteStream(opt.file, {
                        fd: fd,
                        start: position,
                    });
                    p.pipe(stream);
                    stream.on('error', reject);
                    stream.on('close', resolve);
                    addFilesAsync(p, files);
                });
            });
        };
        fs$1.open(opt.file, flag, onopen);
    });
    return promise;
};
const addFilesSync = (p, files) => {
    files.forEach(file => {
        if (file.charAt(0) === '@') {
            list({
                file: path$1.resolve(p.cwd, file.slice(1)),
                sync: true,
                noResume: true,
                onReadEntry: entry => p.add(entry),
            });
        }
        else {
            p.add(file);
        }
    });
    p.end();
};
const addFilesAsync = async (p, files) => {
    for (let i = 0; i < files.length; i++) {
        const file = String(files[i]);
        if (file.charAt(0) === '@') {
            await list({
                file: path$1.resolve(String(p.cwd), file.slice(1)),
                noResume: true,
                onReadEntry: entry => p.add(entry),
            });
        }
        else {
            p.add(file);
        }
    }
    p.end();
};
const replace = makeCommand(replaceSync, replaceAsync, 
/* c8 ignore start */
() => {
    throw new TypeError('file is required');
}, () => {
    throw new TypeError('file is required');
}, 
/* c8 ignore stop */
(opt, entries) => {
    if (!isFile(opt)) {
        throw new TypeError('file is required');
    }
    if (opt.gzip ||
        opt.brotli ||
        opt.file.endsWith('.br') ||
        opt.file.endsWith('.tbr')) {
        throw new TypeError('cannot append to compressed archives');
    }
    if (!entries?.length) {
        throw new TypeError('no paths specified to add/replace');
    }
});

// tar -u
// just call tar.r with the filter and mtimeCache
makeCommand(replace.syncFile, replace.asyncFile, replace.syncNoFile, replace.asyncNoFile, (opt, entries = []) => {
    replace.validate?.(opt, entries);
    mtimeFilter(opt);
});
const mtimeFilter = (opt) => {
    const filter = opt.filter;
    if (!opt.mtimeCache) {
        opt.mtimeCache = new Map();
    }
    opt.filter =
        filter ?
            (path, stat) => filter(path, stat) &&
                !(
                /* c8 ignore start */
                ((opt.mtimeCache?.get(path) ?? stat.mtime ?? 0) >
                    (stat.mtime ?? 0))
                /* c8 ignore stop */
                )
            : (path, stat) => !(
            /* c8 ignore start */
            ((opt.mtimeCache?.get(path) ?? stat.mtime ?? 0) >
                (stat.mtime ?? 0))
            /* c8 ignore stop */
            );
};

var commandExists$1 = {exports: {}};

var hasRequiredCommandExists$1;

function requireCommandExists$1 () {
	if (hasRequiredCommandExists$1) return commandExists$1.exports;
	hasRequiredCommandExists$1 = 1;

	var exec = require$$0$c.exec;
	var execSync = require$$0$c.execSync;
	var fs$1 = fs;
	var path$1 = path;
	var access = fs$1.access;
	var accessSync = fs$1.accessSync;
	var constants = fs$1.constants || fs$1;

	var isUsingWindows = process.platform == 'win32';

	var fileNotExists = function(commandName, callback){
	    access(commandName, constants.F_OK,
	    function(err){
	        callback(!err);
	    });
	};

	var fileNotExistsSync = function(commandName){
	    try{
	        accessSync(commandName, constants.F_OK);
	        return false;
	    }catch(e){
	        return true;
	    }
	};

	var localExecutable = function(commandName, callback){
	    access(commandName, constants.F_OK | constants.X_OK,
	        function(err){
	        callback(null, !err);
	    });
	};

	var localExecutableSync = function(commandName){
	    try{
	        accessSync(commandName, constants.F_OK | constants.X_OK);
	        return true;
	    }catch(e){
	        return false;
	    }
	};

	var commandExistsUnix = function(commandName, cleanedCommandName, callback) {

	    fileNotExists(commandName, function(isFile){

	        if(!isFile){
	            exec('command -v ' + cleanedCommandName +
	                  ' 2>/dev/null' +
	                  ' && { echo >&1 ' + cleanedCommandName + '; exit 0; }',
	                  function (error, stdout, stderr) {
	                      callback(null, !!stdout);
	                  });
	            return;
	        }

	        localExecutable(commandName, callback);
	    });

	};

	var commandExistsWindows = function(commandName, cleanedCommandName, callback) {
	  // Regex from Julio from: https://stackoverflow.com/questions/51494579/regex-windows-path-validator
	  if (!(/^(?!(?:.*\s|.*\.|\W+)$)(?:[a-zA-Z]:)?(?:(?:[^<>:"\|\?\*\n])+(?:\/\/|\/|\\\\|\\)?)+$/m.test(commandName))) {
	    callback(null, false);
	    return;
	  }
	  exec('where ' + cleanedCommandName,
	    function (error) {
	      if (error !== null){
	        callback(null, false);
	      } else {
	        callback(null, true);
	      }
	    }
	  );
	};

	var commandExistsUnixSync = function(commandName, cleanedCommandName) {
	  if(fileNotExistsSync(commandName)){
	      try {
	        var stdout = execSync('command -v ' + cleanedCommandName +
	              ' 2>/dev/null' +
	              ' && { echo >&1 ' + cleanedCommandName + '; exit 0; }'
	              );
	        return !!stdout;
	      } catch (error) {
	        return false;
	      }
	  }
	  return localExecutableSync(commandName);
	};

	var commandExistsWindowsSync = function(commandName, cleanedCommandName, callback) {
	  // Regex from Julio from: https://stackoverflow.com/questions/51494579/regex-windows-path-validator
	  if (!(/^(?!(?:.*\s|.*\.|\W+)$)(?:[a-zA-Z]:)?(?:(?:[^<>:"\|\?\*\n])+(?:\/\/|\/|\\\\|\\)?)+$/m.test(commandName))) {
	    return false;
	  }
	  try {
	      var stdout = execSync('where ' + cleanedCommandName, {stdio: []});
	      return !!stdout;
	  } catch (error) {
	      return false;
	  }
	};

	var cleanInput = function(s) {
	  if (/[^A-Za-z0-9_\/:=-]/.test(s)) {
	    s = "'"+s.replace(/'/g,"'\\''")+"'";
	    s = s.replace(/^(?:'')+/g, '') // unduplicate single-quote at the beginning
	      .replace(/\\'''/g, "\\'" ); // remove non-escaped single-quote if there are enclosed between 2 escaped
	  }
	  return s;
	};

	if (isUsingWindows) {
	  cleanInput = function(s) {
	    var isPathName = /[\\]/.test(s);
	    if (isPathName) {
	      var dirname = '"' + path$1.dirname(s) + '"';
	      var basename = '"' + path$1.basename(s) + '"';
	      return dirname + ':' + basename;
	    }
	    return '"' + s + '"';
	  };
	}

	commandExists$1.exports = function commandExists(commandName, callback) {
	  var cleanedCommandName = cleanInput(commandName);
	  if (!callback && typeof Promise !== 'undefined') {
	    return new Promise(function(resolve, reject){
	      commandExists(commandName, function(error, output) {
	        if (output) {
	          resolve(commandName);
	        } else {
	          reject(error);
	        }
	      });
	    });
	  }
	  if (isUsingWindows) {
	    commandExistsWindows(commandName, cleanedCommandName, callback);
	  } else {
	    commandExistsUnix(commandName, cleanedCommandName, callback);
	  }
	};

	commandExists$1.exports.sync = function(commandName) {
	  var cleanedCommandName = cleanInput(commandName);
	  if (isUsingWindows) {
	    return commandExistsWindowsSync(commandName, cleanedCommandName);
	  } else {
	    return commandExistsUnixSync(commandName, cleanedCommandName);
	  }
	};
	return commandExists$1.exports;
}

var commandExists;
var hasRequiredCommandExists;

function requireCommandExists () {
	if (hasRequiredCommandExists) return commandExists;
	hasRequiredCommandExists = 1;
	commandExists = requireCommandExists$1();
	return commandExists;
}

var commandExistsExports = requireCommandExists();

const execAsync = require$$2$2.promisify(require$$0$c.exec);
const isTarAvailable = commandExistsExports.sync("tar");
const edition_id = {
  asn: "GeoLite2-ASN",
  city: "GeoLite2-City",
  country: "GeoLite2-Country"
};
async function existsAsync(file) {
  try {
    await fs__namespace.stat(file);
    return true;
  } catch {
    return false;
  }
}
async function move(oldPath, newPath) {
  try {
    await fs__namespace.rename(oldPath, newPath);
  } catch (err) {
    if (err.code === "EXDEV") {
      await fs__namespace.copyFile(oldPath, newPath);
      await fs__namespace.rm(oldPath, { force: true });
    } else {
      throw err;
    }
  }
}
function getShaDigest(fileBytes) {
  return crypto.subtle.digest("SHA-256", fileBytes).then((d) => {
    return Array.from(new Uint8Array(d)).map((b) => b.toString(16).padStart(2, "0")).join("");
  });
}
async function readSha(database, updater) {
  const {
    config: { dbRoot }
  } = updater;
  const edition = edition_id[database];
  const digestPath = path.join(dbRoot, `${edition}.tar.gz.sha256`);
  if (!await existsAsync(digestPath)) {
    const error = `Path ${digestPath} for ${database} doesn't exists`;
    throw new Error(error);
  }
  return await fs__namespace.readFile(digestPath, { encoding: "utf8" });
}
async function downloadSha(database, licenseKey) {
  const edition = edition_id[database];
  let resp = await (await fetch(
    `https://download.maxmind.com/app/geoip_download?edition_id=${edition}&license_key=${licenseKey}&suffix=tar.gz.sha256`
  )).text();
  resp = resp.match(/[^\r\n]+/g)?.filter((r) => r)[0];
  const digest = resp.split("  ")[0];
  const gzFile = resp.split("  ")[1];
  if (!digest || !gzFile) {
    throw new Error(resp);
  }
  const dbVersion = parseInt(gzFile.replace(`${edition}_`, "").replace(".tar.gz", ""));
  return {
    digest,
    gzFile,
    dbVersion
  };
}
async function extractDB(database, gzFile, digest, updater) {
  const {
    config: { dbRoot },
    logger
  } = updater;
  const edition = edition_id[database];
  if (isTarAvailable) {
    await execAsync(`tar -xf ${gzFile}`);
  } else {
    logger.warning(
      "Warning: TAR is not installed on system, it is recommended to use the system installed TAR while updating the DB!"
    );
    await extract({
      file: gzFile
    });
    await sleep(1e3);
  }
  const dbFile = path.join(gzFile.split(".")[0], `${edition}.mmdb`);
  if (!await existsAsync(dbFile)) {
    const error = `Error while extracting DB: ${dbFile} doesn't exist!`;
    throw new Error(error);
  }
  await move(gzFile, path.join(dbRoot, `${edition}.tar.gz`));
  await move(dbFile, path.join(dbRoot, `${edition}.mmdb`));
  await fs__namespace.writeFile(path.join(dbRoot, `${edition}.tar.gz.sha256`), digest);
  await fs__namespace.rm(gzFile.split(".")[0], { recursive: true, force: true });
}
async function downloadDB(database, updater) {
  const {
    config: { licenseKey }
  } = updater;
  const edition = edition_id[database];
  const { digest, gzFile, dbVersion } = await downloadSha(database, licenseKey);
  const file = new Uint8Array(
    await (await fetch(
      `https://download.maxmind.com/app/geoip_download?edition_id=${edition}&license_key=${licenseKey}&suffix=tar.gz`
    )).arrayBuffer()
  );
  const fileHash = await getShaDigest(file);
  if (digest !== fileHash) {
    const error = `Wrong digest, wants ${digest} got ${fileHash} while downloading ${gzFile} from MaxMind`;
    throw new Error(error);
  }
  await fs__namespace.writeFile(gzFile, Buffer.from(file));
  await extractDB(database, gzFile, digest, updater);
  return {
    edition,
    digest,
    gzFile,
    dbVersion
  };
}
async function updateDB(database, updater) {
  const { logger } = updater;
  if (!updater.config.licenseKey) {
    throw new Error("License Key not found");
  }
  const [currentDigest, { digest: fetchedDigest }] = await Promise.all([
    readSha(database, updater),
    downloadSha(database, updater.config.licenseKey)
  ]);
  if (currentDigest === fetchedDigest) {
    return;
  }
  const { edition, digest, gzFile, dbVersion } = await downloadDB(database, updater);
  logger.debug(`Updated ${edition} DB to ${dbVersion} (Digest: ${digest})`);
  return {
    edition,
    digest,
    gzFile,
    dbVersion
  };
}
async function fetchExitNodes() {
  const resp = await (await fetch("https://check.torproject.org/torbulkexitlist")).text();
  const list = resp.match(/[^\r\n]+/g)?.filter((r) => r).sort((a, b) => a.localeCompare(b)) || [];
  return list;
}
async function fetchAsnList() {
  const resp = await (await fetch("https://raw.githubusercontent.com/cpuchain/bad-asn-list/master/bad-asn-list.csv")).text();
  const csv = resp.match(/[^\r\n]+/g)?.filter((r) => r).filter((r) => r != "ASN,Entity") || [];
  const list = csv.map((r) => {
    r = r.split(",")[0];
    if (typeof r === "string") {
      r = r.replaceAll('"', "");
    }
    return "AS" + r;
  });
  return list;
}
async function updateAll(updater) {
  const { config, logger } = updater;
  const torList = await fetchExitNodes();
  await fs__namespace.writeFile(path.join(config.dbRoot, "torlist.json"), JSON.stringify(torList));
  logger.debug(`Updated ${torList.length} exit nodes`);
  const asnList = await fetchAsnList();
  await fs__namespace.writeFile(path.join(config.dbRoot, "asnlist.json"), JSON.stringify(asnList));
  logger.debug(`Updated ${asnList.length} asns`);
  if (!config.licenseKey) {
    return;
  }
  const allUpdates = (await Promise.all(Object.keys(edition_id).map((e) => updateDB(e, updater)))).filter((e) => e);
  if (!allUpdates.length) {
    return;
  }
  const dbVersion = allUpdates.reduce((acc, curr) => {
    if (acc < curr.dbVersion) {
      acc = curr.dbVersion;
    }
    return acc;
  }, 0);
  await fs__namespace.writeFile(path.join(config.dbRoot, "last_update.txt"), String(dbVersion));
  logger.debug(`Updated DB version to ${dbVersion}`);
  return dbVersion;
}
async function setupDB(updater) {
  const { config, logger } = updater;
  if (await existsAsync(path.join(config.dbRoot, "last_update.txt"))) {
    const dbVersion2 = Number(
      await fs__namespace.readFile(path.join(config.dbRoot, "last_update.txt"), {
        encoding: "utf8"
      })
    );
    return dbVersion2;
  }
  logger.debug("Setting up DB");
  await fs__namespace.mkdir(config.dbRoot, { recursive: true });
  await fs__namespace.copyFile(path.join(viewsDir, "./asnlist.json"), path.join(config.dbRoot, "asnlist.json"));
  await fs__namespace.copyFile(path.join(viewsDir, "./torlist.json"), path.join(config.dbRoot, "torlist.json"));
  await fs__namespace.copyFile(
    path.join(viewsDir, "./GeoLite2-ASN.tar.gz.sha256"),
    path.join(config.dbRoot, "GeoLite2-ASN.tar.gz.sha256")
  );
  await fs__namespace.copyFile(
    path.join(viewsDir, "./GeoLite2-City.tar.gz.sha256"),
    path.join(config.dbRoot, "GeoLite2-City.tar.gz.sha256")
  );
  await fs__namespace.copyFile(
    path.join(viewsDir, "./GeoLite2-Country.tar.gz.sha256"),
    path.join(config.dbRoot, "GeoLite2-Country.tar.gz.sha256")
  );
  await fs__namespace.copyFile(path.join(viewsDir, "./last_update.txt"), path.join(config.dbRoot, "last_update.txt"));
  const dbVersion = Number(
    await fs__namespace.readFile(path.join(viewsDir, "./last_update.txt"), {
      encoding: "utf8"
    })
  );
  await fs__namespace.copyFile(path.join(viewsDir, "./GeoLite2-ASN.tar.gz"), `GeoLite2-ASN_${dbVersion}.tar.gz`);
  await fs__namespace.copyFile(path.join(viewsDir, "./GeoLite2-City.tar.gz"), `GeoLite2-City_${dbVersion}.tar.gz`);
  await fs__namespace.copyFile(
    path.join(viewsDir, "./GeoLite2-Country.tar.gz"),
    `GeoLite2-Country_${dbVersion}.tar.gz`
  );
  await extractDB("asn", `GeoLite2-ASN_${dbVersion}.tar.gz`, await readSha("asn", updater), updater);
  await extractDB("city", `GeoLite2-City_${dbVersion}.tar.gz`, await readSha("city", updater), updater);
  await extractDB(
    "country",
    `GeoLite2-Country_${dbVersion}.tar.gz`,
    await readSha("country", updater),
    updater
  );
  logger.debug("DB setup complete");
  return dbVersion;
}
class Updater {
  config;
  logger;
  dbVersion;
  constructor(config) {
    this.config = config;
    this.logger = new Logger(config, "Main", "Updater");
    this.dbVersion = 0;
  }
  async setup() {
    if (!this.config.licenseKey) {
      this.logger.warning("MaxMind License Key not found, will not update the latest IP DB");
    }
    this.dbVersion = await setupDB(this);
    await this.update();
  }
  async update() {
    try {
      this.dbVersion = await updateAll(this) || this.dbVersion;
    } catch (error) {
      this.logger.error(
        `Failed to update DB, the DB will be served with the previous version ${this.dbVersion}`
      );
      console.log(error);
    }
  }
}

if (cluster.isWorker) {
  const config2 = JSON.parse(process$1.env.config);
  const forkId = Number(process$1.env.forkId);
  switch (process$1.env.workerType) {
    case "website":
      new WebServer(config2, forkId);
      break;
  }
}
const config = configFactory();
const logger = new Logger(config);
const stats = new Stats(config);
function createServerWorker(forkId) {
  const worker = cluster.fork({
    workerType: "website",
    forkId,
    config: JSON.stringify(config)
  });
  worker.on("exit", (code) => {
    logger.debug(
      "Main",
      "Spawner",
      `Website worker ${forkId} exit with ${code}, spawning replacement...`
    );
    setTimeout(() => {
      createServerWorker(forkId);
    }, 2e3);
  }).on("message", (msg) => {
    switch (msg.type) {
      case "addVisitor":
        stats.addVisitor(msg.ip);
        break;
      case "getStats":
        worker.send({
          uuid: msg.uuid,
          type: "getStats",
          ...stats.serialize()
        });
        break;
    }
  });
}
async function start() {
  const updater = new Updater(config);
  await updater.setup();
  stats.updatedDB++;
  stats.dbVersion = updater.dbVersion;
  stats.lastDBUpdate = formatDate(/* @__PURE__ */ new Date());
  stats.lastUpdate = formatDate(/* @__PURE__ */ new Date());
  let i = 0;
  while (i < config.workers) {
    createServerWorker(i);
    ++i;
  }
  logger.debug("Main", "Spawner", `Spawned ${i} website workers`);
  setInterval(async () => {
    stats.clearVisitors();
    await updater.update();
    if (stats.dbVersion !== updater.dbVersion) {
      stats.updatedDB++;
      stats.dbVersion = updater.dbVersion;
      stats.lastDBUpdate = formatDate(/* @__PURE__ */ new Date());
    }
    stats.lastUpdate = formatDate(/* @__PURE__ */ new Date());
  }, config.updateInterval);
}
if (cluster.isPrimary) {
  start();
}
